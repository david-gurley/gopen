// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tunnel.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TunnelType defines the role of the tunnel
type TunnelType int32

const (
	TunnelType_TUNNEL_TYPE_NONE TunnelType = 0
	// Tunnel type for Internet Gateway
	TunnelType_TUNNEL_TYPE_IGW TunnelType = 1
	// Tunnel type for east-traffic workloads with in a data center
	TunnelType_TUNNEL_TYPE_WORKLOAD TunnelType = 2
	// Tunnel type for inter data center traffic
	TunnelType_TUNNEL_TYPE_INTER_DC TunnelType = 3
	// Tunnel type for provider services
	TunnelType_TUNNEL_TYPE_SERVICE TunnelType = 4
	// Tunnel type ipsec
	TunnelType_TUNNEL_TYPE_IPSEC TunnelType = 5
)

var TunnelType_name = map[int32]string{
	0: "TUNNEL_TYPE_NONE",
	1: "TUNNEL_TYPE_IGW",
	2: "TUNNEL_TYPE_WORKLOAD",
	3: "TUNNEL_TYPE_INTER_DC",
	4: "TUNNEL_TYPE_SERVICE",
	5: "TUNNEL_TYPE_IPSEC",
}

var TunnelType_value = map[string]int32{
	"TUNNEL_TYPE_NONE":     0,
	"TUNNEL_TYPE_IGW":      1,
	"TUNNEL_TYPE_WORKLOAD": 2,
	"TUNNEL_TYPE_INTER_DC": 3,
	"TUNNEL_TYPE_SERVICE":  4,
	"TUNNEL_TYPE_IPSEC":    5,
}

func (x TunnelType) String() string {
	return proto.EnumName(TunnelType_name, int32(x))
}

func (TunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{0}
}

// tunnel configuration
// tunnel is uniquely identified by the 3-tuple (LocalIP, RemoteIP, encap)
type TunnelSpec struct {
	// unique tunnel identifier
	// NOTE: Tunnel id of 0 is reserve for local TEP/host
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// virtual private cloud this is tunnel belongs to
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// local IP of the tunnel (used as outer SIP in tunneled packets)
	LocalIP *IPAddress `protobuf:"bytes,3,opt,name=LocalIP,proto3" json:"LocalIP,omitempty"`
	// remote IP of the tunnel (used as outer DIP in tunneled packets)
	RemoteIP *IPAddress `protobuf:"bytes,4,opt,name=RemoteIP,proto3" json:"RemoteIP,omitempty" meta:mandatory,immutable`
	// type of the tunnel
	Type TunnelType `protobuf:"varint,5,opt,name=Type,proto3,enum=pds.TunnelType" json:"Type,omitempty" meta:mandatory,immutable`
	// encap used while sending traffic to this tunnel
	Encap *Encap `protobuf:"bytes,6,opt,name=Encap,proto3" json:"Encap,omitempty" immutable`
	// if Nat is set to true, do (static) source NAT for the traffic going to
	// this tunnel and (static) destination NAT in the reverse direction if
	// the local IP mapping has NAT/public IP configured
	Nat bool `protobuf:"varint,7,opt,name=Nat,proto3" json:"Nat,omitempty"`
	// Tunnel points to a underlay nexthop/nexthop group (ECMP)/another Tunnel
	//
	// Types that are valid to be assigned to Nh:
	//	*TunnelSpec_NexthopId
	//	*TunnelSpec_NexthopGroupId
	//	*TunnelSpec_TunnelId
	//	*TunnelSpec_DropNexthop
	Nh isTunnelSpec_Nh `protobuf_oneof:"nh"`
	// MAC address of the remote IP (i.e., remote side of the tunnel)
	// NOTE: if dataplane is supposed to resolve this, set to 0
	MACAddress uint64 `protobuf:"varint,12,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	// type of this tunnel
	// RemoteService flag is true when tunnel is pointing to a service
	// that is in a different data center and packet needs to be carried
	// with 2 fabric encaps. IPv4 traffic in this case goes thru protocol
	// translation (to IPv6) and then goes in a Vxlan tunnel
	RemoteService bool `protobuf:"varint,13,opt,name=RemoteService,proto3" json:"RemoteService,omitempty"`
	// RemoteServiceEncap must be set if the tunnel type is
	// TUNNEL_TYPE_REMOTE_SERVICE, this is the outer most vnid seen when the
	// packet is receievd from the remote service
	RemoteServiceEncap *Encap `protobuf:"bytes,14,opt,name=RemoteServiceEncap,proto3" json:"RemoteServiceEncap,omitempty"`
	// public IP of the remote service tunnel that is used as SIPo
	// in the encapped VXLAN packet in the Tx direction
	RemoteServicePublicIP *IPAddress `protobuf:"bytes,15,opt,name=RemoteServicePublicIP,proto3" json:"RemoteServicePublicIP,omitempty"`
	// when ToS is configured on a tunnel object, all traffic destined to the
	// tunnel will carry dscp value as configured.
	// ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
	// header or in the Traffic Class field of IPv6 outer header, this value, if
	// non-zero, will be used as-is (i.e., not interpreted) during encap time by
	// the dataplane
	// NOTE:
	// the ToS value configured on the tunnel will override ToS configuration
	// in vpc and subnet objects
	ToS uint32 `protobuf:"varint,16,opt,name=ToS,proto3" json:"ToS,omitempty"`
	// currently ipsec sa can be present in the following cases
	// 1. single tunnel (nexthop is none) : implies ipsec transport mode - inner
	//    vxlan encapsulation followed by esp header addition on the outer
	// 2. tunnel pointing to tunnel (nexthop is tunnel), and second tunnel has
	//    ipsec sa attributes present : implies ipsec tunnel mode - inner vxlan
	//    encapsulation, followed by a second ipsec tunnel encapsulation
	//    including esp header.
	IpsecEncryptSAId     []byte   `protobuf:"bytes,17,opt,name=IpsecEncryptSAId,proto3" json:"IpsecEncryptSAId,omitempty"`
	IpsecDecryptSAId     []byte   `protobuf:"bytes,18,opt,name=IpsecDecryptSAId,proto3" json:"IpsecDecryptSAId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelSpec) Reset()         { *m = TunnelSpec{} }
func (m *TunnelSpec) String() string { return proto.CompactTextString(m) }
func (*TunnelSpec) ProtoMessage()    {}
func (*TunnelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{0}
}
func (m *TunnelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelSpec.Merge(m, src)
}
func (m *TunnelSpec) XXX_Size() int {
	return m.Size()
}
func (m *TunnelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelSpec proto.InternalMessageInfo

type isTunnelSpec_Nh interface {
	isTunnelSpec_Nh()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelSpec_NexthopId struct {
	NexthopId []byte `protobuf:"bytes,8,opt,name=NexthopId,proto3,oneof"`
}
type TunnelSpec_NexthopGroupId struct {
	NexthopGroupId []byte `protobuf:"bytes,9,opt,name=NexthopGroupId,proto3,oneof"`
}
type TunnelSpec_TunnelId struct {
	TunnelId []byte `protobuf:"bytes,10,opt,name=TunnelId,proto3,oneof"`
}
type TunnelSpec_DropNexthop struct {
	DropNexthop *DropNexthop `protobuf:"bytes,11,opt,name=DropNexthop,proto3,oneof"`
}

func (*TunnelSpec_NexthopId) isTunnelSpec_Nh()      {}
func (*TunnelSpec_NexthopGroupId) isTunnelSpec_Nh() {}
func (*TunnelSpec_TunnelId) isTunnelSpec_Nh()       {}
func (*TunnelSpec_DropNexthop) isTunnelSpec_Nh()    {}

func (m *TunnelSpec) GetNh() isTunnelSpec_Nh {
	if m != nil {
		return m.Nh
	}
	return nil
}

func (m *TunnelSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TunnelSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *TunnelSpec) GetLocalIP() *IPAddress {
	if m != nil {
		return m.LocalIP
	}
	return nil
}

func (m *TunnelSpec) GetRemoteIP() *IPAddress {
	if m != nil {
		return m.RemoteIP
	}
	return nil
}

func (m *TunnelSpec) GetType() TunnelType {
	if m != nil {
		return m.Type
	}
	return TunnelType_TUNNEL_TYPE_NONE
}

func (m *TunnelSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *TunnelSpec) GetNat() bool {
	if m != nil {
		return m.Nat
	}
	return false
}

func (m *TunnelSpec) GetNexthopId() []byte {
	if x, ok := m.GetNh().(*TunnelSpec_NexthopId); ok {
		return x.NexthopId
	}
	return nil
}

func (m *TunnelSpec) GetNexthopGroupId() []byte {
	if x, ok := m.GetNh().(*TunnelSpec_NexthopGroupId); ok {
		return x.NexthopGroupId
	}
	return nil
}

func (m *TunnelSpec) GetTunnelId() []byte {
	if x, ok := m.GetNh().(*TunnelSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (m *TunnelSpec) GetDropNexthop() *DropNexthop {
	if x, ok := m.GetNh().(*TunnelSpec_DropNexthop); ok {
		return x.DropNexthop
	}
	return nil
}

func (m *TunnelSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

func (m *TunnelSpec) GetRemoteService() bool {
	if m != nil {
		return m.RemoteService
	}
	return false
}

func (m *TunnelSpec) GetRemoteServiceEncap() *Encap {
	if m != nil {
		return m.RemoteServiceEncap
	}
	return nil
}

func (m *TunnelSpec) GetRemoteServicePublicIP() *IPAddress {
	if m != nil {
		return m.RemoteServicePublicIP
	}
	return nil
}

func (m *TunnelSpec) GetToS() uint32 {
	if m != nil {
		return m.ToS
	}
	return 0
}

func (m *TunnelSpec) GetIpsecEncryptSAId() []byte {
	if m != nil {
		return m.IpsecEncryptSAId
	}
	return nil
}

func (m *TunnelSpec) GetIpsecDecryptSAId() []byte {
	if m != nil {
		return m.IpsecDecryptSAId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TunnelSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TunnelSpec_NexthopId)(nil),
		(*TunnelSpec_NexthopGroupId)(nil),
		(*TunnelSpec_TunnelId)(nil),
		(*TunnelSpec_DropNexthop)(nil),
	}
}

// operational status of the tunnel, if any
type TunnelStatus struct {
	HwId                 uint32   `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelStatus) Reset()         { *m = TunnelStatus{} }
func (m *TunnelStatus) String() string { return proto.CompactTextString(m) }
func (*TunnelStatus) ProtoMessage()    {}
func (*TunnelStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{1}
}
func (m *TunnelStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelStatus.Merge(m, src)
}
func (m *TunnelStatus) XXX_Size() int {
	return m.Size()
}
func (m *TunnelStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelStatus proto.InternalMessageInfo

func (m *TunnelStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

// stats of the tunnel, if any
type TunnelStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelStats) Reset()         { *m = TunnelStats{} }
func (m *TunnelStats) String() string { return proto.CompactTextString(m) }
func (*TunnelStats) ProtoMessage()    {}
func (*TunnelStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{2}
}
func (m *TunnelStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelStats.Merge(m, src)
}
func (m *TunnelStats) XXX_Size() int {
	return m.Size()
}
func (m *TunnelStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelStats.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelStats proto.InternalMessageInfo

// tunnel object
type Tunnel struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *TunnelSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *TunnelStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *TunnelStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Tunnel) Reset()         { *m = Tunnel{} }
func (m *Tunnel) String() string { return proto.CompactTextString(m) }
func (*Tunnel) ProtoMessage()    {}
func (*Tunnel) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{3}
}
func (m *Tunnel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tunnel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tunnel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tunnel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tunnel.Merge(m, src)
}
func (m *Tunnel) XXX_Size() int {
	return m.Size()
}
func (m *Tunnel) XXX_DiscardUnknown() {
	xxx_messageInfo_Tunnel.DiscardUnknown(m)
}

var xxx_messageInfo_Tunnel proto.InternalMessageInfo

func (m *Tunnel) GetSpec() *TunnelSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Tunnel) GetStatus() *TunnelStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Tunnel) GetStats() *TunnelStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// tunnel create and update request
type TunnelRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt    `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*TunnelSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TunnelRequest) Reset()         { *m = TunnelRequest{} }
func (m *TunnelRequest) String() string { return proto.CompactTextString(m) }
func (*TunnelRequest) ProtoMessage()    {}
func (*TunnelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{4}
}
func (m *TunnelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelRequest.Merge(m, src)
}
func (m *TunnelRequest) XXX_Size() int {
	return m.Size()
}
func (m *TunnelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelRequest proto.InternalMessageInfo

func (m *TunnelRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *TunnelRequest) GetRequest() []*TunnelSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// tunnel create and update response
type TunnelResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TunnelStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TunnelResponse) Reset()         { *m = TunnelResponse{} }
func (m *TunnelResponse) String() string { return proto.CompactTextString(m) }
func (*TunnelResponse) ProtoMessage()    {}
func (*TunnelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{5}
}
func (m *TunnelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelResponse.Merge(m, src)
}
func (m *TunnelResponse) XXX_Size() int {
	return m.Size()
}
func (m *TunnelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelResponse proto.InternalMessageInfo

func (m *TunnelResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TunnelResponse) GetResponse() []*TunnelStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// tunnel get request
type TunnelGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelGetRequest) Reset()         { *m = TunnelGetRequest{} }
func (m *TunnelGetRequest) String() string { return proto.CompactTextString(m) }
func (*TunnelGetRequest) ProtoMessage()    {}
func (*TunnelGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{6}
}
func (m *TunnelGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelGetRequest.Merge(m, src)
}
func (m *TunnelGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *TunnelGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelGetRequest proto.InternalMessageInfo

func (m *TunnelGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// tunnel get response
type TunnelGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Tunnel `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TunnelGetResponse) Reset()         { *m = TunnelGetResponse{} }
func (m *TunnelGetResponse) String() string { return proto.CompactTextString(m) }
func (*TunnelGetResponse) ProtoMessage()    {}
func (*TunnelGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{7}
}
func (m *TunnelGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelGetResponse.Merge(m, src)
}
func (m *TunnelGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TunnelGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelGetResponse proto.InternalMessageInfo

func (m *TunnelGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TunnelGetResponse) GetResponse() []*Tunnel {
	if m != nil {
		return m.Response
	}
	return nil
}

// tunnel delete request
type TunnelDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TunnelDeleteRequest) Reset()         { *m = TunnelDeleteRequest{} }
func (m *TunnelDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*TunnelDeleteRequest) ProtoMessage()    {}
func (*TunnelDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{8}
}
func (m *TunnelDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelDeleteRequest.Merge(m, src)
}
func (m *TunnelDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *TunnelDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelDeleteRequest proto.InternalMessageInfo

func (m *TunnelDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *TunnelDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// tunnel delete response
type TunnelDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TunnelDeleteResponse) Reset()         { *m = TunnelDeleteResponse{} }
func (m *TunnelDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*TunnelDeleteResponse) ProtoMessage()    {}
func (*TunnelDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f51ddaa7891a711, []int{9}
}
func (m *TunnelDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelDeleteResponse.Merge(m, src)
}
func (m *TunnelDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *TunnelDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelDeleteResponse proto.InternalMessageInfo

func (m *TunnelDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.TunnelType", TunnelType_name, TunnelType_value)
	proto.RegisterType((*TunnelSpec)(nil), "pds.TunnelSpec")
	proto.RegisterType((*TunnelStatus)(nil), "pds.TunnelStatus")
	proto.RegisterType((*TunnelStats)(nil), "pds.TunnelStats")
	proto.RegisterType((*Tunnel)(nil), "pds.Tunnel")
	proto.RegisterType((*TunnelRequest)(nil), "pds.TunnelRequest")
	proto.RegisterType((*TunnelResponse)(nil), "pds.TunnelResponse")
	proto.RegisterType((*TunnelGetRequest)(nil), "pds.TunnelGetRequest")
	proto.RegisterType((*TunnelGetResponse)(nil), "pds.TunnelGetResponse")
	proto.RegisterType((*TunnelDeleteRequest)(nil), "pds.TunnelDeleteRequest")
	proto.RegisterType((*TunnelDeleteResponse)(nil), "pds.TunnelDeleteResponse")
}

func init() { proto.RegisterFile("tunnel.proto", fileDescriptor_6f51ddaa7891a711) }

var fileDescriptor_6f51ddaa7891a711 = []byte{
	// 945 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xdd, 0x6e, 0xe2, 0x46,
	0x14, 0xc7, 0x63, 0x43, 0x3e, 0x38, 0x7c, 0x39, 0x87, 0x64, 0xeb, 0xa2, 0x15, 0x20, 0xab, 0x52,
	0x69, 0x94, 0x52, 0x95, 0x4a, 0xad, 0xda, 0x5d, 0x69, 0x85, 0xc1, 0x9b, 0xb8, 0xcd, 0x12, 0x34,
	0x90, 0x5d, 0xf5, 0x2a, 0x72, 0xec, 0xd1, 0x86, 0x15, 0x60, 0x17, 0x0f, 0xdb, 0xe5, 0x05, 0xfa,
	0x12, 0x7d, 0x96, 0xde, 0x57, 0xbd, 0xda, 0x27, 0x40, 0x55, 0x2e, 0x73, 0xb9, 0x4f, 0x50, 0x79,
	0x3c, 0x86, 0x21, 0xa1, 0x4a, 0xbb, 0x37, 0x91, 0xfd, 0x9f, 0xff, 0xcf, 0x73, 0xce, 0x99, 0x39,
	0x27, 0x40, 0x8e, 0xcd, 0x26, 0x13, 0x3a, 0x6a, 0x04, 0x53, 0x9f, 0xf9, 0x98, 0x0a, 0xbc, 0xb0,
	0x0c, 0xaf, 0xfd, 0xd7, 0x7e, 0x2c, 0x94, 0x8b, 0x63, 0xca, 0x9c, 0xaf, 0xa2, 0x3f, 0x42, 0xc8,
	0xb2, 0x79, 0x40, 0xc3, 0xf8, 0xc5, 0xf8, 0x6b, 0x07, 0x60, 0xc0, 0xf9, 0x7e, 0x40, 0x5d, 0x3c,
	0x06, 0xd5, 0xf6, 0x74, 0xa5, 0xa6, 0xd4, 0x73, 0xe6, 0xe3, 0x0f, 0x8b, 0xaa, 0x1e, 0x71, 0x3f,
	0x8c, 0x9d, 0x89, 0xe7, 0x30, 0x7f, 0x3a, 0x3f, 0x1e, 0x8e, 0xc7, 0x33, 0xe6, 0x5c, 0x8d, 0x28,
	0x51, 0x6d, 0x0f, 0x9b, 0xb0, 0xfd, 0xb2, 0xd7, 0xb6, 0x3d, 0x5d, 0xfd, 0x0f, 0x40, 0x6c, 0xc5,
	0x23, 0xd8, 0x3d, 0xf3, 0x5d, 0x67, 0x64, 0xf7, 0xf4, 0x54, 0x4d, 0xa9, 0x67, 0x9b, 0x5a, 0x23,
	0x8e, 0xc7, 0xee, 0xb5, 0x3c, 0x6f, 0x4a, 0xc3, 0x90, 0x24, 0x06, 0xfc, 0x11, 0xf6, 0x08, 0x1d,
	0xfb, 0x8c, 0xda, 0x3d, 0x3d, 0xbd, 0xd9, 0xfc, 0xc0, 0xa6, 0x4b, 0x1e, 0x5b, 0x90, 0x1e, 0xcc,
	0x03, 0xaa, 0x6f, 0xd7, 0x94, 0x7a, 0xa1, 0x59, 0x6c, 0x04, 0x5e, 0xd8, 0x88, 0x13, 0x8f, 0xe4,
	0x07, 0x3e, 0xc3, 0x51, 0xfc, 0x1a, 0xb6, 0xad, 0x89, 0xeb, 0x04, 0xfa, 0x0e, 0x8f, 0x25, 0x27,
	0x62, 0xe1, 0x9a, 0x99, 0xff, 0xb0, 0xa8, 0x66, 0xa4, 0x6c, 0xb9, 0x8a, 0x1a, 0xa4, 0xba, 0x0e,
	0xd3, 0x77, 0x6b, 0x4a, 0x7d, 0x8f, 0x44, 0x8f, 0x58, 0x81, 0x4c, 0x97, 0xbe, 0x63, 0xd7, 0x7e,
	0x60, 0x7b, 0xfa, 0x5e, 0x54, 0xb7, 0xd3, 0x2d, 0xb2, 0x92, 0xb0, 0x0e, 0x05, 0xf1, 0x72, 0x32,
	0xf5, 0x67, 0x91, 0x29, 0x23, 0x4c, 0x77, 0x74, 0x7c, 0x0c, 0x7b, 0x71, 0x02, 0xb6, 0xa7, 0x83,
	0xf0, 0x2c, 0x15, 0xfc, 0x16, 0xb2, 0x9d, 0xa9, 0x1f, 0x08, 0x46, 0xcf, 0xf2, 0x90, 0x51, 0x84,
	0x2c, 0xad, 0x9c, 0x6e, 0x11, 0xd9, 0x88, 0x15, 0x80, 0x17, 0xad, 0xb6, 0xa8, 0xae, 0x9e, 0xab,
	0x29, 0xf5, 0x34, 0x91, 0x14, 0xfc, 0x0c, 0xf2, 0x71, 0x4d, 0xfb, 0x74, 0xfa, 0x76, 0xe8, 0x52,
	0x3d, 0xcf, 0x73, 0x5b, 0x17, 0xf1, 0x29, 0xe0, 0x9a, 0x10, 0xd7, 0xad, 0x70, 0xbf, 0x6e, 0x64,
	0x83, 0x0f, 0x9f, 0xc3, 0xe1, 0x9a, 0xda, 0x9b, 0x5d, 0x8d, 0x86, 0xae, 0xdd, 0xd3, 0x8b, 0xff,
	0x72, 0x63, 0x36, 0xdb, 0xa3, 0xea, 0x0f, 0xfc, 0xbe, 0xae, 0xd5, 0x94, 0x7a, 0x9e, 0x44, 0x8f,
	0x78, 0x04, 0x9a, 0x1d, 0x84, 0xd4, 0xb5, 0x26, 0xee, 0x74, 0x1e, 0xb0, 0x7e, 0xcb, 0xf6, 0xf4,
	0xfd, 0xa8, 0x76, 0xe4, 0x9e, 0xbe, 0xf4, 0x76, 0xe8, 0xca, 0x8b, 0x92, 0x57, 0xd2, 0xcd, 0x34,
	0xa8, 0x93, 0x6b, 0xc3, 0x80, 0x9c, 0xe8, 0x25, 0xe6, 0xb0, 0x59, 0x88, 0x08, 0xe9, 0xd3, 0x5f,
	0x45, 0x3f, 0xe5, 0x09, 0x7f, 0x36, 0xf2, 0x90, 0x5d, 0x79, 0x42, 0xe3, 0x0f, 0x15, 0x76, 0xe2,
	0x77, 0x7c, 0x02, 0x7b, 0xd1, 0x35, 0x7b, 0x41, 0x99, 0xc3, 0x89, 0x6c, 0xb3, 0xd0, 0xe0, 0x6d,
	0x9b, 0xa8, 0x66, 0xf1, 0xfd, 0xa2, 0xaa, 0xdc, 0x2e, 0xaa, 0xbb, 0xc7, 0xc3, 0xc9, 0x68, 0x38,
	0xa1, 0x64, 0x09, 0xe0, 0x33, 0xd8, 0x3d, 0xbf, 0x7a, 0xc3, 0x59, 0x95, 0xb3, 0xf9, 0x98, 0x15,
	0xa2, 0xf9, 0x48, 0xa0, 0x85, 0x48, 0x3d, 0xf6, 0xc7, 0x43, 0x46, 0xc7, 0x01, 0x9b, 0x93, 0x84,
	0xc2, 0xef, 0x20, 0x1d, 0x4d, 0x00, 0xd1, 0x94, 0x72, 0x7f, 0x44, 0xb2, 0x89, 0x11, 0x1b, 0x06,
	0xd4, 0x95, 0x58, 0x0e, 0xe0, 0x33, 0xd8, 0x89, 0xd3, 0x15, 0x2d, 0xba, 0x2f, 0xa3, 0x7c, 0xc1,
	0x3c, 0xb8, 0x5d, 0x54, 0xb5, 0x90, 0x3f, 0x4b, 0xb8, 0xc0, 0xf0, 0x09, 0x6c, 0xf3, 0x5a, 0xf0,
	0xd6, 0x8c, 0x4e, 0x77, 0x9d, 0x0f, 0xcd, 0xd2, 0xed, 0xa2, 0x5a, 0x8c, 0x70, 0x99, 0x8e, 0x19,
	0xe3, 0x0d, 0xe4, 0x63, 0x2b, 0xa1, 0xbf, 0xcc, 0x68, 0xc8, 0xb0, 0x01, 0x19, 0xd3, 0x61, 0xee,
	0x75, 0x9b, 0xbd, 0x63, 0xa2, 0x8c, 0xc9, 0x7d, 0x59, 0xea, 0x64, 0x65, 0xc1, 0x2f, 0x60, 0x57,
	0xa0, 0xba, 0x5a, 0x4b, 0x6d, 0x48, 0x9d, 0x24, 0xeb, 0x86, 0x0f, 0x85, 0x64, 0xaf, 0x30, 0xf0,
	0x27, 0x21, 0x8d, 0x36, 0x6b, 0x05, 0x43, 0x91, 0xbe, 0xc2, 0x27, 0x4b, 0xb2, 0xd9, 0x52, 0x27,
	0x2b, 0x0b, 0x7e, 0x19, 0x0d, 0xb4, 0x98, 0x15, 0xbb, 0xdd, 0xaf, 0x16, 0x59, 0x5a, 0x0c, 0x03,
	0xb4, 0x78, 0xe5, 0x84, 0xb2, 0x24, 0xbf, 0x82, 0x98, 0xd0, 0xa9, 0x7a, 0x2e, 0x9a, 0xc1, 0xc6,
	0x08, 0xf6, 0x25, 0xcf, 0x47, 0xc6, 0xf5, 0xf9, 0xbd, 0xb8, 0xb2, 0x52, 0x5c, 0x52, 0x44, 0x17,
	0x50, 0x8a, 0xb5, 0x0e, 0x1d, 0x51, 0x46, 0x3f, 0xb6, 0xe8, 0x71, 0x12, 0xea, 0x32, 0x89, 0xe7,
	0x70, 0xb0, 0xfe, 0xd9, 0xcd, 0x79, 0xa4, 0x1e, 0xc8, 0xe3, 0xe8, 0x77, 0x25, 0xf9, 0x6f, 0xc6,
	0x07, 0xf6, 0x01, 0x68, 0x83, 0x8b, 0x6e, 0xd7, 0x3a, 0xbb, 0x1c, 0xfc, 0xdc, 0xb3, 0x2e, 0xbb,
	0xe7, 0x5d, 0x4b, 0xdb, 0xc2, 0x12, 0x14, 0x65, 0xd5, 0x3e, 0x79, 0xa5, 0x29, 0xa8, 0xc3, 0x81,
	0x2c, 0xbe, 0x3a, 0x27, 0x3f, 0x9d, 0x9d, 0xb7, 0x3a, 0x9a, 0x7a, 0x77, 0xc5, 0xee, 0x0e, 0x2c,
	0x72, 0xd9, 0x69, 0x6b, 0x29, 0xfc, 0x04, 0x4a, 0xf2, 0x4a, 0xdf, 0x22, 0x2f, 0xed, 0xb6, 0xa5,
	0xa5, 0xf1, 0x10, 0xf6, 0xd7, 0x90, 0x5e, 0xdf, 0x6a, 0x6b, 0xdb, 0xcd, 0xdf, 0x54, 0xc8, 0x88,
	0x93, 0x7e, 0xeb, 0xe2, 0xf7, 0xc9, 0xb0, 0x68, 0x4f, 0xa9, 0xc3, 0x28, 0xa2, 0x5c, 0xf1, 0xb8,
	0xae, 0xe5, 0xd2, 0x9a, 0x26, 0xce, 0x60, 0x6b, 0x85, 0x5e, 0x04, 0xde, 0xff, 0x44, 0x9f, 0x26,
	0x21, 0x9c, 0x50, 0x86, 0x87, 0x92, 0x67, 0x75, 0xc5, 0xca, 0x8f, 0xee, 0xca, 0x4b, 0xda, 0x4a,
	0x36, 0x8e, 0xcf, 0x09, 0x75, 0xc9, 0xb9, 0x76, 0x23, 0xca, 0x9f, 0x6e, 0x58, 0x49, 0x3e, 0x63,
	0xe6, 0xfe, 0xbc, 0xa9, 0x28, 0xef, 0x6f, 0x2a, 0xca, 0xdf, 0x37, 0x15, 0xe5, 0x6a, 0x87, 0xff,
	0x12, 0xf9, 0xe6, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x27, 0xbe, 0x6c, 0xd3, 0xc8, 0x08, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TunnelSvcClient is the client API for TunnelSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TunnelSvcClient interface {
	TunnelCreate(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (*TunnelResponse, error)
	TunnelUpdate(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (*TunnelResponse, error)
	TunnelGet(ctx context.Context, in *TunnelGetRequest, opts ...grpc.CallOption) (*TunnelGetResponse, error)
	TunnelDelete(ctx context.Context, in *TunnelDeleteRequest, opts ...grpc.CallOption) (*TunnelDeleteResponse, error)
}

type tunnelSvcClient struct {
	cc *grpc.ClientConn
}

func NewTunnelSvcClient(cc *grpc.ClientConn) TunnelSvcClient {
	return &tunnelSvcClient{cc}
}

func (c *tunnelSvcClient) TunnelCreate(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (*TunnelResponse, error) {
	out := new(TunnelResponse)
	err := c.cc.Invoke(ctx, "/pds.TunnelSvc/TunnelCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelSvcClient) TunnelUpdate(ctx context.Context, in *TunnelRequest, opts ...grpc.CallOption) (*TunnelResponse, error) {
	out := new(TunnelResponse)
	err := c.cc.Invoke(ctx, "/pds.TunnelSvc/TunnelUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelSvcClient) TunnelGet(ctx context.Context, in *TunnelGetRequest, opts ...grpc.CallOption) (*TunnelGetResponse, error) {
	out := new(TunnelGetResponse)
	err := c.cc.Invoke(ctx, "/pds.TunnelSvc/TunnelGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tunnelSvcClient) TunnelDelete(ctx context.Context, in *TunnelDeleteRequest, opts ...grpc.CallOption) (*TunnelDeleteResponse, error) {
	out := new(TunnelDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.TunnelSvc/TunnelDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TunnelSvcServer is the server API for TunnelSvc service.
type TunnelSvcServer interface {
	TunnelCreate(context.Context, *TunnelRequest) (*TunnelResponse, error)
	TunnelUpdate(context.Context, *TunnelRequest) (*TunnelResponse, error)
	TunnelGet(context.Context, *TunnelGetRequest) (*TunnelGetResponse, error)
	TunnelDelete(context.Context, *TunnelDeleteRequest) (*TunnelDeleteResponse, error)
}

// UnimplementedTunnelSvcServer can be embedded to have forward compatible implementations.
type UnimplementedTunnelSvcServer struct {
}

func (*UnimplementedTunnelSvcServer) TunnelCreate(ctx context.Context, req *TunnelRequest) (*TunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TunnelCreate not implemented")
}
func (*UnimplementedTunnelSvcServer) TunnelUpdate(ctx context.Context, req *TunnelRequest) (*TunnelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TunnelUpdate not implemented")
}
func (*UnimplementedTunnelSvcServer) TunnelGet(ctx context.Context, req *TunnelGetRequest) (*TunnelGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TunnelGet not implemented")
}
func (*UnimplementedTunnelSvcServer) TunnelDelete(ctx context.Context, req *TunnelDeleteRequest) (*TunnelDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TunnelDelete not implemented")
}

func RegisterTunnelSvcServer(s *grpc.Server, srv TunnelSvcServer) {
	s.RegisterService(&_TunnelSvc_serviceDesc, srv)
}

func _TunnelSvc_TunnelCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelSvcServer).TunnelCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TunnelSvc/TunnelCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelSvcServer).TunnelCreate(ctx, req.(*TunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelSvc_TunnelUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelSvcServer).TunnelUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TunnelSvc/TunnelUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelSvcServer).TunnelUpdate(ctx, req.(*TunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelSvc_TunnelGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelSvcServer).TunnelGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TunnelSvc/TunnelGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelSvcServer).TunnelGet(ctx, req.(*TunnelGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TunnelSvc_TunnelDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TunnelDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TunnelSvcServer).TunnelDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TunnelSvc/TunnelDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TunnelSvcServer).TunnelDelete(ctx, req.(*TunnelDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TunnelSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.TunnelSvc",
	HandlerType: (*TunnelSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TunnelCreate",
			Handler:    _TunnelSvc_TunnelCreate_Handler,
		},
		{
			MethodName: "TunnelUpdate",
			Handler:    _TunnelSvc_TunnelUpdate_Handler,
		},
		{
			MethodName: "TunnelGet",
			Handler:    _TunnelSvc_TunnelGet_Handler,
		},
		{
			MethodName: "TunnelDelete",
			Handler:    _TunnelSvc_TunnelDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tunnel.proto",
}

func (m *TunnelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IpsecDecryptSAId) > 0 {
		i -= len(m.IpsecDecryptSAId)
		copy(dAtA[i:], m.IpsecDecryptSAId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.IpsecDecryptSAId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IpsecEncryptSAId) > 0 {
		i -= len(m.IpsecEncryptSAId)
		copy(dAtA[i:], m.IpsecEncryptSAId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.IpsecEncryptSAId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ToS != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.ToS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RemoteServicePublicIP != nil {
		{
			size, err := m.RemoteServicePublicIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.RemoteServiceEncap != nil {
		{
			size, err := m.RemoteServiceEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.RemoteService {
		i--
		if m.RemoteService {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MACAddress != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x60
	}
	if m.Nh != nil {
		{
			size := m.Nh.Size()
			i -= size
			if _, err := m.Nh.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Nat {
		i--
		if m.Nat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.RemoteIP != nil {
		{
			size, err := m.RemoteIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LocalIP != nil {
		{
			size, err := m.LocalIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelSpec_NexthopId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TunnelSpec_NexthopId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NexthopId != nil {
		i -= len(m.NexthopId)
		copy(dAtA[i:], m.NexthopId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.NexthopId)))
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TunnelSpec_NexthopGroupId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TunnelSpec_NexthopGroupId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NexthopGroupId != nil {
		i -= len(m.NexthopGroupId)
		copy(dAtA[i:], m.NexthopGroupId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.NexthopGroupId)))
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *TunnelSpec_TunnelId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TunnelSpec_TunnelId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelId != nil {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintTunnel(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *TunnelSpec_DropNexthop) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *TunnelSpec_DropNexthop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropNexthop != nil {
		{
			size, err := m.DropNexthop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *TunnelStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HwId != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Tunnel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tunnel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tunnel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTunnel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTunnel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintTunnel(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTunnel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTunnel(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintTunnel(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTunnel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA15 := make([]byte, len(m.ApiStatus)*10)
		var j14 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintTunnel(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTunnel(dAtA []byte, offset int, v uint64) int {
	offset -= sovTunnel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TunnelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTunnel(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.LocalIP != nil {
		l = m.LocalIP.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.RemoteIP != nil {
		l = m.RemoteIP.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTunnel(uint64(m.Type))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.Nat {
		n += 2
	}
	if m.Nh != nil {
		n += m.Nh.Size()
	}
	if m.MACAddress != 0 {
		n += 1 + sovTunnel(uint64(m.MACAddress))
	}
	if m.RemoteService {
		n += 2
	}
	if m.RemoteServiceEncap != nil {
		l = m.RemoteServiceEncap.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.RemoteServicePublicIP != nil {
		l = m.RemoteServicePublicIP.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.ToS != 0 {
		n += 2 + sovTunnel(uint64(m.ToS))
	}
	l = len(m.IpsecEncryptSAId)
	if l > 0 {
		n += 2 + l + sovTunnel(uint64(l))
	}
	l = len(m.IpsecDecryptSAId)
	if l > 0 {
		n += 2 + l + sovTunnel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelSpec_NexthopId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NexthopId != nil {
		l = len(m.NexthopId)
		n += 1 + l + sovTunnel(uint64(l))
	}
	return n
}
func (m *TunnelSpec_NexthopGroupId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NexthopGroupId != nil {
		l = len(m.NexthopGroupId)
		n += 1 + l + sovTunnel(uint64(l))
	}
	return n
}
func (m *TunnelSpec_TunnelId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		l = len(m.TunnelId)
		n += 1 + l + sovTunnel(uint64(l))
	}
	return n
}
func (m *TunnelSpec_DropNexthop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropNexthop != nil {
		l = m.DropNexthop.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	return n
}
func (m *TunnelStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovTunnel(uint64(m.HwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tunnel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTunnel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTunnel(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTunnel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovTunnel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTunnel(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTunnel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovTunnel(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovTunnel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovTunnel(uint64(e))
		}
		n += 1 + sovTunnel(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTunnel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTunnel(x uint64) (n int) {
	return sovTunnel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TunnelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIP == nil {
				m.LocalIP = &IPAddress{}
			}
			if err := m.LocalIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIP == nil {
				m.RemoteIP = &IPAddress{}
			}
			if err := m.RemoteIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nat = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &TunnelSpec_NexthopId{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopGroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &TunnelSpec_NexthopGroupId{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &TunnelSpec_TunnelId{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropNexthop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropNexthop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nh = &TunnelSpec_DropNexthop{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteService", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteService = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteServiceEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteServiceEncap == nil {
				m.RemoteServiceEncap = &Encap{}
			}
			if err := m.RemoteServiceEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteServicePublicIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteServicePublicIP == nil {
				m.RemoteServicePublicIP = &IPAddress{}
			}
			if err := m.RemoteServicePublicIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToS", wireType)
			}
			m.ToS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecEncryptSAId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecEncryptSAId = append(m.IpsecEncryptSAId[:0], dAtA[iNdEx:postIndex]...)
			if m.IpsecEncryptSAId == nil {
				m.IpsecEncryptSAId = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecDecryptSAId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecDecryptSAId = append(m.IpsecDecryptSAId[:0], dAtA[iNdEx:postIndex]...)
			if m.IpsecDecryptSAId == nil {
				m.IpsecDecryptSAId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tunnel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tunnel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tunnel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TunnelSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TunnelStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TunnelStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TunnelSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TunnelStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Tunnel{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTunnel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTunnel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTunnel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTunnel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTunnel
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTunnel
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTunnel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTunnel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTunnel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTunnel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTunnel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTunnel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTunnel
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTunnel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTunnel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTunnel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTunnel
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTunnel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTunnel   = fmt.Errorf("proto: integer overflow")
)
