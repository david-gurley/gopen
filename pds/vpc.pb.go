// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vpc.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// type of the virtual private cloud
type VPCType int32

const (
	VPCType_VPC_TYPE_NONE     VPCType = 0
	VPCType_VPC_TYPE_UNDERLAY VPCType = 1
	VPCType_VPC_TYPE_TENANT   VPCType = 2
	VPCType_VPC_TYPE_CONTROL  VPCType = 3
)

var VPCType_name = map[int32]string{
	0: "VPC_TYPE_NONE",
	1: "VPC_TYPE_UNDERLAY",
	2: "VPC_TYPE_TENANT",
	3: "VPC_TYPE_CONTROL",
}

var VPCType_value = map[string]int32{
	"VPC_TYPE_NONE":     0,
	"VPC_TYPE_UNDERLAY": 1,
	"VPC_TYPE_TENANT":   2,
	"VPC_TYPE_CONTROL":  3,
}

func (x VPCType) String() string {
	return proto.EnumName(VPCType_name, int32(x))
}

func (VPCType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{0}
}

// VPCSpec captures VPC configuration
type VPCSpec struct {
	// unique key/identifier of VPC
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// type of the VPC
	Type VPCType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.VPCType" json:"Type,omitempty" meta:mandatory,immutable`
	// identifier of the IPv4 route table to be used and this route table is
	// inherited by the subnets under this VPC, if they are created with no route
	// table explicitly
	V4RouteTableId []byte `protobuf:"bytes,3,opt,name=V4RouteTableId,proto3" json:"V4RouteTableId,omitempty"`
	// identifier of the IPv6 route table to be used, if any and this route table
	// is inherited by the subnets under this VPC, if they are created with no
	// route table explicitly
	V6RouteTableId []byte `protobuf:"bytes,4,opt,name=V6RouteTableId,proto3" json:"V6RouteTableId,omitempty"`
	// identifier of ingress IPv4 security policy to be enforced
	// NOTE:
	// 1. all vnics in this VPC will inherit the policies configured under VPC
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only one policy per vpc in each direction is allowed to be configured
	IngV4SecurityPolicyId [][]byte `protobuf:"bytes,5,rep,name=IngV4SecurityPolicyId,proto3" json:"IngV4SecurityPolicyId,omitempty"`
	// identifier of ingress IPv6 security policy to be enforced
	// NOTE:
	// 1. all vnics in this VPC will inherit the policies configured under VPC
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only one policy per vpc in each direction is allowed to be configured
	IngV6SecurityPolicyId [][]byte `protobuf:"bytes,6,rep,name=IngV6SecurityPolicyId,proto3" json:"IngV6SecurityPolicyId,omitempty"`
	// identifier of egress IPv4 security policy to be enforced
	// NOTE:
	// 1. all vnics in this VPC will inherit the policies configured under VPC
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only one policy per vpc in each direction is allowed to be configured
	EgV4SecurityPolicyId [][]byte `protobuf:"bytes,7,rep,name=EgV4SecurityPolicyId,proto3" json:"EgV4SecurityPolicyId,omitempty"`
	// identifier of egress IPv6 security policy to be enforced
	// NOTE:
	// 1. all vnics in this VPC will inherit the policies configured under VPC
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only one policy per vpc in each direction is allowed to be configured
	EgV6SecurityPolicyId [][]byte `protobuf:"bytes,8,rep,name=EgV6SecurityPolicyId,proto3" json:"EgV6SecurityPolicyId,omitempty"`
	// Virtual Router (VR) MAC address, any packets originated or routed in this
	// VPC carry this MAC as source MAC
	VirtualRouterMac uint64 `protobuf:"varint,9,opt,name=VirtualRouterMac,proto3" json:"VirtualRouterMac,omitempty"`
	// encapped traffic coming with the specified encap from fabric side will be
	// mapped to this VPC
	// NOTE: FabricEncap is needed only for VPCs of type VPC_TYPE_TENANT, for
	//       other types of VPCs user need not provide fabric encap and will be
	//       unused when provided
	FabricEncap *Encap `protobuf:"bytes,10,opt,name=FabricEncap,proto3" json:"FabricEncap,omitempty" meta:immutable`
	// metering policy to be applied for ipv4 traffic ingressing/egressing the vpc
	V4MeterPolicy []byte `protobuf:"bytes,11,opt,name=V4MeterPolicy,proto3" json:"V4MeterPolicy,omitempty"`
	// metering policy to be applied for ipv6 traffic ingressing/egressing the vpc
	V6MeterPolicy []byte `protobuf:"bytes,12,opt,name=V6MeterPolicy,proto3" json:"V6MeterPolicy,omitempty"`
	// ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
	// header or in the Traffic Class field of IPv6 outer header, this value, if
	// non-zero, will be used as-is (i.e., not interpreted) during encap time by
	// the dataplane
	// NOTE:
	// 1. subnets under this VPC don't inherit this ToS value, subnets need to
	//    be explicitly configured with same ToS value as that of VPC or
	//    potentially different ToS value of their own
	// 2. subnet or tunnel objects, if configured with ToS, will override this
	ToS uint32 `protobuf:"varint,13,opt,name=ToS,proto3" json:"ToS,omitempty"`
	// VxLAN Network Identifiers(VNI) associated with this VPC (other than
	// FabricEncap)
	// NOTE:
	// any incoming VxLAN traffic received with the VNI list configured is
	// associated with the VPC for mapping and flow lookup purposes
	VNI                  []uint32 `protobuf:"varint,14,rep,packed,name=VNI,proto3" json:"VNI,omitempty" meta:immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCSpec) Reset()         { *m = VPCSpec{} }
func (m *VPCSpec) String() string { return proto.CompactTextString(m) }
func (*VPCSpec) ProtoMessage()    {}
func (*VPCSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{0}
}
func (m *VPCSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCSpec.Merge(m, src)
}
func (m *VPCSpec) XXX_Size() int {
	return m.Size()
}
func (m *VPCSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VPCSpec proto.InternalMessageInfo

func (m *VPCSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *VPCSpec) GetType() VPCType {
	if m != nil {
		return m.Type
	}
	return VPCType_VPC_TYPE_NONE
}

func (m *VPCSpec) GetV4RouteTableId() []byte {
	if m != nil {
		return m.V4RouteTableId
	}
	return nil
}

func (m *VPCSpec) GetV6RouteTableId() []byte {
	if m != nil {
		return m.V6RouteTableId
	}
	return nil
}

func (m *VPCSpec) GetIngV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV4SecurityPolicyId
	}
	return nil
}

func (m *VPCSpec) GetIngV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV6SecurityPolicyId
	}
	return nil
}

func (m *VPCSpec) GetEgV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV4SecurityPolicyId
	}
	return nil
}

func (m *VPCSpec) GetEgV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV6SecurityPolicyId
	}
	return nil
}

func (m *VPCSpec) GetVirtualRouterMac() uint64 {
	if m != nil {
		return m.VirtualRouterMac
	}
	return 0
}

func (m *VPCSpec) GetFabricEncap() *Encap {
	if m != nil {
		return m.FabricEncap
	}
	return nil
}

func (m *VPCSpec) GetV4MeterPolicy() []byte {
	if m != nil {
		return m.V4MeterPolicy
	}
	return nil
}

func (m *VPCSpec) GetV6MeterPolicy() []byte {
	if m != nil {
		return m.V6MeterPolicy
	}
	return nil
}

func (m *VPCSpec) GetToS() uint32 {
	if m != nil {
		return m.ToS
	}
	return 0
}

func (m *VPCSpec) GetVNI() []uint32 {
	if m != nil {
		return m.VNI
	}
	return nil
}

// operational status of a VPC, if any
type VPCStatus struct {
	// vpc hw id
	HwId uint32 `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	// vpc bd hw id
	BdHwId               uint32   `protobuf:"varint,2,opt,name=BdHwId,proto3" json:"BdHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCStatus) Reset()         { *m = VPCStatus{} }
func (m *VPCStatus) String() string { return proto.CompactTextString(m) }
func (*VPCStatus) ProtoMessage()    {}
func (*VPCStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{1}
}
func (m *VPCStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCStatus.Merge(m, src)
}
func (m *VPCStatus) XXX_Size() int {
	return m.Size()
}
func (m *VPCStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VPCStatus proto.InternalMessageInfo

func (m *VPCStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *VPCStatus) GetBdHwId() uint32 {
	if m != nil {
		return m.BdHwId
	}
	return 0
}

// stats for a VPC, if any
type VPCStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCStats) Reset()         { *m = VPCStats{} }
func (m *VPCStats) String() string { return proto.CompactTextString(m) }
func (*VPCStats) ProtoMessage()    {}
func (*VPCStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{2}
}
func (m *VPCStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCStats.Merge(m, src)
}
func (m *VPCStats) XXX_Size() int {
	return m.Size()
}
func (m *VPCStats) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCStats.DiscardUnknown(m)
}

var xxx_messageInfo_VPCStats proto.InternalMessageInfo

// Virtual Private Cloud object
type VPC struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *VPCSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *VPCStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *VPCStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VPC) Reset()         { *m = VPC{} }
func (m *VPC) String() string { return proto.CompactTextString(m) }
func (*VPC) ProtoMessage()    {}
func (*VPC) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{3}
}
func (m *VPC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPC.Merge(m, src)
}
func (m *VPC) XXX_Size() int {
	return m.Size()
}
func (m *VPC) XXX_DiscardUnknown() {
	xxx_messageInfo_VPC.DiscardUnknown(m)
}

var xxx_messageInfo_VPC proto.InternalMessageInfo

func (m *VPC) GetSpec() *VPCSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *VPC) GetStatus() *VPCStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *VPC) GetStats() *VPCStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// VPC create and update request
type VPCRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched requests
	Request              []*VPCSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VPCRequest) Reset()         { *m = VPCRequest{} }
func (m *VPCRequest) String() string { return proto.CompactTextString(m) }
func (*VPCRequest) ProtoMessage()    {}
func (*VPCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{4}
}
func (m *VPCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCRequest.Merge(m, src)
}
func (m *VPCRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCRequest proto.InternalMessageInfo

func (m *VPCRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VPCRequest) GetRequest() []*VPCSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// VPC create and update response
type VPCResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*VPCStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VPCResponse) Reset()         { *m = VPCResponse{} }
func (m *VPCResponse) String() string { return proto.CompactTextString(m) }
func (*VPCResponse) ProtoMessage()    {}
func (*VPCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{5}
}
func (m *VPCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCResponse.Merge(m, src)
}
func (m *VPCResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCResponse proto.InternalMessageInfo

func (m *VPCResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VPCResponse) GetResponse() []*VPCStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// VPC get request
type VPCGetRequest struct {
	// list of keys of interest
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCGetRequest) Reset()         { *m = VPCGetRequest{} }
func (m *VPCGetRequest) String() string { return proto.CompactTextString(m) }
func (*VPCGetRequest) ProtoMessage()    {}
func (*VPCGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{6}
}
func (m *VPCGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCGetRequest.Merge(m, src)
}
func (m *VPCGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCGetRequest proto.InternalMessageInfo

func (m *VPCGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// VPC get response
type VPCGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*VPC    `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VPCGetResponse) Reset()         { *m = VPCGetResponse{} }
func (m *VPCGetResponse) String() string { return proto.CompactTextString(m) }
func (*VPCGetResponse) ProtoMessage()    {}
func (*VPCGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{7}
}
func (m *VPCGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCGetResponse.Merge(m, src)
}
func (m *VPCGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCGetResponse proto.InternalMessageInfo

func (m *VPCGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VPCGetResponse) GetResponse() []*VPC {
	if m != nil {
		return m.Response
	}
	return nil
}

// VPC delete request
type VPCDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VPCDeleteRequest) Reset()         { *m = VPCDeleteRequest{} }
func (m *VPCDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*VPCDeleteRequest) ProtoMessage()    {}
func (*VPCDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{8}
}
func (m *VPCDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCDeleteRequest.Merge(m, src)
}
func (m *VPCDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCDeleteRequest proto.InternalMessageInfo

func (m *VPCDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VPCDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// VPC delete response
type VPCDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VPCDeleteResponse) Reset()         { *m = VPCDeleteResponse{} }
func (m *VPCDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*VPCDeleteResponse) ProtoMessage()    {}
func (*VPCDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{9}
}
func (m *VPCDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCDeleteResponse.Merge(m, src)
}
func (m *VPCDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCDeleteResponse proto.InternalMessageInfo

func (m *VPCDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// VPCPeerSpec captures configuration for a VPC peering relation
type VPCPeerSpec struct {
	// unique id/key idenitifying this VPC peering relation
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// unique key/identifier of VPC1
	Vpc1 []byte `protobuf:"bytes,2,opt,name=Vpc1,proto3" json:"Vpc1,omitempty" meta:mandatory`
	// unique key/identifier of VPC2
	Vpc2                 []byte   `protobuf:"bytes,3,opt,name=Vpc2,proto3" json:"Vpc2,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCPeerSpec) Reset()         { *m = VPCPeerSpec{} }
func (m *VPCPeerSpec) String() string { return proto.CompactTextString(m) }
func (*VPCPeerSpec) ProtoMessage()    {}
func (*VPCPeerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{10}
}
func (m *VPCPeerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerSpec.Merge(m, src)
}
func (m *VPCPeerSpec) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerSpec proto.InternalMessageInfo

func (m *VPCPeerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *VPCPeerSpec) GetVpc1() []byte {
	if m != nil {
		return m.Vpc1
	}
	return nil
}

func (m *VPCPeerSpec) GetVpc2() []byte {
	if m != nil {
		return m.Vpc2
	}
	return nil
}

// operational status of a VPC peering, if any
type VPCPeerStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCPeerStatus) Reset()         { *m = VPCPeerStatus{} }
func (m *VPCPeerStatus) String() string { return proto.CompactTextString(m) }
func (*VPCPeerStatus) ProtoMessage()    {}
func (*VPCPeerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{11}
}
func (m *VPCPeerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerStatus.Merge(m, src)
}
func (m *VPCPeerStatus) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerStatus proto.InternalMessageInfo

// stats for a VPC peering, if any
type VPCPeerStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCPeerStats) Reset()         { *m = VPCPeerStats{} }
func (m *VPCPeerStats) String() string { return proto.CompactTextString(m) }
func (*VPCPeerStats) ProtoMessage()    {}
func (*VPCPeerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{12}
}
func (m *VPCPeerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerStats.Merge(m, src)
}
func (m *VPCPeerStats) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerStats.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerStats proto.InternalMessageInfo

// Virtual Private Cloud Peer (aka. pairing) object
type VPCPeer struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *VPCPeerSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *VPCPeerStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *VPCPeerStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *VPCPeer) Reset()         { *m = VPCPeer{} }
func (m *VPCPeer) String() string { return proto.CompactTextString(m) }
func (*VPCPeer) ProtoMessage()    {}
func (*VPCPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{13}
}
func (m *VPCPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeer.Merge(m, src)
}
func (m *VPCPeer) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeer.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeer proto.InternalMessageInfo

func (m *VPCPeer) GetSpec() *VPCPeerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *VPCPeer) GetStatus() *VPCPeerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *VPCPeer) GetStats() *VPCPeerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// VPC peer create and update request
type VPCPeerRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Request              []*VPCPeerSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *VPCPeerRequest) Reset()         { *m = VPCPeerRequest{} }
func (m *VPCPeerRequest) String() string { return proto.CompactTextString(m) }
func (*VPCPeerRequest) ProtoMessage()    {}
func (*VPCPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{14}
}
func (m *VPCPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerRequest.Merge(m, src)
}
func (m *VPCPeerRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerRequest proto.InternalMessageInfo

func (m *VPCPeerRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VPCPeerRequest) GetRequest() []*VPCPeerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// VPC peer create and update response
type VPCPeerResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// batched response
	Response             []*VPCPeerStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *VPCPeerResponse) Reset()         { *m = VPCPeerResponse{} }
func (m *VPCPeerResponse) String() string { return proto.CompactTextString(m) }
func (*VPCPeerResponse) ProtoMessage()    {}
func (*VPCPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{15}
}
func (m *VPCPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerResponse.Merge(m, src)
}
func (m *VPCPeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerResponse proto.InternalMessageInfo

func (m *VPCPeerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VPCPeerResponse) GetResponse() []*VPCPeerStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// VPC peer get request
type VPCPeerGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCPeerGetRequest) Reset()         { *m = VPCPeerGetRequest{} }
func (m *VPCPeerGetRequest) String() string { return proto.CompactTextString(m) }
func (*VPCPeerGetRequest) ProtoMessage()    {}
func (*VPCPeerGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{16}
}
func (m *VPCPeerGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerGetRequest.Merge(m, src)
}
func (m *VPCPeerGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerGetRequest proto.InternalMessageInfo

func (m *VPCPeerGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// VPC peer get response
type VPCPeerGetResponse struct {
	// API status code
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*VPCPeer `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VPCPeerGetResponse) Reset()         { *m = VPCPeerGetResponse{} }
func (m *VPCPeerGetResponse) String() string { return proto.CompactTextString(m) }
func (*VPCPeerGetResponse) ProtoMessage()    {}
func (*VPCPeerGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{17}
}
func (m *VPCPeerGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerGetResponse.Merge(m, src)
}
func (m *VPCPeerGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerGetResponse proto.InternalMessageInfo

func (m *VPCPeerGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VPCPeerGetResponse) GetResponse() []*VPCPeer {
	if m != nil {
		return m.Response
	}
	return nil
}

// VPC peer delete request
type VPCPeerDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VPCPeerDeleteRequest) Reset()         { *m = VPCPeerDeleteRequest{} }
func (m *VPCPeerDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*VPCPeerDeleteRequest) ProtoMessage()    {}
func (*VPCPeerDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{18}
}
func (m *VPCPeerDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerDeleteRequest.Merge(m, src)
}
func (m *VPCPeerDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerDeleteRequest proto.InternalMessageInfo

func (m *VPCPeerDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VPCPeerDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// VPC peer delete response
type VPCPeerDeleteResponse struct {
	// API status code
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VPCPeerDeleteResponse) Reset()         { *m = VPCPeerDeleteResponse{} }
func (m *VPCPeerDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*VPCPeerDeleteResponse) ProtoMessage()    {}
func (*VPCPeerDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{19}
}
func (m *VPCPeerDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerDeleteResponse.Merge(m, src)
}
func (m *VPCPeerDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerDeleteResponse proto.InternalMessageInfo

func (m *VPCPeerDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.VPCType", VPCType_name, VPCType_value)
	proto.RegisterType((*VPCSpec)(nil), "pds.VPCSpec")
	proto.RegisterType((*VPCStatus)(nil), "pds.VPCStatus")
	proto.RegisterType((*VPCStats)(nil), "pds.VPCStats")
	proto.RegisterType((*VPC)(nil), "pds.VPC")
	proto.RegisterType((*VPCRequest)(nil), "pds.VPCRequest")
	proto.RegisterType((*VPCResponse)(nil), "pds.VPCResponse")
	proto.RegisterType((*VPCGetRequest)(nil), "pds.VPCGetRequest")
	proto.RegisterType((*VPCGetResponse)(nil), "pds.VPCGetResponse")
	proto.RegisterType((*VPCDeleteRequest)(nil), "pds.VPCDeleteRequest")
	proto.RegisterType((*VPCDeleteResponse)(nil), "pds.VPCDeleteResponse")
	proto.RegisterType((*VPCPeerSpec)(nil), "pds.VPCPeerSpec")
	proto.RegisterType((*VPCPeerStatus)(nil), "pds.VPCPeerStatus")
	proto.RegisterType((*VPCPeerStats)(nil), "pds.VPCPeerStats")
	proto.RegisterType((*VPCPeer)(nil), "pds.VPCPeer")
	proto.RegisterType((*VPCPeerRequest)(nil), "pds.VPCPeerRequest")
	proto.RegisterType((*VPCPeerResponse)(nil), "pds.VPCPeerResponse")
	proto.RegisterType((*VPCPeerGetRequest)(nil), "pds.VPCPeerGetRequest")
	proto.RegisterType((*VPCPeerGetResponse)(nil), "pds.VPCPeerGetResponse")
	proto.RegisterType((*VPCPeerDeleteRequest)(nil), "pds.VPCPeerDeleteRequest")
	proto.RegisterType((*VPCPeerDeleteResponse)(nil), "pds.VPCPeerDeleteResponse")
}

func init() { proto.RegisterFile("vpc.proto", fileDescriptor_95d23e4d548ba1d7) }

var fileDescriptor_95d23e4d548ba1d7 = []byte{
	// 1062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x0e, 0x49, 0xf9, 0x76, 0x74, 0xa3, 0xc7, 0x97, 0x9f, 0xbf, 0x50, 0x58, 0x02, 0x6b, 0x18,
	0x82, 0x61, 0xa8, 0xad, 0x22, 0xb8, 0x41, 0x6b, 0x34, 0x35, 0x15, 0xd5, 0x11, 0x10, 0xcb, 0x02,
	0xad, 0x10, 0xc8, 0xa6, 0x01, 0x4d, 0x4e, 0x5d, 0x15, 0xba, 0x30, 0xe2, 0x28, 0xad, 0x9e, 0xa2,
	0xaf, 0xd1, 0x6d, 0x1f, 0xa1, 0xbb, 0x2e, 0xf3, 0x04, 0x42, 0xe1, 0xa5, 0x97, 0x79, 0x82, 0x62,
	0x0e, 0x87, 0x14, 0x29, 0xa9, 0x4e, 0x20, 0x14, 0xe8, 0xc6, 0x20, 0xbf, 0x73, 0xbe, 0x39, 0x97,
	0x39, 0xdf, 0xa1, 0x05, 0x5b, 0x6f, 0x3d, 0xa7, 0xe2, 0x8d, 0x86, 0x6c, 0x48, 0x14, 0xcf, 0xf5,
	0x0b, 0x70, 0x3b, 0xbc, 0x1d, 0x06, 0x40, 0x21, 0xdf, 0xa7, 0xcc, 0xfe, 0x8c, 0xff, 0x11, 0x40,
	0x9a, 0x4d, 0x3c, 0xea, 0x07, 0x2f, 0xfa, 0xaf, 0x6b, 0xb0, 0x61, 0xb5, 0xeb, 0xd7, 0x1e, 0x75,
	0xc8, 0x09, 0xc8, 0x4d, 0x57, 0x93, 0x4a, 0x52, 0x39, 0x63, 0x7c, 0xf2, 0x7e, 0x5a, 0xd4, 0x38,
	0xe9, 0xab, 0xbe, 0x3d, 0x70, 0x6d, 0x36, 0x1c, 0x4d, 0x4e, 0xba, 0xfd, 0xfe, 0x98, 0xd9, 0x37,
	0x3d, 0x6a, 0xca, 0x4d, 0x97, 0x7c, 0x03, 0xa9, 0xce, 0xc4, 0xa3, 0x9a, 0x5c, 0x92, 0xca, 0xb9,
	0x6a, 0xa6, 0xe2, 0xb9, 0x7e, 0xc5, 0x6a, 0xd7, 0x39, 0xf6, 0x01, 0x36, 0xf2, 0xc8, 0x11, 0xe4,
	0xac, 0x9a, 0x39, 0x1c, 0x33, 0xda, 0xe1, 0x68, 0xd3, 0xd5, 0x14, 0x1e, 0xd9, 0x9c, 0x43, 0xd1,
	0xef, 0x34, 0xe1, 0x97, 0x12, 0x7e, 0x09, 0x94, 0xd4, 0x60, 0xaf, 0x39, 0xb8, 0xb5, 0x6a, 0xd7,
	0xd4, 0x19, 0x8f, 0xba, 0x6c, 0xd2, 0x1e, 0xf6, 0xba, 0xce, 0xa4, 0xe9, 0x6a, 0x6b, 0x25, 0xa5,
	0x9c, 0x31, 0x97, 0x1b, 0x43, 0xd6, 0xe9, 0x02, 0x6b, 0x7d, 0xc6, 0x5a, 0x30, 0x92, 0x2a, 0xec,
	0x36, 0x96, 0x85, 0xda, 0x40, 0xd2, 0x52, 0x9b, 0xe0, 0x2c, 0x06, 0xda, 0x8c, 0x38, 0x8b, 0x71,
	0x8e, 0x41, 0xb5, 0xba, 0x23, 0x36, 0xb6, 0x7b, 0x58, 0xea, 0xe8, 0xd2, 0x76, 0xb4, 0xad, 0x92,
	0x54, 0x4e, 0x99, 0x0b, 0x38, 0x31, 0x20, 0xfd, 0x9d, 0x7d, 0x33, 0xea, 0x3a, 0x8d, 0x81, 0x63,
	0x7b, 0x1a, 0x94, 0xa4, 0x72, 0xba, 0x9a, 0xa9, 0x04, 0x97, 0x8d, 0x98, 0x41, 0xde, 0x4f, 0x8b,
	0x39, 0xbc, 0x96, 0xd9, 0x65, 0xc4, 0x49, 0xe4, 0x10, 0xb2, 0x56, 0xed, 0x92, 0x32, 0x3a, 0x0a,
	0x52, 0xd0, 0xd2, 0xd8, 0xea, 0x24, 0x88, 0x5e, 0xa7, 0x71, 0xaf, 0x8c, 0xf0, 0x8a, 0x83, 0x44,
	0x05, 0xa5, 0x33, 0xbc, 0xd6, 0xb2, 0x25, 0xa9, 0x9c, 0x35, 0xf9, 0x23, 0x39, 0x04, 0xc5, 0x6a,
	0x35, 0xb5, 0x5c, 0x49, 0x29, 0x67, 0x97, 0xe6, 0xc2, 0xcd, 0xfa, 0x97, 0xb0, 0xc5, 0x07, 0x92,
	0xd9, 0x6c, 0xec, 0x13, 0x02, 0xa9, 0xe7, 0x3f, 0x8b, 0xa1, 0xcc, 0x9a, 0xf8, 0x4c, 0xf6, 0x61,
	0xdd, 0x70, 0x11, 0x95, 0x11, 0x15, 0x6f, 0x3a, 0xc0, 0xa6, 0x20, 0xfa, 0xfa, 0xef, 0x32, 0x28,
	0x56, 0xbb, 0x4e, 0xbe, 0x86, 0x4d, 0x3e, 0x6c, 0x97, 0x94, 0xd9, 0x78, 0x46, 0xba, 0x9a, 0xab,
	0xa0, 0x14, 0x42, 0xd4, 0xc8, 0xbf, 0x9b, 0x16, 0xa5, 0xfb, 0x69, 0x71, 0xe3, 0xa4, 0x3b, 0xe8,
	0x75, 0x07, 0xd4, 0x8c, 0x08, 0xe4, 0x29, 0x6c, 0x5c, 0xdd, 0xfc, 0x84, 0x5c, 0x19, 0xb9, 0xd9,
	0x80, 0x2b, 0x40, 0x63, 0x5f, 0x50, 0xb1, 0x8c, 0x93, 0x61, 0xbf, 0xcb, 0x68, 0xdf, 0x63, 0x13,
	0x33, 0x64, 0x91, 0x1a, 0xa4, 0xb8, 0xb0, 0x70, 0xb0, 0xd3, 0x33, 0x89, 0x70, 0xcc, 0x20, 0x9c,
	0xe8, 0x7b, 0xd4, 0x89, 0x11, 0xd1, 0x9b, 0x9c, 0xc1, 0x7a, 0x50, 0x3d, 0x0e, 0x3a, 0xcf, 0x38,
	0xe4, 0x21, 0x6a, 0xec, 0xde, 0x4f, 0x8b, 0xaa, 0x8f, 0xcf, 0x31, 0xae, 0xe0, 0x90, 0x27, 0xb0,
	0x86, 0x2d, 0xd0, 0xd6, 0x44, 0xca, 0x31, 0xb2, 0x6f, 0xec, 0xdc, 0x4f, 0x8b, 0x79, 0xce, 0x8d,
	0x53, 0x03, 0x82, 0xee, 0x02, 0x58, 0xed, 0xba, 0x49, 0xdf, 0x8c, 0xa9, 0xcf, 0x48, 0x05, 0xb6,
	0x0c, 0x9b, 0x39, 0x3f, 0xd6, 0xd9, 0x2f, 0x4c, 0xb4, 0x4e, 0x15, 0xc3, 0x14, 0xe1, 0xe6, 0xcc,
	0x85, 0x1c, 0xc1, 0x86, 0xa0, 0x6a, 0x72, 0x49, 0x99, 0x2f, 0xd7, 0x0c, 0x8d, 0x7a, 0x17, 0xd2,
	0x18, 0xc5, 0xf7, 0x86, 0x03, 0x9f, 0xf2, 0x30, 0xe7, 0x5e, 0x57, 0xd4, 0x2b, 0xe1, 0x2a, 0x09,
	0xc3, 0x44, 0xb8, 0x39, 0x73, 0x21, 0xc7, 0xb0, 0x19, 0x72, 0x45, 0x9c, 0xb9, 0xf6, 0x98, 0x91,
	0x5d, 0x2f, 0x42, 0xd6, 0x6a, 0xd7, 0x2f, 0x28, 0x0b, 0x6b, 0xca, 0x89, 0x05, 0xc7, 0x05, 0x27,
	0x37, 0x5d, 0xfd, 0x07, 0xc8, 0x85, 0x0e, 0x2b, 0xa6, 0x73, 0xb8, 0x90, 0xce, 0x66, 0x98, 0x4e,
	0x2c, 0x11, 0x13, 0x54, 0xab, 0x5d, 0x7f, 0x46, 0x7b, 0x94, 0xd1, 0x55, 0xfb, 0x1b, 0xe4, 0x2e,
	0x47, 0xb9, 0xd7, 0x61, 0x3b, 0x76, 0xe6, 0xf2, 0xf4, 0x95, 0x0f, 0xa4, 0xaf, 0xf7, 0xf1, 0x32,
	0xda, 0x94, 0x8e, 0x70, 0xf2, 0x72, 0xb3, 0x0f, 0x00, 0xae, 0xf8, 0x23, 0x48, 0x59, 0x9e, 0xf3,
	0x05, 0x4e, 0x7f, 0x26, 0xa6, 0xd8, 0x68, 0xa9, 0x9b, 0x68, 0x17, 0x7e, 0xd5, 0x60, 0x81, 0xff,
	0xa3, 0x5f, 0x55, 0xcf, 0xe3, 0x85, 0x60, 0xb8, 0x20, 0x7e, 0x0e, 0x32, 0x31, 0xc0, 0xd7, 0xff,
	0x90, 0xf1, 0x6b, 0xc4, 0x81, 0xff, 0x58, 0xba, 0x4f, 0x12, 0xd2, 0x55, 0xc3, 0x4b, 0x0d, 0x5b,
	0xf5, 0x80, 0x7c, 0xbf, 0x9d, 0x93, 0x2f, 0x49, 0x70, 0x3f, 0x46, 0xc2, 0x67, 0x49, 0x09, 0x6f,
	0xcf, 0x1f, 0xf0, 0xb0, 0x8c, 0x7b, 0x38, 0xd4, 0xdc, 0x77, 0xd5, 0x51, 0x3b, 0x9e, 0x97, 0xf2,
	0x42, 0xf9, 0x33, 0x39, 0xbf, 0x81, 0x7c, 0x14, 0x6d, 0x45, 0x0d, 0x55, 0x16, 0x34, 0xb4, 0xa4,
	0x65, 0x31, 0x35, 0x7d, 0x8a, 0x93, 0xcf, 0x4d, 0x0f, 0x48, 0x7b, 0x00, 0x24, 0xee, 0xb4, 0x62,
	0x6a, 0xe5, 0x85, 0xd4, 0x32, 0xf1, 0xd4, 0x62, 0x49, 0x59, 0xb0, 0x2b, 0xc0, 0x7f, 0x57, 0xe6,
	0x17, 0xb0, 0x37, 0x77, 0xee, 0x6a, 0x52, 0x3f, 0xfe, 0x1e, 0x95, 0x85, 0xff, 0x79, 0x6d, 0xa3,
	0x0c, 0x5f, 0x77, 0x5e, 0xb5, 0x1b, 0xaf, 0x5b, 0x57, 0xad, 0x86, 0xfa, 0x88, 0xec, 0x61, 0x4f,
	0x03, 0xe8, 0x65, 0xeb, 0x59, 0xc3, 0x7c, 0x71, 0xfe, 0x4a, 0x95, 0xc8, 0x0e, 0xde, 0x6e, 0x00,
	0x77, 0x1a, 0xad, 0xf3, 0x56, 0x47, 0x95, 0xc9, 0x2e, 0x6e, 0xb3, 0x00, 0xac, 0x5f, 0xb5, 0x3a,
	0xe6, 0xd5, 0x0b, 0x55, 0xa9, 0xfe, 0xa6, 0xc0, 0x3a, 0x5f, 0xc2, 0x6f, 0x1d, 0xf2, 0x39, 0x7e,
	0xc1, 0xeb, 0x23, 0x6a, 0x33, 0x4a, 0xf2, 0xd1, 0x3e, 0x0c, 0x3a, 0x52, 0x50, 0x67, 0x80, 0xe8,
	0xdd, 0x23, 0xc1, 0x78, 0xe9, 0xb9, 0x1f, 0xcd, 0x78, 0x8c, 0xd1, 0x2e, 0x28, 0x23, 0xd1, 0xb0,
	0xcc, 0xa6, 0xa1, 0xb0, 0x93, 0xc0, 0x22, 0xd2, 0x19, 0x86, 0x09, 0x1a, 0x49, 0xf6, 0x42, 0x9f,
	0xc4, 0x85, 0x15, 0xf6, 0xe7, 0xe1, 0x18, 0x3b, 0xdc, 0x5e, 0xa2, 0xb4, 0x9d, 0xc4, 0x2c, 0x08,
	0xfe, 0x6e, 0x12, 0x8c, 0xd8, 0x4f, 0xf1, 0xeb, 0x2a, 0x06, 0x92, 0xec, 0xc7, 0xbd, 0x62, 0x89,
	0xff, 0x6f, 0x01, 0x8f, 0x0e, 0x78, 0x1e, 0x85, 0x17, 0x05, 0xfc, 0x3f, 0xee, 0x9b, 0x2c, 0xa2,
	0xb0, 0xcc, 0x14, 0x9e, 0x64, 0x64, 0xfe, 0xbc, 0x3b, 0x90, 0xde, 0xdd, 0x1d, 0x48, 0x7f, 0xdd,
	0x1d, 0x48, 0x37, 0xeb, 0xf8, 0x43, 0xe0, 0xf1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x88, 0x09,
	0x82, 0x82, 0x44, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VPCSvcClient is the client API for VPCSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VPCSvcClient interface {
	VPCCreate(ctx context.Context, in *VPCRequest, opts ...grpc.CallOption) (*VPCResponse, error)
	VPCUpdate(ctx context.Context, in *VPCRequest, opts ...grpc.CallOption) (*VPCResponse, error)
	VPCGet(ctx context.Context, in *VPCGetRequest, opts ...grpc.CallOption) (*VPCGetResponse, error)
	VPCDelete(ctx context.Context, in *VPCDeleteRequest, opts ...grpc.CallOption) (*VPCDeleteResponse, error)
	VPCPeerCreate(ctx context.Context, in *VPCPeerRequest, opts ...grpc.CallOption) (*VPCPeerResponse, error)
	VPCPeerGet(ctx context.Context, in *VPCPeerGetRequest, opts ...grpc.CallOption) (*VPCPeerGetResponse, error)
	VPCPeerDelete(ctx context.Context, in *VPCPeerDeleteRequest, opts ...grpc.CallOption) (*VPCPeerDeleteResponse, error)
}

type vPCSvcClient struct {
	cc *grpc.ClientConn
}

func NewVPCSvcClient(cc *grpc.ClientConn) VPCSvcClient {
	return &vPCSvcClient{cc}
}

func (c *vPCSvcClient) VPCCreate(ctx context.Context, in *VPCRequest, opts ...grpc.CallOption) (*VPCResponse, error) {
	out := new(VPCResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCUpdate(ctx context.Context, in *VPCRequest, opts ...grpc.CallOption) (*VPCResponse, error) {
	out := new(VPCResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCGet(ctx context.Context, in *VPCGetRequest, opts ...grpc.CallOption) (*VPCGetResponse, error) {
	out := new(VPCGetResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCDelete(ctx context.Context, in *VPCDeleteRequest, opts ...grpc.CallOption) (*VPCDeleteResponse, error) {
	out := new(VPCDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCPeerCreate(ctx context.Context, in *VPCPeerRequest, opts ...grpc.CallOption) (*VPCPeerResponse, error) {
	out := new(VPCPeerResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCPeerCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCPeerGet(ctx context.Context, in *VPCPeerGetRequest, opts ...grpc.CallOption) (*VPCPeerGetResponse, error) {
	out := new(VPCPeerGetResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCPeerGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCSvcClient) VPCPeerDelete(ctx context.Context, in *VPCPeerDeleteRequest, opts ...grpc.CallOption) (*VPCPeerDeleteResponse, error) {
	out := new(VPCPeerDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.VPCSvc/VPCPeerDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VPCSvcServer is the server API for VPCSvc service.
type VPCSvcServer interface {
	VPCCreate(context.Context, *VPCRequest) (*VPCResponse, error)
	VPCUpdate(context.Context, *VPCRequest) (*VPCResponse, error)
	VPCGet(context.Context, *VPCGetRequest) (*VPCGetResponse, error)
	VPCDelete(context.Context, *VPCDeleteRequest) (*VPCDeleteResponse, error)
	VPCPeerCreate(context.Context, *VPCPeerRequest) (*VPCPeerResponse, error)
	VPCPeerGet(context.Context, *VPCPeerGetRequest) (*VPCPeerGetResponse, error)
	VPCPeerDelete(context.Context, *VPCPeerDeleteRequest) (*VPCPeerDeleteResponse, error)
}

// UnimplementedVPCSvcServer can be embedded to have forward compatible implementations.
type UnimplementedVPCSvcServer struct {
}

func (*UnimplementedVPCSvcServer) VPCCreate(ctx context.Context, req *VPCRequest) (*VPCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCCreate not implemented")
}
func (*UnimplementedVPCSvcServer) VPCUpdate(ctx context.Context, req *VPCRequest) (*VPCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCUpdate not implemented")
}
func (*UnimplementedVPCSvcServer) VPCGet(ctx context.Context, req *VPCGetRequest) (*VPCGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCGet not implemented")
}
func (*UnimplementedVPCSvcServer) VPCDelete(ctx context.Context, req *VPCDeleteRequest) (*VPCDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCDelete not implemented")
}
func (*UnimplementedVPCSvcServer) VPCPeerCreate(ctx context.Context, req *VPCPeerRequest) (*VPCPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCPeerCreate not implemented")
}
func (*UnimplementedVPCSvcServer) VPCPeerGet(ctx context.Context, req *VPCPeerGetRequest) (*VPCPeerGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCPeerGet not implemented")
}
func (*UnimplementedVPCSvcServer) VPCPeerDelete(ctx context.Context, req *VPCPeerDeleteRequest) (*VPCPeerDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCPeerDelete not implemented")
}

func RegisterVPCSvcServer(s *grpc.Server, srv VPCSvcServer) {
	s.RegisterService(&_VPCSvc_serviceDesc, srv)
}

func _VPCSvc_VPCCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCCreate(ctx, req.(*VPCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCUpdate(ctx, req.(*VPCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCGet(ctx, req.(*VPCGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCDelete(ctx, req.(*VPCDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCPeerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCPeerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCPeerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCPeerCreate(ctx, req.(*VPCPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCPeerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCPeerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCPeerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCPeerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCPeerGet(ctx, req.(*VPCPeerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCSvc_VPCPeerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCPeerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCSvcServer).VPCPeerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VPCSvc/VPCPeerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCSvcServer).VPCPeerDelete(ctx, req.(*VPCPeerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VPCSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.VPCSvc",
	HandlerType: (*VPCSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VPCCreate",
			Handler:    _VPCSvc_VPCCreate_Handler,
		},
		{
			MethodName: "VPCUpdate",
			Handler:    _VPCSvc_VPCUpdate_Handler,
		},
		{
			MethodName: "VPCGet",
			Handler:    _VPCSvc_VPCGet_Handler,
		},
		{
			MethodName: "VPCDelete",
			Handler:    _VPCSvc_VPCDelete_Handler,
		},
		{
			MethodName: "VPCPeerCreate",
			Handler:    _VPCSvc_VPCPeerCreate_Handler,
		},
		{
			MethodName: "VPCPeerGet",
			Handler:    _VPCSvc_VPCPeerGet_Handler,
		},
		{
			MethodName: "VPCPeerDelete",
			Handler:    _VPCSvc_VPCPeerDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vpc.proto",
}

func (m *VPCSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VNI) > 0 {
		dAtA2 := make([]byte, len(m.VNI)*10)
		var j1 int
		for _, num := range m.VNI {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintVpc(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x72
	}
	if m.ToS != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.ToS))
		i--
		dAtA[i] = 0x68
	}
	if len(m.V6MeterPolicy) > 0 {
		i -= len(m.V6MeterPolicy)
		copy(dAtA[i:], m.V6MeterPolicy)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.V6MeterPolicy)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.V4MeterPolicy) > 0 {
		i -= len(m.V4MeterPolicy)
		copy(dAtA[i:], m.V4MeterPolicy)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.V4MeterPolicy)))
		i--
		dAtA[i] = 0x5a
	}
	if m.FabricEncap != nil {
		{
			size, err := m.FabricEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.VirtualRouterMac != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.VirtualRouterMac))
		i--
		dAtA[i] = 0x48
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV6SecurityPolicyId[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.EgV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV4SecurityPolicyId[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.EgV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV6SecurityPolicyId[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.IngV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV4SecurityPolicyId[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.IngV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.V6RouteTableId) > 0 {
		i -= len(m.V6RouteTableId)
		copy(dAtA[i:], m.V6RouteTableId)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.V6RouteTableId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.V4RouteTableId) > 0 {
		i -= len(m.V4RouteTableId)
		copy(dAtA[i:], m.V4RouteTableId)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.V4RouteTableId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BdHwId != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.BdHwId))
		i--
		dAtA[i] = 0x10
	}
	if m.HwId != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VPCGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA12 := make([]byte, len(m.ApiStatus)*10)
		var j11 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintVpc(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Vpc2) > 0 {
		i -= len(m.Vpc2)
		copy(dAtA[i:], m.Vpc2)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.Vpc2)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vpc1) > 0 {
		i -= len(m.Vpc1)
		copy(dAtA[i:], m.Vpc1)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.Vpc1)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintVpc(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVpc(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVpc(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA21 := make([]byte, len(m.ApiStatus)*10)
		var j20 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintVpc(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintVpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovVpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VPCSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovVpc(uint64(m.Type))
	}
	l = len(m.V4RouteTableId)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	l = len(m.V6RouteTableId)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for _, b := range m.IngV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for _, b := range m.IngV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for _, b := range m.EgV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for _, b := range m.EgV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.VirtualRouterMac != 0 {
		n += 1 + sovVpc(uint64(m.VirtualRouterMac))
	}
	if m.FabricEncap != nil {
		l = m.FabricEncap.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	l = len(m.V4MeterPolicy)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	l = len(m.V6MeterPolicy)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.ToS != 0 {
		n += 1 + sovVpc(uint64(m.ToS))
	}
	if len(m.VNI) > 0 {
		l = 0
		for _, e := range m.VNI {
			l += sovVpc(uint64(e))
		}
		n += 1 + sovVpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovVpc(uint64(m.HwId))
	}
	if m.BdHwId != 0 {
		n += 1 + sovVpc(uint64(m.BdHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVpc(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVpc(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovVpc(uint64(e))
		}
		n += 1 + sovVpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	l = len(m.Vpc1)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	l = len(m.Vpc2)
	if l > 0 {
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVpc(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVpc(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVpc(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovVpc(uint64(e))
		}
		n += 1 + sovVpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVpc(x uint64) (n int) {
	return sovVpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VPCSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VPCType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4RouteTableId = append(m.V4RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V4RouteTableId == nil {
				m.V4RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6RouteTableId = append(m.V6RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V6RouteTableId == nil {
				m.V6RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV4SecurityPolicyId = append(m.IngV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV4SecurityPolicyId[len(m.IngV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV6SecurityPolicyId = append(m.IngV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV6SecurityPolicyId[len(m.IngV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV4SecurityPolicyId = append(m.EgV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV4SecurityPolicyId[len(m.EgV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV6SecurityPolicyId = append(m.EgV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV6SecurityPolicyId[len(m.EgV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterMac", wireType)
			}
			m.VirtualRouterMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRouterMac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FabricEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FabricEncap == nil {
				m.FabricEncap = &Encap{}
			}
			if err := m.FabricEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4MeterPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4MeterPolicy = append(m.V4MeterPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.V4MeterPolicy == nil {
				m.V4MeterPolicy = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6MeterPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6MeterPolicy = append(m.V6MeterPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.V6MeterPolicy == nil {
				m.V6MeterPolicy = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToS", wireType)
			}
			m.ToS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VNI = append(m.VNI, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVpc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVpc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VNI) == 0 {
					m.VNI = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VNI = append(m.VNI, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BdHwId", wireType)
			}
			m.BdHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BdHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &VPCSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &VPCStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &VPCStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &VPCSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &VPCStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &VPC{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVpc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVpc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vpc1 = append(m.Vpc1[:0], dAtA[iNdEx:postIndex]...)
			if m.Vpc1 == nil {
				m.Vpc1 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vpc2 = append(m.Vpc2[:0], dAtA[iNdEx:postIndex]...)
			if m.Vpc2 == nil {
				m.Vpc2 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &VPCPeerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &VPCPeerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &VPCPeerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &VPCPeerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &VPCPeerStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &VPCPeer{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVpc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVpc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVpc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVpc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVpc   = fmt.Errorf("proto: integer overflow")
)
