// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: subnet.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SubnetSpec captures subnet specific configuration
type SubnetSpec struct {
	// unique identifier of the subnet
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// virtual private cloud this subnet is belongs to
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
	V4Prefix *IPv4Prefix `protobuf:"bytes,3,opt,name=V4Prefix,proto3" json:"V4Prefix,omitempty" meta:mandatory,immutable`
	// IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
	V6Prefix *IPv6Prefix `protobuf:"bytes,4,opt,name=V6Prefix,proto3" json:"V6Prefix,omitempty" meta:mandatory,immutable`
	// IPv4 Virtual Router (VR) IP of this subnet, this IP is owned by the device
	// and packets originated by this device carry this IP as source IP
	IPv4VirtualRouterIP uint32 `protobuf:"varint,5,opt,name=IPv4VirtualRouterIP,proto3" json:"IPv4VirtualRouterIP,omitempty"`
	// Ipv6 Virtual Router (VR) IP of this subnet, this IP is owned by the device
	// and packets originated by this device carry this IP as source IP
	IPv6VirtualRouterIP []byte `protobuf:"bytes,6,opt,name=IPv6VirtualRouterIP,proto3" json:"IPv6VirtualRouterIP,omitempty"`
	// Virtual Router (VR) MAC address, any packets originated or routed by
	// the device carry this MAC as source MAC
	VirtualRouterMac uint64 `protobuf:"varint,7,opt,name=VirtualRouterMac,proto3" json:"VirtualRouterMac,omitempty" meta:mandatory`
	// identifier of the IPv4 route table to be used
	V4RouteTableId []byte `protobuf:"bytes,8,opt,name=V4RouteTableId,proto3" json:"V4RouteTableId,omitempty" meta:mandatory`
	// identifier of the IPv6 route table to be used, if any
	V6RouteTableId []byte `protobuf:"bytes,9,opt,name=V6RouteTableId,proto3" json:"V6RouteTableId,omitempty"`
	// identifier of ingress IPv4 security policy to be enforced
	// NOTE:
	// 1. all vnics in this subnet will inherit the policies configured under subnet
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only two policies per subnet in each direction are allowed to
	//    be configured
	IngV4SecurityPolicyId [][]byte `protobuf:"bytes,10,rep,name=IngV4SecurityPolicyId,proto3" json:"IngV4SecurityPolicyId,omitempty"`
	// identifier of ingress IPv6 security policy to be enforced
	// NOTE:
	// 1. all vnics in this subnet will inherit the policies configured under subnet
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only two policies per subnet in each direction are allowed to
	//    be configured
	IngV6SecurityPolicyId [][]byte `protobuf:"bytes,11,rep,name=IngV6SecurityPolicyId,proto3" json:"IngV6SecurityPolicyId,omitempty"`
	// identifier of egress IPv4 security policy to be enforced
	// NOTE:
	// 1. all vnics in this subnet will inherit the policies configured under subnet
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only two policies per subnet in each direction are allowed to
	//    be configured
	EgV4SecurityPolicyId [][]byte `protobuf:"bytes,12,rep,name=EgV4SecurityPolicyId,proto3" json:"EgV4SecurityPolicyId,omitempty"`
	// identifier of egress IPv6 security policy to be enforced
	// NOTE:
	// 1. all vnics in this subnet will inherit the policies configured under subnet
	// 2. max. of 6 policies per vnic per direction (ingress/egress) are supported
	// 3. currently only two policies per subnet in each direction are allowed to
	//    be configured
	EgV6SecurityPolicyId [][]byte `protobuf:"bytes,13,rep,name=EgV6SecurityPolicyId,proto3" json:"EgV6SecurityPolicyId,omitempty"`
	// AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
	// and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
	// traffic with same DOT1Q tag, in which case vnics are identified with
	// their MAC or IP based on the pipeline in addition to the DOT1Q tag
	// NOTE:
	// 1. when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
	//    identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
	//    VNIC etc.)
	// 2. when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
	//    all traffic from vnics in that subnet is transmitted with this encap
	//    (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
	//     inherit the subnet's encap)
	// 3. it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
	//    certain tag value but some vnic's in that subnet to have different
	//    DOT1Q encap than that of subnet
	AccessEncap *Encap `protobuf:"bytes,14,opt,name=AccessEncap,proto3" json:"AccessEncap,omitempty" meta:immutable`
	// encapped traffic coming with the specified encap from fabric side will be
	// mapped to this subnet and traffic from workloads in this subnet will carry
	// this encap towards the fabric side
	FabricEncap *Encap `protobuf:"bytes,15,opt,name=FabricEncap,proto3" json:"FabricEncap,omitempty" meta:immutable`
	// when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
	// present, subnet needs to be attached to a PF/VF (aka. host interface),
	// HostIf is list of such VF/PFs
	HostIf [][]byte `protobuf:"bytes,16,rep,name=HostIf,proto3" json:"HostIf,omitempty"`
	// DHCP policy to be applied in this subnet
	// NOTE:
	// 1. at any given time, a subnet can either have DHCP relay policy or
	//    DHCP proxy policy only and for simplicty on any given subnet we
	//    can't switch from one type of policy to another
	// 2. Multiple DHCP proxy policies per subnet is not supported
	// 3. More than two DHCP relay policies is not supported
	DHCPPolicyId [][]byte `protobuf:"bytes,17,rep,name=DHCPPolicyId,proto3" json:"DHCPPolicyId,omitempty"`
	// ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
	// header or in the Traffic Class field of IPv6 outer header, this value, if
	// non-zero, will be used as-is (i.e., not interpreted) during encap time by
	// the dataplane
	// NOTE:
	// 1. subnets under this VPC don't inherit this ToS value, subnets need to
	//    be explicitly configured with same ToS value as that of VPC or
	//    potentially different ToS value of their own
	// 2. tunnel objects, if configured with ToS, will override this
	ToS uint32 `protobuf:"varint,18,opt,name=ToS,proto3" json:"ToS,omitempty"`
	// a subnet is marked connected if vnics in this subnet can communicate with
	// external endpoints via routes with some kind of NAT (e.g. 1:1 NAT, NAPT)
	Connected bool `protobuf:"varint,19,opt,name=Connected,proto3" json:"Connected,omitempty"`
	// default ingress stateful security policy for this subnet
	// NOTE:
	// IngDefaultSGPolicy, if configured, is the 1st policy evaluated before
	// evaluating other NSG polices applicable to this vnic
	IngDefaultSGPolicy []byte `protobuf:"bytes,20,opt,name=IngDefaultSGPolicy,proto3" json:"IngDefaultSGPolicy,omitempty" meta:immutable`
	// default egress stateful security policy for this subnet
	// NOTE:
	// EgrDefaultSGPolicy, if configured, is the 1st policy evaluated before
	// evaluating other NSG polices applicable to this vnic
	EgrDefaultSGPolicy []byte `protobuf:"bytes,21,opt,name=EgrDefaultSGPolicy,proto3" json:"EgrDefaultSGPolicy,omitempty" meta:immutable`
	// RemoteSubnet, if set, indicates that the subnet does not have any IP
	// mappings in local pod and such subnets are used to program all remote
	// pod IP mappings behind it
	RemoteSubnet         bool     `protobuf:"varint,22,opt,name=RemoteSubnet,proto3" json:"RemoteSubnet,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetSpec) Reset()         { *m = SubnetSpec{} }
func (m *SubnetSpec) String() string { return proto.CompactTextString(m) }
func (*SubnetSpec) ProtoMessage()    {}
func (*SubnetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{0}
}
func (m *SubnetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetSpec.Merge(m, src)
}
func (m *SubnetSpec) XXX_Size() int {
	return m.Size()
}
func (m *SubnetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetSpec proto.InternalMessageInfo

func (m *SubnetSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SubnetSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *SubnetSpec) GetV4Prefix() *IPv4Prefix {
	if m != nil {
		return m.V4Prefix
	}
	return nil
}

func (m *SubnetSpec) GetV6Prefix() *IPv6Prefix {
	if m != nil {
		return m.V6Prefix
	}
	return nil
}

func (m *SubnetSpec) GetIPv4VirtualRouterIP() uint32 {
	if m != nil {
		return m.IPv4VirtualRouterIP
	}
	return 0
}

func (m *SubnetSpec) GetIPv6VirtualRouterIP() []byte {
	if m != nil {
		return m.IPv6VirtualRouterIP
	}
	return nil
}

func (m *SubnetSpec) GetVirtualRouterMac() uint64 {
	if m != nil {
		return m.VirtualRouterMac
	}
	return 0
}

func (m *SubnetSpec) GetV4RouteTableId() []byte {
	if m != nil {
		return m.V4RouteTableId
	}
	return nil
}

func (m *SubnetSpec) GetV6RouteTableId() []byte {
	if m != nil {
		return m.V6RouteTableId
	}
	return nil
}

func (m *SubnetSpec) GetIngV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV4SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetIngV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV6SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetEgV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV4SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetEgV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV6SecurityPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetAccessEncap() *Encap {
	if m != nil {
		return m.AccessEncap
	}
	return nil
}

func (m *SubnetSpec) GetFabricEncap() *Encap {
	if m != nil {
		return m.FabricEncap
	}
	return nil
}

func (m *SubnetSpec) GetHostIf() [][]byte {
	if m != nil {
		return m.HostIf
	}
	return nil
}

func (m *SubnetSpec) GetDHCPPolicyId() [][]byte {
	if m != nil {
		return m.DHCPPolicyId
	}
	return nil
}

func (m *SubnetSpec) GetToS() uint32 {
	if m != nil {
		return m.ToS
	}
	return 0
}

func (m *SubnetSpec) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

func (m *SubnetSpec) GetIngDefaultSGPolicy() []byte {
	if m != nil {
		return m.IngDefaultSGPolicy
	}
	return nil
}

func (m *SubnetSpec) GetEgrDefaultSGPolicy() []byte {
	if m != nil {
		return m.EgrDefaultSGPolicy
	}
	return nil
}

func (m *SubnetSpec) GetRemoteSubnet() bool {
	if m != nil {
		return m.RemoteSubnet
	}
	return false
}

// operational status of the subnet, if any
type SubnetStatus struct {
	// subnet hw id
	HwId                 uint32   `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetStatus) Reset()         { *m = SubnetStatus{} }
func (m *SubnetStatus) String() string { return proto.CompactTextString(m) }
func (*SubnetStatus) ProtoMessage()    {}
func (*SubnetStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{1}
}
func (m *SubnetStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetStatus.Merge(m, src)
}
func (m *SubnetStatus) XXX_Size() int {
	return m.Size()
}
func (m *SubnetStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetStatus proto.InternalMessageInfo

func (m *SubnetStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

// stats of the subnet, if any
type SubnetStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetStats) Reset()         { *m = SubnetStats{} }
func (m *SubnetStats) String() string { return proto.CompactTextString(m) }
func (*SubnetStats) ProtoMessage()    {}
func (*SubnetStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{2}
}
func (m *SubnetStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetStats.Merge(m, src)
}
func (m *SubnetStats) XXX_Size() int {
	return m.Size()
}
func (m *SubnetStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetStats.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetStats proto.InternalMessageInfo

// subnet object
type Subnet struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjectMeta,proto3,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec                 *SubnetSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *SubnetStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *SubnetStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Subnet) Reset()         { *m = Subnet{} }
func (m *Subnet) String() string { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()    {}
func (*Subnet) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{3}
}
func (m *Subnet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subnet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subnet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subnet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subnet.Merge(m, src)
}
func (m *Subnet) XXX_Size() int {
	return m.Size()
}
func (m *Subnet) XXX_DiscardUnknown() {
	xxx_messageInfo_Subnet.DiscardUnknown(m)
}

var xxx_messageInfo_Subnet proto.InternalMessageInfo

func (m *Subnet) GetSpec() *SubnetSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Subnet) GetStatus() *SubnetStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Subnet) GetStats() *SubnetStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// subnet create and update request
type SubnetRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt    `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*SubnetSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubnetRequest) Reset()         { *m = SubnetRequest{} }
func (m *SubnetRequest) String() string { return proto.CompactTextString(m) }
func (*SubnetRequest) ProtoMessage()    {}
func (*SubnetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{4}
}
func (m *SubnetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetRequest.Merge(m, src)
}
func (m *SubnetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubnetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetRequest proto.InternalMessageInfo

func (m *SubnetRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SubnetRequest) GetRequest() []*SubnetSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// subnet create and update response
type SubnetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*SubnetStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SubnetResponse) Reset()         { *m = SubnetResponse{} }
func (m *SubnetResponse) String() string { return proto.CompactTextString(m) }
func (*SubnetResponse) ProtoMessage()    {}
func (*SubnetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{5}
}
func (m *SubnetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetResponse.Merge(m, src)
}
func (m *SubnetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubnetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetResponse proto.InternalMessageInfo

func (m *SubnetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SubnetResponse) GetResponse() []*SubnetStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// subnet get request
type SubnetGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubnetGetRequest) Reset()         { *m = SubnetGetRequest{} }
func (m *SubnetGetRequest) String() string { return proto.CompactTextString(m) }
func (*SubnetGetRequest) ProtoMessage()    {}
func (*SubnetGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{6}
}
func (m *SubnetGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetGetRequest.Merge(m, src)
}
func (m *SubnetGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubnetGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetGetRequest proto.InternalMessageInfo

func (m *SubnetGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// subnet get response
type SubnetGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Subnet `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SubnetGetResponse) Reset()         { *m = SubnetGetResponse{} }
func (m *SubnetGetResponse) String() string { return proto.CompactTextString(m) }
func (*SubnetGetResponse) ProtoMessage()    {}
func (*SubnetGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{7}
}
func (m *SubnetGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetGetResponse.Merge(m, src)
}
func (m *SubnetGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubnetGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetGetResponse proto.InternalMessageInfo

func (m *SubnetGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SubnetGetResponse) GetResponse() []*Subnet {
	if m != nil {
		return m.Response
	}
	return nil
}

// subnet delete request
type SubnetDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SubnetDeleteRequest) Reset()         { *m = SubnetDeleteRequest{} }
func (m *SubnetDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SubnetDeleteRequest) ProtoMessage()    {}
func (*SubnetDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{8}
}
func (m *SubnetDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetDeleteRequest.Merge(m, src)
}
func (m *SubnetDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubnetDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetDeleteRequest proto.InternalMessageInfo

func (m *SubnetDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SubnetDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// subnet delete response
type SubnetDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SubnetDeleteResponse) Reset()         { *m = SubnetDeleteResponse{} }
func (m *SubnetDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SubnetDeleteResponse) ProtoMessage()    {}
func (*SubnetDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1c07f925b5dc5a, []int{9}
}
func (m *SubnetDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetDeleteResponse.Merge(m, src)
}
func (m *SubnetDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubnetDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetDeleteResponse proto.InternalMessageInfo

func (m *SubnetDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*SubnetSpec)(nil), "pds.SubnetSpec")
	proto.RegisterType((*SubnetStatus)(nil), "pds.SubnetStatus")
	proto.RegisterType((*SubnetStats)(nil), "pds.SubnetStats")
	proto.RegisterType((*Subnet)(nil), "pds.Subnet")
	proto.RegisterType((*SubnetRequest)(nil), "pds.SubnetRequest")
	proto.RegisterType((*SubnetResponse)(nil), "pds.SubnetResponse")
	proto.RegisterType((*SubnetGetRequest)(nil), "pds.SubnetGetRequest")
	proto.RegisterType((*SubnetGetResponse)(nil), "pds.SubnetGetResponse")
	proto.RegisterType((*SubnetDeleteRequest)(nil), "pds.SubnetDeleteRequest")
	proto.RegisterType((*SubnetDeleteResponse)(nil), "pds.SubnetDeleteResponse")
}

func init() { proto.RegisterFile("subnet.proto", fileDescriptor_ce1c07f925b5dc5a) }

var fileDescriptor_ce1c07f925b5dc5a = []byte{
	// 904 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xcd, 0x6e, 0xe2, 0x56,
	0x14, 0xc7, 0x6b, 0x93, 0x10, 0x38, 0x7c, 0xe6, 0x90, 0x44, 0x2e, 0x1a, 0x05, 0xe4, 0x45, 0x4b,
	0xa5, 0x94, 0x56, 0x14, 0x51, 0x75, 0xa6, 0x6a, 0x35, 0x26, 0x4c, 0x62, 0x55, 0xa3, 0x41, 0x26,
	0xc3, 0xde, 0xd8, 0x37, 0xd4, 0x11, 0xd8, 0xae, 0x7d, 0x99, 0x0e, 0xfb, 0xaa, 0x2f, 0xd6, 0x4d,
	0x97, 0xf3, 0x04, 0xa8, 0xca, 0x32, 0xcb, 0x79, 0x82, 0xca, 0xd7, 0xd7, 0x1f, 0x80, 0xab, 0x49,
	0xb3, 0x41, 0xbe, 0xe7, 0x9c, 0xdf, 0xff, 0x7c, 0x70, 0x7d, 0x00, 0xca, 0xfe, 0x6a, 0x66, 0x13,
	0xda, 0x75, 0x3d, 0x87, 0x3a, 0x98, 0x73, 0x4d, 0xbf, 0x09, 0x73, 0x67, 0xee, 0x84, 0x86, 0x66,
	0x6d, 0x49, 0xa8, 0xfe, 0x4d, 0xf0, 0xc1, 0x0d, 0x25, 0xba, 0x76, 0x89, 0x1f, 0x1e, 0xe4, 0x3f,
	0x8a, 0x00, 0x13, 0xc6, 0x4f, 0x5c, 0x62, 0xe0, 0x05, 0x88, 0xaa, 0x29, 0x09, 0x6d, 0xa1, 0x53,
	0x56, 0x9e, 0x7d, 0xdc, 0xb4, 0xa4, 0x80, 0x7b, 0xbe, 0xd4, 0x6d, 0x53, 0xa7, 0x8e, 0xb7, 0xbe,
	0xb0, 0x96, 0xcb, 0x15, 0xd5, 0x67, 0x0b, 0xa2, 0x89, 0xaa, 0x89, 0x3d, 0x38, 0x9c, 0x8e, 0x87,
	0xaa, 0x29, 0x89, 0x8f, 0x00, 0xc2, 0x50, 0xfc, 0x05, 0x0a, 0xd3, 0xfe, 0xd8, 0x23, 0xb7, 0xd6,
	0x7b, 0x29, 0xd7, 0x16, 0x3a, 0xa5, 0xde, 0x71, 0x37, 0x2c, 0x48, 0x1d, 0xbf, 0xe3, 0x8e, 0x4f,
	0x28, 0xc5, 0x02, 0x4c, 0x6c, 0xc0, 0xc5, 0x0e, 0x76, 0xc5, 0x06, 0x8f, 0x14, 0xe3, 0x71, 0xf8,
	0x2d, 0x34, 0x82, 0x12, 0xa6, 0x96, 0x47, 0x57, 0xfa, 0x42, 0x73, 0x56, 0x94, 0x78, 0xea, 0x58,
	0x3a, 0x6c, 0x0b, 0x9d, 0x8a, 0x96, 0xe5, 0xe2, 0xc4, 0x60, 0x97, 0xc8, 0x07, 0xd3, 0xd0, 0xb2,
	0x5c, 0xf8, 0x13, 0xd4, 0xb7, 0x4c, 0xaf, 0x75, 0x43, 0x3a, 0x6a, 0x0b, 0x9d, 0x03, 0x05, 0x3f,
	0x6e, 0x5a, 0xd5, 0xed, 0x2a, 0xb5, 0xbd, 0x58, 0x7c, 0x0e, 0xd5, 0x69, 0x9f, 0x1d, 0x6f, 0x82,
	0xea, 0x55, 0x53, 0x2a, 0xb0, 0xd1, 0x67, 0xd1, 0x3b, 0x91, 0xf8, 0x05, 0x54, 0xa7, 0x83, 0x2d,
	0xb6, 0xc8, 0x0a, 0xdd, 0xb1, 0x62, 0x1f, 0x4e, 0x55, 0x7b, 0x3e, 0xed, 0x4f, 0x88, 0xb1, 0xf2,
	0x2c, 0xba, 0x1e, 0x3b, 0x0b, 0xcb, 0x58, 0xab, 0xa6, 0x04, 0xed, 0x5c, 0xa7, 0xac, 0x65, 0x3b,
	0x23, 0x6a, 0xb0, 0x47, 0x95, 0x12, 0x6a, 0xcf, 0x89, 0x3d, 0x38, 0x19, 0x65, 0xa5, 0x2a, 0x33,
	0x28, 0xd3, 0xc7, 0x99, 0xfd, 0x44, 0x95, 0x98, 0xd9, 0xcf, 0xa3, 0x40, 0xe9, 0xa5, 0x61, 0x10,
	0xdf, 0x1f, 0xd9, 0x86, 0xee, 0x4a, 0x55, 0x76, 0x57, 0xca, 0xfc, 0xae, 0x30, 0x5b, 0x6a, 0x84,
	0xc9, 0xe5, 0x48, 0x43, 0x81, 0xc6, 0x2b, 0x7d, 0xe6, 0x59, 0x46, 0xa8, 0x51, 0x7b, 0xac, 0x46,
	0x0a, 0xc2, 0x33, 0xc8, 0x5f, 0x3b, 0x3e, 0x55, 0x6f, 0xa5, 0x3a, 0xab, 0x96, 0x9f, 0x50, 0x86,
	0xf2, 0xe5, 0xf5, 0x70, 0x1c, 0xf7, 0x72, 0xcc, 0xbc, 0x5b, 0x36, 0xac, 0x43, 0xee, 0xc6, 0x99,
	0x48, 0xc8, 0xee, 0x63, 0xf0, 0x88, 0xcf, 0xa0, 0x38, 0x74, 0x6c, 0x9b, 0x18, 0x94, 0x98, 0x52,
	0xa3, 0x2d, 0x74, 0x0a, 0x5a, 0x62, 0x40, 0x05, 0x50, 0xb5, 0xe7, 0x97, 0xe4, 0x56, 0x5f, 0x2d,
	0xe8, 0xe4, 0x2a, 0xd4, 0x91, 0x4e, 0x76, 0xee, 0x4b, 0x52, 0x68, 0x46, 0x74, 0xa0, 0x31, 0x9a,
	0x7b, 0xbb, 0x1a, 0xa7, 0xff, 0xad, 0xb1, 0x1f, 0x1d, 0xf4, 0xa6, 0x91, 0xa5, 0x43, 0x49, 0xb8,
	0x67, 0xa4, 0x33, 0x56, 0xe8, 0x96, 0x4d, 0x96, 0xa1, 0xcc, 0xb7, 0x10, 0xd5, 0xe9, 0xca, 0x47,
	0x84, 0x83, 0xeb, 0xdf, 0xf9, 0x26, 0xaa, 0x68, 0xec, 0x59, 0xae, 0x40, 0x29, 0x89, 0xf1, 0xe5,
	0xbf, 0x44, 0xc8, 0x87, 0x67, 0x7c, 0x01, 0x85, 0x9b, 0xb5, 0x4b, 0x5e, 0x13, 0xaa, 0x33, 0xa2,
	0xd4, 0xab, 0x76, 0xd9, 0xc2, 0x8b, 0xac, 0x4a, 0xed, 0xc3, 0xa6, 0x25, 0x3c, 0x6c, 0x5a, 0x47,
	0x17, 0x96, 0xbd, 0xb0, 0x6c, 0xa2, 0xc5, 0x00, 0x8e, 0x00, 0xde, 0xcc, 0xee, 0x88, 0x41, 0x19,
	0x2e, 0x32, 0xbc, 0x12, 0xe2, 0x6f, 0x66, 0x77, 0x8c, 0x3e, 0xe3, 0x34, 0xeb, 0xf6, 0xc2, 0x59,
	0x5a, 0x94, 0x2c, 0x5d, 0xba, 0xd6, 0x52, 0x20, 0x7e, 0x0f, 0x07, 0xc1, 0x06, 0xe5, 0x3b, 0xad,
	0xd6, 0x75, 0x4d, 0xbf, 0x9b, 0x2c, 0x56, 0x05, 0x03, 0xdc, 0x77, 0x89, 0x91, 0xc2, 0x19, 0x80,
	0x3f, 0x43, 0x3e, 0x6c, 0x3a, 0xde, 0x60, 0x29, 0x94, 0x39, 0x94, 0x93, 0x87, 0x4d, 0xab, 0xee,
	0xb3, 0xe7, 0x14, 0xce, 0x31, 0x7c, 0x01, 0x87, 0x6c, 0x22, 0x6c, 0x53, 0x95, 0x7a, 0xf5, 0x1d,
	0xde, 0x57, 0x1a, 0x0f, 0x9b, 0x56, 0x2d, 0xc0, 0xd3, 0x74, 0xc8, 0xc8, 0x77, 0x50, 0x09, 0x43,
	0x35, 0xf2, 0xdb, 0x8a, 0xf8, 0x14, 0xbb, 0x50, 0x54, 0x74, 0x6a, 0xfc, 0x3a, 0xa4, 0xef, 0x29,
	0x1f, 0x66, 0x9d, 0xdf, 0xf1, 0xd8, 0xae, 0x25, 0x21, 0xf8, 0x15, 0x1c, 0x71, 0x54, 0x12, 0xdb,
	0xb9, 0x8c, 0xd6, 0xb5, 0xc8, 0x2f, 0x3b, 0x50, 0x8d, 0x72, 0xf9, 0xae, 0x63, 0xfb, 0x24, 0x48,
	0xf6, 0xd2, 0xb5, 0x78, 0xfb, 0x41, 0xb2, 0x6a, 0x9c, 0x2c, 0xb6, 0x6b, 0x49, 0x08, 0x7e, 0x0d,
	0x85, 0x88, 0xe5, 0xd9, 0xf6, 0xa7, 0xa5, 0xc5, 0x21, 0xb2, 0x0c, 0xf5, 0xd0, 0x73, 0x95, 0xf4,
	0x57, 0xe5, 0xbf, 0x70, 0xc1, 0xfb, 0x25, 0xaa, 0xa6, 0xbc, 0x80, 0xe3, 0x54, 0xcc, 0x13, 0xeb,
	0xfa, 0x72, 0xaf, 0xae, 0x52, 0xaa, 0xae, 0x54, 0x45, 0x6f, 0xa1, 0x11, 0xda, 0x2e, 0xc9, 0x82,
	0x50, 0xf2, 0xd4, 0xa1, 0x87, 0x4d, 0x88, 0x71, 0x13, 0xaf, 0xe0, 0x64, 0x5b, 0x36, 0xbb, 0x8f,
	0xdc, 0x27, 0xfa, 0xe8, 0xfd, 0x29, 0x42, 0x91, 0xcf, 0xf2, 0x9d, 0x81, 0x3f, 0x44, 0x2f, 0xe5,
	0xd0, 0x23, 0x3a, 0x25, 0x88, 0xe9, 0x9e, 0xc2, 0xca, 0x9b, 0x8d, 0x2d, 0x1b, 0xef, 0xf2, 0xb3,
	0x04, 0x7d, 0xeb, 0x9a, 0xff, 0x13, 0xfd, 0x31, 0x2a, 0xe1, 0x8a, 0x50, 0x3c, 0x4d, 0xc5, 0x24,
	0x5f, 0x62, 0xf3, 0x6c, 0xd7, 0x1c, 0xd3, 0xa3, 0x28, 0x71, 0x38, 0x09, 0x94, 0x52, 0x91, 0x5b,
	0x33, 0x6f, 0x7e, 0x9e, 0xe1, 0x89, 0x64, 0x94, 0xf2, 0xdf, 0xf7, 0xe7, 0xc2, 0x87, 0xfb, 0x73,
	0xe1, 0x9f, 0xfb, 0x73, 0x61, 0x96, 0x67, 0xff, 0x95, 0xbe, 0xfb, 0x37, 0x00, 0x00, 0xff, 0xff,
	0x36, 0x2f, 0x36, 0xb3, 0x6a, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SubnetSvcClient is the client API for SubnetSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubnetSvcClient interface {
	SubnetCreate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error)
	SubnetUpdate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error)
	SubnetGet(ctx context.Context, in *SubnetGetRequest, opts ...grpc.CallOption) (*SubnetGetResponse, error)
	SubnetDelete(ctx context.Context, in *SubnetDeleteRequest, opts ...grpc.CallOption) (*SubnetDeleteResponse, error)
}

type subnetSvcClient struct {
	cc *grpc.ClientConn
}

func NewSubnetSvcClient(cc *grpc.ClientConn) SubnetSvcClient {
	return &subnetSvcClient{cc}
}

func (c *subnetSvcClient) SubnetCreate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error) {
	out := new(SubnetResponse)
	err := c.cc.Invoke(ctx, "/pds.SubnetSvc/SubnetCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetUpdate(ctx context.Context, in *SubnetRequest, opts ...grpc.CallOption) (*SubnetResponse, error) {
	out := new(SubnetResponse)
	err := c.cc.Invoke(ctx, "/pds.SubnetSvc/SubnetUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetGet(ctx context.Context, in *SubnetGetRequest, opts ...grpc.CallOption) (*SubnetGetResponse, error) {
	out := new(SubnetGetResponse)
	err := c.cc.Invoke(ctx, "/pds.SubnetSvc/SubnetGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetSvcClient) SubnetDelete(ctx context.Context, in *SubnetDeleteRequest, opts ...grpc.CallOption) (*SubnetDeleteResponse, error) {
	out := new(SubnetDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.SubnetSvc/SubnetDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubnetSvcServer is the server API for SubnetSvc service.
type SubnetSvcServer interface {
	SubnetCreate(context.Context, *SubnetRequest) (*SubnetResponse, error)
	SubnetUpdate(context.Context, *SubnetRequest) (*SubnetResponse, error)
	SubnetGet(context.Context, *SubnetGetRequest) (*SubnetGetResponse, error)
	SubnetDelete(context.Context, *SubnetDeleteRequest) (*SubnetDeleteResponse, error)
}

// UnimplementedSubnetSvcServer can be embedded to have forward compatible implementations.
type UnimplementedSubnetSvcServer struct {
}

func (*UnimplementedSubnetSvcServer) SubnetCreate(ctx context.Context, req *SubnetRequest) (*SubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubnetCreate not implemented")
}
func (*UnimplementedSubnetSvcServer) SubnetUpdate(ctx context.Context, req *SubnetRequest) (*SubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubnetUpdate not implemented")
}
func (*UnimplementedSubnetSvcServer) SubnetGet(ctx context.Context, req *SubnetGetRequest) (*SubnetGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubnetGet not implemented")
}
func (*UnimplementedSubnetSvcServer) SubnetDelete(ctx context.Context, req *SubnetDeleteRequest) (*SubnetDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubnetDelete not implemented")
}

func RegisterSubnetSvcServer(s *grpc.Server, srv SubnetSvcServer) {
	s.RegisterService(&_SubnetSvc_serviceDesc, srv)
}

func _SubnetSvc_SubnetCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetCreate(ctx, req.(*SubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetUpdate(ctx, req.(*SubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetGet(ctx, req.(*SubnetGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubnetSvc_SubnetDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetSvcServer).SubnetDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SubnetSvc/SubnetDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetSvcServer).SubnetDelete(ctx, req.(*SubnetDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubnetSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SubnetSvc",
	HandlerType: (*SubnetSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubnetCreate",
			Handler:    _SubnetSvc_SubnetCreate_Handler,
		},
		{
			MethodName: "SubnetUpdate",
			Handler:    _SubnetSvc_SubnetUpdate_Handler,
		},
		{
			MethodName: "SubnetGet",
			Handler:    _SubnetSvc_SubnetGet_Handler,
		},
		{
			MethodName: "SubnetDelete",
			Handler:    _SubnetSvc_SubnetDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subnet.proto",
}

func (m *SubnetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoteSubnet {
		i--
		if m.RemoteSubnet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.EgrDefaultSGPolicy) > 0 {
		i -= len(m.EgrDefaultSGPolicy)
		copy(dAtA[i:], m.EgrDefaultSGPolicy)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.EgrDefaultSGPolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.IngDefaultSGPolicy) > 0 {
		i -= len(m.IngDefaultSGPolicy)
		copy(dAtA[i:], m.IngDefaultSGPolicy)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.IngDefaultSGPolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Connected {
		i--
		if m.Connected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ToS != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.ToS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.DHCPPolicyId) > 0 {
		for iNdEx := len(m.DHCPPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DHCPPolicyId[iNdEx])
			copy(dAtA[i:], m.DHCPPolicyId[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.DHCPPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.HostIf) > 0 {
		for iNdEx := len(m.HostIf) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostIf[iNdEx])
			copy(dAtA[i:], m.HostIf[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.HostIf[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.FabricEncap != nil {
		{
			size, err := m.FabricEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.AccessEncap != nil {
		{
			size, err := m.AccessEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV6SecurityPolicyId[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.EgV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV4SecurityPolicyId[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.EgV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV6SecurityPolicyId[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.IngV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV4SecurityPolicyId[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.IngV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.V6RouteTableId) > 0 {
		i -= len(m.V6RouteTableId)
		copy(dAtA[i:], m.V6RouteTableId)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.V6RouteTableId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.V4RouteTableId) > 0 {
		i -= len(m.V4RouteTableId)
		copy(dAtA[i:], m.V4RouteTableId)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.V4RouteTableId)))
		i--
		dAtA[i] = 0x42
	}
	if m.VirtualRouterMac != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.VirtualRouterMac))
		i--
		dAtA[i] = 0x38
	}
	if len(m.IPv6VirtualRouterIP) > 0 {
		i -= len(m.IPv6VirtualRouterIP)
		copy(dAtA[i:], m.IPv6VirtualRouterIP)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.IPv6VirtualRouterIP)))
		i--
		dAtA[i] = 0x32
	}
	if m.IPv4VirtualRouterIP != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.IPv4VirtualRouterIP))
		i--
		dAtA[i] = 0x28
	}
	if m.V6Prefix != nil {
		{
			size, err := m.V6Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.V4Prefix != nil {
		{
			size, err := m.V4Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSubnet(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HwId != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Subnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubnet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubnet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubnetGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubnet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSubnet(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintSubnet(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubnet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA13 := make([]byte, len(m.ApiStatus)*10)
		var j12 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintSubnet(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubnet(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubnet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubnetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.V4Prefix != nil {
		l = m.V4Prefix.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.V6Prefix != nil {
		l = m.V6Prefix.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.IPv4VirtualRouterIP != 0 {
		n += 1 + sovSubnet(uint64(m.IPv4VirtualRouterIP))
	}
	l = len(m.IPv6VirtualRouterIP)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.VirtualRouterMac != 0 {
		n += 1 + sovSubnet(uint64(m.VirtualRouterMac))
	}
	l = len(m.V4RouteTableId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	l = len(m.V6RouteTableId)
	if l > 0 {
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for _, b := range m.IngV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for _, b := range m.IngV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for _, b := range m.EgV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for _, b := range m.EgV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.AccessEncap != nil {
		l = m.AccessEncap.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.FabricEncap != nil {
		l = m.FabricEncap.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.HostIf) > 0 {
		for _, b := range m.HostIf {
			l = len(b)
			n += 2 + l + sovSubnet(uint64(l))
		}
	}
	if len(m.DHCPPolicyId) > 0 {
		for _, b := range m.DHCPPolicyId {
			l = len(b)
			n += 2 + l + sovSubnet(uint64(l))
		}
	}
	if m.ToS != 0 {
		n += 2 + sovSubnet(uint64(m.ToS))
	}
	if m.Connected {
		n += 3
	}
	l = len(m.IngDefaultSGPolicy)
	if l > 0 {
		n += 2 + l + sovSubnet(uint64(l))
	}
	l = len(m.EgrDefaultSGPolicy)
	if l > 0 {
		n += 2 + l + sovSubnet(uint64(l))
	}
	if m.RemoteSubnet {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovSubnet(uint64(m.HwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSubnet(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSubnet(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovSubnet(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovSubnet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovSubnet(uint64(e))
		}
		n += 1 + sovSubnet(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSubnet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubnet(x uint64) (n int) {
	return sovSubnet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubnetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V4Prefix == nil {
				m.V4Prefix = &IPv4Prefix{}
			}
			if err := m.V4Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V6Prefix == nil {
				m.V6Prefix = &IPv6Prefix{}
			}
			if err := m.V6Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4VirtualRouterIP", wireType)
			}
			m.IPv4VirtualRouterIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv4VirtualRouterIP |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6VirtualRouterIP", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPv6VirtualRouterIP = append(m.IPv6VirtualRouterIP[:0], dAtA[iNdEx:postIndex]...)
			if m.IPv6VirtualRouterIP == nil {
				m.IPv6VirtualRouterIP = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterMac", wireType)
			}
			m.VirtualRouterMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRouterMac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4RouteTableId = append(m.V4RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V4RouteTableId == nil {
				m.V4RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6RouteTableId = append(m.V6RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.V6RouteTableId == nil {
				m.V6RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV4SecurityPolicyId = append(m.IngV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV4SecurityPolicyId[len(m.IngV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV6SecurityPolicyId = append(m.IngV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV6SecurityPolicyId[len(m.IngV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV4SecurityPolicyId = append(m.EgV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV4SecurityPolicyId[len(m.EgV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV6SecurityPolicyId = append(m.EgV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV6SecurityPolicyId[len(m.EgV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessEncap == nil {
				m.AccessEncap = &Encap{}
			}
			if err := m.AccessEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FabricEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FabricEncap == nil {
				m.FabricEncap = &Encap{}
			}
			if err := m.FabricEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIf = append(m.HostIf, make([]byte, postIndex-iNdEx))
			copy(m.HostIf[len(m.HostIf)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DHCPPolicyId = append(m.DHCPPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.DHCPPolicyId[len(m.DHCPPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToS", wireType)
			}
			m.ToS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connected = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngDefaultSGPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngDefaultSGPolicy = append(m.IngDefaultSGPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.IngDefaultSGPolicy == nil {
				m.IngDefaultSGPolicy = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgrDefaultSGPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgrDefaultSGPolicy = append(m.EgrDefaultSGPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.EgrDefaultSGPolicy == nil {
				m.EgrDefaultSGPolicy = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteSubnet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteSubnet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SubnetSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SubnetStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SubnetStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SubnetSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SubnetStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Subnet{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubnet
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubnet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubnet
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubnet
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubnet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubnet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSubnet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubnet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubnet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubnet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubnet
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSubnet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSubnet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSubnet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSubnet
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSubnet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubnet   = fmt.Errorf("proto: integer overflow")
)
