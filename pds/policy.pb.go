// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policy.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ALG specifices with Application Level Gateway (ALG) should be invoked
// when a rule match happens. This ALG will also be reported in the flow
// logs
// NOTE:
// 1. TFTP, DNS ALGs are supported on UDP only
// 2. FTP, RTSP ALGs are supported on TCP only
// 3. SUNRPC and MSRPC ALGs are supported on both TCP and UDP
type ALG int32

const (
	ALG_ALG_NONE ALG = 0
	// TFTP ALG
	ALG_ALG_TFTP ALG = 1
	// FTP ALG
	ALG_ALG_FTP ALG = 2
	// DNS ALG
	ALG_ALG_DNS ALG = 3
	// SUNRPC ALG
	ALG_ALG_SUNRPC ALG = 4
	// MSRPC ALG
	ALG_ALG_MSRPC ALG = 5
	// RTSP ALG
	ALG_ALG_RTSP ALG = 6
)

var ALG_name = map[int32]string{
	0: "ALG_NONE",
	1: "ALG_TFTP",
	2: "ALG_FTP",
	3: "ALG_DNS",
	4: "ALG_SUNRPC",
	5: "ALG_MSRPC",
	6: "ALG_RTSP",
}

var ALG_value = map[string]int32{
	"ALG_NONE":   0,
	"ALG_TFTP":   1,
	"ALG_FTP":    2,
	"ALG_DNS":    3,
	"ALG_SUNRPC": 4,
	"ALG_MSRPC":  5,
	"ALG_RTSP":   6,
}

func (x ALG) String() string {
	return proto.EnumName(ALG_name, int32(x))
}

func (ALG) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{0}
}

// types of security policies
type SecurityPolicyType int32

const (
	SecurityPolicyType_SECURITY_POLICY_TYPE_NONE SecurityPolicyType = 0
	// UNDERLAY security policy object is singleton object per DSC
	SecurityPolicyType_SECURITY_POLICY_TYPE_UNDERLAY SecurityPolicyType = 1
	/// TENANT security policy objects are attached to tenant VPCs
	SecurityPolicyType_SECURITY_POLICY_TYPE_TENANT SecurityPolicyType = 2
)

var SecurityPolicyType_name = map[int32]string{
	0: "SECURITY_POLICY_TYPE_NONE",
	1: "SECURITY_POLICY_TYPE_UNDERLAY",
	2: "SECURITY_POLICY_TYPE_TENANT",
}

var SecurityPolicyType_value = map[string]int32{
	"SECURITY_POLICY_TYPE_NONE":     0,
	"SECURITY_POLICY_TYPE_UNDERLAY": 1,
	"SECURITY_POLICY_TYPE_TENANT":   2,
}

func (x SecurityPolicyType) String() string {
	return proto.EnumName(SecurityPolicyType_name, int32(x))
}

func (SecurityPolicyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{1}
}

// PolicyRuleFormat captures what format is used for the rules in a given
// SecurityPolicySpec object
type PolicyRuleFormat int32

const (
	// POLICY_RULE_FORMAT_NONE indicates that user has not set format
	// explicitly, in which case POLICY_RULE_FORMAT_FLATTENED is assumed
	// for backward compatibility
	PolicyRuleFormat_POLICY_RULE_FORMAT_NONE PolicyRuleFormat = 0
	// POLICY_RULE_FORMAT_FLATTENED is used when agent expands the
	// user configured rules so that each rule has only single source
	// IP address/prefix/range, destination IP address/prefix/range,
	// source port range, destination port range as match conditions
	// NOTE: in this format none of the rules must use SrcIPList,
	//       DstIPList, PortList, ICMPMatchList attributes, wherever
	//       applicable
	PolicyRuleFormat_POLICY_RULE_FORMAT_FLATTENED PolicyRuleFormat = 1
	// POLICY_RULE_FORMAT_COMPACT is used when rules contain list of
	// source IP, destination IP, src port range, destination port ranges
	// as match conditions
	// NOTE: in this format, ALL the rules must use SrcIPList, DstIPList,
	//       PortList, ICMPMatchList attributes only, whereever applicable
	PolicyRuleFormat_POLICY_RULE_FORMAT_COMPACT PolicyRuleFormat = 2
)

var PolicyRuleFormat_name = map[int32]string{
	0: "POLICY_RULE_FORMAT_NONE",
	1: "POLICY_RULE_FORMAT_FLATTENED",
	2: "POLICY_RULE_FORMAT_COMPACT",
}

var PolicyRuleFormat_value = map[string]int32{
	"POLICY_RULE_FORMAT_NONE":      0,
	"POLICY_RULE_FORMAT_FLATTENED": 1,
	"POLICY_RULE_FORMAT_COMPACT":   2,
}

func (x PolicyRuleFormat) String() string {
	return proto.EnumName(PolicyRuleFormat_name, int32(x))
}

func (PolicyRuleFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{2}
}

// FTP ALG specific options
type FTPOptions struct {
	// allow FTP data sessions with IP address that is different from
	// control sessions
	AllowIPMismatch      bool     `protobuf:"varint,1,opt,name=AllowIPMismatch,proto3" json:"AllowIPMismatch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FTPOptions) Reset()         { *m = FTPOptions{} }
func (m *FTPOptions) String() string { return proto.CompactTextString(m) }
func (*FTPOptions) ProtoMessage()    {}
func (*FTPOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{0}
}
func (m *FTPOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FTPOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FTPOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FTPOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FTPOptions.Merge(m, src)
}
func (m *FTPOptions) XXX_Size() int {
	return m.Size()
}
func (m *FTPOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FTPOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FTPOptions proto.InternalMessageInfo

func (m *FTPOptions) GetAllowIPMismatch() bool {
	if m != nil {
		return m.AllowIPMismatch
	}
	return false
}

// DNS ALG specific options
// these options are applicable to DNS request messages only
type DNSOptions struct {
	//  when DropMultiQueryMessage is set, drop DNS query messages that contain
	//  more than one DNS query in same packet
	DropMultiQueryMessages bool `protobuf:"varint,1,opt,name=DropMultiQueryMessages,proto3" json:"DropMultiQueryMessages,omitempty"`
	// when DropLargeDomainNameMessage is set, DNS mwessages containing domain
	// name exceeding 255 bytes are dropped
	DropLargeDomainNameMessages bool `protobuf:"varint,2,opt,name=DropLargeDomainNameMessages,proto3" json:"DropLargeDomainNameMessages,omitempty"`
	// when DropLongLabelMessage is set, DNS messages containing labels
	// exceeding 63 bytes are dropped
	DropLongLabelMessages bool `protobuf:"varint,3,opt,name=DropLongLabelMessages,proto3" json:"DropLongLabelMessages,omitempty"`
	// when DropMultiZoneMessagesis set, DNS messages containing more than one
	// zone are dropped
	DropMultiZoneMessages bool `protobuf:"varint,4,opt,name=DropMultiZoneMessages,proto3" json:"DropMultiZoneMessages,omitempty"`
	// DNS session will be closed if response is not seen for a DNS query within
	// ResponseTimeout seconds
	ResponseTimeout uint32 `protobuf:"varint,5,opt,name=ResponseTimeout,proto3" json:"ResponseTimeout,omitempty" meta:default=60`
	// MaxMessageLength defines the maximum length of the DNS query/response
	// message the ALG will handle
	MaxMessageLength     uint32   `protobuf:"varint,6,opt,name=MaxMessageLength,proto3" json:"MaxMessageLength,omitempty" meta:range:512-8192,meta:default=512`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNSOptions) Reset()         { *m = DNSOptions{} }
func (m *DNSOptions) String() string { return proto.CompactTextString(m) }
func (*DNSOptions) ProtoMessage()    {}
func (*DNSOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{1}
}
func (m *DNSOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSOptions.Merge(m, src)
}
func (m *DNSOptions) XXX_Size() int {
	return m.Size()
}
func (m *DNSOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DNSOptions proto.InternalMessageInfo

func (m *DNSOptions) GetDropMultiQueryMessages() bool {
	if m != nil {
		return m.DropMultiQueryMessages
	}
	return false
}

func (m *DNSOptions) GetDropLargeDomainNameMessages() bool {
	if m != nil {
		return m.DropLargeDomainNameMessages
	}
	return false
}

func (m *DNSOptions) GetDropLongLabelMessages() bool {
	if m != nil {
		return m.DropLongLabelMessages
	}
	return false
}

func (m *DNSOptions) GetDropMultiZoneMessages() bool {
	if m != nil {
		return m.DropMultiZoneMessages
	}
	return false
}

func (m *DNSOptions) GetResponseTimeout() uint32 {
	if m != nil {
		return m.ResponseTimeout
	}
	return 0
}

func (m *DNSOptions) GetMaxMessageLength() uint32 {
	if m != nil {
		return m.MaxMessageLength
	}
	return 0
}

// MSRPC ALG specific options
type MSRPCOptions struct {
	// RPC program uuids
	// NOTE: maximum of 8 program identifiers are supported per rule
	ProgramId            [][]byte `protobuf:"bytes,1,rep,name=ProgramId,proto3" json:"ProgramId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MSRPCOptions) Reset()         { *m = MSRPCOptions{} }
func (m *MSRPCOptions) String() string { return proto.CompactTextString(m) }
func (*MSRPCOptions) ProtoMessage()    {}
func (*MSRPCOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{2}
}
func (m *MSRPCOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MSRPCOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MSRPCOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MSRPCOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MSRPCOptions.Merge(m, src)
}
func (m *MSRPCOptions) XXX_Size() int {
	return m.Size()
}
func (m *MSRPCOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MSRPCOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MSRPCOptions proto.InternalMessageInfo

func (m *MSRPCOptions) GetProgramId() [][]byte {
	if m != nil {
		return m.ProgramId
	}
	return nil
}

// SunRPC ALG specific options
type SunRPCOptions struct {
	// RPC program identifiers
	// NOTE: maximum of 8 program identifiers are supported per rule
	ProgramId            []uint64 `protobuf:"varint,1,rep,packed,name=ProgramId,proto3" json:"ProgramId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SunRPCOptions) Reset()         { *m = SunRPCOptions{} }
func (m *SunRPCOptions) String() string { return proto.CompactTextString(m) }
func (*SunRPCOptions) ProtoMessage()    {}
func (*SunRPCOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{3}
}
func (m *SunRPCOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SunRPCOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SunRPCOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SunRPCOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SunRPCOptions.Merge(m, src)
}
func (m *SunRPCOptions) XXX_Size() int {
	return m.Size()
}
func (m *SunRPCOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SunRPCOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SunRPCOptions proto.InternalMessageInfo

func (m *SunRPCOptions) GetProgramId() []uint64 {
	if m != nil {
		return m.ProgramId
	}
	return nil
}

type ALGSpec struct {
	// ALG to invoke (if set to ALG_NONE, no ALG is invoked)
	ALG ALG `protobuf:"varint,1,opt,name=ALG,proto3,enum=pds.ALG" json:"ALG,omitempty"`
	// IdleTimeout indicates ALG specific session timeout in seconds
	// if IdleTimeout is not set, timeout from SecurityProfile object
	// is applied on both control and data sessions of the ALG
	IdleTimeout uint32 `protobuf:"varint,2,opt,name=IdleTimeout,proto3" json:"IdleTimeout,omitempty"`
	// ALG specific options, if any
	//
	// Types that are valid to be assigned to AlgOptions:
	//	*ALGSpec_FTPOptions
	//	*ALGSpec_DNSOptions
	//	*ALGSpec_MSRPCOptions
	//	*ALGSpec_SunRPCOptions
	AlgOptions           isALGSpec_AlgOptions `protobuf_oneof:"alg_options"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ALGSpec) Reset()         { *m = ALGSpec{} }
func (m *ALGSpec) String() string { return proto.CompactTextString(m) }
func (*ALGSpec) ProtoMessage()    {}
func (*ALGSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{4}
}
func (m *ALGSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ALGSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ALGSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ALGSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ALGSpec.Merge(m, src)
}
func (m *ALGSpec) XXX_Size() int {
	return m.Size()
}
func (m *ALGSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ALGSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ALGSpec proto.InternalMessageInfo

type isALGSpec_AlgOptions interface {
	isALGSpec_AlgOptions()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ALGSpec_FTPOptions struct {
	FTPOptions *FTPOptions `protobuf:"bytes,3,opt,name=FTPOptions,proto3,oneof"`
}
type ALGSpec_DNSOptions struct {
	DNSOptions *DNSOptions `protobuf:"bytes,4,opt,name=DNSOptions,proto3,oneof"`
}
type ALGSpec_MSRPCOptions struct {
	MSRPCOptions *MSRPCOptions `protobuf:"bytes,5,opt,name=MSRPCOptions,proto3,oneof"`
}
type ALGSpec_SunRPCOptions struct {
	SunRPCOptions *SunRPCOptions `protobuf:"bytes,6,opt,name=SunRPCOptions,proto3,oneof"`
}

func (*ALGSpec_FTPOptions) isALGSpec_AlgOptions()    {}
func (*ALGSpec_DNSOptions) isALGSpec_AlgOptions()    {}
func (*ALGSpec_MSRPCOptions) isALGSpec_AlgOptions()  {}
func (*ALGSpec_SunRPCOptions) isALGSpec_AlgOptions() {}

func (m *ALGSpec) GetAlgOptions() isALGSpec_AlgOptions {
	if m != nil {
		return m.AlgOptions
	}
	return nil
}

func (m *ALGSpec) GetALG() ALG {
	if m != nil {
		return m.ALG
	}
	return ALG_ALG_NONE
}

func (m *ALGSpec) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *ALGSpec) GetFTPOptions() *FTPOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_FTPOptions); ok {
		return x.FTPOptions
	}
	return nil
}

func (m *ALGSpec) GetDNSOptions() *DNSOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_DNSOptions); ok {
		return x.DNSOptions
	}
	return nil
}

func (m *ALGSpec) GetMSRPCOptions() *MSRPCOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_MSRPCOptions); ok {
		return x.MSRPCOptions
	}
	return nil
}

func (m *ALGSpec) GetSunRPCOptions() *SunRPCOptions {
	if x, ok := m.GetAlgOptions().(*ALGSpec_SunRPCOptions); ok {
		return x.SunRPCOptions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ALGSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ALGSpec_FTPOptions)(nil),
		(*ALGSpec_DNSOptions)(nil),
		(*ALGSpec_MSRPCOptions)(nil),
		(*ALGSpec_SunRPCOptions)(nil),
	}
}

// security rule attributes
type SecurityRuleAttrs struct {
	// priority of this rule (lower the numeric value, higher the priority is)
	// if there are multiple rules with same highest priority that match the
	// packet, the first such matching rule in the policy is picked (i.e., based
	// on the order, first in the list of such matching rules)
	Priority uint32 `protobuf:"varint,1,opt,name=Priority,proto3" json:"Priority,omitempty" meta:range:0-65534`
	// rule match criteria
	Match *RuleMatch `protobuf:"bytes,2,opt,name=Match,proto3" json:"Match,omitempty"`
	// action to take when this rule is matched
	Action SecurityRuleAction `protobuf:"varint,3,opt,name=Action,proto3,enum=types.SecurityRuleAction" json:"Action,omitempty" meta:mandatory`
	// when a rule marked as terminating is picked (based on the priority) as the
	// matching rule from a policy, then the action of such rule will prevail or
	// stick over the matching rules picked from already evaluated policies and
	// the search for other matching rules in policies yet to be evaluated for
	// that packet will stop (i.e., packet hitting terminating rule will pick
	// corresponding action irrespective any other matching rules across all
	// policies)
	Terminating bool `protobuf:"varint,4,opt,name=Terminating,proto3" json:"Terminating,omitempty"`
	// ALGSpec contains optional ALG specific behavior, if ALG is enabled for
	// this rule
	ALGSpec              *ALGSpec `protobuf:"bytes,5,opt,name=ALGSpec,proto3" json:"ALGSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityRuleAttrs) Reset()         { *m = SecurityRuleAttrs{} }
func (m *SecurityRuleAttrs) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleAttrs) ProtoMessage()    {}
func (*SecurityRuleAttrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{5}
}
func (m *SecurityRuleAttrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleAttrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleAttrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleAttrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleAttrs.Merge(m, src)
}
func (m *SecurityRuleAttrs) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleAttrs) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleAttrs.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleAttrs proto.InternalMessageInfo

func (m *SecurityRuleAttrs) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SecurityRuleAttrs) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *SecurityRuleAttrs) GetAction() SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityRuleAttrs) GetTerminating() bool {
	if m != nil {
		return m.Terminating
	}
	return false
}

func (m *SecurityRuleAttrs) GetALGSpec() *ALGSpec {
	if m != nil {
		return m.ALGSpec
	}
	return nil
}

// SecurityRuleInfo is a single rule in the security policy
type SecurityRuleInfo struct {
	// optional rule id needed if incremental route ADD/DEL/UPD functionality
	// is needed
	Id                   []byte             `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Attrs                *SecurityRuleAttrs `protobuf:"bytes,2,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SecurityRuleInfo) Reset()         { *m = SecurityRuleInfo{} }
func (m *SecurityRuleInfo) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleInfo) ProtoMessage()    {}
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{6}
}
func (m *SecurityRuleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleInfo.Merge(m, src)
}
func (m *SecurityRuleInfo) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleInfo proto.InternalMessageInfo

func (m *SecurityRuleInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleInfo) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// security policy configuration
type SecurityPolicySpec struct {
	// unique identifier of security policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// SecurityPolicyType is either TENANT or UNDERLAY (aka. infra) policy
	// NOTE:
	// 1. only one instance of UNDERLAY policy can exist on a DSC
	// 2. if Type is not specified, policy type defaults to TENANT policy
	Type SecurityPolicyType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.SecurityPolicyType" json:"Type,omitempty" meta:immutable,default=SECURITY_POLICY_TYPE_TENANT`
	// IPv4 or IPv6 policy
	AddrFamily IPAF `protobuf:"varint,3,opt,name=AddrFamily,proto3,enum=types.IPAF" json:"AddrFamily,omitempty" meta:mandatory,immutable`
	// when Stateless attribute is set on a policy, the policy is applied for
	// traffic in both directions before deciding the final action of the flow
	// when Stateless is set to false, the policy behavior is same as Network
	// Security Group (NSG) construct whereas if Stateless is set to true, the
	// behavior is same as ACL construct
	Stateless bool `protobuf:"varint,4,opt,name=Stateless,proto3" json:"Stateless,omitempty" meta:immutable`
	// DefaultFWAction is the action taken by the firewall when SG policies are
	// configured on vnic but no rule is hit. Similarly, when NACLs are configured
	// on a subnet and no rule is hit, this action is taken by the firewall.
	// if this attribute is not set, it will inherit from security profile and if
	// that is also not set then  default "deny" action is enforced
	// NOTE: when no policy is configured on subnet and vnic, this knob doesn't
	//       apply and traffic is allowed in that case
	DefaultFWAction SecurityRuleAction `protobuf:"varint,5,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_NONE`
	// list of security rules
	Rules []*SecurityRuleInfo `protobuf:"bytes,6,rep,name=Rules,proto3" json:"Rules,omitempty" meta:mandatory`
	// PolicyRuleFormat indicates whether the policy is set of flattened rules
	// or whether they are in compact form
	RuleFormat           PolicyRuleFormat `protobuf:"varint,7,opt,name=RuleFormat,proto3,enum=pds.PolicyRuleFormat" json:"RuleFormat,omitempty" meta:default=SECURITY_POLICY_FORMAT_FLATTENED`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SecurityPolicySpec) Reset()         { *m = SecurityPolicySpec{} }
func (m *SecurityPolicySpec) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicySpec) ProtoMessage()    {}
func (*SecurityPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{7}
}
func (m *SecurityPolicySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicySpec.Merge(m, src)
}
func (m *SecurityPolicySpec) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicySpec.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicySpec proto.InternalMessageInfo

func (m *SecurityPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicySpec) GetType() SecurityPolicyType {
	if m != nil {
		return m.Type
	}
	return SecurityPolicyType_SECURITY_POLICY_TYPE_NONE
}

func (m *SecurityPolicySpec) GetAddrFamily() IPAF {
	if m != nil {
		return m.AddrFamily
	}
	return IPAF_IP_AF_NONE
}

func (m *SecurityPolicySpec) GetStateless() bool {
	if m != nil {
		return m.Stateless
	}
	return false
}

func (m *SecurityPolicySpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityPolicySpec) GetRules() []*SecurityRuleInfo {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *SecurityPolicySpec) GetRuleFormat() PolicyRuleFormat {
	if m != nil {
		return m.RuleFormat
	}
	return PolicyRuleFormat_POLICY_RULE_FORMAT_NONE
}

// operational status of security policy, if any
type SecurityPolicyStatus struct {
	PoolId               uint32   `protobuf:"varint,1,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
	HwId                 uint32   `protobuf:"varint,2,opt,name=HwId,proto3" json:"HwId,omitempty"`
	PolicyBaseAddr       uint64   `protobuf:"varint,3,opt,name=PolicyBaseAddr,proto3" json:"PolicyBaseAddr,omitempty"`
	RuleCount            uint32   `protobuf:"varint,4,opt,name=RuleCount,proto3" json:"RuleCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityPolicyStatus) Reset()         { *m = SecurityPolicyStatus{} }
func (m *SecurityPolicyStatus) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyStatus) ProtoMessage()    {}
func (*SecurityPolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{8}
}
func (m *SecurityPolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyStatus.Merge(m, src)
}
func (m *SecurityPolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyStatus proto.InternalMessageInfo

func (m *SecurityPolicyStatus) GetPoolId() uint32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *SecurityPolicyStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *SecurityPolicyStatus) GetPolicyBaseAddr() uint64 {
	if m != nil {
		return m.PolicyBaseAddr
	}
	return 0
}

func (m *SecurityPolicyStatus) GetRuleCount() uint32 {
	if m != nil {
		return m.RuleCount
	}
	return 0
}

// stats of security policy, if any
type SecurityPolicyStats struct {
	// stats corresponding to the default action of the policy
	DefaultRuleStats *SecurityRuleStats `protobuf:"bytes,1,opt,name=DefaultRuleStats,proto3" json:"DefaultRuleStats,omitempty"`
	// per security rule statistics
	RuleStats            []*SecurityRuleStats `protobuf:"bytes,2,rep,name=RuleStats,proto3" json:"RuleStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SecurityPolicyStats) Reset()         { *m = SecurityPolicyStats{} }
func (m *SecurityPolicyStats) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyStats) ProtoMessage()    {}
func (*SecurityPolicyStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{9}
}
func (m *SecurityPolicyStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyStats.Merge(m, src)
}
func (m *SecurityPolicyStats) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyStats.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyStats proto.InternalMessageInfo

func (m *SecurityPolicyStats) GetDefaultRuleStats() *SecurityRuleStats {
	if m != nil {
		return m.DefaultRuleStats
	}
	return nil
}

func (m *SecurityPolicyStats) GetRuleStats() []*SecurityRuleStats {
	if m != nil {
		return m.RuleStats
	}
	return nil
}

// security policy object
type SecurityPolicy struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *SecurityPolicySpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *SecurityPolicyStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *SecurityPolicyStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SecurityPolicy) Reset()         { *m = SecurityPolicy{} }
func (m *SecurityPolicy) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicy) ProtoMessage()    {}
func (*SecurityPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{10}
}
func (m *SecurityPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicy.Merge(m, src)
}
func (m *SecurityPolicy) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicy proto.InternalMessageInfo

func (m *SecurityPolicy) GetSpec() *SecurityPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityPolicy) GetStatus() *SecurityPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityPolicy) GetStats() *SecurityPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy create and update request
type SecurityPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt            `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*SecurityPolicySpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SecurityPolicyRequest) Reset()         { *m = SecurityPolicyRequest{} }
func (m *SecurityPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyRequest) ProtoMessage()    {}
func (*SecurityPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{11}
}
func (m *SecurityPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyRequest.Merge(m, src)
}
func (m *SecurityPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyRequest proto.InternalMessageInfo

func (m *SecurityPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyRequest) GetRequest() []*SecurityPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy create and update response
type SecurityPolicyResponse struct {
	ApiStatus            ApiStatus               `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*SecurityPolicyStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SecurityPolicyResponse) Reset()         { *m = SecurityPolicyResponse{} }
func (m *SecurityPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyResponse) ProtoMessage()    {}
func (*SecurityPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{12}
}
func (m *SecurityPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyResponse.Merge(m, src)
}
func (m *SecurityPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyResponse proto.InternalMessageInfo

func (m *SecurityPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyResponse) GetResponse() []*SecurityPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy get request
type SecurityPolicyGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityPolicyGetRequest) Reset()         { *m = SecurityPolicyGetRequest{} }
func (m *SecurityPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyGetRequest) ProtoMessage()    {}
func (*SecurityPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{13}
}
func (m *SecurityPolicyGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyGetRequest.Merge(m, src)
}
func (m *SecurityPolicyGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyGetRequest proto.InternalMessageInfo

func (m *SecurityPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy get response
type SecurityPolicyGetResponse struct {
	ApiStatus            ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*SecurityPolicy `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SecurityPolicyGetResponse) Reset()         { *m = SecurityPolicyGetResponse{} }
func (m *SecurityPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyGetResponse) ProtoMessage()    {}
func (*SecurityPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{14}
}
func (m *SecurityPolicyGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyGetResponse.Merge(m, src)
}
func (m *SecurityPolicyGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyGetResponse proto.InternalMessageInfo

func (m *SecurityPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityPolicyGetResponse) GetResponse() []*SecurityPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy delete request
type SecurityPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SecurityPolicyDeleteRequest) Reset()         { *m = SecurityPolicyDeleteRequest{} }
func (m *SecurityPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteRequest) ProtoMessage()    {}
func (*SecurityPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{15}
}
func (m *SecurityPolicyDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyDeleteRequest.Merge(m, src)
}
func (m *SecurityPolicyDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyDeleteRequest proto.InternalMessageInfo

func (m *SecurityPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy delete response
type SecurityPolicyDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SecurityPolicyDeleteResponse) Reset()         { *m = SecurityPolicyDeleteResponse{} }
func (m *SecurityPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyDeleteResponse) ProtoMessage()    {}
func (*SecurityPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{16}
}
func (m *SecurityPolicyDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyDeleteResponse.Merge(m, src)
}
func (m *SecurityPolicyDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyDeleteResponse proto.InternalMessageInfo

func (m *SecurityPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// unique id to identify a security policy rule
type SecurityPolicyRuleId struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId     []byte   `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityPolicyRuleId) Reset()         { *m = SecurityPolicyRuleId{} }
func (m *SecurityPolicyRuleId) String() string { return proto.CompactTextString(m) }
func (*SecurityPolicyRuleId) ProtoMessage()    {}
func (*SecurityPolicyRuleId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{17}
}
func (m *SecurityPolicyRuleId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityPolicyRuleId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityPolicyRuleId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityPolicyRuleId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityPolicyRuleId.Merge(m, src)
}
func (m *SecurityPolicyRuleId) XXX_Size() int {
	return m.Size()
}
func (m *SecurityPolicyRuleId) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityPolicyRuleId.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityPolicyRuleId proto.InternalMessageInfo

func (m *SecurityPolicyRuleId) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityPolicyRuleId) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

// security rule configuration
type SecurityRuleSpec struct {
	// unique identifier of security rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// security policy this rule belongs to
	SecurityPolicyId []byte `protobuf:"bytes,2,opt,name=SecurityPolicyId,proto3" json:"SecurityPolicyId,omitempty" meta:mandatory,immutable`
	// rule information
	Attrs                *SecurityRuleAttrs `protobuf:"bytes,3,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SecurityRuleSpec) Reset()         { *m = SecurityRuleSpec{} }
func (m *SecurityRuleSpec) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleSpec) ProtoMessage()    {}
func (*SecurityRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{18}
}
func (m *SecurityRuleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleSpec.Merge(m, src)
}
func (m *SecurityRuleSpec) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleSpec proto.InternalMessageInfo

func (m *SecurityRuleSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityRuleSpec) GetSecurityPolicyId() []byte {
	if m != nil {
		return m.SecurityPolicyId
	}
	return nil
}

func (m *SecurityRuleSpec) GetAttrs() *SecurityRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// operational status of the security rule, if any
type SecurityRuleStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityRuleStatus) Reset()         { *m = SecurityRuleStatus{} }
func (m *SecurityRuleStatus) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleStatus) ProtoMessage()    {}
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{19}
}
func (m *SecurityRuleStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleStatus.Merge(m, src)
}
func (m *SecurityRuleStatus) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleStatus proto.InternalMessageInfo

// stats of the security rule, if any
type SecurityRuleStats struct {
	// number of times the rule is hit
	NumRuleHit           uint64   `protobuf:"varint,1,opt,name=NumRuleHit,proto3" json:"NumRuleHit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityRuleStats) Reset()         { *m = SecurityRuleStats{} }
func (m *SecurityRuleStats) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleStats) ProtoMessage()    {}
func (*SecurityRuleStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{20}
}
func (m *SecurityRuleStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleStats.Merge(m, src)
}
func (m *SecurityRuleStats) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleStats.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleStats proto.InternalMessageInfo

func (m *SecurityRuleStats) GetNumRuleHit() uint64 {
	if m != nil {
		return m.NumRuleHit
	}
	return 0
}

// security rule object
type SecurityRule struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *SecurityRuleSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *SecurityRuleStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *SecurityRuleStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityRule) Reset()         { *m = SecurityRule{} }
func (m *SecurityRule) String() string { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()    {}
func (*SecurityRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{21}
}
func (m *SecurityRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRule.Merge(m, src)
}
func (m *SecurityRule) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRule.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRule proto.InternalMessageInfo

func (m *SecurityRule) GetSpec() *SecurityRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityRule) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityRule) GetStats() *SecurityRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security policy rule create and update request
type SecurityRuleRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// security policy rule configuration
	Request              *SecurityRuleSpec `protobuf:"bytes,2,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SecurityRuleRequest) Reset()         { *m = SecurityRuleRequest{} }
func (m *SecurityRuleRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleRequest) ProtoMessage()    {}
func (*SecurityRuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{22}
}
func (m *SecurityRuleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleRequest.Merge(m, src)
}
func (m *SecurityRuleRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleRequest proto.InternalMessageInfo

func (m *SecurityRuleRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleRequest) GetRequest() *SecurityRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security policy rule create and update response
type SecurityRuleResponse struct {
	// success or failure status
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// operational status
	Response             *SecurityRuleStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityRuleResponse) Reset()         { *m = SecurityRuleResponse{} }
func (m *SecurityRuleResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleResponse) ProtoMessage()    {}
func (*SecurityRuleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{23}
}
func (m *SecurityRuleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleResponse.Merge(m, src)
}
func (m *SecurityRuleResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleResponse proto.InternalMessageInfo

func (m *SecurityRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleResponse) GetResponse() *SecurityRuleStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule get request
type SecurityRuleGetRequest struct {
	// list of id/key of the security policy rules of interest
	Id                   []*SecurityPolicyRuleId `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SecurityRuleGetRequest) Reset()         { *m = SecurityRuleGetRequest{} }
func (m *SecurityRuleGetRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleGetRequest) ProtoMessage()    {}
func (*SecurityRuleGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{24}
}
func (m *SecurityRuleGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleGetRequest.Merge(m, src)
}
func (m *SecurityRuleGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleGetRequest proto.InternalMessageInfo

func (m *SecurityRuleGetRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule get response
type SecurityRuleGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// security policy rule information
	Response             []*SecurityRule `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SecurityRuleGetResponse) Reset()         { *m = SecurityRuleGetResponse{} }
func (m *SecurityRuleGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleGetResponse) ProtoMessage()    {}
func (*SecurityRuleGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{25}
}
func (m *SecurityRuleGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleGetResponse.Merge(m, src)
}
func (m *SecurityRuleGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleGetResponse proto.InternalMessageInfo

func (m *SecurityRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleGetResponse) GetResponse() []*SecurityRule {
	if m != nil {
		return m.Response
	}
	return nil
}

// security policy rule delete request
type SecurityRuleDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// id/key list of the security policy rule(s) to be deleted
	Id                   []*SecurityPolicyRuleId `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SecurityRuleDeleteRequest) Reset()         { *m = SecurityRuleDeleteRequest{} }
func (m *SecurityRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteRequest) ProtoMessage()    {}
func (*SecurityRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{26}
}
func (m *SecurityRuleDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleDeleteRequest.Merge(m, src)
}
func (m *SecurityRuleDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleDeleteRequest proto.InternalMessageInfo

func (m *SecurityRuleDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityRuleDeleteRequest) GetId() []*SecurityPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// security policy rule delete response
type SecurityRuleDeleteResponse struct {
	// API status code
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SecurityRuleDeleteResponse) Reset()         { *m = SecurityRuleDeleteResponse{} }
func (m *SecurityRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteResponse) ProtoMessage()    {}
func (*SecurityRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{27}
}
func (m *SecurityRuleDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityRuleDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityRuleDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityRuleDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityRuleDeleteResponse.Merge(m, src)
}
func (m *SecurityRuleDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityRuleDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityRuleDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityRuleDeleteResponse proto.InternalMessageInfo

func (m *SecurityRuleDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// security profile configuration
// NOTE:
// 1. currently security profile object is global and only a singleton object,
//    any attempt to create multiple objects will be treated as an error
// 2. if no object is created, indicated default values will be used
// 3. all timeouts specified in this object are in seconds
type SecurityProfileSpec struct {
	// unique identifier of security profile
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// ConnTrackEn, if set to true, will enable full connection tracking
	// NOTE: if ConnTrackEn is modified on the fly, it will take affect only on
	//       sessions created thereafter and doesn't affect existing sessions
	ConnTrackEn bool `protobuf:"varint,2,opt,name=ConnTrackEn,proto3" json:"ConnTrackEn,omitempty" meta:default=false`
	// RuleStatsEn, if set to true, will enable per security policy rule
	// statistics feature in the datapath (by default rule stats functionality is
	// turned off and can be enabled on the fly for debugging)
	RuleStatsEn bool `protobuf:"varint,3,opt,name=RuleStatsEn,proto3" json:"RuleStatsEn,omitempty"`
	// DefaultFWAction is the action taken by the smartnic when policies are
	// configured on the subnet or vnic, no rule matches and default action for policy is none
	// this will have effect iff policy is attached on either vnic or subnet.
	// if no action is specified  in security profile, default action is "deny"
	DefaultFWAction SecurityRuleAction `protobuf:"varint,4,opt,name=DefaultFWAction,proto3,enum=types.SecurityRuleAction" json:"DefaultFWAction,omitempty" meta:default=SECURITY_RULE_ACTION_DENY`
	// timeouts for established sessions per TCP/UDP/ICMP and other protocols
	TCPIdleTimeout   uint32 `protobuf:"varint,5,opt,name=TCPIdleTimeout,proto3" json:"TCPIdleTimeout,omitempty" meta:range:1-86400, meta:default=600`
	UDPIdleTimeout   uint32 `protobuf:"varint,6,opt,name=UDPIdleTimeout,proto3" json:"UDPIdleTimeout,omitempty" meta:range:1-86400, meta:default=120`
	ICMPIdleTimeout  uint32 `protobuf:"varint,7,opt,name=ICMPIdleTimeout,proto3" json:"ICMPIdleTimeout,omitempty" meta:range:1-86400, meta:default=15`
	OtherIdleTimeout uint32 `protobuf:"varint,8,opt,name=OtherIdleTimeout,proto3" json:"OtherIdleTimeout,omitempty" meta:range:1-86400, meta:default=90`
	// TCP specific timeouts
	// TCPCnxnSetupTimeout is the maximum allowed time since first SYN seen to
	// 3-way handshake completion, session gets cleaned up if 3-way handshake is
	// not completed and session moves to ESTABLISHED state by then
	TCPCnxnSetupTimeout uint32 `protobuf:"varint,9,opt,name=TCPCnxnSetupTimeout,proto3" json:"TCPCnxnSetupTimeout,omitempty" meta:range:1-60, meta:default=10`
	// TCPHalfCloseTimeout is the maximum allowed time since first FIN seen to
	// 3/4way close, session gets cleaned up if this timer elapses.
	TCPHalfCloseTimeout uint32 `protobuf:"varint,10,opt,name=TCPHalfCloseTimeout,proto3" json:"TCPHalfCloseTimeout,omitempty" meta:range:1-172800, meta:default=120`
	// TCPCloseTimeout is wait time since FIN is seen from *both* sides (or RST)
	// before cleaning up the session
	TCPCloseTimeout uint32 `protobuf:"varint,11,opt,name=TCPCloseTimeout,proto3" json:"TCPCloseTimeout,omitempty" meta:range:1-300, meta:default=15`
	// timeouts applicable to sessions installed with drop action
	TCPDropTimeout       uint32   `protobuf:"varint,12,opt,name=TCPDropTimeout,proto3" json:"TCPDropTimeout,omitempty" meta:range:1-300, meta:default=90`
	UDPDropTimeout       uint32   `protobuf:"varint,13,opt,name=UDPDropTimeout,proto3" json:"UDPDropTimeout,omitempty" meta:range:1-172800, meta:default=60`
	ICMPDropTimeout      uint32   `protobuf:"varint,14,opt,name=ICMPDropTimeout,proto3" json:"ICMPDropTimeout,omitempty" meta:range:1-300, meta:default=30`
	OtherDropTimeout     uint32   `protobuf:"varint,15,opt,name=OtherDropTimeout,proto3" json:"OtherDropTimeout,omitempty" meta:range:1-300, meta:default=60`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityProfileSpec) Reset()         { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()    {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{28}
}
func (m *SecurityProfileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileSpec.Merge(m, src)
}
func (m *SecurityProfileSpec) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileSpec proto.InternalMessageInfo

func (m *SecurityProfileSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityProfileSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SecurityProfileSpec) GetRuleStatsEn() bool {
	if m != nil {
		return m.RuleStatsEn
	}
	return false
}

func (m *SecurityProfileSpec) GetDefaultFWAction() SecurityRuleAction {
	if m != nil {
		return m.DefaultFWAction
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityProfileSpec) GetTCPIdleTimeout() uint32 {
	if m != nil {
		return m.TCPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPIdleTimeout() uint32 {
	if m != nil {
		return m.UDPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPIdleTimeout() uint32 {
	if m != nil {
		return m.ICMPIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherIdleTimeout() uint32 {
	if m != nil {
		return m.OtherIdleTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCnxnSetupTimeout() uint32 {
	if m != nil {
		return m.TCPCnxnSetupTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPHalfCloseTimeout() uint32 {
	if m != nil {
		return m.TCPHalfCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPCloseTimeout() uint32 {
	if m != nil {
		return m.TCPCloseTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetTCPDropTimeout() uint32 {
	if m != nil {
		return m.TCPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetUDPDropTimeout() uint32 {
	if m != nil {
		return m.UDPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetICMPDropTimeout() uint32 {
	if m != nil {
		return m.ICMPDropTimeout
	}
	return 0
}

func (m *SecurityProfileSpec) GetOtherDropTimeout() uint32 {
	if m != nil {
		return m.OtherDropTimeout
	}
	return 0
}

// operational status of security profile, if any
type SecurityProfileStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityProfileStatus) Reset()         { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()    {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{29}
}
func (m *SecurityProfileStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileStatus.Merge(m, src)
}
func (m *SecurityProfileStatus) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileStatus proto.InternalMessageInfo

// stats of security profile, if any
type SecurityProfileStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityProfileStats) Reset()         { *m = SecurityProfileStats{} }
func (m *SecurityProfileStats) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileStats) ProtoMessage()    {}
func (*SecurityProfileStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{30}
}
func (m *SecurityProfileStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileStats.Merge(m, src)
}
func (m *SecurityProfileStats) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileStats.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileStats proto.InternalMessageInfo

// security profile object
type SecurityProfile struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *SecurityProfileSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *SecurityProfileStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *SecurityProfileStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SecurityProfile) Reset()         { *m = SecurityProfile{} }
func (m *SecurityProfile) String() string { return proto.CompactTextString(m) }
func (*SecurityProfile) ProtoMessage()    {}
func (*SecurityProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{31}
}
func (m *SecurityProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfile.Merge(m, src)
}
func (m *SecurityProfile) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfile.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfile proto.InternalMessageInfo

func (m *SecurityProfile) GetSpec() *SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityProfile) GetStatus() *SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SecurityProfile) GetStats() *SecurityProfileStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// security profile create and update request
type SecurityProfileRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt             `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*SecurityProfileSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SecurityProfileRequest) Reset()         { *m = SecurityProfileRequest{} }
func (m *SecurityProfileRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileRequest) ProtoMessage()    {}
func (*SecurityProfileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{32}
}
func (m *SecurityProfileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileRequest.Merge(m, src)
}
func (m *SecurityProfileRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileRequest proto.InternalMessageInfo

func (m *SecurityProfileRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileRequest) GetRequest() []*SecurityProfileSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// security profile create and update response
type SecurityProfileResponse struct {
	ApiStatus            ApiStatus                `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*SecurityProfileStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *SecurityProfileResponse) Reset()         { *m = SecurityProfileResponse{} }
func (m *SecurityProfileResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileResponse) ProtoMessage()    {}
func (*SecurityProfileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{33}
}
func (m *SecurityProfileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileResponse.Merge(m, src)
}
func (m *SecurityProfileResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileResponse proto.InternalMessageInfo

func (m *SecurityProfileResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileResponse) GetResponse() []*SecurityProfileStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile get request
type SecurityProfileGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityProfileGetRequest) Reset()         { *m = SecurityProfileGetRequest{} }
func (m *SecurityProfileGetRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetRequest) ProtoMessage()    {}
func (*SecurityProfileGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{34}
}
func (m *SecurityProfileGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileGetRequest.Merge(m, src)
}
func (m *SecurityProfileGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileGetRequest proto.InternalMessageInfo

func (m *SecurityProfileGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile get response
type SecurityProfileGetResponse struct {
	ApiStatus            ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*SecurityProfile `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SecurityProfileGetResponse) Reset()         { *m = SecurityProfileGetResponse{} }
func (m *SecurityProfileGetResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileGetResponse) ProtoMessage()    {}
func (*SecurityProfileGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{35}
}
func (m *SecurityProfileGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileGetResponse.Merge(m, src)
}
func (m *SecurityProfileGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileGetResponse proto.InternalMessageInfo

func (m *SecurityProfileGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityProfileGetResponse) GetResponse() []*SecurityProfile {
	if m != nil {
		return m.Response
	}
	return nil
}

// security profile delete request
type SecurityProfileDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SecurityProfileDeleteRequest) Reset()         { *m = SecurityProfileDeleteRequest{} }
func (m *SecurityProfileDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteRequest) ProtoMessage()    {}
func (*SecurityProfileDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{36}
}
func (m *SecurityProfileDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileDeleteRequest.Merge(m, src)
}
func (m *SecurityProfileDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileDeleteRequest proto.InternalMessageInfo

func (m *SecurityProfileDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *SecurityProfileDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// security profile delete response
type SecurityProfileDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SecurityProfileDeleteResponse) Reset()         { *m = SecurityProfileDeleteResponse{} }
func (m *SecurityProfileDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileDeleteResponse) ProtoMessage()    {}
func (*SecurityProfileDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac3b897852294d6a, []int{37}
}
func (m *SecurityProfileDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityProfileDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityProfileDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityProfileDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityProfileDeleteResponse.Merge(m, src)
}
func (m *SecurityProfileDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityProfileDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityProfileDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityProfileDeleteResponse proto.InternalMessageInfo

func (m *SecurityProfileDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.ALG", ALG_name, ALG_value)
	proto.RegisterEnum("pds.SecurityPolicyType", SecurityPolicyType_name, SecurityPolicyType_value)
	proto.RegisterEnum("pds.PolicyRuleFormat", PolicyRuleFormat_name, PolicyRuleFormat_value)
	proto.RegisterType((*FTPOptions)(nil), "pds.FTPOptions")
	proto.RegisterType((*DNSOptions)(nil), "pds.DNSOptions")
	proto.RegisterType((*MSRPCOptions)(nil), "pds.MSRPCOptions")
	proto.RegisterType((*SunRPCOptions)(nil), "pds.SunRPCOptions")
	proto.RegisterType((*ALGSpec)(nil), "pds.ALGSpec")
	proto.RegisterType((*SecurityRuleAttrs)(nil), "pds.SecurityRuleAttrs")
	proto.RegisterType((*SecurityRuleInfo)(nil), "pds.SecurityRuleInfo")
	proto.RegisterType((*SecurityPolicySpec)(nil), "pds.SecurityPolicySpec")
	proto.RegisterType((*SecurityPolicyStatus)(nil), "pds.SecurityPolicyStatus")
	proto.RegisterType((*SecurityPolicyStats)(nil), "pds.SecurityPolicyStats")
	proto.RegisterType((*SecurityPolicy)(nil), "pds.SecurityPolicy")
	proto.RegisterType((*SecurityPolicyRequest)(nil), "pds.SecurityPolicyRequest")
	proto.RegisterType((*SecurityPolicyResponse)(nil), "pds.SecurityPolicyResponse")
	proto.RegisterType((*SecurityPolicyGetRequest)(nil), "pds.SecurityPolicyGetRequest")
	proto.RegisterType((*SecurityPolicyGetResponse)(nil), "pds.SecurityPolicyGetResponse")
	proto.RegisterType((*SecurityPolicyDeleteRequest)(nil), "pds.SecurityPolicyDeleteRequest")
	proto.RegisterType((*SecurityPolicyDeleteResponse)(nil), "pds.SecurityPolicyDeleteResponse")
	proto.RegisterType((*SecurityPolicyRuleId)(nil), "pds.SecurityPolicyRuleId")
	proto.RegisterType((*SecurityRuleSpec)(nil), "pds.SecurityRuleSpec")
	proto.RegisterType((*SecurityRuleStatus)(nil), "pds.SecurityRuleStatus")
	proto.RegisterType((*SecurityRuleStats)(nil), "pds.SecurityRuleStats")
	proto.RegisterType((*SecurityRule)(nil), "pds.SecurityRule")
	proto.RegisterType((*SecurityRuleRequest)(nil), "pds.SecurityRuleRequest")
	proto.RegisterType((*SecurityRuleResponse)(nil), "pds.SecurityRuleResponse")
	proto.RegisterType((*SecurityRuleGetRequest)(nil), "pds.SecurityRuleGetRequest")
	proto.RegisterType((*SecurityRuleGetResponse)(nil), "pds.SecurityRuleGetResponse")
	proto.RegisterType((*SecurityRuleDeleteRequest)(nil), "pds.SecurityRuleDeleteRequest")
	proto.RegisterType((*SecurityRuleDeleteResponse)(nil), "pds.SecurityRuleDeleteResponse")
	proto.RegisterType((*SecurityProfileSpec)(nil), "pds.SecurityProfileSpec")
	proto.RegisterType((*SecurityProfileStatus)(nil), "pds.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileStats)(nil), "pds.SecurityProfileStats")
	proto.RegisterType((*SecurityProfile)(nil), "pds.SecurityProfile")
	proto.RegisterType((*SecurityProfileRequest)(nil), "pds.SecurityProfileRequest")
	proto.RegisterType((*SecurityProfileResponse)(nil), "pds.SecurityProfileResponse")
	proto.RegisterType((*SecurityProfileGetRequest)(nil), "pds.SecurityProfileGetRequest")
	proto.RegisterType((*SecurityProfileGetResponse)(nil), "pds.SecurityProfileGetResponse")
	proto.RegisterType((*SecurityProfileDeleteRequest)(nil), "pds.SecurityProfileDeleteRequest")
	proto.RegisterType((*SecurityProfileDeleteResponse)(nil), "pds.SecurityProfileDeleteResponse")
}

func init() { proto.RegisterFile("policy.proto", fileDescriptor_ac3b897852294d6a) }

var fileDescriptor_ac3b897852294d6a = []byte{
	// 2291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0x4b, 0x73, 0x13, 0xcb,
	0x15, 0xb6, 0xe4, 0xf7, 0x91, 0x2d, 0x89, 0x06, 0x8c, 0x2d, 0x83, 0x65, 0x26, 0xf7, 0x12, 0x5f,
	0x62, 0x1b, 0x59, 0xc6, 0xba, 0x40, 0x8a, 0x02, 0xbd, 0x6c, 0xab, 0xa2, 0x17, 0xad, 0x71, 0x28,
	0x92, 0xba, 0x71, 0x06, 0xab, 0x11, 0x4a, 0xa4, 0x19, 0xdd, 0x99, 0x11, 0xe0, 0xe4, 0x56, 0x5e,
	0x9b, 0x64, 0x95, 0xfc, 0x82, 0xfc, 0x87, 0xe4, 0x1f, 0x64, 0x99, 0x45, 0x16, 0x77, 0x93, 0x65,
	0x54, 0x09, 0x4b, 0x96, 0xfa, 0x05, 0xa9, 0xe9, 0xe9, 0x99, 0xe9, 0x79, 0x48, 0x06, 0x41, 0xd5,
	0xdd, 0xb8, 0x34, 0x7d, 0xce, 0xf7, 0xf5, 0xe9, 0x73, 0x4e, 0x9f, 0x3e, 0xdd, 0x65, 0x58, 0xea,
	0x29, 0x9d, 0xf6, 0xd9, 0xf9, 0x6e, 0x4f, 0x55, 0x74, 0x05, 0x4d, 0xf7, 0x9a, 0x5a, 0x02, 0x5a,
	0x4a, 0x4b, 0x31, 0x07, 0x12, 0xb1, 0x2e, 0xd1, 0xa5, 0x3b, 0xc6, 0x1f, 0x36, 0x10, 0xd1, 0xcf,
	0x7b, 0x44, 0x33, 0x3f, 0x84, 0x0c, 0xc0, 0xa1, 0x58, 0xaf, 0xf5, 0xf4, 0xb6, 0x22, 0x6b, 0x68,
	0x0b, 0x62, 0xd9, 0x4e, 0x47, 0x79, 0x5d, 0xaa, 0x57, 0xda, 0x5a, 0x57, 0xd2, 0xcf, 0x5e, 0xae,
	0x86, 0x36, 0x43, 0x5b, 0x0b, 0xd8, 0x3b, 0x2c, 0xfc, 0x71, 0x1a, 0xa0, 0x50, 0x6d, 0x58, 0xc0,
	0x0c, 0xac, 0x14, 0x54, 0xa5, 0x57, 0xe9, 0x77, 0xf4, 0xf6, 0x93, 0x3e, 0x51, 0xcf, 0x2b, 0x44,
	0xd3, 0xa4, 0x16, 0xd1, 0x18, 0x7e, 0x84, 0x14, 0x3d, 0x86, 0x75, 0x43, 0x52, 0x96, 0xd4, 0x16,
	0x29, 0x28, 0x5d, 0xa9, 0x2d, 0x57, 0xa5, 0x2e, 0xb1, 0xc1, 0x61, 0x0a, 0x1e, 0xa7, 0x82, 0xee,
	0xc2, 0x55, 0x2a, 0x56, 0xe4, 0x56, 0x59, 0x7a, 0x4e, 0x3a, 0x36, 0x76, 0x9a, 0x62, 0x83, 0x85,
	0x16, 0x8a, 0x5a, 0xf4, 0x13, 0x45, 0x76, 0x66, 0x9c, 0x71, 0x50, 0x3e, 0x21, 0x7a, 0x08, 0x31,
	0x4c, 0xb4, 0x9e, 0x22, 0x6b, 0x44, 0x6c, 0x77, 0x89, 0xd2, 0xd7, 0x57, 0x67, 0x37, 0x43, 0x5b,
	0xcb, 0xb9, 0xcb, 0xc3, 0x41, 0x92, 0xfa, 0xf9, 0x41, 0x93, 0xbc, 0x90, 0xfa, 0x1d, 0xfd, 0x61,
	0x26, 0x85, 0xbd, 0xba, 0x48, 0x84, 0x78, 0x45, 0x7a, 0xc3, 0xd8, 0xca, 0x44, 0x6e, 0xe9, 0x2f,
	0x57, 0xe7, 0x28, 0x7e, 0x6b, 0x38, 0x48, 0x7e, 0x46, 0xf1, 0xaa, 0x24, 0xb7, 0xc8, 0x83, 0x83,
	0xbd, 0xf4, 0xce, 0xbd, 0xbd, 0xfb, 0xe9, 0x6d, 0x17, 0xe7, 0xc1, 0x5e, 0x1a, 0xfb, 0x18, 0x84,
	0x6d, 0x58, 0xaa, 0x34, 0x70, 0x3d, 0x6f, 0x85, 0xe2, 0x3a, 0x2c, 0xd6, 0x55, 0xa5, 0xa5, 0x4a,
	0xdd, 0x52, 0x73, 0x35, 0xb4, 0x39, 0xbd, 0xb5, 0x84, 0x9d, 0x01, 0x61, 0x07, 0x96, 0x1b, 0x7d,
	0x79, 0x9c, 0xfa, 0x0c, 0xaf, 0xfe, 0xf7, 0x30, 0xcc, 0x67, 0xcb, 0x47, 0x8d, 0x1e, 0x39, 0x43,
	0x09, 0x98, 0xce, 0x96, 0x8f, 0x68, 0x40, 0xa3, 0xe9, 0x85, 0xdd, 0x5e, 0x53, 0xdb, 0xcd, 0x96,
	0x8f, 0xb0, 0x31, 0x88, 0x36, 0x21, 0x52, 0x6a, 0x76, 0x6c, 0xaf, 0x18, 0x71, 0x5b, 0xc6, 0xfc,
	0x10, 0xda, 0xe3, 0x13, 0x8d, 0x06, 0x27, 0x92, 0x8e, 0x51, 0x12, 0x67, 0xf8, 0x78, 0x0a, 0xf3,
	0xd9, 0xb8, 0xc7, 0xa7, 0x18, 0x8d, 0x8c, 0x05, 0x71, 0x86, 0x0d, 0x08, 0x97, 0x87, 0x5f, 0xba,
	0x9d, 0x41, 0xc3, 0x13, 0x49, 0x5f, 0xa2, 0x20, 0x5e, 0x70, 0x3c, 0x85, 0xdd, 0x5e, 0x7b, 0xe0,
	0xf1, 0x0b, 0x0d, 0x4c, 0x24, 0x8d, 0x28, 0xd2, 0x25, 0x39, 0x9e, 0xc2, 0x6e, 0xd5, 0xdc, 0x32,
	0x44, 0xa4, 0x4e, 0xeb, 0x54, 0x31, 0x3f, 0x85, 0xdf, 0x85, 0xe1, 0x52, 0x83, 0x9c, 0xf5, 0xd5,
	0xb6, 0x7e, 0x8e, 0xfb, 0x1d, 0x92, 0xd5, 0x75, 0x55, 0x43, 0x69, 0x58, 0xa8, 0xab, 0x6d, 0xc5,
	0x18, 0xa4, 0x2e, 0x5c, 0xce, 0xad, 0x0c, 0x07, 0x49, 0xc4, 0x05, 0x3d, 0xb5, 0x93, 0x39, 0x38,
	0xd8, 0xbf, 0x8b, 0x6d, 0x3d, 0x74, 0x0b, 0x66, 0x2b, 0x74, 0x13, 0x86, 0xa9, 0x31, 0xf1, 0x5d,
	0x73, 0xe7, 0x1a, 0xa4, 0x74, 0x1c, 0x9b, 0x62, 0x54, 0x84, 0xb9, 0xec, 0x99, 0x31, 0x39, 0xf5,
	0x6b, 0x34, 0xbd, 0xc6, 0x14, 0x5d, 0x56, 0x50, 0x85, 0x1c, 0x1a, 0x0e, 0x92, 0x51, 0x3a, 0x69,
	0x57, 0x92, 0x9b, 0x92, 0xae, 0xa8, 0xe7, 0x98, 0x81, 0x8d, 0x20, 0x8a, 0x44, 0xed, 0xb6, 0x65,
	0x49, 0x6f, 0xcb, 0x2d, 0xb6, 0x15, 0xf8, 0x21, 0x74, 0xcb, 0xce, 0x06, 0xe6, 0xd9, 0x25, 0x2b,
	0x0d, 0x8c, 0x31, 0x6c, 0x09, 0x85, 0x3f, 0x84, 0x20, 0xce, 0x4f, 0x5e, 0x92, 0x5f, 0x28, 0x68,
	0x1b, 0xc2, 0x34, 0xc5, 0x42, 0x5b, 0x4b, 0xb9, 0xeb, 0xc3, 0x41, 0x72, 0xd5, 0x6d, 0xc6, 0x76,
	0xbb, 0xdb, 0xed, 0xeb, 0xd2, 0xf3, 0x0e, 0xc1, 0xe1, 0x52, 0x13, 0x3d, 0x86, 0x59, 0xea, 0x38,
	0xb6, 0xf6, 0x15, 0x33, 0x10, 0x5e, 0xb7, 0x06, 0xae, 0xc7, 0x04, 0x0a, 0xff, 0x98, 0x01, 0x64,
	0x01, 0xea, 0xb4, 0x44, 0xd2, 0x34, 0xfe, 0x30, 0x33, 0xce, 0x60, 0x46, 0x3c, 0xef, 0x11, 0x6a,
	0x45, 0x34, 0x7d, 0xcd, 0x65, 0x85, 0x49, 0x6a, 0x88, 0x73, 0x99, 0xe1, 0x20, 0x99, 0xa6, 0x44,
	0x36, 0x7c, 0xdb, 0xda, 0xb6, 0x8d, 0x62, 0xfe, 0x04, 0x97, 0xc4, 0x67, 0xa7, 0xf5, 0x5a, 0xb9,
	0x94, 0x7f, 0x76, 0x2a, 0x3e, 0xab, 0x17, 0x4f, 0xc5, 0x62, 0x35, 0x5b, 0x15, 0x31, 0x25, 0x47,
	0x25, 0x80, 0x6c, 0xb3, 0xa9, 0x1e, 0x4a, 0xdd, 0x76, 0xe7, 0x9c, 0xc5, 0x30, 0xc2, 0x62, 0x58,
	0xaa, 0x67, 0x0f, 0x2f, 0xb0, 0x93, 0x03, 0xa3, 0x14, 0x2c, 0x36, 0x74, 0x49, 0x27, 0x1d, 0xa2,
	0xb1, 0x62, 0xc6, 0xb9, 0xc8, 0x81, 0x38, 0x4a, 0x48, 0x81, 0x58, 0xc1, 0xb4, 0xf4, 0xf0, 0x29,
	0xcb, 0xa2, 0xd9, 0x8b, 0xb2, 0xe8, 0xf6, 0x70, 0x90, 0xbc, 0xe5, 0xaa, 0x4d, 0xf6, 0x22, 0xf1,
	0x49, 0xb9, 0x78, 0x9a, 0xcd, 0x8b, 0xa5, 0x5a, 0xf5, 0xb4, 0x5a, 0xab, 0x16, 0xb1, 0x97, 0x1d,
	0x3d, 0x82, 0x59, 0x83, 0xca, 0xd8, 0x62, 0xd3, 0x5b, 0x91, 0xf4, 0x55, 0x5f, 0x64, 0x8d, 0x6c,
	0x09, 0x0e, 0x2c, 0xc5, 0xa1, 0x97, 0x00, 0xc6, 0x8f, 0x43, 0x45, 0xed, 0x4a, 0xfa, 0xea, 0x3c,
	0x35, 0xd6, 0x64, 0x31, 0x23, 0xe2, 0x08, 0x73, 0x7b, 0xc3, 0x41, 0x72, 0x27, 0xd8, 0x50, 0x16,
	0x8d, 0xc3, 0x1a, 0xae, 0x64, 0xc5, 0xd3, 0xc3, 0x72, 0x56, 0x14, 0x8b, 0xd5, 0x62, 0x01, 0x73,
	0xdc, 0xc2, 0x9f, 0x42, 0x70, 0xc5, 0x93, 0x42, 0xba, 0xa4, 0xf7, 0x35, 0xb4, 0x02, 0x73, 0x75,
	0x45, 0xe9, 0xb0, 0x44, 0x5a, 0xc6, 0xec, 0x0b, 0x21, 0x98, 0x39, 0x7e, 0x5d, 0x6a, 0xb2, 0x02,
	0x48, 0x7f, 0xa3, 0x5b, 0x10, 0x35, 0xb1, 0x39, 0x49, 0x23, 0x46, 0xa8, 0x68, 0x84, 0x67, 0xb0,
	0x67, 0xd4, 0xa8, 0xc4, 0xc6, 0xd4, 0x79, 0xa5, 0x2f, 0xeb, 0x34, 0x74, 0xcb, 0xd8, 0x19, 0x10,
	0xfe, 0x12, 0x82, 0xcb, 0x7e, 0x53, 0x34, 0x94, 0x83, 0x38, 0x73, 0xb0, 0xa1, 0x4b, 0xc7, 0xa8,
	0x4d, 0x41, 0x5b, 0x86, 0x4a, 0xb1, 0x4f, 0x1f, 0xdd, 0x35, 0x67, 0x36, 0xc1, 0x61, 0x1a, 0x95,
	0x51, 0x60, 0x47, 0x51, 0xf8, 0x4f, 0x18, 0xa2, 0x6e, 0x8b, 0xd0, 0x0f, 0x61, 0xc1, 0x48, 0xe8,
	0x0a, 0xd1, 0x25, 0x66, 0x44, 0x74, 0x97, 0x76, 0x1e, 0xd6, 0x68, 0x2e, 0xf6, 0xed, 0x20, 0x19,
	0x7a, 0x37, 0x48, 0xce, 0x6f, 0xb7, 0xe5, 0x4e, 0x5b, 0x26, 0xd8, 0x06, 0xa0, 0x47, 0x30, 0x5f,
	0x7b, 0xfe, 0x0b, 0x8a, 0x35, 0xf7, 0xfc, 0xb2, 0x89, 0x65, 0x83, 0xb9, 0x15, 0x06, 0xa5, 0x59,
	0xb1, 0xad, 0x74, 0xdb, 0x3a, 0xe9, 0xf6, 0xf4, 0x73, 0x6c, 0xa1, 0xd0, 0x23, 0x98, 0xa1, 0xa5,
	0xc9, 0x3c, 0x5c, 0x82, 0xf6, 0xaa, 0x21, 0xce, 0x21, 0x83, 0x43, 0xeb, 0x91, 0x33, 0x8e, 0x83,
	0x02, 0xd1, 0x11, 0xcc, 0x99, 0xf1, 0x65, 0x87, 0xcd, 0x5a, 0x10, 0x05, 0x55, 0xc8, 0x5d, 0x79,
	0x37, 0x48, 0xc6, 0x35, 0xfa, 0x9b, 0xa3, 0x61, 0x70, 0x94, 0x87, 0x59, 0xd3, 0x99, 0x66, 0x95,
	0x5c, 0x1d, 0xc1, 0xa3, 0xe5, 0x2e, 0xbf, 0x1b, 0x24, 0x63, 0x06, 0x0d, 0xcf, 0x62, 0x62, 0x85,
	0x5f, 0xc1, 0x55, 0x37, 0x04, 0x93, 0xaf, 0xfb, 0x44, 0xd3, 0xd1, 0x2e, 0x2c, 0xe6, 0x8c, 0xba,
	0x9f, 0xd7, 0xdf, 0xe8, 0xcc, 0xcd, 0xd6, 0xd1, 0x60, 0x8f, 0x63, 0x47, 0x05, 0xed, 0xc1, 0x3c,
	0x83, 0xb2, 0xe0, 0x8e, 0x72, 0x0d, 0xb6, 0xf4, 0x84, 0xdf, 0xc2, 0x8a, 0x77, 0x6e, 0xb3, 0x97,
	0x31, 0x26, 0xcf, 0xf6, 0xda, 0xcc, 0x4d, 0x66, 0x2f, 0x60, 0x4d, 0x6e, 0x8f, 0x63, 0x47, 0x05,
	0x1d, 0xc0, 0x82, 0x85, 0x65, 0xb3, 0x8f, 0xf6, 0x2a, 0xb6, 0x55, 0x85, 0xdb, 0xb0, 0xea, 0xd6,
	0x38, 0x22, 0xba, 0xb5, 0xfe, 0x28, 0xab, 0xe0, 0x46, 0x6b, 0x13, 0x2e, 0x35, 0x85, 0x6f, 0x60,
	0x2d, 0x40, 0x77, 0x42, 0x7b, 0xef, 0xf8, 0xec, 0xbd, 0x1c, 0x60, 0x2f, 0x67, 0xe9, 0x57, 0xb0,
	0xee, 0x96, 0x15, 0x48, 0x87, 0xe8, 0x64, 0xd2, 0x60, 0x99, 0x8b, 0x0b, 0xdb, 0x8b, 0xab, 0xc2,
	0xf5, 0x60, 0xfa, 0xe0, 0xf5, 0x4d, 0x5f, 0xb0, 0x3e, 0xe1, 0xcf, 0xbe, 0x92, 0x46, 0x4b, 0x6e,
	0xf3, 0x03, 0xcf, 0xc5, 0x63, 0xe7, 0x80, 0x37, 0x59, 0x58, 0xd1, 0xbb, 0x08, 0xeb, 0x43, 0x09,
	0xff, 0xf2, 0xf4, 0x0a, 0x13, 0x1c, 0xd2, 0x9f, 0xcc, 0x18, 0xa7, 0xeb, 0x98, 0x9e, 0xb4, 0xeb,
	0xb8, 0xe2, 0x34, 0x1d, 0x56, 0xa9, 0xec, 0x6b, 0xc2, 0xbe, 0xbb, 0x25, 0x34, 0xcb, 0xee, 0x06,
	0x40, 0xb5, 0xdf, 0x35, 0xbe, 0x8f, 0xdb, 0x66, 0x6e, 0xcc, 0x60, 0x6e, 0x44, 0xf8, 0x77, 0x18,
	0x96, 0x78, 0xd4, 0x77, 0x5c, 0x5e, 0x1f, 0xba, 0xca, 0xab, 0xff, 0xd8, 0xbe, 0xa0, 0xb8, 0x16,
	0x3d, 0xc5, 0xf5, 0x5a, 0xe0, 0x09, 0x73, 0x61, 0x69, 0xcd, 0xba, 0x4b, 0xeb, 0x88, 0x73, 0x6a,
	0x6c, 0x61, 0x7d, 0xe5, 0x9c, 0xa4, 0x06, 0x60, 0xd2, 0x9d, 0x7a, 0x87, 0x2f, 0xab, 0xa3, 0x5d,
	0xe2, 0x14, 0xd5, 0x5f, 0x3b, 0x3b, 0xcf, 0x9c, 0x77, 0xc2, 0x12, 0xb5, 0xef, 0x2a, 0x51, 0xe3,
	0x7c, 0xc9, 0x95, 0xa9, 0xa7, 0x4e, 0x45, 0x37, 0xe4, 0x5c, 0x39, 0x7d, 0x68, 0x97, 0xd3, 0xe0,
	0xda, 0x6c, 0xd6, 0x87, 0xc0, 0x9c, 0x37, 0x0a, 0xd4, 0x1b, 0xb8, 0xe6, 0x23, 0x9e, 0x70, 0x61,
	0x3b, 0xbe, 0xda, 0x7b, 0xc9, 0xb7, 0x30, 0x6e, 0x49, 0xaf, 0x9c, 0xba, 0x6f, 0x48, 0x3e, 0xae,
	0xee, 0x7e, 0x61, 0xd7, 0xdd, 0x71, 0x5e, 0xa0, 0x2b, 0x2e, 0x43, 0x22, 0x68, 0xde, 0x09, 0x0b,
	0xf2, 0x5f, 0x17, 0xb9, 0xc6, 0x4e, 0x55, 0x5e, 0xb4, 0x59, 0x09, 0x14, 0xb8, 0x12, 0x38, 0xc2,
	0xf7, 0xe8, 0x1e, 0x44, 0xf2, 0x8a, 0x2c, 0x8b, 0xaa, 0x74, 0xf6, 0xcb, 0xa2, 0x6c, 0x3e, 0x97,
	0x70, 0xf7, 0x4a, 0xab, 0xe7, 0x7d, 0x21, 0x75, 0x34, 0x82, 0x79, 0x55, 0xe3, 0xae, 0x67, 0x6f,
	0x96, 0xa2, 0xcc, 0x1e, 0x4b, 0xf8, 0xa1, 0xa0, 0x7b, 0xc1, 0xcc, 0x27, 0xba, 0x17, 0x14, 0x8a,
	0xd5, 0x67, 0xfe, 0x7b, 0x41, 0x1d, 0xa2, 0x62, 0xbe, 0xce, 0x3f, 0x23, 0xcc, 0x06, 0x3e, 0x8e,
	0xec, 0xed, 0xdc, 0xcb, 0xdc, 0x4d, 0xa5, 0xb6, 0x37, 0x3d, 0x0f, 0x2e, 0x29, 0xec, 0xc1, 0x1b,
	0x8c, 0x27, 0x05, 0x17, 0xe3, 0xdc, 0x07, 0x30, 0xee, 0xa5, 0x53, 0xd8, 0x83, 0x47, 0x4f, 0x20,
	0x56, 0xca, 0x57, 0x5c, 0x94, 0xf3, 0x94, 0xf2, 0xfb, 0xc3, 0x41, 0xf2, 0x7b, 0x17, 0x53, 0x1e,
	0x60, 0x2f, 0x1e, 0x35, 0x20, 0x5e, 0xd3, 0x5f, 0x12, 0x95, 0xe7, 0x5c, 0xf8, 0x00, 0xce, 0xfb,
	0x29, 0xec, 0x23, 0x40, 0x3f, 0x86, 0xcb, 0x62, 0xbe, 0x9e, 0x97, 0xdf, 0xc8, 0x0d, 0xa2, 0xf7,
	0x7b, 0x16, 0xef, 0x22, 0xe5, 0xfd, 0x6c, 0x38, 0x48, 0x6e, 0xba, 0x78, 0x33, 0x3e, 0x43, 0x53,
	0x38, 0x88, 0x00, 0xfd, 0x94, 0xf2, 0x1e, 0x4b, 0x9d, 0x17, 0xf9, 0x8e, 0xe2, 0xbc, 0x82, 0x01,
	0xe5, 0xfd, 0x62, 0x38, 0x48, 0x7e, 0xee, 0xe2, 0xdd, 0xfb, 0x32, 0x7d, 0x2f, 0xd0, 0xaf, 0x41,
	0x2c, 0xa8, 0x06, 0x31, 0x63, 0x4e, 0x9e, 0x38, 0x42, 0x89, 0x3f, 0x1f, 0x0e, 0x92, 0x37, 0x5d,
	0xc4, 0xfb, 0x81, 0xae, 0xf5, 0xa0, 0x51, 0x85, 0x66, 0x54, 0x41, 0x55, 0x6c, 0x07, 0x2c, 0xbd,
	0x37, 0xdf, 0x7d, 0x33, 0x9d, 0x38, 0x30, 0x4b, 0x27, 0x9e, 0x6e, 0x79, 0x44, 0x3a, 0x05, 0xae,
	0x3b, 0x63, 0xa6, 0x13, 0xcf, 0x58, 0x33, 0xd3, 0x89, 0xa7, 0x8c, 0xbe, 0xb7, 0x85, 0xfb, 0x29,
	0xec, 0x45, 0xa3, 0x27, 0x2c, 0x99, 0x78, 0xc6, 0xd8, 0x7b, 0x33, 0x66, 0xac, 0x54, 0xe2, 0xe0,
	0xc2, 0x35, 0xee, 0x1a, 0xc2, 0xca, 0x93, 0x59, 0xb8, 0x56, 0xb8, 0x46, 0xd2, 0x11, 0x68, 0xc2,
	0xff, 0xc2, 0x10, 0xf3, 0x08, 0xbe, 0xe3, 0xce, 0xe5, 0xb1, 0xab, 0x73, 0xf1, 0xdc, 0xc6, 0x9c,
	0x92, 0x3b, 0xa6, 0x79, 0x39, 0xf6, 0x34, 0x2f, 0x89, 0x40, 0x8e, 0xf7, 0xe9, 0x5f, 0x0a, 0xee,
	0xfe, 0x65, 0x6d, 0x14, 0xd1, 0xf8, 0x16, 0xe6, 0x1b, 0xee, 0x7e, 0x66, 0x62, 0x26, 0x3d, 0xf7,
	0xd2, 0xde, 0xcb, 0xe1, 0x48, 0xf7, 0x38, 0x8d, 0xcc, 0xef, 0x43, 0xce, 0x99, 0x6f, 0x4f, 0x3f,
	0xe1, 0x99, 0x9f, 0xf1, 0x9d, 0xf9, 0x63, 0x7c, 0xcb, 0x1d, 0xfe, 0x3f, 0xe0, 0x2e, 0x7d, 0xa6,
	0xca, 0x98, 0x1b, 0xe2, 0x6f, 0x9c, 0x13, 0x9b, 0x57, 0x9e, 0xd0, 0xe4, 0x94, 0xcf, 0xe4, 0x2b,
	0x41, 0x26, 0x73, 0xc6, 0xfe, 0x8c, 0xbb, 0xc4, 0x99, 0xc2, 0x4f, 0x7b, 0x49, 0xac, 0xc1, 0x8d,
	0x11, 0xfc, 0x93, 0x35, 0x25, 0xb7, 0x5f, 0xd2, 0xb7, 0x7e, 0xb4, 0x04, 0x0b, 0xd9, 0xf2, 0x11,
	0x7d, 0xc7, 0x8b, 0x4f, 0x59, 0x5f, 0xe2, 0xa1, 0x58, 0x8f, 0x87, 0x50, 0x84, 0xbe, 0x05, 0x9f,
	0x1a, 0x1f, 0x61, 0xeb, 0xa3, 0x50, 0x6d, 0xc4, 0xa7, 0x51, 0x14, 0xc0, 0xf8, 0x68, 0x9c, 0x54,
	0x71, 0x3d, 0x1f, 0x9f, 0x41, 0xcb, 0xb0, 0x68, 0x7c, 0xd3, 0xf7, 0xf6, 0xf8, 0xac, 0x45, 0x83,
	0xc5, 0x46, 0x3d, 0x3e, 0x77, 0xfb, 0xb5, 0xf7, 0x91, 0x96, 0xbe, 0x88, 0xde, 0x80, 0xb5, 0xc0,
	0x67, 0x53, 0x66, 0xc9, 0x4d, 0xb8, 0x11, 0x28, 0x3e, 0xa9, 0x16, 0x8a, 0xb8, 0x9c, 0x7d, 0x16,
	0x0f, 0xa1, 0x24, 0xac, 0x8f, 0x79, 0x78, 0x8d, 0x87, 0x6f, 0x7f, 0x0d, 0x71, 0xef, 0x73, 0x21,
	0x5a, 0x87, 0x6b, 0x4c, 0x97, 0xb6, 0x2b, 0xec, 0x6d, 0x90, 0x4d, 0xba, 0x09, 0xd7, 0x03, 0x84,
	0xf6, 0xc3, 0x61, 0x3c, 0x84, 0x36, 0x20, 0x11, 0xa0, 0x91, 0xaf, 0x55, 0xea, 0xd9, 0xbc, 0x18,
	0x0f, 0xa7, 0xff, 0xb6, 0xe8, 0x5c, 0x03, 0xd9, 0xbb, 0xc7, 0xab, 0x33, 0xf4, 0xc4, 0x7b, 0x21,
	0xcf, 0xab, 0x44, 0xd2, 0x09, 0x4a, 0x04, 0x75, 0xa1, 0x66, 0xc2, 0x24, 0xd6, 0x03, 0x65, 0x2c,
	0xdb, 0xa6, 0xfc, 0x94, 0x27, 0xbd, 0xe6, 0x47, 0x52, 0x8a, 0x5e, 0xd3, 0x8f, 0x88, 0x8e, 0x6e,
	0x04, 0x60, 0x9c, 0x6d, 0x98, 0xd8, 0x18, 0x25, 0xb6, 0x59, 0x4f, 0xb9, 0x8d, 0x69, 0x89, 0x1b,
	0xba, 0x4a, 0xa4, 0x6e, 0x5b, 0x6e, 0x7d, 0x34, 0x7d, 0x2a, 0x84, 0xbe, 0xf2, 0x7a, 0xc2, 0xdc,
	0x18, 0x68, 0x33, 0x00, 0xeb, 0xda, 0x93, 0x89, 0x9b, 0x63, 0x34, 0x6c, 0xfb, 0x0f, 0xbc, 0xcf,
	0x54, 0xe6, 0x2b, 0x29, 0xd1, 0x88, 0x8e, 0x16, 0xad, 0x17, 0xfc, 0x66, 0x62, 0x89, 0xfd, 0x2c,
	0x1a, 0x35, 0x5c, 0x98, 0x42, 0x3f, 0x72, 0x3f, 0x12, 0xb0, 0x80, 0xaf, 0xfa, 0x2f, 0x3b, 0xcc,
	0x96, 0xb5, 0x00, 0x89, 0x6d, 0x83, 0x87, 0x8c, 0x85, 0x7a, 0x42, 0xb2, 0xaa, 0x73, 0x76, 0xb3,
	0xdb, 0x1c, 0x5a, 0xf7, 0xe9, 0x73, 0x31, 0xb8, 0x1e, 0x2c, 0xb4, 0xf9, 0x9e, 0xba, 0x8d, 0x63,
	0xde, 0xdf, 0xf0, 0xa1, 0xdc, 0xbe, 0x4f, 0x8e, 0x94, 0x73, 0xf9, 0xe8, 0x6d, 0x4b, 0x98, 0x17,
	0xd7, 0x03, 0x6b, 0x71, 0xa0, 0xb9, 0x9e, 0xb3, 0x2b, 0x90, 0x95, 0xb9, 0xf3, 0xa3, 0x58, 0x39,
	0x27, 0x38, 0xc7, 0x8f, 0xc7, 0x09, 0xbe, 0x43, 0xcc, 0xe3, 0x04, 0xff, 0xb9, 0x25, 0x4c, 0xa1,
	0x9f, 0xfb, 0xcc, 0x65, 0x0e, 0xbe, 0x19, 0x84, 0x75, 0xfb, 0x58, 0x18, 0xa7, 0x62, 0xcd, 0x90,
	0x5b, 0xfa, 0xe7, 0xdb, 0x8d, 0xd0, 0xb7, 0x6f, 0x37, 0x42, 0xff, 0x7d, 0xbb, 0x11, 0x7a, 0x3e,
	0x47, 0xff, 0x69, 0x60, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x71, 0x14, 0xb0, 0x8f, 0x73,
	0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SecurityPolicySvcClient is the client API for SecurityPolicySvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SecurityPolicySvcClient interface {
	// security policy APIs
	SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error)
	SecurityPolicyGetStreaming(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (SecurityPolicySvc_SecurityPolicyGetStreamingClient, error)
	SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error)
	// given a uuid of a security policy, clear its stats
	// or else clear stats of all security policies
	SecurityPolicyStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	// security policy rule APIs
	SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error)
	SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error)
	SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error)
}

type securityPolicySvcClient struct {
	cc *grpc.ClientConn
}

func NewSecurityPolicySvcClient(cc *grpc.ClientConn) SecurityPolicySvcClient {
	return &securityPolicySvcClient{cc}
}

func (c *securityPolicySvcClient) SecurityPolicyCreate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyUpdate(ctx context.Context, in *SecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyResponse, error) {
	out := new(SecurityPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyGet(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (*SecurityPolicyGetResponse, error) {
	out := new(SecurityPolicyGetResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyGetStreaming(ctx context.Context, in *SecurityPolicyGetRequest, opts ...grpc.CallOption) (SecurityPolicySvc_SecurityPolicyGetStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SecurityPolicySvc_serviceDesc.Streams[0], "/pds.SecurityPolicySvc/SecurityPolicyGetStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityPolicySvcSecurityPolicyGetStreamingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityPolicySvc_SecurityPolicyGetStreamingClient interface {
	Recv() (*SecurityPolicyGetResponse, error)
	grpc.ClientStream
}

type securityPolicySvcSecurityPolicyGetStreamingClient struct {
	grpc.ClientStream
}

func (x *securityPolicySvcSecurityPolicyGetStreamingClient) Recv() (*SecurityPolicyGetResponse, error) {
	m := new(SecurityPolicyGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityPolicySvcClient) SecurityPolicyDelete(ctx context.Context, in *SecurityPolicyDeleteRequest, opts ...grpc.CallOption) (*SecurityPolicyDeleteResponse, error) {
	out := new(SecurityPolicyDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityPolicyStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityPolicyStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequest, opts ...grpc.CallOption) (*SecurityRuleResponse, error) {
	out := new(SecurityRuleResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleGet(ctx context.Context, in *SecurityRuleGetRequest, opts ...grpc.CallOption) (*SecurityRuleGetResponse, error) {
	out := new(SecurityRuleGetResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequest, opts ...grpc.CallOption) (*SecurityRuleDeleteResponse, error) {
	out := new(SecurityRuleDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityRuleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileCreate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileUpdate(ctx context.Context, in *SecurityProfileRequest, opts ...grpc.CallOption) (*SecurityProfileResponse, error) {
	out := new(SecurityProfileResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileGet(ctx context.Context, in *SecurityProfileGetRequest, opts ...grpc.CallOption) (*SecurityProfileGetResponse, error) {
	out := new(SecurityProfileGetResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPolicySvcClient) SecurityProfileDelete(ctx context.Context, in *SecurityProfileDeleteRequest, opts ...grpc.CallOption) (*SecurityProfileDeleteResponse, error) {
	out := new(SecurityProfileDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.SecurityPolicySvc/SecurityProfileDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SecurityPolicySvcServer is the server API for SecurityPolicySvc service.
type SecurityPolicySvcServer interface {
	// security policy APIs
	SecurityPolicyCreate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyUpdate(context.Context, *SecurityPolicyRequest) (*SecurityPolicyResponse, error)
	SecurityPolicyGet(context.Context, *SecurityPolicyGetRequest) (*SecurityPolicyGetResponse, error)
	SecurityPolicyGetStreaming(*SecurityPolicyGetRequest, SecurityPolicySvc_SecurityPolicyGetStreamingServer) error
	SecurityPolicyDelete(context.Context, *SecurityPolicyDeleteRequest) (*SecurityPolicyDeleteResponse, error)
	// given a uuid of a security policy, clear its stats
	// or else clear stats of all security policies
	SecurityPolicyStatsReset(context.Context, *Id) (*Empty, error)
	// security policy rule APIs
	SecurityRuleCreate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleUpdate(context.Context, *SecurityRuleRequest) (*SecurityRuleResponse, error)
	SecurityRuleGet(context.Context, *SecurityRuleGetRequest) (*SecurityRuleGetResponse, error)
	SecurityRuleDelete(context.Context, *SecurityRuleDeleteRequest) (*SecurityRuleDeleteResponse, error)
	// security profile APIs
	SecurityProfileCreate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileUpdate(context.Context, *SecurityProfileRequest) (*SecurityProfileResponse, error)
	SecurityProfileGet(context.Context, *SecurityProfileGetRequest) (*SecurityProfileGetResponse, error)
	SecurityProfileDelete(context.Context, *SecurityProfileDeleteRequest) (*SecurityProfileDeleteResponse, error)
}

// UnimplementedSecurityPolicySvcServer can be embedded to have forward compatible implementations.
type UnimplementedSecurityPolicySvcServer struct {
}

func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyCreate(ctx context.Context, req *SecurityPolicyRequest) (*SecurityPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityPolicyCreate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyUpdate(ctx context.Context, req *SecurityPolicyRequest) (*SecurityPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityPolicyUpdate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyGet(ctx context.Context, req *SecurityPolicyGetRequest) (*SecurityPolicyGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityPolicyGet not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyGetStreaming(req *SecurityPolicyGetRequest, srv SecurityPolicySvc_SecurityPolicyGetStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method SecurityPolicyGetStreaming not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyDelete(ctx context.Context, req *SecurityPolicyDeleteRequest) (*SecurityPolicyDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityPolicyDelete not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityPolicyStatsReset(ctx context.Context, req *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityPolicyStatsReset not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityRuleCreate(ctx context.Context, req *SecurityRuleRequest) (*SecurityRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityRuleCreate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityRuleUpdate(ctx context.Context, req *SecurityRuleRequest) (*SecurityRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityRuleUpdate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityRuleGet(ctx context.Context, req *SecurityRuleGetRequest) (*SecurityRuleGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityRuleGet not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityRuleDelete(ctx context.Context, req *SecurityRuleDeleteRequest) (*SecurityRuleDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityRuleDelete not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityProfileCreate(ctx context.Context, req *SecurityProfileRequest) (*SecurityProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityProfileCreate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityProfileUpdate(ctx context.Context, req *SecurityProfileRequest) (*SecurityProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityProfileUpdate not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityProfileGet(ctx context.Context, req *SecurityProfileGetRequest) (*SecurityProfileGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityProfileGet not implemented")
}
func (*UnimplementedSecurityPolicySvcServer) SecurityProfileDelete(ctx context.Context, req *SecurityProfileDeleteRequest) (*SecurityProfileDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityProfileDelete not implemented")
}

func RegisterSecurityPolicySvcServer(s *grpc.Server, srv SecurityPolicySvcServer) {
	s.RegisterService(&_SecurityPolicySvc_serviceDesc, srv)
}

func _SecurityPolicySvc_SecurityPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyCreate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyUpdate(ctx, req.(*SecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyGet(ctx, req.(*SecurityPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyGetStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SecurityPolicyGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityPolicySvcServer).SecurityPolicyGetStreaming(m, &securityPolicySvcSecurityPolicyGetStreamingServer{stream})
}

type SecurityPolicySvc_SecurityPolicyGetStreamingServer interface {
	Send(*SecurityPolicyGetResponse) error
	grpc.ServerStream
}

type securityPolicySvcSecurityPolicyGetStreamingServer struct {
	grpc.ServerStream
}

func (x *securityPolicySvcSecurityPolicyGetStreamingServer) Send(m *SecurityPolicyGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityPolicySvc_SecurityPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyDelete(ctx, req.(*SecurityPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityPolicyStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityPolicyStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityPolicyStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityPolicyStatsReset(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleCreate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleUpdate(ctx, req.(*SecurityRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleGet(ctx, req.(*SecurityRuleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityRuleDelete(ctx, req.(*SecurityRuleDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileCreate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileUpdate(ctx, req.(*SecurityProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileGet(ctx, req.(*SecurityProfileGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicySvc_SecurityProfileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfileDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SecurityPolicySvc/SecurityProfileDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPolicySvcServer).SecurityProfileDelete(ctx, req.(*SecurityProfileDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SecurityPolicySvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SecurityPolicySvc",
	HandlerType: (*SecurityPolicySvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityPolicyCreate",
			Handler:    _SecurityPolicySvc_SecurityPolicyCreate_Handler,
		},
		{
			MethodName: "SecurityPolicyUpdate",
			Handler:    _SecurityPolicySvc_SecurityPolicyUpdate_Handler,
		},
		{
			MethodName: "SecurityPolicyGet",
			Handler:    _SecurityPolicySvc_SecurityPolicyGet_Handler,
		},
		{
			MethodName: "SecurityPolicyDelete",
			Handler:    _SecurityPolicySvc_SecurityPolicyDelete_Handler,
		},
		{
			MethodName: "SecurityPolicyStatsReset",
			Handler:    _SecurityPolicySvc_SecurityPolicyStatsReset_Handler,
		},
		{
			MethodName: "SecurityRuleCreate",
			Handler:    _SecurityPolicySvc_SecurityRuleCreate_Handler,
		},
		{
			MethodName: "SecurityRuleUpdate",
			Handler:    _SecurityPolicySvc_SecurityRuleUpdate_Handler,
		},
		{
			MethodName: "SecurityRuleGet",
			Handler:    _SecurityPolicySvc_SecurityRuleGet_Handler,
		},
		{
			MethodName: "SecurityRuleDelete",
			Handler:    _SecurityPolicySvc_SecurityRuleDelete_Handler,
		},
		{
			MethodName: "SecurityProfileCreate",
			Handler:    _SecurityPolicySvc_SecurityProfileCreate_Handler,
		},
		{
			MethodName: "SecurityProfileUpdate",
			Handler:    _SecurityPolicySvc_SecurityProfileUpdate_Handler,
		},
		{
			MethodName: "SecurityProfileGet",
			Handler:    _SecurityPolicySvc_SecurityProfileGet_Handler,
		},
		{
			MethodName: "SecurityProfileDelete",
			Handler:    _SecurityPolicySvc_SecurityProfileDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SecurityPolicyGetStreaming",
			Handler:       _SecurityPolicySvc_SecurityPolicyGetStreaming_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "policy.proto",
}

func (m *FTPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FTPOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowIPMismatch {
		i--
		if m.AllowIPMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxMessageLength != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.MaxMessageLength))
		i--
		dAtA[i] = 0x30
	}
	if m.ResponseTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ResponseTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.DropMultiZoneMessages {
		i--
		if m.DropMultiZoneMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DropLongLabelMessages {
		i--
		if m.DropLongLabelMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DropLargeDomainNameMessages {
		i--
		if m.DropLargeDomainNameMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.DropMultiQueryMessages {
		i--
		if m.DropMultiQueryMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MSRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MSRPCOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProgramId) > 0 {
		for iNdEx := len(m.ProgramId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProgramId[iNdEx])
			copy(dAtA[i:], m.ProgramId[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.ProgramId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SunRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SunRPCOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProgramId) > 0 {
		dAtA2 := make([]byte, len(m.ProgramId)*10)
		var j1 int
		for _, num := range m.ProgramId {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPolicy(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ALGSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ALGSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ALGSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AlgOptions != nil {
		{
			size := m.AlgOptions.Size()
			i -= size
			if _, err := m.AlgOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.ALG != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ALG))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ALGSpec_FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ALGSpec_FTPOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FTPOptions != nil {
		{
			size, err := m.FTPOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ALGSpec_DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ALGSpec_DNSOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DNSOptions != nil {
		{
			size, err := m.DNSOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ALGSpec_MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ALGSpec_MSRPCOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MSRPCOptions != nil {
		{
			size, err := m.MSRPCOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ALGSpec_SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ALGSpec_SunRPCOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SunRPCOptions != nil {
		{
			size, err := m.SunRPCOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SecurityRuleAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ALGSpec != nil {
		{
			size, err := m.ALGSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Terminating {
		i--
		if m.Terminating {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Action != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Priority != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuleFormat != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.RuleFormat))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DefaultFWAction != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
		i--
		dAtA[i] = 0x28
	}
	if m.Stateless {
		i--
		if m.Stateless {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AddrFamily != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.AddrFamily))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuleCount != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.RuleCount))
		i--
		dAtA[i] = 0x20
	}
	if m.PolicyBaseAddr != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.PolicyBaseAddr))
		i--
		dAtA[i] = 0x18
	}
	if m.HwId != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuleStats) > 0 {
		for iNdEx := len(m.RuleStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuleStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultRuleStats != nil {
		{
			size, err := m.DefaultRuleStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA19 := make([]byte, len(m.ApiStatus)*10)
		var j18 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintPolicy(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityPolicyRuleId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityPolicyRuleId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityPolicyRuleId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SecurityPolicyId) > 0 {
		i -= len(m.SecurityPolicyId)
		copy(dAtA[i:], m.SecurityPolicyId)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SecurityPolicyId) > 0 {
		i -= len(m.SecurityPolicyId)
		copy(dAtA[i:], m.SecurityPolicyId)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.SecurityPolicyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumRuleHit != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.NumRuleHit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityRuleDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA31 := make([]byte, len(m.ApiStatus)*10)
		var j30 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintPolicy(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OtherDropTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherDropTimeout))
		i--
		dAtA[i] = 0x78
	}
	if m.ICMPDropTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPDropTimeout))
		i--
		dAtA[i] = 0x70
	}
	if m.UDPDropTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPDropTimeout))
		i--
		dAtA[i] = 0x68
	}
	if m.TCPDropTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPDropTimeout))
		i--
		dAtA[i] = 0x60
	}
	if m.TCPCloseTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCloseTimeout))
		i--
		dAtA[i] = 0x58
	}
	if m.TCPHalfCloseTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPHalfCloseTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.TCPCnxnSetupTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPCnxnSetupTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.OtherIdleTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.OtherIdleTimeout))
		i--
		dAtA[i] = 0x40
	}
	if m.ICMPIdleTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ICMPIdleTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.UDPIdleTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.UDPIdleTimeout))
		i--
		dAtA[i] = 0x30
	}
	if m.TCPIdleTimeout != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.TCPIdleTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.DefaultFWAction != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.DefaultFWAction))
		i--
		dAtA[i] = 0x20
	}
	if m.RuleStatsEn {
		i--
		if m.RuleStatsEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ConnTrackEn {
		i--
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicy(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicy(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityProfileDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityProfileDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA40 := make([]byte, len(m.ApiStatus)*10)
		var j39 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintPolicy(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovPolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FTPOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowIPMismatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DNSOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropMultiQueryMessages {
		n += 2
	}
	if m.DropLargeDomainNameMessages {
		n += 2
	}
	if m.DropLongLabelMessages {
		n += 2
	}
	if m.DropMultiZoneMessages {
		n += 2
	}
	if m.ResponseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ResponseTimeout))
	}
	if m.MaxMessageLength != 0 {
		n += 1 + sovPolicy(uint64(m.MaxMessageLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MSRPCOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		for _, b := range m.ProgramId {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SunRPCOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProgramId) > 0 {
		l = 0
		for _, e := range m.ProgramId {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ALGSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ALG != 0 {
		n += 1 + sovPolicy(uint64(m.ALG))
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.IdleTimeout))
	}
	if m.AlgOptions != nil {
		n += m.AlgOptions.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ALGSpec_FTPOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FTPOptions != nil {
		l = m.FTPOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_DNSOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DNSOptions != nil {
		l = m.DNSOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_MSRPCOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MSRPCOptions != nil {
		l = m.MSRPCOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *ALGSpec_SunRPCOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SunRPCOptions != nil {
		l = m.SunRPCOptions.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	return n
}
func (m *SecurityRuleAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovPolicy(uint64(m.Priority))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPolicy(uint64(m.Action))
	}
	if m.Terminating {
		n += 2
	}
	if m.ALGSpec != nil {
		l = m.ALGSpec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPolicy(uint64(m.Type))
	}
	if m.AddrFamily != 0 {
		n += 1 + sovPolicy(uint64(m.AddrFamily))
	}
	if m.Stateless {
		n += 2
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.RuleFormat != 0 {
		n += 1 + sovPolicy(uint64(m.RuleFormat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovPolicy(uint64(m.PoolId))
	}
	if m.HwId != 0 {
		n += 1 + sovPolicy(uint64(m.HwId))
	}
	if m.PolicyBaseAddr != 0 {
		n += 1 + sovPolicy(uint64(m.PolicyBaseAddr))
	}
	if m.RuleCount != 0 {
		n += 1 + sovPolicy(uint64(m.RuleCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRuleStats != nil {
		l = m.DefaultRuleStats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.RuleStats) > 0 {
		for _, e := range m.RuleStats {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityPolicyRuleId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	l = len(m.SecurityPolicyId)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumRuleHit != 0 {
		n += 1 + sovPolicy(uint64(m.NumRuleHit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityRuleDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ConnTrackEn {
		n += 2
	}
	if m.RuleStatsEn {
		n += 2
	}
	if m.DefaultFWAction != 0 {
		n += 1 + sovPolicy(uint64(m.DefaultFWAction))
	}
	if m.TCPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPIdleTimeout))
	}
	if m.UDPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPIdleTimeout))
	}
	if m.ICMPIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPIdleTimeout))
	}
	if m.OtherIdleTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherIdleTimeout))
	}
	if m.TCPCnxnSetupTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCnxnSetupTimeout))
	}
	if m.TCPHalfCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPHalfCloseTimeout))
	}
	if m.TCPCloseTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPCloseTimeout))
	}
	if m.TCPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.TCPDropTimeout))
	}
	if m.UDPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.UDPDropTimeout))
	}
	if m.ICMPDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.ICMPDropTimeout))
	}
	if m.OtherDropTimeout != 0 {
		n += 1 + sovPolicy(uint64(m.OtherDropTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicy(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityProfileDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FTPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIPMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIPMismatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQueryMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQueryMessages = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainNameMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainNameMessages = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLongLabelMessages = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiZoneMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiZoneMessages = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimeout", wireType)
			}
			m.ResponseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMessageLength", wireType)
			}
			m.MaxMessageLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMessageLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = append(m.ProgramId, make([]byte, postIndex-iNdEx))
			copy(m.ProgramId[len(m.ProgramId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SunRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SunRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SunRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProgramId = append(m.ProgramId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProgramId) == 0 {
					m.ProgramId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProgramId = append(m.ProgramId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ALGSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ALGSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ALGSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALG", wireType)
			}
			m.ALG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ALG |= ALG(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTPOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FTPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_FTPOptions{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DNSOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_DNSOptions{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSRPCOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MSRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_MSRPCOptions{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SunRPCOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SunRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlgOptions = &ALGSpec_SunRPCOptions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= SecurityRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminating = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALGSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ALGSpec == nil {
				m.ALGSpec = &ALGSpec{}
			}
			if err := m.ALGSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SecurityPolicyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrFamily", wireType)
			}
			m.AddrFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrFamily |= IPAF(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stateless", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stateless = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= SecurityRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &SecurityRuleInfo{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleFormat", wireType)
			}
			m.RuleFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleFormat |= PolicyRuleFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyBaseAddr", wireType)
			}
			m.PolicyBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolicyBaseAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleCount", wireType)
			}
			m.RuleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRuleStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultRuleStats == nil {
				m.DefaultRuleStats = &SecurityRuleStats{}
			}
			if err := m.DefaultRuleStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleStats = append(m.RuleStats, &SecurityRuleStats{})
			if err := m.RuleStats[len(m.RuleStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityPolicyRuleId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityPolicyRuleId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicyId = append(m.SecurityPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicyId == nil {
				m.SecurityPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &SecurityRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRuleHit", wireType)
			}
			m.NumRuleHit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRuleHit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &SecurityRuleSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &SecurityRuleStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRule{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &SecurityPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStatsEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuleStatsEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFWAction", wireType)
			}
			m.DefaultFWAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFWAction |= SecurityRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPIdleTimeout", wireType)
			}
			m.TCPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPIdleTimeout", wireType)
			}
			m.UDPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPIdleTimeout", wireType)
			}
			m.ICMPIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherIdleTimeout", wireType)
			}
			m.OtherIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCnxnSetupTimeout", wireType)
			}
			m.TCPCnxnSetupTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCnxnSetupTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPHalfCloseTimeout", wireType)
			}
			m.TCPHalfCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPHalfCloseTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPCloseTimeout", wireType)
			}
			m.TCPCloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPCloseTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPDropTimeout", wireType)
			}
			m.TCPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TCPDropTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPDropTimeout", wireType)
			}
			m.UDPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UDPDropTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPDropTimeout", wireType)
			}
			m.ICMPDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ICMPDropTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDropTimeout", wireType)
			}
			m.OtherDropTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherDropTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityProfileSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityProfileStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SecurityProfileStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityProfileSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfileStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityProfile{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPolicy
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)
