// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: upgrade.proto

package pds

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// upgrade request type
type UpgradeRequestType int32

const (
	// invalid request
	UpgradeRequestType_UPGRADE_REQUEST_NONE UpgradeRequestType = 0
	// start an upgrade
	UpgradeRequestType_UPGRADE_REQUEST_START UpgradeRequestType = 1
)

var UpgradeRequestType_name = map[int32]string{
	0: "UPGRADE_REQUEST_NONE",
	1: "UPGRADE_REQUEST_START",
}

var UpgradeRequestType_value = map[string]int32{
	"UPGRADE_REQUEST_NONE":  0,
	"UPGRADE_REQUEST_START": 1,
}

func (x UpgradeRequestType) String() string {
	return proto.EnumName(UpgradeRequestType_name, int32(x))
}

func (UpgradeRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{0}
}

// upgrade mode
type UpgradeMode int32

const (
	// invalid mode
	UpgradeMode_UPGRADE_MODE_NONE UpgradeMode = 0
	// graceful upgrade
	UpgradeMode_UPGRADE_MODE_GRACEFUL UpgradeMode = 1
	// hitless upgrade
	UpgradeMode_UPGRADE_MODE_HITLESS UpgradeMode = 2
)

var UpgradeMode_name = map[int32]string{
	0: "UPGRADE_MODE_NONE",
	1: "UPGRADE_MODE_GRACEFUL",
	2: "UPGRADE_MODE_HITLESS",
}

var UpgradeMode_value = map[string]int32{
	"UPGRADE_MODE_NONE":     0,
	"UPGRADE_MODE_GRACEFUL": 1,
	"UPGRADE_MODE_HITLESS":  2,
}

func (x UpgradeMode) String() string {
	return proto.EnumName(UpgradeMode_name, int32(x))
}

func (UpgradeMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{1}
}

// upgrade return status
type UpgradeStatus int32

const (
	// upgrade successful
	UpgradeStatus_UPGRADE_STATUS_OK UpgradeStatus = 0
	// upgrade failed
	UpgradeStatus_UPGRADE_STATUS_FAIL UpgradeStatus = 1
	// upgrade in progress
	UpgradeStatus_UPGRADE_STATUS_IN_PROGRESS UpgradeStatus = 2
)

var UpgradeStatus_name = map[int32]string{
	0: "UPGRADE_STATUS_OK",
	1: "UPGRADE_STATUS_FAIL",
	2: "UPGRADE_STATUS_IN_PROGRESS",
}

var UpgradeStatus_value = map[string]int32{
	"UPGRADE_STATUS_OK":          0,
	"UPGRADE_STATUS_FAIL":        1,
	"UPGRADE_STATUS_IN_PROGRESS": 2,
}

func (x UpgradeStatus) String() string {
	return proto.EnumName(UpgradeStatus_name, int32(x))
}

func (UpgradeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{2}
}

type UpgradeError int32

const (
	UpgradeError_UPGRADE_ERR_NONE UpgradeError = 0
	// error due to memory availability
	UpgradeError_UPGRADE_ERR_MEMORY_CHECK UpgradeError = 1
	// error due to CPLD check
	UpgradeError_UPGRADE_ERR_CPLD_CHECK UpgradeError = 2
	// error due to supported version check
	UpgradeError_UPGRADE_ERR_VERSION_CHECK UpgradeError = 3
	// faiure due to non ethernet device present
	UpgradeError_UPGRADE_ERR_NON_ETH_DEVICE_CHECK UpgradeError = 4
	// error due to dpdk device present
	UpgradeError_UPGRADE_ERR_DPDK_DEVICE_CHECK UpgradeError = 5
	// error due to pipeline quiesce
	UpgradeError_UPGRADE_ERR_PIPELINE_QUIESCE UpgradeError = 6
	// error due to service non responsive
	UpgradeError_UPGRADE_ERR_NON_RESPONSIVE UpgradeError = 7
	// error due to ipxe device present
	UpgradeError_UPGRADE_ERR_IPXE_DEVICE_CHECK UpgradeError = 8
	// error due to service unreachable
	UpgradeError_UPGRADE_ERR_SVC_UNREACHABLE UpgradeError = 9
	// error due to shell cmd execution
	UpgradeError_UPGRADE_ERR_CMD_EXEC UpgradeError = 10
	// error due to service response timeout
	UpgradeError_UPGRADE_ERR_SVC_TIMEOUT UpgradeError = 11
	// error due to firmware image doesn't exist
	UpgradeError_UPGRADE_ERR_INVALID_FW_IMAGEPATH UpgradeError = 12
	// error due to invalid fw image
	UpgradeError_UPGRADE_ERR_INVALID_FW_IMAGE UpgradeError = 13
	// error due to metafile not found.
	UpgradeError_UPGRADE_ERR_METAFILE_NOT_FOUND UpgradeError = 14
	// error due to invalid metafile present in the image.
	UpgradeError_UPGRADE_ERR_INVALID_METAFILE UpgradeError = 15
	// error due to invalid module target version.
	UpgradeError_UPGRADE_ERR_INVALID_MODULE_TARGET_VER UpgradeError = 16
	// error due to invalid fw target version.
	UpgradeError_UPGRADE_ERR_INVALID_TARGET_VER UpgradeError = 17
	// error due to incompatible major target version.
	UpgradeError_UPGRADE_ERR_INCOMPATIBLE_MAJOR_VER UpgradeError = 18
	// error due to build pipeline mismatch.
	UpgradeError_UPGRADE_ERR_PIPELINE_MISMATCH UpgradeError = 19
	// error due to previous upgrade not completed.
	UpgradeError_UPGRADE_ERR_PREV_UPGRADE_IN_PROGRESS UpgradeError = 20
)

var UpgradeError_name = map[int32]string{
	0:  "UPGRADE_ERR_NONE",
	1:  "UPGRADE_ERR_MEMORY_CHECK",
	2:  "UPGRADE_ERR_CPLD_CHECK",
	3:  "UPGRADE_ERR_VERSION_CHECK",
	4:  "UPGRADE_ERR_NON_ETH_DEVICE_CHECK",
	5:  "UPGRADE_ERR_DPDK_DEVICE_CHECK",
	6:  "UPGRADE_ERR_PIPELINE_QUIESCE",
	7:  "UPGRADE_ERR_NON_RESPONSIVE",
	8:  "UPGRADE_ERR_IPXE_DEVICE_CHECK",
	9:  "UPGRADE_ERR_SVC_UNREACHABLE",
	10: "UPGRADE_ERR_CMD_EXEC",
	11: "UPGRADE_ERR_SVC_TIMEOUT",
	12: "UPGRADE_ERR_INVALID_FW_IMAGEPATH",
	13: "UPGRADE_ERR_INVALID_FW_IMAGE",
	14: "UPGRADE_ERR_METAFILE_NOT_FOUND",
	15: "UPGRADE_ERR_INVALID_METAFILE",
	16: "UPGRADE_ERR_INVALID_MODULE_TARGET_VER",
	17: "UPGRADE_ERR_INVALID_TARGET_VER",
	18: "UPGRADE_ERR_INCOMPATIBLE_MAJOR_VER",
	19: "UPGRADE_ERR_PIPELINE_MISMATCH",
	20: "UPGRADE_ERR_PREV_UPGRADE_IN_PROGRESS",
}

var UpgradeError_value = map[string]int32{
	"UPGRADE_ERR_NONE":                      0,
	"UPGRADE_ERR_MEMORY_CHECK":              1,
	"UPGRADE_ERR_CPLD_CHECK":                2,
	"UPGRADE_ERR_VERSION_CHECK":             3,
	"UPGRADE_ERR_NON_ETH_DEVICE_CHECK":      4,
	"UPGRADE_ERR_DPDK_DEVICE_CHECK":         5,
	"UPGRADE_ERR_PIPELINE_QUIESCE":          6,
	"UPGRADE_ERR_NON_RESPONSIVE":            7,
	"UPGRADE_ERR_IPXE_DEVICE_CHECK":         8,
	"UPGRADE_ERR_SVC_UNREACHABLE":           9,
	"UPGRADE_ERR_CMD_EXEC":                  10,
	"UPGRADE_ERR_SVC_TIMEOUT":               11,
	"UPGRADE_ERR_INVALID_FW_IMAGEPATH":      12,
	"UPGRADE_ERR_INVALID_FW_IMAGE":          13,
	"UPGRADE_ERR_METAFILE_NOT_FOUND":        14,
	"UPGRADE_ERR_INVALID_METAFILE":          15,
	"UPGRADE_ERR_INVALID_MODULE_TARGET_VER": 16,
	"UPGRADE_ERR_INVALID_TARGET_VER":        17,
	"UPGRADE_ERR_INCOMPATIBLE_MAJOR_VER":    18,
	"UPGRADE_ERR_PIPELINE_MISMATCH":         19,
	"UPGRADE_ERR_PREV_UPGRADE_IN_PROGRESS":  20,
}

func (x UpgradeError) String() string {
	return proto.EnumName(UpgradeError_name, int32(x))
}

func (UpgradeError) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{3}
}

// upgrade specification
type UpgradeSpec struct {
	RequestType UpgradeRequestType `protobuf:"varint,1,opt,name=RequestType,proto3,enum=pds.UpgradeRequestType" json:"RequestType,omitempty" meta:mandatory,immutable`
	Mode        UpgradeMode        `protobuf:"varint,2,opt,name=Mode,proto3,enum=pds.UpgradeMode" json:"Mode,omitempty" meta:mandatory,immutable`
	// new package name with full path
	PackageName string `protobuf:"bytes,3,opt,name=PackageName,proto3" json:"PackageName,omitempty" meta:mandatory,immutable`
	// stop the upgrade if a service failed to respond for upgrade events
	// this is valid only for Graceful upgrade mode. In hitless upgrade mode, the upgrade aborts
	// as soon as there is a service error
	StopOnSvcFailure bool `protobuf:"varint,4,opt,name=StopOnSvcFailure,proto3" json:"StopOnSvcFailure,omitempty" meta:default=false,immutable`
	// when DryRun is set to true, only sanity & compatibility checks are
	// performed to see if there could be any potential issues that could fail
	// or prevent the actual firmware upgrade (which can happen due to
	// incompatibility between major release)
	DryRun               bool     `protobuf:"varint,5,opt,name=DryRun,proto3" json:"DryRun,omitempty" meta:default=false,immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpgradeSpec) Reset()         { *m = UpgradeSpec{} }
func (m *UpgradeSpec) String() string { return proto.CompactTextString(m) }
func (*UpgradeSpec) ProtoMessage()    {}
func (*UpgradeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{0}
}
func (m *UpgradeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeSpec.Merge(m, src)
}
func (m *UpgradeSpec) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeSpec proto.InternalMessageInfo

func (m *UpgradeSpec) GetRequestType() UpgradeRequestType {
	if m != nil {
		return m.RequestType
	}
	return UpgradeRequestType_UPGRADE_REQUEST_NONE
}

func (m *UpgradeSpec) GetMode() UpgradeMode {
	if m != nil {
		return m.Mode
	}
	return UpgradeMode_UPGRADE_MODE_NONE
}

func (m *UpgradeSpec) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *UpgradeSpec) GetStopOnSvcFailure() bool {
	if m != nil {
		return m.StopOnSvcFailure
	}
	return false
}

func (m *UpgradeSpec) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

// ugprade request
type UpgradeRequest struct {
	Request              *UpgradeSpec `protobuf:"bytes,1,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UpgradeRequest) Reset()         { *m = UpgradeRequest{} }
func (m *UpgradeRequest) String() string { return proto.CompactTextString(m) }
func (*UpgradeRequest) ProtoMessage()    {}
func (*UpgradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{1}
}
func (m *UpgradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeRequest.Merge(m, src)
}
func (m *UpgradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeRequest proto.InternalMessageInfo

func (m *UpgradeRequest) GetRequest() *UpgradeSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type UpgradeProgressInfo struct {
	Stage                string        `protobuf:"bytes,1,opt,name=Stage,proto3" json:"Stage,omitempty"`
	SvcName              string        `protobuf:"bytes,2,opt,name=SvcName,proto3" json:"SvcName,omitempty"`
	Status               UpgradeStatus `protobuf:"varint,3,opt,name=Status,proto3,enum=pds.UpgradeStatus" json:"Status,omitempty"`
	Error                UpgradeError  `protobuf:"varint,4,opt,name=Error,proto3,enum=pds.UpgradeError" json:"Error,omitempty"`
	Time                 string        `protobuf:"bytes,5,opt,name=Time,proto3" json:"Time,omitempty"`
	ErrorMsg             string        `protobuf:"bytes,6,opt,name=ErrorMsg,proto3" json:"ErrorMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpgradeProgressInfo) Reset()         { *m = UpgradeProgressInfo{} }
func (m *UpgradeProgressInfo) String() string { return proto.CompactTextString(m) }
func (*UpgradeProgressInfo) ProtoMessage()    {}
func (*UpgradeProgressInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{2}
}
func (m *UpgradeProgressInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeProgressInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeProgressInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeProgressInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeProgressInfo.Merge(m, src)
}
func (m *UpgradeProgressInfo) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeProgressInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeProgressInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeProgressInfo proto.InternalMessageInfo

func (m *UpgradeProgressInfo) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

func (m *UpgradeProgressInfo) GetSvcName() string {
	if m != nil {
		return m.SvcName
	}
	return ""
}

func (m *UpgradeProgressInfo) GetStatus() UpgradeStatus {
	if m != nil {
		return m.Status
	}
	return UpgradeStatus_UPGRADE_STATUS_OK
}

func (m *UpgradeProgressInfo) GetError() UpgradeError {
	if m != nil {
		return m.Error
	}
	return UpgradeError_UPGRADE_ERR_NONE
}

func (m *UpgradeProgressInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *UpgradeProgressInfo) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

// upgrade response
type UpgradeResponse struct {
	Status               UpgradeStatus          `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.UpgradeStatus" json:"Status,omitempty"`
	ProgressInfo         []*UpgradeProgressInfo `protobuf:"bytes,2,rep,name=ProgressInfo,proto3" json:"ProgressInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpgradeResponse) Reset()         { *m = UpgradeResponse{} }
func (m *UpgradeResponse) String() string { return proto.CompactTextString(m) }
func (*UpgradeResponse) ProtoMessage()    {}
func (*UpgradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{3}
}
func (m *UpgradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeResponse.Merge(m, src)
}
func (m *UpgradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeResponse proto.InternalMessageInfo

func (m *UpgradeResponse) GetStatus() UpgradeStatus {
	if m != nil {
		return m.Status
	}
	return UpgradeStatus_UPGRADE_STATUS_OK
}

func (m *UpgradeResponse) GetProgressInfo() []*UpgradeProgressInfo {
	if m != nil {
		return m.ProgressInfo
	}
	return nil
}

// configuration replay ready check response
type ConfigReplayReadyRsp struct {
	IsReady              bool     `protobuf:"varint,1,opt,name=IsReady,proto3" json:"IsReady,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigReplayReadyRsp) Reset()         { *m = ConfigReplayReadyRsp{} }
func (m *ConfigReplayReadyRsp) String() string { return proto.CompactTextString(m) }
func (*ConfigReplayReadyRsp) ProtoMessage()    {}
func (*ConfigReplayReadyRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{4}
}
func (m *ConfigReplayReadyRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigReplayReadyRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigReplayReadyRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigReplayReadyRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigReplayReadyRsp.Merge(m, src)
}
func (m *ConfigReplayReadyRsp) XXX_Size() int {
	return m.Size()
}
func (m *ConfigReplayReadyRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigReplayReadyRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigReplayReadyRsp proto.InternalMessageInfo

func (m *ConfigReplayReadyRsp) GetIsReady() bool {
	if m != nil {
		return m.IsReady
	}
	return false
}

// empty upgrade status request
type UpgradeStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpgradeStatusRequest) Reset()         { *m = UpgradeStatusRequest{} }
func (m *UpgradeStatusRequest) String() string { return proto.CompactTextString(m) }
func (*UpgradeStatusRequest) ProtoMessage()    {}
func (*UpgradeStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{5}
}
func (m *UpgradeStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeStatusRequest.Merge(m, src)
}
func (m *UpgradeStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeStatusRequest proto.InternalMessageInfo

// empty msg
type EmptyMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyMsg) Reset()         { *m = EmptyMsg{} }
func (m *EmptyMsg) String() string { return proto.CompactTextString(m) }
func (*EmptyMsg) ProtoMessage()    {}
func (*EmptyMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6adee5b6c4cf09e, []int{6}
}
func (m *EmptyMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyMsg.Merge(m, src)
}
func (m *EmptyMsg) XXX_Size() int {
	return m.Size()
}
func (m *EmptyMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyMsg proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("pds.UpgradeRequestType", UpgradeRequestType_name, UpgradeRequestType_value)
	proto.RegisterEnum("pds.UpgradeMode", UpgradeMode_name, UpgradeMode_value)
	proto.RegisterEnum("pds.UpgradeStatus", UpgradeStatus_name, UpgradeStatus_value)
	proto.RegisterEnum("pds.UpgradeError", UpgradeError_name, UpgradeError_value)
	proto.RegisterType((*UpgradeSpec)(nil), "pds.UpgradeSpec")
	proto.RegisterType((*UpgradeRequest)(nil), "pds.UpgradeRequest")
	proto.RegisterType((*UpgradeProgressInfo)(nil), "pds.UpgradeProgressInfo")
	proto.RegisterType((*UpgradeResponse)(nil), "pds.UpgradeResponse")
	proto.RegisterType((*ConfigReplayReadyRsp)(nil), "pds.ConfigReplayReadyRsp")
	proto.RegisterType((*UpgradeStatusRequest)(nil), "pds.UpgradeStatusRequest")
	proto.RegisterType((*EmptyMsg)(nil), "pds.EmptyMsg")
}

func init() { proto.RegisterFile("upgrade.proto", fileDescriptor_b6adee5b6c4cf09e) }

var fileDescriptor_b6adee5b6c4cf09e = []byte{
	// 1013 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x4f, 0xdb, 0x56,
	0x14, 0xc6, 0x01, 0x52, 0x38, 0x01, 0x7a, 0xb9, 0x04, 0x30, 0x29, 0x85, 0x2c, 0xea, 0x36, 0x86,
	0x26, 0x54, 0x65, 0x9b, 0x34, 0x6d, 0xdd, 0x24, 0xc7, 0xbe, 0x21, 0x2e, 0xf1, 0x8f, 0x5e, 0xdb,
	0x69, 0xfb, 0x64, 0xb9, 0x89, 0xf1, 0x50, 0x49, 0xec, 0xd9, 0x0e, 0x52, 0xb4, 0x3f, 0x6e, 0xaf,
	0xd3, 0x9e, 0xf6, 0xb2, 0xd7, 0x6a, 0xe2, 0x4f, 0xe0, 0x2f, 0x98, 0x72, 0x13, 0xb3, 0x6b, 0x43,
	0xc7, 0xf6, 0x96, 0x73, 0xbe, 0xef, 0x7c, 0xe7, 0xfa, 0x3b, 0xd7, 0xc7, 0x81, 0xf5, 0x71, 0x14,
	0xc4, 0xde, 0xc0, 0x3f, 0x89, 0xe2, 0x30, 0x0d, 0xf1, 0x62, 0x34, 0x48, 0x6a, 0x10, 0x84, 0x41,
	0x38, 0x4b, 0x34, 0x6e, 0x4a, 0x50, 0x71, 0x66, 0x14, 0x2b, 0xf2, 0xfb, 0xf8, 0x35, 0x54, 0xa8,
	0xff, 0xf3, 0xd8, 0x4f, 0x52, 0x7b, 0x12, 0xf9, 0xa2, 0x50, 0x17, 0x8e, 0x36, 0x9a, 0xbb, 0x27,
	0xd1, 0x20, 0x39, 0x99, 0xd3, 0x38, 0xb8, 0xb5, 0x7f, 0xf3, 0xe1, 0x50, 0x1c, 0xfa, 0xa9, 0xf7,
	0xdd, 0xd0, 0x1b, 0x0d, 0xbc, 0x34, 0x8c, 0x27, 0x5f, 0x5e, 0x0c, 0x87, 0xe3, 0xd4, 0x7b, 0x77,
	0xe9, 0x53, 0x5e, 0x09, 0xb7, 0x60, 0x49, 0x0b, 0x07, 0xbe, 0x58, 0x62, 0x8a, 0x88, 0x57, 0x9c,
	0xe6, 0x1f, 0x90, 0x62, 0xb5, 0xf8, 0x47, 0xa8, 0x98, 0x5e, 0xff, 0xbd, 0x17, 0xf8, 0xba, 0x37,
	0xf4, 0xc5, 0xc5, 0xba, 0x70, 0xb4, 0xfa, 0xd0, 0x19, 0xb8, 0x02, 0xdc, 0x05, 0x64, 0xa5, 0x61,
	0x64, 0x8c, 0xac, 0xab, 0x7e, 0xdb, 0xbb, 0xb8, 0x1c, 0xc7, 0xbe, 0xb8, 0x54, 0x17, 0x8e, 0x56,
	0x5a, 0xf5, 0x9b, 0x0f, 0x87, 0xfb, 0x4c, 0x64, 0xe0, 0x9f, 0x7b, 0xe3, 0xcb, 0xf4, 0x87, 0x73,
	0xef, 0x32, 0xf1, 0x39, 0xa1, 0x3b, 0x95, 0xf8, 0x5b, 0x28, 0x2b, 0xf1, 0x84, 0x8e, 0x47, 0xe2,
	0xf2, 0x7f, 0xd4, 0x98, 0xf3, 0x1b, 0x2f, 0x60, 0x23, 0x6f, 0x26, 0x3e, 0x86, 0x47, 0xf3, 0x9f,
	0xcc, 0xf2, 0x4a, 0xde, 0xa0, 0xe9, 0x64, 0x68, 0x46, 0x68, 0xfc, 0x2e, 0xc0, 0xd6, 0x1c, 0x30,
	0xe3, 0x30, 0x88, 0xfd, 0x24, 0x51, 0x47, 0xe7, 0x21, 0xae, 0xc2, 0xb2, 0x95, 0x7a, 0xc1, 0x6c,
	0x68, 0xab, 0x74, 0x16, 0x60, 0x11, 0x1e, 0x59, 0x57, 0x7d, 0xe6, 0x57, 0x89, 0xe5, 0xb3, 0x10,
	0x1f, 0x43, 0xd9, 0x4a, 0xbd, 0x74, 0x9c, 0x30, 0x23, 0x37, 0x9a, 0x38, 0xd7, 0x92, 0x21, 0x74,
	0xce, 0xc0, 0x9f, 0xc3, 0x32, 0x89, 0xe3, 0x30, 0x66, 0x76, 0x6d, 0x34, 0x37, 0x79, 0x2a, 0x03,
	0xe8, 0x0c, 0xc7, 0x18, 0x96, 0xec, 0x8b, 0xa1, 0xcf, 0x2c, 0x59, 0xa5, 0xec, 0x37, 0xae, 0xc1,
	0x0a, 0x03, 0xb5, 0x24, 0x10, 0xcb, 0x2c, 0x7f, 0x1b, 0x37, 0x7e, 0x81, 0xc7, 0xb7, 0x56, 0x24,
	0x51, 0x38, 0x4a, 0xf8, 0x73, 0x09, 0x0f, 0x9e, 0xeb, 0x05, 0xac, 0xf1, 0x1e, 0x88, 0xa5, 0xfa,
	0xe2, 0x51, 0xa5, 0x29, 0xf2, 0x15, 0x3c, 0x4e, 0x73, 0xec, 0xc6, 0x73, 0xa8, 0xca, 0xe1, 0xe8,
	0xfc, 0x22, 0xa0, 0x7e, 0x74, 0xe9, 0x4d, 0xa8, 0xef, 0x0d, 0x26, 0x34, 0x89, 0xa6, 0x9e, 0xa9,
	0x09, 0x8b, 0xd8, 0x11, 0x56, 0x68, 0x16, 0x36, 0x76, 0xa0, 0x9a, 0x3f, 0xc8, 0x7c, 0x26, 0x00,
	0x2b, 0x64, 0x18, 0xa5, 0x13, 0x2d, 0x09, 0x8e, 0x55, 0xc0, 0x77, 0x5f, 0x15, 0x2c, 0x42, 0xd5,
	0x31, 0x4f, 0xa9, 0xa4, 0x10, 0x97, 0x92, 0x57, 0x0e, 0xb1, 0x6c, 0x57, 0x37, 0x74, 0x82, 0x16,
	0xf0, 0x1e, 0x6c, 0x17, 0x11, 0xcb, 0x96, 0xa8, 0x8d, 0x84, 0xe3, 0xb7, 0xb7, 0x2f, 0x27, 0xbb,
	0xff, 0xdb, 0xb0, 0x99, 0x31, 0x35, 0x43, 0x21, 0xf7, 0x08, 0xb0, 0xf4, 0x29, 0x95, 0x64, 0xd2,
	0x76, 0xba, 0x48, 0xe0, 0xbb, 0x32, 0xa8, 0xa3, 0xda, 0x5d, 0x62, 0x59, 0xa8, 0x74, 0xec, 0xc2,
	0x7a, 0xee, 0x49, 0x78, 0x71, 0xcb, 0x96, 0x6c, 0xc7, 0x72, 0x8d, 0x33, 0xb4, 0x80, 0x77, 0x61,
	0xab, 0x90, 0x6e, 0x4b, 0xea, 0x54, 0xfa, 0x00, 0x6a, 0x05, 0x40, 0xd5, 0x5d, 0x93, 0x1a, 0xa7,
	0x74, 0xd6, 0xe0, 0xcf, 0x65, 0x58, 0xe3, 0x6f, 0x08, 0xae, 0x02, 0xca, 0x0a, 0x08, 0xa5, 0xd9,
	0xe1, 0xf7, 0x41, 0xe4, 0xb3, 0x1a, 0xd1, 0x0c, 0xfa, 0xd6, 0x95, 0x3b, 0x44, 0x3e, 0x43, 0x02,
	0xae, 0xc1, 0x0e, 0x8f, 0xca, 0x66, 0x57, 0x99, 0x63, 0x25, 0xfc, 0x14, 0xf6, 0x78, 0xac, 0x47,
	0xa8, 0xa5, 0x1a, 0xfa, 0x1c, 0x5e, 0xc4, 0xcf, 0xa0, 0x5e, 0x68, 0xe7, 0x12, 0xbb, 0xe3, 0x2a,
	0xa4, 0xa7, 0xca, 0x64, 0xce, 0x5a, 0xc2, 0x9f, 0xc0, 0x53, 0x9e, 0xa5, 0x98, 0xca, 0x59, 0x9e,
	0xb2, 0x8c, 0xeb, 0xb0, 0xcf, 0x53, 0x4c, 0xd5, 0x24, 0x5d, 0x55, 0x27, 0xee, 0x2b, 0x47, 0x25,
	0x96, 0x4c, 0x50, 0x99, 0xb7, 0x22, 0x6b, 0x45, 0x89, 0x65, 0x1a, 0xba, 0xa5, 0xf6, 0x08, 0x7a,
	0x54, 0x6c, 0xa2, 0x9a, 0x6f, 0x48, 0xbe, 0xc9, 0x0a, 0x3e, 0x84, 0x27, 0x3c, 0xc5, 0xea, 0xc9,
	0xae, 0xa3, 0x53, 0x22, 0xc9, 0x1d, 0xa9, 0xd5, 0x25, 0x68, 0x95, 0x9f, 0x24, 0x73, 0x42, 0x53,
	0x5c, 0xf2, 0x86, 0xc8, 0x08, 0xf0, 0x13, 0xd8, 0x2d, 0x96, 0xda, 0xaa, 0x46, 0x0c, 0xc7, 0x46,
	0x95, 0xa2, 0x0b, 0xaa, 0xde, 0x93, 0xba, 0xaa, 0xe2, 0xb6, 0x5f, 0xbb, 0xaa, 0x26, 0x9d, 0x12,
	0x53, 0xb2, 0x3b, 0x68, 0xad, 0xf8, 0x88, 0x45, 0x16, 0x5a, 0xc7, 0x0d, 0x38, 0xc8, 0x8f, 0xc9,
	0x96, 0xda, 0x6a, 0x77, 0x7a, 0x05, 0x6d, 0xb7, 0x6d, 0x38, 0xba, 0x82, 0x36, 0x3e, 0xa6, 0x92,
	0x71, 0xd1, 0x63, 0xfc, 0x05, 0x7c, 0x7a, 0x2f, 0xc3, 0x50, 0x9c, 0x2e, 0x71, 0x6d, 0x89, 0x9e,
	0x12, 0x7b, 0x3a, 0x48, 0x84, 0x8a, 0x0d, 0x33, 0x2a, 0xc7, 0xd9, 0xc4, 0x9f, 0x41, 0x23, 0xcf,
	0x91, 0x0d, 0xcd, 0x94, 0x6c, 0xb5, 0xd5, 0x25, 0xae, 0x26, 0xbd, 0x34, 0xd8, 0xa5, 0x40, 0xb8,
	0xe8, 0xff, 0xed, 0x04, 0x35, 0xd5, 0xd2, 0x24, 0x5b, 0xee, 0xa0, 0x2d, 0x7c, 0x04, 0xcf, 0x72,
	0x14, 0x4a, 0x7a, 0x6e, 0x96, 0xe0, 0xef, 0x75, 0xb5, 0xf9, 0xeb, 0x22, 0x94, 0x9d, 0x28, 0xb0,
	0xae, 0xfa, 0xf8, 0x7b, 0x00, 0x27, 0x0a, 0xb2, 0x1d, 0xbe, 0x75, 0xcf, 0x57, 0xb2, 0x56, 0xcd,
	0x27, 0x67, 0x2b, 0xae, 0xb1, 0xf0, 0x5c, 0xc0, 0x04, 0x76, 0xfe, 0x29, 0xd6, 0xc3, 0x91, 0x95,
	0xc6, 0xbe, 0x37, 0xbc, 0x18, 0x05, 0xff, 0x4b, 0x08, 0x2b, 0xb0, 0x73, 0x67, 0x87, 0xc9, 0x3f,
	0xf9, 0xfd, 0xf7, 0x78, 0x9d, 0x55, 0x64, 0x6b, 0xa9, 0xb6, 0xc7, 0xc2, 0xfb, 0xf6, 0x5d, 0x63,
	0x01, 0x7f, 0x03, 0x5b, 0x3c, 0x62, 0xa5, 0x5e, 0x9c, 0xfa, 0x83, 0xa2, 0x44, 0x3e, 0x6c, 0x2c,
	0xe0, 0x26, 0x20, 0xbe, 0x4c, 0x09, 0x47, 0xfe, 0x83, 0x35, 0x5f, 0xc3, 0xea, 0xd4, 0xbe, 0xd9,
	0xd2, 0x29, 0x90, 0x3f, 0xee, 0xd6, 0x4b, 0xd8, 0xbe, 0xad, 0xca, 0x99, 0xb5, 0x77, 0xcf, 0xd7,
	0xe1, 0xdf, 0x2d, 0x6b, 0xad, 0xfd, 0x76, 0x7d, 0x20, 0xfc, 0x71, 0x7d, 0x20, 0xfc, 0x75, 0x7d,
	0x20, 0xbc, 0x2b, 0xb3, 0x3f, 0x42, 0x5f, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x1b, 0xfd,
	0x7f, 0x2a, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UpgSvcClient is the client API for UpgSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UpgSvcClient interface {
	// start the upgrade
	// NOTE: abort operation is not supported
	UpgRequest(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (UpgSvc_UpgRequestClient, error)
	// start the upgrade non streaming
	UpgRequestNonStreaming(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	// check if configuration replay can be started
	ConfigReplayReadyCheck(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*ConfigReplayReadyRsp, error)
	// notify configuration replay started
	ConfigReplayStarted(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*EmptyMsg, error)
	// notify configuration replay done
	ConfigReplayDone(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*EmptyMsg, error)
	// check for upgrade status
	UpgStatus(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (UpgSvc_UpgStatusClient, error)
	// check for upgrade status non streaming
	UpgStatusNonStreaming(ctx context.Context, in *UpgradeStatusRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
}

type upgSvcClient struct {
	cc *grpc.ClientConn
}

func NewUpgSvcClient(cc *grpc.ClientConn) UpgSvcClient {
	return &upgSvcClient{cc}
}

func (c *upgSvcClient) UpgRequest(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (UpgSvc_UpgRequestClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UpgSvc_serviceDesc.Streams[0], "/pds.UpgSvc/UpgRequest", opts...)
	if err != nil {
		return nil, err
	}
	x := &upgSvcUpgRequestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UpgSvc_UpgRequestClient interface {
	Recv() (*UpgradeResponse, error)
	grpc.ClientStream
}

type upgSvcUpgRequestClient struct {
	grpc.ClientStream
}

func (x *upgSvcUpgRequestClient) Recv() (*UpgradeResponse, error) {
	m := new(UpgradeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *upgSvcClient) UpgRequestNonStreaming(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, "/pds.UpgSvc/UpgRequestNonStreaming", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upgSvcClient) ConfigReplayReadyCheck(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*ConfigReplayReadyRsp, error) {
	out := new(ConfigReplayReadyRsp)
	err := c.cc.Invoke(ctx, "/pds.UpgSvc/ConfigReplayReadyCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upgSvcClient) ConfigReplayStarted(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*EmptyMsg, error) {
	out := new(EmptyMsg)
	err := c.cc.Invoke(ctx, "/pds.UpgSvc/ConfigReplayStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upgSvcClient) ConfigReplayDone(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (*EmptyMsg, error) {
	out := new(EmptyMsg)
	err := c.cc.Invoke(ctx, "/pds.UpgSvc/ConfigReplayDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upgSvcClient) UpgStatus(ctx context.Context, in *EmptyMsg, opts ...grpc.CallOption) (UpgSvc_UpgStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UpgSvc_serviceDesc.Streams[1], "/pds.UpgSvc/UpgStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &upgSvcUpgStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UpgSvc_UpgStatusClient interface {
	Recv() (*UpgradeResponse, error)
	grpc.ClientStream
}

type upgSvcUpgStatusClient struct {
	grpc.ClientStream
}

func (x *upgSvcUpgStatusClient) Recv() (*UpgradeResponse, error) {
	m := new(UpgradeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *upgSvcClient) UpgStatusNonStreaming(ctx context.Context, in *UpgradeStatusRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, "/pds.UpgSvc/UpgStatusNonStreaming", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UpgSvcServer is the server API for UpgSvc service.
type UpgSvcServer interface {
	// start the upgrade
	// NOTE: abort operation is not supported
	UpgRequest(*UpgradeRequest, UpgSvc_UpgRequestServer) error
	// start the upgrade non streaming
	UpgRequestNonStreaming(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	// check if configuration replay can be started
	ConfigReplayReadyCheck(context.Context, *EmptyMsg) (*ConfigReplayReadyRsp, error)
	// notify configuration replay started
	ConfigReplayStarted(context.Context, *EmptyMsg) (*EmptyMsg, error)
	// notify configuration replay done
	ConfigReplayDone(context.Context, *EmptyMsg) (*EmptyMsg, error)
	// check for upgrade status
	UpgStatus(*EmptyMsg, UpgSvc_UpgStatusServer) error
	// check for upgrade status non streaming
	UpgStatusNonStreaming(context.Context, *UpgradeStatusRequest) (*UpgradeResponse, error)
}

// UnimplementedUpgSvcServer can be embedded to have forward compatible implementations.
type UnimplementedUpgSvcServer struct {
}

func (*UnimplementedUpgSvcServer) UpgRequest(req *UpgradeRequest, srv UpgSvc_UpgRequestServer) error {
	return status.Errorf(codes.Unimplemented, "method UpgRequest not implemented")
}
func (*UnimplementedUpgSvcServer) UpgRequestNonStreaming(ctx context.Context, req *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgRequestNonStreaming not implemented")
}
func (*UnimplementedUpgSvcServer) ConfigReplayReadyCheck(ctx context.Context, req *EmptyMsg) (*ConfigReplayReadyRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigReplayReadyCheck not implemented")
}
func (*UnimplementedUpgSvcServer) ConfigReplayStarted(ctx context.Context, req *EmptyMsg) (*EmptyMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigReplayStarted not implemented")
}
func (*UnimplementedUpgSvcServer) ConfigReplayDone(ctx context.Context, req *EmptyMsg) (*EmptyMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigReplayDone not implemented")
}
func (*UnimplementedUpgSvcServer) UpgStatus(req *EmptyMsg, srv UpgSvc_UpgStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method UpgStatus not implemented")
}
func (*UnimplementedUpgSvcServer) UpgStatusNonStreaming(ctx context.Context, req *UpgradeStatusRequest) (*UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgStatusNonStreaming not implemented")
}

func RegisterUpgSvcServer(s *grpc.Server, srv UpgSvcServer) {
	s.RegisterService(&_UpgSvc_serviceDesc, srv)
}

func _UpgSvc_UpgRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpgradeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UpgSvcServer).UpgRequest(m, &upgSvcUpgRequestServer{stream})
}

type UpgSvc_UpgRequestServer interface {
	Send(*UpgradeResponse) error
	grpc.ServerStream
}

type upgSvcUpgRequestServer struct {
	grpc.ServerStream
}

func (x *upgSvcUpgRequestServer) Send(m *UpgradeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UpgSvc_UpgRequestNonStreaming_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpgSvcServer).UpgRequestNonStreaming(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.UpgSvc/UpgRequestNonStreaming",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpgSvcServer).UpgRequestNonStreaming(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpgSvc_ConfigReplayReadyCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpgSvcServer).ConfigReplayReadyCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.UpgSvc/ConfigReplayReadyCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpgSvcServer).ConfigReplayReadyCheck(ctx, req.(*EmptyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpgSvc_ConfigReplayStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpgSvcServer).ConfigReplayStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.UpgSvc/ConfigReplayStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpgSvcServer).ConfigReplayStarted(ctx, req.(*EmptyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpgSvc_ConfigReplayDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpgSvcServer).ConfigReplayDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.UpgSvc/ConfigReplayDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpgSvcServer).ConfigReplayDone(ctx, req.(*EmptyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpgSvc_UpgStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyMsg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UpgSvcServer).UpgStatus(m, &upgSvcUpgStatusServer{stream})
}

type UpgSvc_UpgStatusServer interface {
	Send(*UpgradeResponse) error
	grpc.ServerStream
}

type upgSvcUpgStatusServer struct {
	grpc.ServerStream
}

func (x *upgSvcUpgStatusServer) Send(m *UpgradeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UpgSvc_UpgStatusNonStreaming_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpgSvcServer).UpgStatusNonStreaming(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.UpgSvc/UpgStatusNonStreaming",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpgSvcServer).UpgStatusNonStreaming(ctx, req.(*UpgradeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UpgSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.UpgSvc",
	HandlerType: (*UpgSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpgRequestNonStreaming",
			Handler:    _UpgSvc_UpgRequestNonStreaming_Handler,
		},
		{
			MethodName: "ConfigReplayReadyCheck",
			Handler:    _UpgSvc_ConfigReplayReadyCheck_Handler,
		},
		{
			MethodName: "ConfigReplayStarted",
			Handler:    _UpgSvc_ConfigReplayStarted_Handler,
		},
		{
			MethodName: "ConfigReplayDone",
			Handler:    _UpgSvc_ConfigReplayDone_Handler,
		},
		{
			MethodName: "UpgStatusNonStreaming",
			Handler:    _UpgSvc_UpgStatusNonStreaming_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpgRequest",
			Handler:       _UpgSvc_UpgRequest_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpgStatus",
			Handler:       _UpgSvc_UpgStatus_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "upgrade.proto",
}

func (m *UpgradeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.StopOnSvcFailure {
		i--
		if m.StopOnSvcFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PackageName) > 0 {
		i -= len(m.PackageName)
		copy(dAtA[i:], m.PackageName)
		i = encodeVarintUpgrade(dAtA, i, uint64(len(m.PackageName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintUpgrade(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestType != 0 {
		i = encodeVarintUpgrade(dAtA, i, uint64(m.RequestType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpgrade(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeProgressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeProgressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeProgressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintUpgrade(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintUpgrade(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Error != 0 {
		i = encodeVarintUpgrade(dAtA, i, uint64(m.Error))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintUpgrade(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SvcName) > 0 {
		i -= len(m.SvcName)
		copy(dAtA[i:], m.SvcName)
		i = encodeVarintUpgrade(dAtA, i, uint64(len(m.SvcName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Stage) > 0 {
		i -= len(m.Stage)
		copy(dAtA[i:], m.Stage)
		i = encodeVarintUpgrade(dAtA, i, uint64(len(m.Stage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProgressInfo) > 0 {
		for iNdEx := len(m.ProgressInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProgressInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUpgrade(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintUpgrade(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfigReplayReadyRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigReplayReadyRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigReplayReadyRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsReady {
		i--
		if m.IsReady {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EmptyMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintUpgrade(dAtA []byte, offset int, v uint64) int {
	offset -= sovUpgrade(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpgradeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestType != 0 {
		n += 1 + sovUpgrade(uint64(m.RequestType))
	}
	if m.Mode != 0 {
		n += 1 + sovUpgrade(uint64(m.Mode))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 1 + l + sovUpgrade(uint64(l))
	}
	if m.StopOnSvcFailure {
		n += 2
	}
	if m.DryRun {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovUpgrade(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeProgressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovUpgrade(uint64(l))
	}
	l = len(m.SvcName)
	if l > 0 {
		n += 1 + l + sovUpgrade(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovUpgrade(uint64(m.Status))
	}
	if m.Error != 0 {
		n += 1 + sovUpgrade(uint64(m.Error))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovUpgrade(uint64(l))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovUpgrade(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovUpgrade(uint64(m.Status))
	}
	if len(m.ProgressInfo) > 0 {
		for _, e := range m.ProgressInfo {
			l = e.Size()
			n += 1 + l + sovUpgrade(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigReplayReadyRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsReady {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmptyMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovUpgrade(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUpgrade(x uint64) (n int) {
	return sovUpgrade(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpgradeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= UpgradeRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= UpgradeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopOnSvcFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StopOnSvcFailure = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &UpgradeSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeProgressInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeProgressInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeProgressInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SvcName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UpgradeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= UpgradeError(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UpgradeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpgrade
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpgrade
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgressInfo = append(m.ProgressInfo, &UpgradeProgressInfo{})
			if err := m.ProgressInfo[len(m.ProgressInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigReplayReadyRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigReplayReadyRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigReplayReadyRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReady = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUpgrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUpgrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpgrade(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpgrade
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpgrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUpgrade
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthUpgrade
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUpgrade
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUpgrade(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthUpgrade
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUpgrade = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpgrade   = fmt.Errorf("proto: integer overflow")
)
