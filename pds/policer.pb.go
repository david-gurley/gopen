// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policer.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// traffic direction in which policer is applied
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
type PolicerDir int32

const (
	PolicerDir_POLICER_DIR_NONE    PolicerDir = 0
	PolicerDir_POLICER_DIR_INGRESS PolicerDir = 1
	PolicerDir_POLICER_DIR_EGRESS  PolicerDir = 2
)

var PolicerDir_name = map[int32]string{
	0: "POLICER_DIR_NONE",
	1: "POLICER_DIR_INGRESS",
	2: "POLICER_DIR_EGRESS",
}

var PolicerDir_value = map[string]int32{
	"POLICER_DIR_NONE":    0,
	"POLICER_DIR_INGRESS": 1,
	"POLICER_DIR_EGRESS":  2,
}

func (x PolicerDir) String() string {
	return proto.EnumName(PolicerDir_name, int32(x))
}

func (PolicerDir) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{0}
}

// packet policer
type PacketPolicerSpec struct {
	// packets per second
	PacketsPerSecond uint64 `protobuf:"varint,1,opt,name=PacketsPerSecond,proto3" json:"PacketsPerSecond,omitempty" meta:mandatory`
	// number/burst of packets to absorb
	Burst                uint64   `protobuf:"varint,2,opt,name=Burst,proto3" json:"Burst,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PacketPolicerSpec) Reset()         { *m = PacketPolicerSpec{} }
func (m *PacketPolicerSpec) String() string { return proto.CompactTextString(m) }
func (*PacketPolicerSpec) ProtoMessage()    {}
func (*PacketPolicerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{0}
}
func (m *PacketPolicerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketPolicerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketPolicerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketPolicerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketPolicerSpec.Merge(m, src)
}
func (m *PacketPolicerSpec) XXX_Size() int {
	return m.Size()
}
func (m *PacketPolicerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketPolicerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PacketPolicerSpec proto.InternalMessageInfo

func (m *PacketPolicerSpec) GetPacketsPerSecond() uint64 {
	if m != nil {
		return m.PacketsPerSecond
	}
	return 0
}

func (m *PacketPolicerSpec) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// byte policer
type BytePolicerSpec struct {
	// bytes per second
	BytesPerSecond uint64 `protobuf:"varint,1,opt,name=BytesPerSecond,proto3" json:"BytesPerSecond,omitempty" meta:mandatory`
	// number/burst of bytes to absorb
	Burst                uint64   `protobuf:"varint,2,opt,name=Burst,proto3" json:"Burst,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BytePolicerSpec) Reset()         { *m = BytePolicerSpec{} }
func (m *BytePolicerSpec) String() string { return proto.CompactTextString(m) }
func (*BytePolicerSpec) ProtoMessage()    {}
func (*BytePolicerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{1}
}
func (m *BytePolicerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BytePolicerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BytePolicerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BytePolicerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BytePolicerSpec.Merge(m, src)
}
func (m *BytePolicerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BytePolicerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BytePolicerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BytePolicerSpec proto.InternalMessageInfo

func (m *BytePolicerSpec) GetBytesPerSecond() uint64 {
	if m != nil {
		return m.BytesPerSecond
	}
	return 0
}

func (m *BytePolicerSpec) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// policer specification
type PolicerSpec struct {
	// unique policer id
	Id        []byte     `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Direction PolicerDir `protobuf:"varint,2,opt,name=Direction,proto3,enum=pds.PolicerDir" json:"Direction,omitempty" meta:mandatory,immutable`
	// policer is one byte policer or packet policer
	//
	// Types that are valid to be assigned to Policer:
	//	*PolicerSpec_PPSPolicer
	//	*PolicerSpec_BPSPolicer
	Policer              isPolicerSpec_Policer `protobuf_oneof:"policer"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PolicerSpec) Reset()         { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()    {}
func (*PolicerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{2}
}
func (m *PolicerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerSpec.Merge(m, src)
}
func (m *PolicerSpec) XXX_Size() int {
	return m.Size()
}
func (m *PolicerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerSpec proto.InternalMessageInfo

type isPolicerSpec_Policer interface {
	isPolicerSpec_Policer()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PolicerSpec_PPSPolicer struct {
	PPSPolicer *PacketPolicerSpec `protobuf:"bytes,3,opt,name=PPSPolicer,proto3,oneof"`
}
type PolicerSpec_BPSPolicer struct {
	BPSPolicer *BytePolicerSpec `protobuf:"bytes,4,opt,name=BPSPolicer,proto3,oneof"`
}

func (*PolicerSpec_PPSPolicer) isPolicerSpec_Policer() {}
func (*PolicerSpec_BPSPolicer) isPolicerSpec_Policer() {}

func (m *PolicerSpec) GetPolicer() isPolicerSpec_Policer {
	if m != nil {
		return m.Policer
	}
	return nil
}

func (m *PolicerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PolicerSpec) GetDirection() PolicerDir {
	if m != nil {
		return m.Direction
	}
	return PolicerDir_POLICER_DIR_NONE
}

func (m *PolicerSpec) GetPPSPolicer() *PacketPolicerSpec {
	if x, ok := m.GetPolicer().(*PolicerSpec_PPSPolicer); ok {
		return x.PPSPolicer
	}
	return nil
}

func (m *PolicerSpec) GetBPSPolicer() *BytePolicerSpec {
	if x, ok := m.GetPolicer().(*PolicerSpec_BPSPolicer); ok {
		return x.BPSPolicer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PolicerSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PolicerSpec_PPSPolicer)(nil),
		(*PolicerSpec_BPSPolicer)(nil),
	}
}

// operational status of the policer, if any
type PolicerStatus struct {
	HwId                 uint32   `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicerStatus) Reset()         { *m = PolicerStatus{} }
func (m *PolicerStatus) String() string { return proto.CompactTextString(m) }
func (*PolicerStatus) ProtoMessage()    {}
func (*PolicerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{3}
}
func (m *PolicerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerStatus.Merge(m, src)
}
func (m *PolicerStatus) XXX_Size() int {
	return m.Size()
}
func (m *PolicerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerStatus proto.InternalMessageInfo

func (m *PolicerStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

// stats of the policer, if any
type PolicerStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicerStats) Reset()         { *m = PolicerStats{} }
func (m *PolicerStats) String() string { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()    {}
func (*PolicerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{4}
}
func (m *PolicerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerStats.Merge(m, src)
}
func (m *PolicerStats) XXX_Size() int {
	return m.Size()
}
func (m *PolicerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerStats.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerStats proto.InternalMessageInfo

// Policer policy object
type Policer struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *PolicerSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *PolicerStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *PolicerStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Policer) Reset()         { *m = Policer{} }
func (m *Policer) String() string { return proto.CompactTextString(m) }
func (*Policer) ProtoMessage()    {}
func (*Policer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{5}
}
func (m *Policer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policer.Merge(m, src)
}
func (m *Policer) XXX_Size() int {
	return m.Size()
}
func (m *Policer) XXX_DiscardUnknown() {
	xxx_messageInfo_Policer.DiscardUnknown(m)
}

var xxx_messageInfo_Policer proto.InternalMessageInfo

func (m *Policer) GetSpec() *PolicerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Policer) GetStatus() *PolicerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Policer) GetStats() *PolicerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// policer table create and update request
type PolicerRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Request              []*PolicerSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PolicerRequest) Reset()         { *m = PolicerRequest{} }
func (m *PolicerRequest) String() string { return proto.CompactTextString(m) }
func (*PolicerRequest) ProtoMessage()    {}
func (*PolicerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{6}
}
func (m *PolicerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerRequest.Merge(m, src)
}
func (m *PolicerRequest) XXX_Size() int {
	return m.Size()
}
func (m *PolicerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerRequest proto.InternalMessageInfo

func (m *PolicerRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *PolicerRequest) GetRequest() []*PolicerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// policer table create and update response
type PolicerResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*PolicerStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PolicerResponse) Reset()         { *m = PolicerResponse{} }
func (m *PolicerResponse) String() string { return proto.CompactTextString(m) }
func (*PolicerResponse) ProtoMessage()    {}
func (*PolicerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{7}
}
func (m *PolicerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerResponse.Merge(m, src)
}
func (m *PolicerResponse) XXX_Size() int {
	return m.Size()
}
func (m *PolicerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerResponse proto.InternalMessageInfo

func (m *PolicerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *PolicerResponse) GetResponse() []*PolicerStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// policer table get request
type PolicerGetRequest struct {
	// batched request
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicerGetRequest) Reset()         { *m = PolicerGetRequest{} }
func (m *PolicerGetRequest) String() string { return proto.CompactTextString(m) }
func (*PolicerGetRequest) ProtoMessage()    {}
func (*PolicerGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{8}
}
func (m *PolicerGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerGetRequest.Merge(m, src)
}
func (m *PolicerGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *PolicerGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerGetRequest proto.InternalMessageInfo

func (m *PolicerGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// policer table get response
type PolicerGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Policer `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PolicerGetResponse) Reset()         { *m = PolicerGetResponse{} }
func (m *PolicerGetResponse) String() string { return proto.CompactTextString(m) }
func (*PolicerGetResponse) ProtoMessage()    {}
func (*PolicerGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{9}
}
func (m *PolicerGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerGetResponse.Merge(m, src)
}
func (m *PolicerGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *PolicerGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerGetResponse proto.InternalMessageInfo

func (m *PolicerGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *PolicerGetResponse) GetResponse() []*Policer {
	if m != nil {
		return m.Response
	}
	return nil
}

// policer table delete request
type PolicerDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Id                   [][]byte `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicerDeleteRequest) Reset()         { *m = PolicerDeleteRequest{} }
func (m *PolicerDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*PolicerDeleteRequest) ProtoMessage()    {}
func (*PolicerDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{10}
}
func (m *PolicerDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerDeleteRequest.Merge(m, src)
}
func (m *PolicerDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *PolicerDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerDeleteRequest proto.InternalMessageInfo

func (m *PolicerDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *PolicerDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// policer table delete response
type PolicerDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PolicerDeleteResponse) Reset()         { *m = PolicerDeleteResponse{} }
func (m *PolicerDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*PolicerDeleteResponse) ProtoMessage()    {}
func (*PolicerDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f2a9cdc5bf69f7d, []int{11}
}
func (m *PolicerDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicerDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicerDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerDeleteResponse.Merge(m, src)
}
func (m *PolicerDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *PolicerDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerDeleteResponse proto.InternalMessageInfo

func (m *PolicerDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.PolicerDir", PolicerDir_name, PolicerDir_value)
	proto.RegisterType((*PacketPolicerSpec)(nil), "pds.PacketPolicerSpec")
	proto.RegisterType((*BytePolicerSpec)(nil), "pds.BytePolicerSpec")
	proto.RegisterType((*PolicerSpec)(nil), "pds.PolicerSpec")
	proto.RegisterType((*PolicerStatus)(nil), "pds.PolicerStatus")
	proto.RegisterType((*PolicerStats)(nil), "pds.PolicerStats")
	proto.RegisterType((*Policer)(nil), "pds.Policer")
	proto.RegisterType((*PolicerRequest)(nil), "pds.PolicerRequest")
	proto.RegisterType((*PolicerResponse)(nil), "pds.PolicerResponse")
	proto.RegisterType((*PolicerGetRequest)(nil), "pds.PolicerGetRequest")
	proto.RegisterType((*PolicerGetResponse)(nil), "pds.PolicerGetResponse")
	proto.RegisterType((*PolicerDeleteRequest)(nil), "pds.PolicerDeleteRequest")
	proto.RegisterType((*PolicerDeleteResponse)(nil), "pds.PolicerDeleteResponse")
}

func init() { proto.RegisterFile("policer.proto", fileDescriptor_1f2a9cdc5bf69f7d) }

var fileDescriptor_1f2a9cdc5bf69f7d = []byte{
	// 744 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xcf, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0xb1, 0x13, 0x08, 0x9c, 0xfc, 0x65, 0xc8, 0x0d, 0xb9, 0xd1, 0x15, 0x41, 0x66, 0x13,
	0xa1, 0x28, 0x57, 0x4a, 0xa5, 0x0a, 0x51, 0x54, 0x5a, 0x43, 0x14, 0xa2, 0xb6, 0x10, 0x4d, 0xda,
	0x6e, 0x91, 0x71, 0x46, 0xd4, 0x6d, 0x62, 0x1b, 0x7b, 0x52, 0x9a, 0x45, 0x97, 0x7d, 0x82, 0x3e,
	0x51, 0x77, 0x5d, 0xf2, 0x04, 0x51, 0xc5, 0x92, 0x25, 0x4f, 0x50, 0x79, 0x66, 0x6c, 0x4f, 0x42,
	0x2a, 0x0a, 0x1b, 0x14, 0xbe, 0xf9, 0x7e, 0xe7, 0xcc, 0xf9, 0x66, 0x26, 0x81, 0xac, 0xeb, 0x0c,
	0x2c, 0x93, 0x78, 0x0d, 0xd7, 0x73, 0xa8, 0x83, 0x12, 0x6e, 0xdf, 0xaf, 0xc0, 0xb9, 0x73, 0xee,
	0x70, 0xa1, 0x92, 0x1f, 0x12, 0x6a, 0xfc, 0x1f, 0xfc, 0x11, 0x42, 0x9a, 0x8e, 0x5d, 0xe2, 0xf3,
	0x7f, 0xb4, 0xaf, 0xb0, 0xda, 0x35, 0xcc, 0x4f, 0x84, 0x76, 0x79, 0x95, 0x9e, 0x4b, 0x4c, 0xf4,
	0x1c, 0x0a, 0x5c, 0xf4, 0xbb, 0xc4, 0xeb, 0x11, 0xd3, 0xb1, 0xfb, 0x65, 0x65, 0x53, 0xa9, 0x25,
	0x75, 0x74, 0x3b, 0xa9, 0xe6, 0x82, 0x5a, 0xbb, 0x43, 0xc3, 0xee, 0x1b, 0xd4, 0xf1, 0xc6, 0xf8,
	0x8e, 0x17, 0xd5, 0x60, 0x51, 0x1f, 0x79, 0x3e, 0x2d, 0xab, 0x7f, 0x84, 0xb8, 0x41, 0xbb, 0x84,
	0xbc, 0x3e, 0xa6, 0x44, 0x6e, 0xbe, 0x0b, 0xb9, 0x40, 0xfa, 0xab, 0xd6, 0x33, 0xce, 0x07, 0x34,
	0xfe, 0xa6, 0x42, 0x5a, 0xee, 0x5a, 0x07, 0xb5, 0xc3, 0x3b, 0x65, 0xf4, 0xff, 0x6e, 0x27, 0xd5,
	0xf2, 0x34, 0x56, 0xb7, 0x86, 0xc3, 0x11, 0x35, 0xce, 0x06, 0x04, 0xab, 0x9d, 0x3e, 0x7a, 0x05,
	0x2b, 0x87, 0x96, 0x47, 0x4c, 0x6a, 0x39, 0x36, 0xeb, 0x95, 0x6b, 0xe6, 0x1b, 0x6e, 0xdf, 0x6f,
	0x88, 0x92, 0x87, 0x96, 0x77, 0x4f, 0x95, 0x98, 0x47, 0x3b, 0x00, 0xdd, 0x6e, 0x4f, 0x90, 0xe5,
	0xc4, 0xa6, 0x52, 0x4b, 0x37, 0x4b, 0xbc, 0xda, 0xec, 0xc9, 0x1c, 0x2d, 0x60, 0xc9, 0x8b, 0x9e,
	0x02, 0xe8, 0x31, 0x99, 0x64, 0x64, 0x91, 0x91, 0x33, 0xa1, 0x06, 0x5c, 0xec, 0xd4, 0x57, 0x20,
	0x25, 0x2e, 0x8d, 0xb6, 0x05, 0xd9, 0xd0, 0x47, 0x0d, 0x3a, 0xf2, 0x11, 0x82, 0xe4, 0xd1, 0xa5,
	0x88, 0x22, 0x8b, 0xd9, 0x67, 0x2d, 0x07, 0x19, 0xc9, 0xe4, 0x6b, 0x3f, 0x54, 0x48, 0x85, 0x7b,
	0x78, 0x06, 0xcb, 0x6f, 0xc7, 0x2e, 0x79, 0x43, 0xa8, 0xc1, 0x98, 0x74, 0x33, 0xd7, 0x60, 0x97,
	0x2d, 0x54, 0xf5, 0xfc, 0xd5, 0xa4, 0xaa, 0xdc, 0x4c, 0xaa, 0xa9, 0xba, 0x65, 0x0f, 0x2c, 0x9b,
	0xe0, 0x08, 0x40, 0xfb, 0x90, 0x3a, 0x39, 0xfb, 0xc8, 0x58, 0x95, 0xb1, 0x59, 0xce, 0x0a, 0x51,
	0x2f, 0x09, 0x94, 0x1d, 0x62, 0xdd, 0x19, 0x5a, 0x94, 0x0c, 0x5d, 0x3a, 0xc6, 0x21, 0x85, 0x76,
	0x20, 0x19, 0xcc, 0x27, 0x52, 0x2b, 0xc8, 0x67, 0x10, 0xe8, 0x3a, 0x0a, 0x60, 0xdf, 0x25, 0xa6,
	0x04, 0x33, 0x02, 0xbd, 0x80, 0x25, 0x3e, 0xb1, 0xc8, 0x0d, 0x4d, 0xb1, 0x6c, 0x45, 0x2f, 0xde,
	0x4c, 0xaa, 0x05, 0x9f, 0x7d, 0x96, 0x78, 0xc1, 0xa1, 0x3d, 0x58, 0x64, 0x71, 0x94, 0x17, 0x59,
	0x81, 0xd5, 0xd9, 0x02, 0xbe, 0xbe, 0x76, 0x33, 0xa9, 0xe6, 0x03, 0x5e, 0xc6, 0x39, 0xa4, 0x0d,
	0x20, 0x27, 0xbc, 0x98, 0x5c, 0x8c, 0x88, 0x4f, 0x51, 0x03, 0x56, 0x74, 0x83, 0x9a, 0x1f, 0x0e,
	0xe8, 0x17, 0x2a, 0xa2, 0x2c, 0x34, 0xf8, 0x5b, 0x8d, 0x74, 0x1c, 0x5b, 0xd0, 0x36, 0xa4, 0x04,
	0x5a, 0x56, 0x37, 0x13, 0xf3, 0xc6, 0xc7, 0xa1, 0x41, 0xbb, 0x80, 0x7c, 0xd4, 0xcd, 0x77, 0x1d,
	0xdb, 0x27, 0x41, 0xbb, 0x97, 0xae, 0x25, 0x32, 0x50, 0xd8, 0x1d, 0x0e, 0xdb, 0x45, 0x3a, 0x8e,
	0x2d, 0xa8, 0x01, 0xcb, 0x21, 0x2b, 0xfa, 0xcd, 0x89, 0x0c, 0x47, 0x1e, 0x6d, 0x0b, 0x56, 0xc5,
	0x52, 0x9b, 0xd0, 0x70, 0xc6, 0x9c, 0x78, 0x66, 0x89, 0x5a, 0x26, 0x78, 0x48, 0x9a, 0x0d, 0x48,
	0x36, 0x3d, 0x72, 0x6b, 0xb5, 0x3b, 0x5b, 0xcb, 0xc8, 0x5b, 0x93, 0x36, 0xf5, 0x1e, 0x8a, 0xe1,
	0x13, 0x25, 0x03, 0x42, 0xc9, 0x63, 0xb3, 0xe7, 0x73, 0xa8, 0xd1, 0x1c, 0x6d, 0xf8, 0x67, 0xa6,
	0xee, 0xfc, 0x51, 0x12, 0xf7, 0x8c, 0xb2, 0xdd, 0x03, 0x88, 0xbf, 0x43, 0x50, 0x11, 0x0a, 0xdd,
	0x93, 0xd7, 0x9d, 0x83, 0x16, 0x3e, 0x3d, 0xec, 0xe0, 0xd3, 0xe3, 0x93, 0xe3, 0x56, 0x61, 0x01,
	0xad, 0xc3, 0x9a, 0xac, 0x76, 0x8e, 0xdb, 0xb8, 0xd5, 0xeb, 0x15, 0x14, 0x54, 0x02, 0x24, 0x2f,
	0xb4, 0xb8, 0xae, 0x36, 0xbf, 0xab, 0x51, 0xd5, 0xde, 0x67, 0x13, 0xed, 0x45, 0x6f, 0xfe, 0xc0,
	0x23, 0x06, 0x25, 0x68, 0x6d, 0x2a, 0x2d, 0x1e, 0x49, 0xa5, 0x38, 0x2d, 0x8a, 0x00, 0x17, 0x24,
	0xfa, 0x9d, 0xdb, 0x7f, 0x30, 0xbd, 0x1f, 0xed, 0xa4, 0x4d, 0x28, 0x2a, 0xc9, 0xae, 0xf8, 0x9a,
	0x54, 0xd6, 0xef, 0xe8, 0x51, 0x81, 0xa3, 0xa8, 0x3d, 0x4f, 0x1a, 0xfd, 0x3b, 0xf5, 0xc5, 0x2b,
	0x9f, 0x6a, 0xa5, 0x32, 0x6f, 0x29, 0xac, 0xa4, 0x67, 0x7e, 0x5e, 0x6f, 0x28, 0x57, 0xd7, 0x1b,
	0xca, 0xaf, 0xeb, 0x0d, 0xe5, 0x6c, 0x89, 0xfd, 0x1e, 0x3e, 0xf9, 0x1d, 0x00, 0x00, 0xff, 0xff,
	0xd7, 0x36, 0x4e, 0xc2, 0x4f, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PolicerSvcClient is the client API for PolicerSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PolicerSvcClient interface {
	PolicerCreate(ctx context.Context, in *PolicerRequest, opts ...grpc.CallOption) (*PolicerResponse, error)
	PolicerUpdate(ctx context.Context, in *PolicerRequest, opts ...grpc.CallOption) (*PolicerResponse, error)
	PolicerGet(ctx context.Context, in *PolicerGetRequest, opts ...grpc.CallOption) (*PolicerGetResponse, error)
	PolicerDelete(ctx context.Context, in *PolicerDeleteRequest, opts ...grpc.CallOption) (*PolicerDeleteResponse, error)
}

type policerSvcClient struct {
	cc *grpc.ClientConn
}

func NewPolicerSvcClient(cc *grpc.ClientConn) PolicerSvcClient {
	return &policerSvcClient{cc}
}

func (c *policerSvcClient) PolicerCreate(ctx context.Context, in *PolicerRequest, opts ...grpc.CallOption) (*PolicerResponse, error) {
	out := new(PolicerResponse)
	err := c.cc.Invoke(ctx, "/pds.PolicerSvc/PolicerCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policerSvcClient) PolicerUpdate(ctx context.Context, in *PolicerRequest, opts ...grpc.CallOption) (*PolicerResponse, error) {
	out := new(PolicerResponse)
	err := c.cc.Invoke(ctx, "/pds.PolicerSvc/PolicerUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policerSvcClient) PolicerGet(ctx context.Context, in *PolicerGetRequest, opts ...grpc.CallOption) (*PolicerGetResponse, error) {
	out := new(PolicerGetResponse)
	err := c.cc.Invoke(ctx, "/pds.PolicerSvc/PolicerGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policerSvcClient) PolicerDelete(ctx context.Context, in *PolicerDeleteRequest, opts ...grpc.CallOption) (*PolicerDeleteResponse, error) {
	out := new(PolicerDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.PolicerSvc/PolicerDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicerSvcServer is the server API for PolicerSvc service.
type PolicerSvcServer interface {
	PolicerCreate(context.Context, *PolicerRequest) (*PolicerResponse, error)
	PolicerUpdate(context.Context, *PolicerRequest) (*PolicerResponse, error)
	PolicerGet(context.Context, *PolicerGetRequest) (*PolicerGetResponse, error)
	PolicerDelete(context.Context, *PolicerDeleteRequest) (*PolicerDeleteResponse, error)
}

// UnimplementedPolicerSvcServer can be embedded to have forward compatible implementations.
type UnimplementedPolicerSvcServer struct {
}

func (*UnimplementedPolicerSvcServer) PolicerCreate(ctx context.Context, req *PolicerRequest) (*PolicerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicerCreate not implemented")
}
func (*UnimplementedPolicerSvcServer) PolicerUpdate(ctx context.Context, req *PolicerRequest) (*PolicerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicerUpdate not implemented")
}
func (*UnimplementedPolicerSvcServer) PolicerGet(ctx context.Context, req *PolicerGetRequest) (*PolicerGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicerGet not implemented")
}
func (*UnimplementedPolicerSvcServer) PolicerDelete(ctx context.Context, req *PolicerDeleteRequest) (*PolicerDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicerDelete not implemented")
}

func RegisterPolicerSvcServer(s *grpc.Server, srv PolicerSvcServer) {
	s.RegisterService(&_PolicerSvc_serviceDesc, srv)
}

func _PolicerSvc_PolicerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicerSvcServer).PolicerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.PolicerSvc/PolicerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicerSvcServer).PolicerCreate(ctx, req.(*PolicerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicerSvc_PolicerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicerSvcServer).PolicerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.PolicerSvc/PolicerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicerSvcServer).PolicerUpdate(ctx, req.(*PolicerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicerSvc_PolicerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicerSvcServer).PolicerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.PolicerSvc/PolicerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicerSvcServer).PolicerGet(ctx, req.(*PolicerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicerSvc_PolicerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicerSvcServer).PolicerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.PolicerSvc/PolicerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicerSvcServer).PolicerDelete(ctx, req.(*PolicerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PolicerSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.PolicerSvc",
	HandlerType: (*PolicerSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PolicerCreate",
			Handler:    _PolicerSvc_PolicerCreate_Handler,
		},
		{
			MethodName: "PolicerUpdate",
			Handler:    _PolicerSvc_PolicerUpdate_Handler,
		},
		{
			MethodName: "PolicerGet",
			Handler:    _PolicerSvc_PolicerGet_Handler,
		},
		{
			MethodName: "PolicerDelete",
			Handler:    _PolicerSvc_PolicerDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "policer.proto",
}

func (m *PacketPolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketPolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketPolicerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Burst != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.Burst))
		i--
		dAtA[i] = 0x10
	}
	if m.PacketsPerSecond != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.PacketsPerSecond))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BytePolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BytePolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BytePolicerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Burst != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.Burst))
		i--
		dAtA[i] = 0x10
	}
	if m.BytesPerSecond != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.BytesPerSecond))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policer != nil {
		{
			size := m.Policer.Size()
			i -= size
			if _, err := m.Policer.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Direction != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPolicer(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicerSpec_PPSPolicer) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PolicerSpec_PPSPolicer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PPSPolicer != nil {
		{
			size, err := m.PPSPolicer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PolicerSpec_BPSPolicer) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PolicerSpec_BPSPolicer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BPSPolicer != nil {
		{
			size, err := m.BPSPolicer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PolicerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HwId != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Policer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicer(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PolicerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPolicer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintPolicer(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintPolicer(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPolicer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA11 := make([]byte, len(m.ApiStatus)*10)
		var j10 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintPolicer(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPolicer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPolicer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PacketPolicerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketsPerSecond != 0 {
		n += 1 + sovPolicer(uint64(m.PacketsPerSecond))
	}
	if m.Burst != 0 {
		n += 1 + sovPolicer(uint64(m.Burst))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BytePolicerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesPerSecond != 0 {
		n += 1 + sovPolicer(uint64(m.BytesPerSecond))
	}
	if m.Burst != 0 {
		n += 1 + sovPolicer(uint64(m.Burst))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovPolicer(uint64(m.Direction))
	}
	if m.Policer != nil {
		n += m.Policer.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerSpec_PPSPolicer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PPSPolicer != nil {
		l = m.PPSPolicer.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	return n
}
func (m *PolicerSpec_BPSPolicer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BPSPolicer != nil {
		l = m.BPSPolicer.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	return n
}
func (m *PolicerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovPolicer(uint64(m.HwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Policer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovPolicer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicer(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovPolicer(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovPolicer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovPolicer(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovPolicer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicerDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovPolicer(uint64(e))
		}
		n += 1 + sovPolicer(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPolicer(x uint64) (n int) {
	return sovPolicer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PacketPolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketPolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketPolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsPerSecond", wireType)
			}
			m.PacketsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsPerSecond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burst", wireType)
			}
			m.Burst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Burst |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BytePolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytePolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytePolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerSecond", wireType)
			}
			m.BytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPerSecond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burst", wireType)
			}
			m.Burst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Burst |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= PolicerDir(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PPSPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PacketPolicerSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Policer = &PolicerSpec_PPSPolicer{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPSPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BytePolicerSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Policer = &PolicerSpec_BPSPolicer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PolicerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PolicerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PolicerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &PolicerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &PolicerStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Policer{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPolicer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPolicer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicer
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPolicer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPolicer
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicer   = fmt.Errorf("proto: integer overflow")
)
