// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: evpn.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EVPN RD/RT config types - manual or auto-generated
type EvpnCfg int32

const (
	EvpnCfg_EVPN_CFG_NONE   EvpnCfg = 0
	EvpnCfg_EVPN_CFG_MANUAL EvpnCfg = 1
	EvpnCfg_EVPN_CFG_AUTO   EvpnCfg = 2
)

var EvpnCfg_name = map[int32]string{
	0: "EVPN_CFG_NONE",
	1: "EVPN_CFG_MANUAL",
	2: "EVPN_CFG_AUTO",
}

var EvpnCfg_value = map[string]int32{
	"EVPN_CFG_NONE":   0,
	"EVPN_CFG_MANUAL": 1,
	"EVPN_CFG_AUTO":   2,
}

func (x EvpnCfg) String() string {
	return proto.EnumName(EvpnCfg_name, int32(x))
}

func (EvpnCfg) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{0}
}

// EVPN route-target import/export type
type EvpnRtType int32

const (
	EvpnRtType_EVPN_RT_NONE          EvpnRtType = 0
	EvpnRtType_EVPN_RT_IMPORT        EvpnRtType = 1
	EvpnRtType_EVPN_RT_EXPORT        EvpnRtType = 2
	EvpnRtType_EVPN_RT_IMPORT_EXPORT EvpnRtType = 3
)

var EvpnRtType_name = map[int32]string{
	0: "EVPN_RT_NONE",
	1: "EVPN_RT_IMPORT",
	2: "EVPN_RT_EXPORT",
	3: "EVPN_RT_IMPORT_EXPORT",
}

var EvpnRtType_value = map[string]int32{
	"EVPN_RT_NONE":          0,
	"EVPN_RT_IMPORT":        1,
	"EVPN_RT_EXPORT":        2,
	"EVPN_RT_IMPORT_EXPORT": 3,
}

func (x EvpnRtType) String() string {
	return proto.EnumName(EvpnRtType_name, int32(x))
}

func (EvpnRtType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{1}
}

// EVPN route source local/remote
type EvpnSource int32

const (
	EvpnSource_EVPN_SOURCE_NONE   EvpnSource = 0
	EvpnSource_EVPN_SOURCE_LOCAL  EvpnSource = 1
	EvpnSource_EVPN_SOURCE_REMOTE EvpnSource = 2
)

var EvpnSource_name = map[int32]string{
	0: "EVPN_SOURCE_NONE",
	1: "EVPN_SOURCE_LOCAL",
	2: "EVPN_SOURCE_REMOTE",
}

var EvpnSource_value = map[string]int32{
	"EVPN_SOURCE_NONE":   0,
	"EVPN_SOURCE_LOCAL":  1,
	"EVPN_SOURCE_REMOTE": 2,
}

func (x EvpnSource) String() string {
	return proto.EnumName(EvpnSource_name, int32(x))
}

func (EvpnSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{2}
}

// EVPN operational status
type EvpnOperStatus int32

const (
	EvpnOperStatus_EVPN_OPER_STATUS_NONE       EvpnOperStatus = 0
	EvpnOperStatus_EVPN_OPER_STATUS_UP         EvpnOperStatus = 1
	EvpnOperStatus_EVPN_OPER_STATUS_DOWN       EvpnOperStatus = 2
	EvpnOperStatus_EVPN_OPER_STATUS_GOING_UP   EvpnOperStatus = 3
	EvpnOperStatus_EVPN_OPER_STATUS_GOING_DOWN EvpnOperStatus = 4
	EvpnOperStatus_EVPN_OPER_STATUS_ACT_FAILED EvpnOperStatus = 5
	EvpnOperStatus_EVPN_OPER_STATUS_QUIESCING  EvpnOperStatus = 6
	EvpnOperStatus_EVPN_OPER_STATUS_NOT_READY  EvpnOperStatus = 7
	EvpnOperStatus_EVPN_OPER_STATUS_FAILED     EvpnOperStatus = 8
	EvpnOperStatus_EVPN_OPER_STATUS_PRNT_FAILD EvpnOperStatus = 9
	EvpnOperStatus_EVPN_OPER_STATUS_FAILD_PERM EvpnOperStatus = 10
	EvpnOperStatus_EVPN_OPER_STATUS_FAILING    EvpnOperStatus = 11
)

var EvpnOperStatus_name = map[int32]string{
	0:  "EVPN_OPER_STATUS_NONE",
	1:  "EVPN_OPER_STATUS_UP",
	2:  "EVPN_OPER_STATUS_DOWN",
	3:  "EVPN_OPER_STATUS_GOING_UP",
	4:  "EVPN_OPER_STATUS_GOING_DOWN",
	5:  "EVPN_OPER_STATUS_ACT_FAILED",
	6:  "EVPN_OPER_STATUS_QUIESCING",
	7:  "EVPN_OPER_STATUS_NOT_READY",
	8:  "EVPN_OPER_STATUS_FAILED",
	9:  "EVPN_OPER_STATUS_PRNT_FAILD",
	10: "EVPN_OPER_STATUS_FAILD_PERM",
	11: "EVPN_OPER_STATUS_FAILING",
}

var EvpnOperStatus_value = map[string]int32{
	"EVPN_OPER_STATUS_NONE":       0,
	"EVPN_OPER_STATUS_UP":         1,
	"EVPN_OPER_STATUS_DOWN":       2,
	"EVPN_OPER_STATUS_GOING_UP":   3,
	"EVPN_OPER_STATUS_GOING_DOWN": 4,
	"EVPN_OPER_STATUS_ACT_FAILED": 5,
	"EVPN_OPER_STATUS_QUIESCING":  6,
	"EVPN_OPER_STATUS_NOT_READY":  7,
	"EVPN_OPER_STATUS_FAILED":     8,
	"EVPN_OPER_STATUS_PRNT_FAILD": 9,
	"EVPN_OPER_STATUS_FAILD_PERM": 10,
	"EVPN_OPER_STATUS_FAILING":    11,
}

func (x EvpnOperStatus) String() string {
	return proto.EnumName(EvpnOperStatus_name, int32(x))
}

func (EvpnOperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{3}
}

type EvpnOperReason int32

const (
	EvpnOperReason_EVPN_OPER_REASON_INVALID    EvpnOperReason = 0
	EvpnOperReason_EVPN_OPER_REASON_NONE       EvpnOperReason = 1
	EvpnOperReason_EVPN_ENTITY_NOT_UP          EvpnOperReason = 2
	EvpnOperReason_EVPN_ADMIN_CONFIG           EvpnOperReason = 3
	EvpnOperReason_EVPN_RESOURCE_FAILURE       EvpnOperReason = 4
	EvpnOperReason_EVPN_NO_IF_INFO             EvpnOperReason = 5
	EvpnOperReason_EVPN_EVI_NOT_UP             EvpnOperReason = 6
	EvpnOperReason_EVPN_BD_NOT_UP              EvpnOperReason = 7
	EvpnOperReason_EVPN_NO_ROUTE_DISTINGUISHER EvpnOperReason = 8
	EvpnOperReason_EVPN_ROUTE_DIST_CLASH       EvpnOperReason = 9
	EvpnOperReason_EVPN_NO_ESI                 EvpnOperReason = 10
	EvpnOperReason_EVPN_BAD_VNI                EvpnOperReason = 11
	EvpnOperReason_EVPN_VNI_CLASH              EvpnOperReason = 12
	EvpnOperReason_EVPN_VLAN_SUB_IF_EVI_CLASH  EvpnOperReason = 13
	EvpnOperReason_EVPN_NO_BGP_ID              EvpnOperReason = 14
	EvpnOperReason_EVPN_RT_TYPE_CLASH          EvpnOperReason = 15
	EvpnOperReason_EVPN_NO_RT                  EvpnOperReason = 16
	EvpnOperReason_EVPN_IP_VRF_NOT_UP          EvpnOperReason = 17
	EvpnOperReason_EVPN_NO_SYSTEM_MAC          EvpnOperReason = 18
	EvpnOperReason_EVPN_RT_CLASH               EvpnOperReason = 19
	EvpnOperReason_EVPN_NO_MCAST_GROUP         EvpnOperReason = 20
	EvpnOperReason_EVPN_NO_SOURCE_IP           EvpnOperReason = 21
	EvpnOperReason_EVPN_BAD_TNNL_DEST_TYPE     EvpnOperReason = 22
	EvpnOperReason_EVPN_NO_ROUTERS_MAC         EvpnOperReason = 23
)

var EvpnOperReason_name = map[int32]string{
	0:  "EVPN_OPER_REASON_INVALID",
	1:  "EVPN_OPER_REASON_NONE",
	2:  "EVPN_ENTITY_NOT_UP",
	3:  "EVPN_ADMIN_CONFIG",
	4:  "EVPN_RESOURCE_FAILURE",
	5:  "EVPN_NO_IF_INFO",
	6:  "EVPN_EVI_NOT_UP",
	7:  "EVPN_BD_NOT_UP",
	8:  "EVPN_NO_ROUTE_DISTINGUISHER",
	9:  "EVPN_ROUTE_DIST_CLASH",
	10: "EVPN_NO_ESI",
	11: "EVPN_BAD_VNI",
	12: "EVPN_VNI_CLASH",
	13: "EVPN_VLAN_SUB_IF_EVI_CLASH",
	14: "EVPN_NO_BGP_ID",
	15: "EVPN_RT_TYPE_CLASH",
	16: "EVPN_NO_RT",
	17: "EVPN_IP_VRF_NOT_UP",
	18: "EVPN_NO_SYSTEM_MAC",
	19: "EVPN_RT_CLASH",
	20: "EVPN_NO_MCAST_GROUP",
	21: "EVPN_NO_SOURCE_IP",
	22: "EVPN_BAD_TNNL_DEST_TYPE",
	23: "EVPN_NO_ROUTERS_MAC",
}

var EvpnOperReason_value = map[string]int32{
	"EVPN_OPER_REASON_INVALID":    0,
	"EVPN_OPER_REASON_NONE":       1,
	"EVPN_ENTITY_NOT_UP":          2,
	"EVPN_ADMIN_CONFIG":           3,
	"EVPN_RESOURCE_FAILURE":       4,
	"EVPN_NO_IF_INFO":             5,
	"EVPN_EVI_NOT_UP":             6,
	"EVPN_BD_NOT_UP":              7,
	"EVPN_NO_ROUTE_DISTINGUISHER": 8,
	"EVPN_ROUTE_DIST_CLASH":       9,
	"EVPN_NO_ESI":                 10,
	"EVPN_BAD_VNI":                11,
	"EVPN_VNI_CLASH":              12,
	"EVPN_VLAN_SUB_IF_EVI_CLASH":  13,
	"EVPN_NO_BGP_ID":              14,
	"EVPN_RT_TYPE_CLASH":          15,
	"EVPN_NO_RT":                  16,
	"EVPN_IP_VRF_NOT_UP":          17,
	"EVPN_NO_SYSTEM_MAC":          18,
	"EVPN_RT_CLASH":               19,
	"EVPN_NO_MCAST_GROUP":         20,
	"EVPN_NO_SOURCE_IP":           21,
	"EVPN_BAD_TNNL_DEST_TYPE":     22,
	"EVPN_NO_ROUTERS_MAC":         23,
}

func (x EvpnOperReason) String() string {
	return proto.EnumName(EvpnOperReason_name, int32(x))
}

func (EvpnOperReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{4}
}

// EVPN EVI configuration
type EvpnEviSpec struct {
	// unique key/identifier of EVPN EVI
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to subnet
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory,immutable`
	// manual or auto route-distinguisher
	AutoRD EvpnCfg `protobuf:"varint,3,opt,name=AutoRD,proto3,enum=pds.EvpnCfg" json:"AutoRD,omitempty"`
	// 8 byte route-distinguisher, in case of manual configuration
	RD []byte `protobuf:"bytes,4,opt,name=RD,proto3" json:"RD,omitempty"`
	// manual or auto route-target. in case of manual route-target,
	// route-targets should be configured with EvpnEviRtSpec
	AutoRT EvpnCfg `protobuf:"varint,5,opt,name=AutoRT,proto3,enum=pds.EvpnCfg" json:"AutoRT,omitempty"`
	// route-target type, applicable to auto route-targets only
	RTType               EvpnRtType `protobuf:"varint,6,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnEviSpec) Reset()         { *m = EvpnEviSpec{} }
func (m *EvpnEviSpec) String() string { return proto.CompactTextString(m) }
func (*EvpnEviSpec) ProtoMessage()    {}
func (*EvpnEviSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{0}
}
func (m *EvpnEviSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviSpec.Merge(m, src)
}
func (m *EvpnEviSpec) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviSpec proto.InternalMessageInfo

func (m *EvpnEviSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnEviSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviSpec) GetAutoRD() EvpnCfg {
	if m != nil {
		return m.AutoRD
	}
	return EvpnCfg_EVPN_CFG_NONE
}

func (m *EvpnEviSpec) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *EvpnEviSpec) GetAutoRT() EvpnCfg {
	if m != nil {
		return m.AutoRT
	}
	return EvpnCfg_EVPN_CFG_NONE
}

func (m *EvpnEviSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN EVI, if any
type EvpnEviStatus struct {
	// in use route-distinguisher of the EVI
	RD []byte `protobuf:"bytes,1,opt,name=RD,proto3" json:"RD,omitempty"`
	// oper status
	Status EvpnOperStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=pds.EvpnOperStatus" json:"Status,omitempty"`
	// reason if the current opertional status is not active
	OperReason           EvpnOperReason `protobuf:"varint,3,opt,name=OperReason,proto3,enum=pds.EvpnOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnEviStatus) Reset()         { *m = EvpnEviStatus{} }
func (m *EvpnEviStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnEviStatus) ProtoMessage()    {}
func (*EvpnEviStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{1}
}
func (m *EvpnEviStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviStatus.Merge(m, src)
}
func (m *EvpnEviStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviStatus proto.InternalMessageInfo

func (m *EvpnEviStatus) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *EvpnEviStatus) GetStatus() EvpnOperStatus {
	if m != nil {
		return m.Status
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

func (m *EvpnEviStatus) GetOperReason() EvpnOperReason {
	if m != nil {
		return m.OperReason
	}
	return EvpnOperReason_EVPN_OPER_REASON_INVALID
}

// EVPN EVI object
type EvpnEvi struct {
	Spec                 *EvpnEviSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *EvpnEviStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnEvi) Reset()         { *m = EvpnEvi{} }
func (m *EvpnEvi) String() string { return proto.CompactTextString(m) }
func (*EvpnEvi) ProtoMessage()    {}
func (*EvpnEvi) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{2}
}
func (m *EvpnEvi) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEvi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEvi.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEvi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEvi.Merge(m, src)
}
func (m *EvpnEvi) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEvi) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEvi.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEvi proto.InternalMessageInfo

func (m *EvpnEvi) GetSpec() *EvpnEviSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnEvi) GetStatus() *EvpnEviStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN EVI create and update response
type EvpnEviResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnEviResponse) Reset()         { *m = EvpnEviResponse{} }
func (m *EvpnEviResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviResponse) ProtoMessage()    {}
func (*EvpnEviResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{3}
}
func (m *EvpnEviResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviResponse.Merge(m, src)
}
func (m *EvpnEviResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviResponse proto.InternalMessageInfo

func (m *EvpnEviResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI create and update request
type EvpnEviRequest struct {
	Request              []*EvpnEviSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnEviRequest) Reset()         { *m = EvpnEviRequest{} }
func (m *EvpnEviRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRequest) ProtoMessage()    {}
func (*EvpnEviRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{4}
}
func (m *EvpnEviRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRequest.Merge(m, src)
}
func (m *EvpnEviRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRequest proto.InternalMessageInfo

func (m *EvpnEviRequest) GetRequest() []*EvpnEviSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI key parameters
type EvpnEviKey struct {
	// reference to subnet spec
	SubnetId             []byte   `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnEviKey) Reset()         { *m = EvpnEviKey{} }
func (m *EvpnEviKey) String() string { return proto.CompactTextString(m) }
func (*EvpnEviKey) ProtoMessage()    {}
func (*EvpnEviKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{5}
}
func (m *EvpnEviKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviKey.Merge(m, src)
}
func (m *EvpnEviKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviKey proto.InternalMessageInfo

func (m *EvpnEviKey) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

// EVPN EVI key handle for get and delete
type EvpnEviKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnEviKeyHandle_Id
	//	*EvpnEviKeyHandle_Key
	IdOrKey              isEvpnEviKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *EvpnEviKeyHandle) Reset()         { *m = EvpnEviKeyHandle{} }
func (m *EvpnEviKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnEviKeyHandle) ProtoMessage()    {}
func (*EvpnEviKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{6}
}
func (m *EvpnEviKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviKeyHandle.Merge(m, src)
}
func (m *EvpnEviKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviKeyHandle proto.InternalMessageInfo

type isEvpnEviKeyHandle_IdOrKey interface {
	isEvpnEviKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnEviKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnEviKeyHandle_Key struct {
	Key *EvpnEviKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*EvpnEviKeyHandle_Id) isEvpnEviKeyHandle_IdOrKey()  {}
func (*EvpnEviKeyHandle_Key) isEvpnEviKeyHandle_IdOrKey() {}

func (m *EvpnEviKeyHandle) GetIdOrKey() isEvpnEviKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnEviKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnEviKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnEviKeyHandle) GetKey() *EvpnEviKey {
	if x, ok := m.GetIdOrKey().(*EvpnEviKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EvpnEviKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EvpnEviKeyHandle_Id)(nil),
		(*EvpnEviKeyHandle_Key)(nil),
	}
}

// EVPN EVI delete request
type EvpnEviDeleteRequest struct {
	Request              []*EvpnEviKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EvpnEviDeleteRequest) Reset()         { *m = EvpnEviDeleteRequest{} }
func (m *EvpnEviDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviDeleteRequest) ProtoMessage()    {}
func (*EvpnEviDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{7}
}
func (m *EvpnEviDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviDeleteRequest.Merge(m, src)
}
func (m *EvpnEviDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviDeleteRequest proto.InternalMessageInfo

func (m *EvpnEviDeleteRequest) GetRequest() []*EvpnEviKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI delete response
type EvpnEviDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnEviDeleteResponse) Reset()         { *m = EvpnEviDeleteResponse{} }
func (m *EvpnEviDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviDeleteResponse) ProtoMessage()    {}
func (*EvpnEviDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{8}
}
func (m *EvpnEviDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviDeleteResponse.Merge(m, src)
}
func (m *EvpnEviDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviDeleteResponse proto.InternalMessageInfo

func (m *EvpnEviDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI get request
type EvpnEviGetRequest struct {
	Request              []*EvpnEviKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EvpnEviGetRequest) Reset()         { *m = EvpnEviGetRequest{} }
func (m *EvpnEviGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviGetRequest) ProtoMessage()    {}
func (*EvpnEviGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{9}
}
func (m *EvpnEviGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviGetRequest.Merge(m, src)
}
func (m *EvpnEviGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviGetRequest proto.InternalMessageInfo

func (m *EvpnEviGetRequest) GetRequest() []*EvpnEviKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI get response
type EvpnEviGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnEvi `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnEviGetResponse) Reset()         { *m = EvpnEviGetResponse{} }
func (m *EvpnEviGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviGetResponse) ProtoMessage()    {}
func (*EvpnEviGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{10}
}
func (m *EvpnEviGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviGetResponse.Merge(m, src)
}
func (m *EvpnEviGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviGetResponse proto.InternalMessageInfo

func (m *EvpnEviGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnEviGetResponse) GetResponse() []*EvpnEvi {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN IP VRF configuration
type EvpnIpVrfSpec struct {
	// unique key/identifier of EVPN IP VRF
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to VPC
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// VxLAN vnid
	VNI uint32 `protobuf:"varint,3,opt,name=VNI,proto3" json:"VNI,omitempty"`
	// 8 byte manual route-distinguisher, if not auto route-distinguisher
	RD                   []byte   `protobuf:"bytes,4,opt,name=RD,proto3" json:"RD,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnIpVrfSpec) Reset()         { *m = EvpnIpVrfSpec{} }
func (m *EvpnIpVrfSpec) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfSpec) ProtoMessage()    {}
func (*EvpnIpVrfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{11}
}
func (m *EvpnIpVrfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfSpec.Merge(m, src)
}
func (m *EvpnIpVrfSpec) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfSpec proto.InternalMessageInfo

func (m *EvpnIpVrfSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnIpVrfSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfSpec) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *EvpnIpVrfSpec) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

// operational status of EVPN IP VRF, if any
type EvpnIpVrfStatus struct {
	// in use route-distinguisher of the IP VRF
	RD []byte `protobuf:"bytes,1,opt,name=RD,proto3" json:"RD,omitempty"`
	// operational status of the IP VRF
	Status EvpnOperStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=pds.EvpnOperStatus" json:"Status,omitempty"`
	// reason if the current opertional status is not active
	OperReason           EvpnOperReason `protobuf:"varint,3,opt,name=OperReason,proto3,enum=pds.EvpnOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnIpVrfStatus) Reset()         { *m = EvpnIpVrfStatus{} }
func (m *EvpnIpVrfStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfStatus) ProtoMessage()    {}
func (*EvpnIpVrfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{12}
}
func (m *EvpnIpVrfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfStatus.Merge(m, src)
}
func (m *EvpnIpVrfStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfStatus proto.InternalMessageInfo

func (m *EvpnIpVrfStatus) GetRD() []byte {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *EvpnIpVrfStatus) GetStatus() EvpnOperStatus {
	if m != nil {
		return m.Status
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

func (m *EvpnIpVrfStatus) GetOperReason() EvpnOperReason {
	if m != nil {
		return m.OperReason
	}
	return EvpnOperReason_EVPN_OPER_REASON_INVALID
}

// EVPN IP VRF object
type EvpnIpVrf struct {
	Spec                 *EvpnIpVrfSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *EvpnIpVrfStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvpnIpVrf) Reset()         { *m = EvpnIpVrf{} }
func (m *EvpnIpVrf) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrf) ProtoMessage()    {}
func (*EvpnIpVrf) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{13}
}
func (m *EvpnIpVrf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrf.Merge(m, src)
}
func (m *EvpnIpVrf) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrf) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrf.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrf proto.InternalMessageInfo

func (m *EvpnIpVrf) GetSpec() *EvpnIpVrfSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnIpVrf) GetStatus() *EvpnIpVrfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN IP VRF create and update request
type EvpnIpVrfRequest struct {
	Request              []*EvpnIpVrfSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvpnIpVrfRequest) Reset()         { *m = EvpnIpVrfRequest{} }
func (m *EvpnIpVrfRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRequest) ProtoMessage()    {}
func (*EvpnIpVrfRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{14}
}
func (m *EvpnIpVrfRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRequest.Merge(m, src)
}
func (m *EvpnIpVrfRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRequest proto.InternalMessageInfo

func (m *EvpnIpVrfRequest) GetRequest() []*EvpnIpVrfSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF create and update response
type EvpnIpVrfResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnIpVrfResponse) Reset()         { *m = EvpnIpVrfResponse{} }
func (m *EvpnIpVrfResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfResponse) ProtoMessage()    {}
func (*EvpnIpVrfResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{15}
}
func (m *EvpnIpVrfResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfResponse.Merge(m, src)
}
func (m *EvpnIpVrfResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfResponse proto.InternalMessageInfo

func (m *EvpnIpVrfResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF key parameters
type EvpnIpVrfKey struct {
	// reference to vpc spec
	VPCId                []byte   `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnIpVrfKey) Reset()         { *m = EvpnIpVrfKey{} }
func (m *EvpnIpVrfKey) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfKey) ProtoMessage()    {}
func (*EvpnIpVrfKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{16}
}
func (m *EvpnIpVrfKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfKey.Merge(m, src)
}
func (m *EvpnIpVrfKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfKey proto.InternalMessageInfo

func (m *EvpnIpVrfKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

// EVPN IP VRF key handle
type EvpnIpVrfKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnIpVrfKeyHandle_Id
	//	*EvpnIpVrfKeyHandle_Key
	IdOrKey              isEvpnIpVrfKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *EvpnIpVrfKeyHandle) Reset()         { *m = EvpnIpVrfKeyHandle{} }
func (m *EvpnIpVrfKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfKeyHandle) ProtoMessage()    {}
func (*EvpnIpVrfKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{17}
}
func (m *EvpnIpVrfKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfKeyHandle.Merge(m, src)
}
func (m *EvpnIpVrfKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfKeyHandle proto.InternalMessageInfo

type isEvpnIpVrfKeyHandle_IdOrKey interface {
	isEvpnIpVrfKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnIpVrfKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnIpVrfKeyHandle_Key struct {
	Key *EvpnIpVrfKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*EvpnIpVrfKeyHandle_Id) isEvpnIpVrfKeyHandle_IdOrKey()  {}
func (*EvpnIpVrfKeyHandle_Key) isEvpnIpVrfKeyHandle_IdOrKey() {}

func (m *EvpnIpVrfKeyHandle) GetIdOrKey() isEvpnIpVrfKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnIpVrfKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnIpVrfKeyHandle) GetKey() *EvpnIpVrfKey {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EvpnIpVrfKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EvpnIpVrfKeyHandle_Id)(nil),
		(*EvpnIpVrfKeyHandle_Key)(nil),
	}
}

// EVPN IP VRF delete request
type EvpnIpVrfDeleteRequest struct {
	Request              []*EvpnIpVrfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EvpnIpVrfDeleteRequest) Reset()         { *m = EvpnIpVrfDeleteRequest{} }
func (m *EvpnIpVrfDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfDeleteRequest) ProtoMessage()    {}
func (*EvpnIpVrfDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{18}
}
func (m *EvpnIpVrfDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfDeleteRequest.Merge(m, src)
}
func (m *EvpnIpVrfDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfDeleteRequest proto.InternalMessageInfo

func (m *EvpnIpVrfDeleteRequest) GetRequest() []*EvpnIpVrfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF delete response
type EvpnIpVrfDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnIpVrfDeleteResponse) Reset()         { *m = EvpnIpVrfDeleteResponse{} }
func (m *EvpnIpVrfDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfDeleteResponse) ProtoMessage()    {}
func (*EvpnIpVrfDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{19}
}
func (m *EvpnIpVrfDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfDeleteResponse.Merge(m, src)
}
func (m *EvpnIpVrfDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfDeleteResponse proto.InternalMessageInfo

func (m *EvpnIpVrfDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF get request
type EvpnIpVrfGetRequest struct {
	Request              []*EvpnIpVrfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EvpnIpVrfGetRequest) Reset()         { *m = EvpnIpVrfGetRequest{} }
func (m *EvpnIpVrfGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfGetRequest) ProtoMessage()    {}
func (*EvpnIpVrfGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{20}
}
func (m *EvpnIpVrfGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfGetRequest.Merge(m, src)
}
func (m *EvpnIpVrfGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfGetRequest proto.InternalMessageInfo

func (m *EvpnIpVrfGetRequest) GetRequest() []*EvpnIpVrfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF get response
type EvpnIpVrfGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnIpVrf `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EvpnIpVrfGetResponse) Reset()         { *m = EvpnIpVrfGetResponse{} }
func (m *EvpnIpVrfGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfGetResponse) ProtoMessage()    {}
func (*EvpnIpVrfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{21}
}
func (m *EvpnIpVrfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfGetResponse.Merge(m, src)
}
func (m *EvpnIpVrfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfGetResponse proto.InternalMessageInfo

func (m *EvpnIpVrfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnIpVrfGetResponse) GetResponse() []*EvpnIpVrf {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN EVI RT Configuration
type EvpnEviRtSpec struct {
	// unique key/identifier of EVPN EVI RT
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to subnet
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory,immutable`
	// 8 byte route-target. first two octets represent type of extended community
	// octet 1: type or type-high, only 0,1 and 2 are allowed types
	// octet 2: sub-type or type-low, should always be 2 for route-target extended
	// community
	RT []byte `protobuf:"bytes,3,opt,name=RT,proto3" json:"RT,omitempty" meta:mandatory,immutable`
	// route-target import/export type. EVPN_RT_NONE is an invalid type for manual route-targets
	RTType               EvpnRtType `protobuf:"varint,4,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnEviRtSpec) Reset()         { *m = EvpnEviRtSpec{} }
func (m *EvpnEviRtSpec) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtSpec) ProtoMessage()    {}
func (*EvpnEviRtSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{22}
}
func (m *EvpnEviRtSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtSpec.Merge(m, src)
}
func (m *EvpnEviRtSpec) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtSpec proto.InternalMessageInfo

func (m *EvpnEviRtSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnEviRtSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviRtSpec) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

func (m *EvpnEviRtSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN EVI RT, if any
type EvpnEviRtStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnEviRtStatus) Reset()         { *m = EvpnEviRtStatus{} }
func (m *EvpnEviRtStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtStatus) ProtoMessage()    {}
func (*EvpnEviRtStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{23}
}
func (m *EvpnEviRtStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtStatus.Merge(m, src)
}
func (m *EvpnEviRtStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtStatus proto.InternalMessageInfo

// EVPN EVI RT object
type EvpnEviRt struct {
	Spec                 *EvpnEviRtSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *EvpnEviRtStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvpnEviRt) Reset()         { *m = EvpnEviRt{} }
func (m *EvpnEviRt) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRt) ProtoMessage()    {}
func (*EvpnEviRt) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{24}
}
func (m *EvpnEviRt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRt.Merge(m, src)
}
func (m *EvpnEviRt) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRt) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRt.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRt proto.InternalMessageInfo

func (m *EvpnEviRt) GetSpec() *EvpnEviRtSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnEviRt) GetStatus() *EvpnEviRtStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN EVI RT create and update response
type EvpnEviRtResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnEviRtResponse) Reset()         { *m = EvpnEviRtResponse{} }
func (m *EvpnEviRtResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtResponse) ProtoMessage()    {}
func (*EvpnEviRtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{25}
}
func (m *EvpnEviRtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtResponse.Merge(m, src)
}
func (m *EvpnEviRtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtResponse proto.InternalMessageInfo

func (m *EvpnEviRtResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EvpnEviRtSpec create and update request
type EvpnEviRtRequest struct {
	Request              []*EvpnEviRtSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvpnEviRtRequest) Reset()         { *m = EvpnEviRtRequest{} }
func (m *EvpnEviRtRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtRequest) ProtoMessage()    {}
func (*EvpnEviRtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{26}
}
func (m *EvpnEviRtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtRequest.Merge(m, src)
}
func (m *EvpnEviRtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtRequest proto.InternalMessageInfo

func (m *EvpnEviRtRequest) GetRequest() []*EvpnEviRtSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT key
type EvpnEviRtKey struct {
	// reference to subnet spec
	SubnetId             []byte   `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	RT                   []byte   `protobuf:"bytes,2,opt,name=RT,proto3" json:"RT,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnEviRtKey) Reset()         { *m = EvpnEviRtKey{} }
func (m *EvpnEviRtKey) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtKey) ProtoMessage()    {}
func (*EvpnEviRtKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{27}
}
func (m *EvpnEviRtKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtKey.Merge(m, src)
}
func (m *EvpnEviRtKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtKey proto.InternalMessageInfo

func (m *EvpnEviRtKey) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *EvpnEviRtKey) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

// EVPN EVI RT Key Handle
type EvpnEviRtKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnEviRtKeyHandle_Id
	//	*EvpnEviRtKeyHandle_Key
	IdOrKey              isEvpnEviRtKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *EvpnEviRtKeyHandle) Reset()         { *m = EvpnEviRtKeyHandle{} }
func (m *EvpnEviRtKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtKeyHandle) ProtoMessage()    {}
func (*EvpnEviRtKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{28}
}
func (m *EvpnEviRtKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtKeyHandle.Merge(m, src)
}
func (m *EvpnEviRtKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtKeyHandle proto.InternalMessageInfo

type isEvpnEviRtKeyHandle_IdOrKey interface {
	isEvpnEviRtKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnEviRtKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnEviRtKeyHandle_Key struct {
	Key *EvpnEviRtKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*EvpnEviRtKeyHandle_Id) isEvpnEviRtKeyHandle_IdOrKey()  {}
func (*EvpnEviRtKeyHandle_Key) isEvpnEviRtKeyHandle_IdOrKey() {}

func (m *EvpnEviRtKeyHandle) GetIdOrKey() isEvpnEviRtKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnEviRtKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnEviRtKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnEviRtKeyHandle) GetKey() *EvpnEviRtKey {
	if x, ok := m.GetIdOrKey().(*EvpnEviRtKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EvpnEviRtKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EvpnEviRtKeyHandle_Id)(nil),
		(*EvpnEviRtKeyHandle_Key)(nil),
	}
}

// EVPN EVI RT delete request
type EvpnEviRtDeleteRequest struct {
	Request              []*EvpnEviRtKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EvpnEviRtDeleteRequest) Reset()         { *m = EvpnEviRtDeleteRequest{} }
func (m *EvpnEviRtDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtDeleteRequest) ProtoMessage()    {}
func (*EvpnEviRtDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{29}
}
func (m *EvpnEviRtDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtDeleteRequest.Merge(m, src)
}
func (m *EvpnEviRtDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtDeleteRequest proto.InternalMessageInfo

func (m *EvpnEviRtDeleteRequest) GetRequest() []*EvpnEviRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT delete response
type EvpnEviRtDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnEviRtDeleteResponse) Reset()         { *m = EvpnEviRtDeleteResponse{} }
func (m *EvpnEviRtDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtDeleteResponse) ProtoMessage()    {}
func (*EvpnEviRtDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{30}
}
func (m *EvpnEviRtDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtDeleteResponse.Merge(m, src)
}
func (m *EvpnEviRtDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtDeleteResponse proto.InternalMessageInfo

func (m *EvpnEviRtDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN EVI RT get request
type EvpnEviRtGetRequest struct {
	Request              []*EvpnEviRtKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EvpnEviRtGetRequest) Reset()         { *m = EvpnEviRtGetRequest{} }
func (m *EvpnEviRtGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtGetRequest) ProtoMessage()    {}
func (*EvpnEviRtGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{31}
}
func (m *EvpnEviRtGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtGetRequest.Merge(m, src)
}
func (m *EvpnEviRtGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtGetRequest proto.InternalMessageInfo

func (m *EvpnEviRtGetRequest) GetRequest() []*EvpnEviRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN EVI RT get response
type EvpnEviRtGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnEviRt `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EvpnEviRtGetResponse) Reset()         { *m = EvpnEviRtGetResponse{} }
func (m *EvpnEviRtGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnEviRtGetResponse) ProtoMessage()    {}
func (*EvpnEviRtGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{32}
}
func (m *EvpnEviRtGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnEviRtGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnEviRtGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnEviRtGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnEviRtGetResponse.Merge(m, src)
}
func (m *EvpnEviRtGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnEviRtGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnEviRtGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnEviRtGetResponse proto.InternalMessageInfo

func (m *EvpnEviRtGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnEviRtGetResponse) GetResponse() []*EvpnEviRt {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN EVI RT create/update request
type EvpnIpVrfRtRequest struct {
	Request              []*EvpnIpVrfRtSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EvpnIpVrfRtRequest) Reset()         { *m = EvpnIpVrfRtRequest{} }
func (m *EvpnIpVrfRtRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtRequest) ProtoMessage()    {}
func (*EvpnIpVrfRtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{33}
}
func (m *EvpnIpVrfRtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtRequest.Merge(m, src)
}
func (m *EvpnIpVrfRtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtRequest proto.InternalMessageInfo

func (m *EvpnIpVrfRtRequest) GetRequest() []*EvpnIpVrfRtSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT Configuration
type EvpnIpVrfRtSpec struct {
	// unique key/identifier of EVPN IP VRF
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// reference to VPC
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory,immutable`
	// 8 byte route-target. first two octets represent type of extended community
	// octet 1: type or type-high, only 0,1 and 2 are allowed types
	// octet 2: sub-type or type-low, should always be 2 for route-target extended
	// community
	RT []byte `protobuf:"bytes,3,opt,name=RT,proto3" json:"RT,omitempty" meta:mandatory,immutable`
	// route-target import/export type. EVPN_RT_NONE is an invalid type for manual route-targets
	RTType               EvpnRtType `protobuf:"varint,4,opt,name=RTType,proto3,enum=pds.EvpnRtType" json:"RTType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnIpVrfRtSpec) Reset()         { *m = EvpnIpVrfRtSpec{} }
func (m *EvpnIpVrfRtSpec) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtSpec) ProtoMessage()    {}
func (*EvpnIpVrfRtSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{34}
}
func (m *EvpnIpVrfRtSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtSpec.Merge(m, src)
}
func (m *EvpnIpVrfRtSpec) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtSpec.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtSpec proto.InternalMessageInfo

func (m *EvpnIpVrfRtSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

func (m *EvpnIpVrfRtSpec) GetRTType() EvpnRtType {
	if m != nil {
		return m.RTType
	}
	return EvpnRtType_EVPN_RT_NONE
}

// operational status of EVPN IP VRF RT, if any
type EvpnIpVrfRtStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnIpVrfRtStatus) Reset()         { *m = EvpnIpVrfRtStatus{} }
func (m *EvpnIpVrfRtStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtStatus) ProtoMessage()    {}
func (*EvpnIpVrfRtStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{35}
}
func (m *EvpnIpVrfRtStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtStatus.Merge(m, src)
}
func (m *EvpnIpVrfRtStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtStatus proto.InternalMessageInfo

// EVPN IP VRF RT object
type EvpnIpVrfRt struct {
	Spec                 *EvpnIpVrfRtSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *EvpnIpVrfRtStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EvpnIpVrfRt) Reset()         { *m = EvpnIpVrfRt{} }
func (m *EvpnIpVrfRt) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRt) ProtoMessage()    {}
func (*EvpnIpVrfRt) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{36}
}
func (m *EvpnIpVrfRt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRt.Merge(m, src)
}
func (m *EvpnIpVrfRt) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRt) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRt.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRt proto.InternalMessageInfo

func (m *EvpnIpVrfRt) GetSpec() *EvpnIpVrfRtSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EvpnIpVrfRt) GetStatus() *EvpnIpVrfRtStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN IP VRF RT create and update response
type EvpnIpVrfRtResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnIpVrfRtResponse) Reset()         { *m = EvpnIpVrfRtResponse{} }
func (m *EvpnIpVrfRtResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtResponse) ProtoMessage()    {}
func (*EvpnIpVrfRtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{37}
}
func (m *EvpnIpVrfRtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtResponse.Merge(m, src)
}
func (m *EvpnIpVrfRtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtResponse proto.InternalMessageInfo

func (m *EvpnIpVrfRtResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF RT key parameters
type EvpnIpVrfRtKey struct {
	// reference to vpc spec
	VPCId                []byte   `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	RT                   []byte   `protobuf:"bytes,2,opt,name=RT,proto3" json:"RT,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnIpVrfRtKey) Reset()         { *m = EvpnIpVrfRtKey{} }
func (m *EvpnIpVrfRtKey) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtKey) ProtoMessage()    {}
func (*EvpnIpVrfRtKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{38}
}
func (m *EvpnIpVrfRtKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtKey.Merge(m, src)
}
func (m *EvpnIpVrfRtKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtKey proto.InternalMessageInfo

func (m *EvpnIpVrfRtKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *EvpnIpVrfRtKey) GetRT() []byte {
	if m != nil {
		return m.RT
	}
	return nil
}

// EVPN IP VRF RT key handle
type EvpnIpVrfRtKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*EvpnIpVrfRtKeyHandle_Id
	//	*EvpnIpVrfRtKeyHandle_Key
	IdOrKey              isEvpnIpVrfRtKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *EvpnIpVrfRtKeyHandle) Reset()         { *m = EvpnIpVrfRtKeyHandle{} }
func (m *EvpnIpVrfRtKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtKeyHandle) ProtoMessage()    {}
func (*EvpnIpVrfRtKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{39}
}
func (m *EvpnIpVrfRtKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtKeyHandle.Merge(m, src)
}
func (m *EvpnIpVrfRtKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtKeyHandle proto.InternalMessageInfo

type isEvpnIpVrfRtKeyHandle_IdOrKey interface {
	isEvpnIpVrfRtKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EvpnIpVrfRtKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type EvpnIpVrfRtKeyHandle_Key struct {
	Key *EvpnIpVrfRtKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*EvpnIpVrfRtKeyHandle_Id) isEvpnIpVrfRtKeyHandle_IdOrKey()  {}
func (*EvpnIpVrfRtKeyHandle_Key) isEvpnIpVrfRtKeyHandle_IdOrKey() {}

func (m *EvpnIpVrfRtKeyHandle) GetIdOrKey() isEvpnIpVrfRtKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *EvpnIpVrfRtKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfRtKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *EvpnIpVrfRtKeyHandle) GetKey() *EvpnIpVrfRtKey {
	if x, ok := m.GetIdOrKey().(*EvpnIpVrfRtKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EvpnIpVrfRtKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EvpnIpVrfRtKeyHandle_Id)(nil),
		(*EvpnIpVrfRtKeyHandle_Key)(nil),
	}
}

// EVPN IP VRF RT delete request
type EvpnIpVrfRtDeleteRequest struct {
	Request              []*EvpnIpVrfRtKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *EvpnIpVrfRtDeleteRequest) Reset()         { *m = EvpnIpVrfRtDeleteRequest{} }
func (m *EvpnIpVrfRtDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtDeleteRequest) ProtoMessage()    {}
func (*EvpnIpVrfRtDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{40}
}
func (m *EvpnIpVrfRtDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtDeleteRequest.Merge(m, src)
}
func (m *EvpnIpVrfRtDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtDeleteRequest proto.InternalMessageInfo

func (m *EvpnIpVrfRtDeleteRequest) GetRequest() []*EvpnIpVrfRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT delete response
type EvpnIpVrfRtDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnIpVrfRtDeleteResponse) Reset()         { *m = EvpnIpVrfRtDeleteResponse{} }
func (m *EvpnIpVrfRtDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtDeleteResponse) ProtoMessage()    {}
func (*EvpnIpVrfRtDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{41}
}
func (m *EvpnIpVrfRtDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtDeleteResponse.Merge(m, src)
}
func (m *EvpnIpVrfRtDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtDeleteResponse proto.InternalMessageInfo

func (m *EvpnIpVrfRtDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EVPN IP VRF RT get request
type EvpnIpVrfRtGetRequest struct {
	Request              []*EvpnIpVrfRtKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *EvpnIpVrfRtGetRequest) Reset()         { *m = EvpnIpVrfRtGetRequest{} }
func (m *EvpnIpVrfRtGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtGetRequest) ProtoMessage()    {}
func (*EvpnIpVrfRtGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{42}
}
func (m *EvpnIpVrfRtGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtGetRequest.Merge(m, src)
}
func (m *EvpnIpVrfRtGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtGetRequest proto.InternalMessageInfo

func (m *EvpnIpVrfRtGetRequest) GetRequest() []*EvpnIpVrfRtKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN IP VRF RT get response
type EvpnIpVrfRtGetResponse struct {
	ApiStatus            ApiStatus      `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnIpVrfRt `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnIpVrfRtGetResponse) Reset()         { *m = EvpnIpVrfRtGetResponse{} }
func (m *EvpnIpVrfRtGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnIpVrfRtGetResponse) ProtoMessage()    {}
func (*EvpnIpVrfRtGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{43}
}
func (m *EvpnIpVrfRtGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnIpVrfRtGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnIpVrfRtGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnIpVrfRtGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnIpVrfRtGetResponse.Merge(m, src)
}
func (m *EvpnIpVrfRtGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnIpVrfRtGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnIpVrfRtGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnIpVrfRtGetResponse proto.InternalMessageInfo

func (m *EvpnIpVrfRtGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnIpVrfRtGetResponse) GetResponse() []*EvpnIpVrfRt {
	if m != nil {
		return m.Response
	}
	return nil
}

// EVPN MAC IP table entries
type EvpnMacIpStatus struct {
	EVIId                uint32     `protobuf:"varint,1,opt,name=EVIId,proto3" json:"EVIId,omitempty"`
	EthTagID             uint32     `protobuf:"varint,2,opt,name=EthTagID,proto3" json:"EthTagID,omitempty"`
	MACAddress           []byte     `protobuf:"bytes,3,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	IPAddress            *IPAddress `protobuf:"bytes,4,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	PathID               uint32     `protobuf:"varint,5,opt,name=PathID,proto3" json:"PathID,omitempty"`
	Source               EvpnSource `protobuf:"varint,6,opt,name=Source,proto3,enum=pds.EvpnSource" json:"Source,omitempty"`
	NHAddress            *IPAddress `protobuf:"bytes,7,opt,name=NHAddress,proto3" json:"NHAddress,omitempty"`
	LocalIfId            uint32     `protobuf:"varint,8,opt,name=LocalIfId,proto3" json:"LocalIfId,omitempty"`
	Label                uint32     `protobuf:"varint,9,opt,name=Label,proto3" json:"Label,omitempty"`
	InUse                bool       `protobuf:"varint,10,opt,name=InUse,proto3" json:"InUse,omitempty"`
	Esi                  string     `protobuf:"bytes,11,opt,name=Esi,proto3" json:"Esi,omitempty"`
	SeqNum               uint32     `protobuf:"varint,12,opt,name=SeqNum,proto3" json:"SeqNum,omitempty"`
	Sticky               bool       `protobuf:"varint,13,opt,name=Sticky,proto3" json:"Sticky,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnMacIpStatus) Reset()         { *m = EvpnMacIpStatus{} }
func (m *EvpnMacIpStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIpStatus) ProtoMessage()    {}
func (*EvpnMacIpStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{44}
}
func (m *EvpnMacIpStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIpStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIpStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIpStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIpStatus.Merge(m, src)
}
func (m *EvpnMacIpStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIpStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIpStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIpStatus proto.InternalMessageInfo

func (m *EvpnMacIpStatus) GetEVIId() uint32 {
	if m != nil {
		return m.EVIId
	}
	return 0
}

func (m *EvpnMacIpStatus) GetEthTagID() uint32 {
	if m != nil {
		return m.EthTagID
	}
	return 0
}

func (m *EvpnMacIpStatus) GetMACAddress() []byte {
	if m != nil {
		return m.MACAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetIPAddress() *IPAddress {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

func (m *EvpnMacIpStatus) GetSource() EvpnSource {
	if m != nil {
		return m.Source
	}
	return EvpnSource_EVPN_SOURCE_NONE
}

func (m *EvpnMacIpStatus) GetNHAddress() *IPAddress {
	if m != nil {
		return m.NHAddress
	}
	return nil
}

func (m *EvpnMacIpStatus) GetLocalIfId() uint32 {
	if m != nil {
		return m.LocalIfId
	}
	return 0
}

func (m *EvpnMacIpStatus) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *EvpnMacIpStatus) GetInUse() bool {
	if m != nil {
		return m.InUse
	}
	return false
}

func (m *EvpnMacIpStatus) GetEsi() string {
	if m != nil {
		return m.Esi
	}
	return ""
}

func (m *EvpnMacIpStatus) GetSeqNum() uint32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *EvpnMacIpStatus) GetSticky() bool {
	if m != nil {
		return m.Sticky
	}
	return false
}

// EVPN MAC IP Table Key
type EvpnMacIpKey struct {
	EVIId                uint32     `protobuf:"varint,1,opt,name=EVIId,proto3" json:"EVIId,omitempty"`
	EthTagID             uint32     `protobuf:"varint,2,opt,name=EthTagID,proto3" json:"EthTagID,omitempty"`
	MACAddress           []byte     `protobuf:"bytes,3,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	IPAddress            *IPAddress `protobuf:"bytes,4,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	PathID               uint32     `protobuf:"varint,5,opt,name=PathID,proto3" json:"PathID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnMacIpKey) Reset()         { *m = EvpnMacIpKey{} }
func (m *EvpnMacIpKey) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIpKey) ProtoMessage()    {}
func (*EvpnMacIpKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{45}
}
func (m *EvpnMacIpKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIpKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIpKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIpKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIpKey.Merge(m, src)
}
func (m *EvpnMacIpKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIpKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIpKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIpKey proto.InternalMessageInfo

func (m *EvpnMacIpKey) GetEVIId() uint32 {
	if m != nil {
		return m.EVIId
	}
	return 0
}

func (m *EvpnMacIpKey) GetEthTagID() uint32 {
	if m != nil {
		return m.EthTagID
	}
	return 0
}

func (m *EvpnMacIpKey) GetMACAddress() []byte {
	if m != nil {
		return m.MACAddress
	}
	return nil
}

func (m *EvpnMacIpKey) GetIPAddress() *IPAddress {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *EvpnMacIpKey) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

// EVPN MAC IP Table key handle for get and delete
type EvpnMacIpKeyHandle struct {
	Key                  *EvpnMacIpKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EvpnMacIpKeyHandle) Reset()         { *m = EvpnMacIpKeyHandle{} }
func (m *EvpnMacIpKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIpKeyHandle) ProtoMessage()    {}
func (*EvpnMacIpKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{46}
}
func (m *EvpnMacIpKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIpKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIpKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIpKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIpKeyHandle.Merge(m, src)
}
func (m *EvpnMacIpKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIpKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIpKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIpKeyHandle proto.InternalMessageInfo

func (m *EvpnMacIpKeyHandle) GetKey() *EvpnMacIpKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// EVPN MAC IP get request
type EvpnMacIpGetRequest struct {
	Request              []*EvpnMacIpKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EvpnMacIpGetRequest) Reset()         { *m = EvpnMacIpGetRequest{} }
func (m *EvpnMacIpGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIpGetRequest) ProtoMessage()    {}
func (*EvpnMacIpGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{47}
}
func (m *EvpnMacIpGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIpGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIpGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIpGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIpGetRequest.Merge(m, src)
}
func (m *EvpnMacIpGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIpGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIpGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIpGetRequest proto.InternalMessageInfo

func (m *EvpnMacIpGetRequest) GetRequest() []*EvpnMacIpKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN MAC IP
type EvpnMacIp struct {
	Status               *EvpnMacIpStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EvpnMacIp) Reset()         { *m = EvpnMacIp{} }
func (m *EvpnMacIp) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIp) ProtoMessage()    {}
func (*EvpnMacIp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{48}
}
func (m *EvpnMacIp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIp.Merge(m, src)
}
func (m *EvpnMacIp) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIp) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIp.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIp proto.InternalMessageInfo

func (m *EvpnMacIp) GetStatus() *EvpnMacIpStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN MAC IP get response
type EvpnMacIpGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnMacIp `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EvpnMacIpGetResponse) Reset()         { *m = EvpnMacIpGetResponse{} }
func (m *EvpnMacIpGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnMacIpGetResponse) ProtoMessage()    {}
func (*EvpnMacIpGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{49}
}
func (m *EvpnMacIpGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnMacIpGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnMacIpGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnMacIpGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnMacIpGetResponse.Merge(m, src)
}
func (m *EvpnMacIpGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnMacIpGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnMacIpGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnMacIpGetResponse proto.InternalMessageInfo

func (m *EvpnMacIpGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnMacIpGetResponse) GetResponse() []*EvpnMacIp {
	if m != nil {
		return m.Response
	}
	return nil
}

type EvpnBdStatus struct {
	// Identifies a DC-EVPN entity
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// Index identifying the EVPN instance
	EviIndex uint32 `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
	// Operational status of the bridge domain
	OperStatus EvpnOperStatus `protobuf:"varint,3,opt,name=OperStatus,proto3,enum=pds.EvpnOperStatus" json:"OperStatus,omitempty"`
	// The reason for the bridge domain to be in its current oper status
	OperReason           EvpnOperReason `protobuf:"varint,4,opt,name=OperReason,proto3,enum=pds.EvpnOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnBdStatus) Reset()         { *m = EvpnBdStatus{} }
func (m *EvpnBdStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnBdStatus) ProtoMessage()    {}
func (*EvpnBdStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{50}
}
func (m *EvpnBdStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdStatus.Merge(m, src)
}
func (m *EvpnBdStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdStatus proto.InternalMessageInfo

func (m *EvpnBdStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdStatus) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

func (m *EvpnBdStatus) GetOperStatus() EvpnOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

func (m *EvpnBdStatus) GetOperReason() EvpnOperReason {
	if m != nil {
		return m.OperReason
	}
	return EvpnOperReason_EVPN_OPER_REASON_INVALID
}

// EVPN BD Table Key
type EvpnBdKey struct {
	EntityIndex          uint32   `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	EviIndex             uint32   `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnBdKey) Reset()         { *m = EvpnBdKey{} }
func (m *EvpnBdKey) String() string { return proto.CompactTextString(m) }
func (*EvpnBdKey) ProtoMessage()    {}
func (*EvpnBdKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{51}
}
func (m *EvpnBdKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdKey.Merge(m, src)
}
func (m *EvpnBdKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdKey proto.InternalMessageInfo

func (m *EvpnBdKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdKey) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

// EVPN BD Table key handle for get and delete
type EvpnBdKeyHandle struct {
	Key                  *EvpnBdKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EvpnBdKeyHandle) Reset()         { *m = EvpnBdKeyHandle{} }
func (m *EvpnBdKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnBdKeyHandle) ProtoMessage()    {}
func (*EvpnBdKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{52}
}
func (m *EvpnBdKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdKeyHandle.Merge(m, src)
}
func (m *EvpnBdKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdKeyHandle proto.InternalMessageInfo

func (m *EvpnBdKeyHandle) GetKey() *EvpnBdKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// EVPN MAC IP get request
type EvpnBdGetRequest struct {
	Request              []*EvpnBdKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EvpnBdGetRequest) Reset()         { *m = EvpnBdGetRequest{} }
func (m *EvpnBdGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnBdGetRequest) ProtoMessage()    {}
func (*EvpnBdGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{53}
}
func (m *EvpnBdGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdGetRequest.Merge(m, src)
}
func (m *EvpnBdGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdGetRequest proto.InternalMessageInfo

func (m *EvpnBdGetRequest) GetRequest() []*EvpnBdKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN BD
type EvpnBd struct {
	Status               *EvpnBdStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EvpnBd) Reset()         { *m = EvpnBd{} }
func (m *EvpnBd) String() string { return proto.CompactTextString(m) }
func (*EvpnBd) ProtoMessage()    {}
func (*EvpnBd) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{54}
}
func (m *EvpnBd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBd.Merge(m, src)
}
func (m *EvpnBd) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBd) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBd.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBd proto.InternalMessageInfo

func (m *EvpnBd) GetStatus() *EvpnBdStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN BD get response
type EvpnBdGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnBd `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EvpnBdGetResponse) Reset()         { *m = EvpnBdGetResponse{} }
func (m *EvpnBdGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnBdGetResponse) ProtoMessage()    {}
func (*EvpnBdGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{55}
}
func (m *EvpnBdGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdGetResponse.Merge(m, src)
}
func (m *EvpnBdGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdGetResponse proto.InternalMessageInfo

func (m *EvpnBdGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnBdGetResponse) GetResponse() []*EvpnBd {
	if m != nil {
		return m.Response
	}
	return nil
}

type EvpnBdIfStatus struct {
	// Identifies a DC-EVPN entity
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// Index identifying the EVPN instance
	EviIndex uint32 `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
	// Interface index
	IfId uint32 `protobuf:"varint,3,opt,name=IfId,proto3" json:"IfId,omitempty"`
	// Operational status of the bridge domain
	OperStatus EvpnOperStatus `protobuf:"varint,4,opt,name=OperStatus,proto3,enum=pds.EvpnOperStatus" json:"OperStatus,omitempty"`
	// The reason for the bridge domain to be in its current oper status
	OperReason           EvpnOperReason `protobuf:"varint,5,opt,name=OperReason,proto3,enum=pds.EvpnOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EvpnBdIfStatus) Reset()         { *m = EvpnBdIfStatus{} }
func (m *EvpnBdIfStatus) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIfStatus) ProtoMessage()    {}
func (*EvpnBdIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{56}
}
func (m *EvpnBdIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIfStatus.Merge(m, src)
}
func (m *EvpnBdIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIfStatus proto.InternalMessageInfo

func (m *EvpnBdIfStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdIfStatus) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

func (m *EvpnBdIfStatus) GetIfId() uint32 {
	if m != nil {
		return m.IfId
	}
	return 0
}

func (m *EvpnBdIfStatus) GetOperStatus() EvpnOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return EvpnOperStatus_EVPN_OPER_STATUS_NONE
}

func (m *EvpnBdIfStatus) GetOperReason() EvpnOperReason {
	if m != nil {
		return m.OperReason
	}
	return EvpnOperReason_EVPN_OPER_REASON_INVALID
}

// EVPN BD Table Key
type EvpnBdIfKey struct {
	EntityIndex          uint32   `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	EviIndex             uint32   `protobuf:"varint,2,opt,name=EviIndex,proto3" json:"EviIndex,omitempty"`
	IfId                 uint32   `protobuf:"varint,3,opt,name=IfId,proto3" json:"IfId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EvpnBdIfKey) Reset()         { *m = EvpnBdIfKey{} }
func (m *EvpnBdIfKey) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIfKey) ProtoMessage()    {}
func (*EvpnBdIfKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{57}
}
func (m *EvpnBdIfKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIfKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIfKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIfKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIfKey.Merge(m, src)
}
func (m *EvpnBdIfKey) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIfKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIfKey.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIfKey proto.InternalMessageInfo

func (m *EvpnBdIfKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *EvpnBdIfKey) GetEviIndex() uint32 {
	if m != nil {
		return m.EviIndex
	}
	return 0
}

func (m *EvpnBdIfKey) GetIfId() uint32 {
	if m != nil {
		return m.IfId
	}
	return 0
}

// EVPN BD Table key handle for get and delete
type EvpnBdIfKeyHandle struct {
	Key                  *EvpnBdIfKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EvpnBdIfKeyHandle) Reset()         { *m = EvpnBdIfKeyHandle{} }
func (m *EvpnBdIfKeyHandle) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIfKeyHandle) ProtoMessage()    {}
func (*EvpnBdIfKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{58}
}
func (m *EvpnBdIfKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIfKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIfKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIfKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIfKeyHandle.Merge(m, src)
}
func (m *EvpnBdIfKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIfKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIfKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIfKeyHandle proto.InternalMessageInfo

func (m *EvpnBdIfKeyHandle) GetKey() *EvpnBdIfKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// EVPN MAC IP get request
type EvpnBdIfGetRequest struct {
	Request              []*EvpnBdIfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *EvpnBdIfGetRequest) Reset()         { *m = EvpnBdIfGetRequest{} }
func (m *EvpnBdIfGetRequest) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIfGetRequest) ProtoMessage()    {}
func (*EvpnBdIfGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{59}
}
func (m *EvpnBdIfGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIfGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIfGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIfGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIfGetRequest.Merge(m, src)
}
func (m *EvpnBdIfGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIfGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIfGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIfGetRequest proto.InternalMessageInfo

func (m *EvpnBdIfGetRequest) GetRequest() []*EvpnBdIfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// EVPN BD
type EvpnBdIf struct {
	Status               *EvpnBdIfStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EvpnBdIf) Reset()         { *m = EvpnBdIf{} }
func (m *EvpnBdIf) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIf) ProtoMessage()    {}
func (*EvpnBdIf) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{60}
}
func (m *EvpnBdIf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIf.Merge(m, src)
}
func (m *EvpnBdIf) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIf) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIf.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIf proto.InternalMessageInfo

func (m *EvpnBdIf) GetStatus() *EvpnBdIfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// EVPN BD get response
type EvpnBdIfGetResponse struct {
	ApiStatus            ApiStatus   `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EvpnBdIf `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *EvpnBdIfGetResponse) Reset()         { *m = EvpnBdIfGetResponse{} }
func (m *EvpnBdIfGetResponse) String() string { return proto.CompactTextString(m) }
func (*EvpnBdIfGetResponse) ProtoMessage()    {}
func (*EvpnBdIfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ba0efeae78b23a00, []int{61}
}
func (m *EvpnBdIfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvpnBdIfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvpnBdIfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvpnBdIfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvpnBdIfGetResponse.Merge(m, src)
}
func (m *EvpnBdIfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *EvpnBdIfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvpnBdIfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvpnBdIfGetResponse proto.InternalMessageInfo

func (m *EvpnBdIfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EvpnBdIfGetResponse) GetResponse() []*EvpnBdIf {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.EvpnCfg", EvpnCfg_name, EvpnCfg_value)
	proto.RegisterEnum("pds.EvpnRtType", EvpnRtType_name, EvpnRtType_value)
	proto.RegisterEnum("pds.EvpnSource", EvpnSource_name, EvpnSource_value)
	proto.RegisterEnum("pds.EvpnOperStatus", EvpnOperStatus_name, EvpnOperStatus_value)
	proto.RegisterEnum("pds.EvpnOperReason", EvpnOperReason_name, EvpnOperReason_value)
	proto.RegisterType((*EvpnEviSpec)(nil), "pds.EvpnEviSpec")
	proto.RegisterType((*EvpnEviStatus)(nil), "pds.EvpnEviStatus")
	proto.RegisterType((*EvpnEvi)(nil), "pds.EvpnEvi")
	proto.RegisterType((*EvpnEviResponse)(nil), "pds.EvpnEviResponse")
	proto.RegisterType((*EvpnEviRequest)(nil), "pds.EvpnEviRequest")
	proto.RegisterType((*EvpnEviKey)(nil), "pds.EvpnEviKey")
	proto.RegisterType((*EvpnEviKeyHandle)(nil), "pds.EvpnEviKeyHandle")
	proto.RegisterType((*EvpnEviDeleteRequest)(nil), "pds.EvpnEviDeleteRequest")
	proto.RegisterType((*EvpnEviDeleteResponse)(nil), "pds.EvpnEviDeleteResponse")
	proto.RegisterType((*EvpnEviGetRequest)(nil), "pds.EvpnEviGetRequest")
	proto.RegisterType((*EvpnEviGetResponse)(nil), "pds.EvpnEviGetResponse")
	proto.RegisterType((*EvpnIpVrfSpec)(nil), "pds.EvpnIpVrfSpec")
	proto.RegisterType((*EvpnIpVrfStatus)(nil), "pds.EvpnIpVrfStatus")
	proto.RegisterType((*EvpnIpVrf)(nil), "pds.EvpnIpVrf")
	proto.RegisterType((*EvpnIpVrfRequest)(nil), "pds.EvpnIpVrfRequest")
	proto.RegisterType((*EvpnIpVrfResponse)(nil), "pds.EvpnIpVrfResponse")
	proto.RegisterType((*EvpnIpVrfKey)(nil), "pds.EvpnIpVrfKey")
	proto.RegisterType((*EvpnIpVrfKeyHandle)(nil), "pds.EvpnIpVrfKeyHandle")
	proto.RegisterType((*EvpnIpVrfDeleteRequest)(nil), "pds.EvpnIpVrfDeleteRequest")
	proto.RegisterType((*EvpnIpVrfDeleteResponse)(nil), "pds.EvpnIpVrfDeleteResponse")
	proto.RegisterType((*EvpnIpVrfGetRequest)(nil), "pds.EvpnIpVrfGetRequest")
	proto.RegisterType((*EvpnIpVrfGetResponse)(nil), "pds.EvpnIpVrfGetResponse")
	proto.RegisterType((*EvpnEviRtSpec)(nil), "pds.EvpnEviRtSpec")
	proto.RegisterType((*EvpnEviRtStatus)(nil), "pds.EvpnEviRtStatus")
	proto.RegisterType((*EvpnEviRt)(nil), "pds.EvpnEviRt")
	proto.RegisterType((*EvpnEviRtResponse)(nil), "pds.EvpnEviRtResponse")
	proto.RegisterType((*EvpnEviRtRequest)(nil), "pds.EvpnEviRtRequest")
	proto.RegisterType((*EvpnEviRtKey)(nil), "pds.EvpnEviRtKey")
	proto.RegisterType((*EvpnEviRtKeyHandle)(nil), "pds.EvpnEviRtKeyHandle")
	proto.RegisterType((*EvpnEviRtDeleteRequest)(nil), "pds.EvpnEviRtDeleteRequest")
	proto.RegisterType((*EvpnEviRtDeleteResponse)(nil), "pds.EvpnEviRtDeleteResponse")
	proto.RegisterType((*EvpnEviRtGetRequest)(nil), "pds.EvpnEviRtGetRequest")
	proto.RegisterType((*EvpnEviRtGetResponse)(nil), "pds.EvpnEviRtGetResponse")
	proto.RegisterType((*EvpnIpVrfRtRequest)(nil), "pds.EvpnIpVrfRtRequest")
	proto.RegisterType((*EvpnIpVrfRtSpec)(nil), "pds.EvpnIpVrfRtSpec")
	proto.RegisterType((*EvpnIpVrfRtStatus)(nil), "pds.EvpnIpVrfRtStatus")
	proto.RegisterType((*EvpnIpVrfRt)(nil), "pds.EvpnIpVrfRt")
	proto.RegisterType((*EvpnIpVrfRtResponse)(nil), "pds.EvpnIpVrfRtResponse")
	proto.RegisterType((*EvpnIpVrfRtKey)(nil), "pds.EvpnIpVrfRtKey")
	proto.RegisterType((*EvpnIpVrfRtKeyHandle)(nil), "pds.EvpnIpVrfRtKeyHandle")
	proto.RegisterType((*EvpnIpVrfRtDeleteRequest)(nil), "pds.EvpnIpVrfRtDeleteRequest")
	proto.RegisterType((*EvpnIpVrfRtDeleteResponse)(nil), "pds.EvpnIpVrfRtDeleteResponse")
	proto.RegisterType((*EvpnIpVrfRtGetRequest)(nil), "pds.EvpnIpVrfRtGetRequest")
	proto.RegisterType((*EvpnIpVrfRtGetResponse)(nil), "pds.EvpnIpVrfRtGetResponse")
	proto.RegisterType((*EvpnMacIpStatus)(nil), "pds.EvpnMacIpStatus")
	proto.RegisterType((*EvpnMacIpKey)(nil), "pds.EvpnMacIpKey")
	proto.RegisterType((*EvpnMacIpKeyHandle)(nil), "pds.EvpnMacIpKeyHandle")
	proto.RegisterType((*EvpnMacIpGetRequest)(nil), "pds.EvpnMacIpGetRequest")
	proto.RegisterType((*EvpnMacIp)(nil), "pds.EvpnMacIp")
	proto.RegisterType((*EvpnMacIpGetResponse)(nil), "pds.EvpnMacIpGetResponse")
	proto.RegisterType((*EvpnBdStatus)(nil), "pds.EvpnBdStatus")
	proto.RegisterType((*EvpnBdKey)(nil), "pds.EvpnBdKey")
	proto.RegisterType((*EvpnBdKeyHandle)(nil), "pds.EvpnBdKeyHandle")
	proto.RegisterType((*EvpnBdGetRequest)(nil), "pds.EvpnBdGetRequest")
	proto.RegisterType((*EvpnBd)(nil), "pds.EvpnBd")
	proto.RegisterType((*EvpnBdGetResponse)(nil), "pds.EvpnBdGetResponse")
	proto.RegisterType((*EvpnBdIfStatus)(nil), "pds.EvpnBdIfStatus")
	proto.RegisterType((*EvpnBdIfKey)(nil), "pds.EvpnBdIfKey")
	proto.RegisterType((*EvpnBdIfKeyHandle)(nil), "pds.EvpnBdIfKeyHandle")
	proto.RegisterType((*EvpnBdIfGetRequest)(nil), "pds.EvpnBdIfGetRequest")
	proto.RegisterType((*EvpnBdIf)(nil), "pds.EvpnBdIf")
	proto.RegisterType((*EvpnBdIfGetResponse)(nil), "pds.EvpnBdIfGetResponse")
}

func init() { proto.RegisterFile("evpn.proto", fileDescriptor_ba0efeae78b23a00) }

var fileDescriptor_ba0efeae78b23a00 = []byte{
	// 2266 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x4d, 0x6f, 0x23, 0x49,
	0xf9, 0x4f, 0xdb, 0xce, 0x5b, 0x39, 0x71, 0x3a, 0x95, 0x37, 0xc7, 0x33, 0x9b, 0x89, 0xfc, 0xdf,
	0xbf, 0x26, 0x84, 0x28, 0x0b, 0x19, 0x09, 0x96, 0xd1, 0x48, 0xbb, 0x6d, 0x77, 0xc7, 0x29, 0xc5,
	0xee, 0xf6, 0x56, 0xb7, 0x0d, 0xc3, 0x81, 0x96, 0x27, 0xee, 0x64, 0xa3, 0x4d, 0x6c, 0xaf, 0xdd,
	0x89, 0xc8, 0x11, 0x21, 0x4e, 0x5c, 0x40, 0x7c, 0x09, 0x3e, 0x01, 0x9f, 0x01, 0x10, 0x5a, 0xf1,
	0x09, 0x46, 0x68, 0x8e, 0x7b, 0xe4, 0x88, 0x84, 0x84, 0xba, 0xaa, 0xba, 0xba, 0xba, 0xba, 0x9d,
	0x78, 0x1c, 0x06, 0xb8, 0x8c, 0xd2, 0xcf, 0x5b, 0x3d, 0xf5, 0xd4, 0xef, 0xf7, 0xd4, 0x8b, 0x07,
	0x00, 0xef, 0x76, 0xd0, 0x3b, 0x1c, 0x0c, 0xfb, 0x7e, 0x1f, 0x66, 0x07, 0xdd, 0x51, 0x09, 0x5c,
	0xf4, 0x2f, 0xfa, 0x54, 0x50, 0x5a, 0xb9, 0xf6, 0xfc, 0xce, 0x27, 0xc1, 0x3f, 0x4c, 0x90, 0xf7,
	0xef, 0x06, 0xde, 0x88, 0x7e, 0x94, 0xff, 0xa1, 0x80, 0xbc, 0x71, 0x3b, 0xe8, 0x19, 0xb7, 0x97,
	0xf6, 0xc0, 0x3b, 0x83, 0x07, 0x20, 0x83, 0xba, 0x45, 0x65, 0x57, 0xd9, 0x5b, 0xaa, 0x3c, 0xfd,
	0xfb, 0xdb, 0x67, 0xc5, 0xc0, 0xf1, 0xe5, 0x75, 0xa7, 0xd7, 0xed, 0xf8, 0xfd, 0xe1, 0xdd, 0xc1,
	0xe5, 0xf5, 0xf5, 0x8d, 0xdf, 0x79, 0x73, 0xe5, 0xe1, 0x0c, 0xea, 0xc2, 0x4f, 0xc1, 0x82, 0x7d,
	0xf3, 0xa6, 0xe7, 0xf9, 0xa8, 0x5b, 0xcc, 0x4c, 0xe0, 0xc3, 0xad, 0xe1, 0xc7, 0x60, 0x4e, 0xbb,
	0xf1, 0xfb, 0x58, 0x2f, 0x66, 0x77, 0x95, 0xbd, 0xc2, 0xd1, 0xd2, 0xe1, 0xa0, 0x3b, 0x3a, 0x0c,
	0x32, 0xa9, 0x9e, 0x5f, 0x60, 0xa6, 0x83, 0x05, 0x90, 0xc1, 0x7a, 0x31, 0x17, 0x44, 0xc6, 0x19,
	0xac, 0x73, 0x2f, 0xa7, 0x38, 0x3b, 0xd6, 0xcb, 0x81, 0xcf, 0xc1, 0x1c, 0x76, 0x9c, 0xbb, 0x81,
	0x57, 0x9c, 0x23, 0x56, 0x2b, 0xdc, 0x0a, 0xfb, 0x81, 0x18, 0x33, 0x75, 0xf9, 0x17, 0x0a, 0x58,
	0x0e, 0x27, 0xef, 0x77, 0xfc, 0x9b, 0x11, 0x1b, 0x50, 0xe1, 0x03, 0x7e, 0x17, 0xcc, 0x51, 0x0d,
	0x99, 0x5e, 0xe1, 0x68, 0x8d, 0x87, 0xb2, 0x06, 0xde, 0x90, 0xaa, 0x30, 0x33, 0x81, 0x2f, 0x00,
	0x08, 0xa4, 0xd8, 0xeb, 0x8c, 0xfa, 0x3d, 0x36, 0xaf, 0xb8, 0x03, 0x55, 0x61, 0xc1, 0xac, 0xfc,
	0x2b, 0x05, 0xcc, 0xb3, 0x1c, 0xe0, 0xa7, 0x20, 0x17, 0x2c, 0x02, 0x19, 0x3f, 0x7f, 0xa4, 0x72,
	0x57, 0xb6, 0x38, 0x15, 0xf8, 0xed, 0xdb, 0x67, 0x85, 0xd1, 0xc0, 0x3b, 0x3b, 0xe8, 0x5f, 0x5f,
	0xfa, 0xde, 0xf5, 0xc0, 0xbf, 0xc3, 0xc4, 0x03, 0x7e, 0x1e, 0xcb, 0x33, 0x7f, 0x04, 0x63, 0xbe,
	0x44, 0x53, 0x59, 0xff, 0xf6, 0xed, 0x33, 0x75, 0x44, 0xfe, 0x16, 0xfc, 0x99, 0x5f, 0x59, 0x03,
	0x2b, 0xcc, 0x1c, 0x7b, 0xa3, 0x41, 0xbf, 0x37, 0xf2, 0xe0, 0x21, 0x58, 0xd4, 0x06, 0xcc, 0x9b,
	0xe4, 0x54, 0x38, 0x52, 0x0f, 0x29, 0x78, 0xb8, 0x1c, 0x47, 0x26, 0xe5, 0x57, 0xa0, 0xc0, 0x43,
	0x7c, 0x7d, 0xe3, 0x8d, 0x7c, 0xb8, 0x0f, 0xe6, 0xd9, 0x9f, 0x45, 0x65, 0x37, 0x9b, 0x36, 0x27,
	0x1c, 0x1a, 0x94, 0xf7, 0x00, 0x60, 0xf2, 0x53, 0xef, 0x0e, 0x96, 0x04, 0x64, 0xd1, 0xe5, 0xe0,
	0xdf, 0xe5, 0x36, 0x50, 0x23, 0xcb, 0x93, 0x4e, 0xaf, 0x7b, 0xe5, 0x41, 0x35, 0xc2, 0xed, 0xc9,
	0x0c, 0xc1, 0xe6, 0xff, 0x81, 0xec, 0xa9, 0x77, 0xc7, 0xea, 0xb1, 0x22, 0x8e, 0x1b, 0x78, 0xcd,
	0xe0, 0x40, 0x5b, 0xc9, 0x83, 0xc5, 0xcb, 0xae, 0xdb, 0x1f, 0xba, 0x5f, 0x79, 0x77, 0xe5, 0x1a,
	0x58, 0x67, 0x16, 0xba, 0x77, 0xe5, 0xf9, 0x5e, 0x38, 0x8b, 0x4f, 0xe4, 0x59, 0x6c, 0xc8, 0xd1,
	0x48, 0x0e, 0xd1, 0x54, 0x6a, 0x60, 0x43, 0x0a, 0x34, 0x65, 0x45, 0x75, 0xb0, 0xca, 0x02, 0xd5,
	0x3c, 0x7f, 0xea, 0x74, 0x7a, 0x00, 0x8a, 0x51, 0xa6, 0xcb, 0x05, 0xee, 0x81, 0x85, 0xd0, 0xb7,
	0x98, 0x21, 0xe3, 0x2e, 0x89, 0xe3, 0x62, 0xae, 0x2d, 0xff, 0x8e, 0xd1, 0x0a, 0x0d, 0xda, 0xc3,
	0xf3, 0x29, 0xba, 0xca, 0x11, 0x98, 0x6d, 0x37, 0xab, 0x13, 0xb6, 0x14, 0x6a, 0x0a, 0x55, 0x90,
	0x6d, 0x9b, 0x88, 0x90, 0x6e, 0x19, 0x07, 0x7f, 0xca, 0xbd, 0xa3, 0xfc, 0x4b, 0x85, 0x22, 0x9c,
	0x66, 0xf5, 0xdf, 0xa2, 0xfb, 0xaf, 0x15, 0xb0, 0xc8, 0xb3, 0x80, 0x2f, 0x63, 0x84, 0x8f, 0x48,
	0xcb, 0x2b, 0x77, 0x0f, 0xe5, 0x2b, 0x12, 0xe5, 0xd7, 0x25, 0xef, 0x49, 0x48, 0xff, 0x39, 0x65,
	0x12, 0x71, 0x08, 0xe1, 0x75, 0x20, 0xc3, 0x2b, 0x25, 0xad, 0x08, 0x5b, 0x55, 0x8a, 0x50, 0x16,
	0x61, 0x4a, 0x98, 0x7f, 0x0c, 0x96, 0x78, 0x90, 0x80, 0xfc, 0xeb, 0x21, 0x00, 0xe8, 0xca, 0xd0,
	0x8f, 0xf2, 0x4f, 0x29, 0x8c, 0x43, 0xab, 0xb1, 0xc4, 0xff, 0x7f, 0x91, 0xf8, 0xab, 0xf1, 0xe4,
	0xc7, 0x51, 0xff, 0x14, 0x6c, 0x72, 0x9b, 0x38, 0xf9, 0xbf, 0x2f, 0x97, 0x63, 0x2b, 0x19, 0x51,
	0xe2, 0x1b, 0x02, 0x5b, 0x89, 0x60, 0x53, 0x56, 0xe6, 0x04, 0xac, 0xf1, 0x50, 0x42, 0x0b, 0x98,
	0x22, 0xa9, 0x21, 0x6d, 0x6e, 0x51, 0xa4, 0x29, 0xdb, 0xc0, 0x7e, 0xa2, 0x0d, 0x14, 0xe2, 0x63,
	0x0b, 0x8d, 0xe0, 0x9b, 0x68, 0x7f, 0xc5, 0xfe, 0x7f, 0xf4, 0x78, 0x71, 0x00, 0x32, 0xd8, 0x21,
	0x9c, 0x7c, 0x70, 0x9c, 0xd8, 0x81, 0x21, 0x77, 0xff, 0x81, 0x61, 0x35, 0xda, 0x24, 0x7d, 0xb6,
	0x42, 0x21, 0xa1, 0x89, 0x6c, 0x2c, 0xa1, 0x79, 0x05, 0xa6, 0x22, 0xb4, 0x30, 0xde, 0x03, 0x84,
	0xae, 0xf2, 0x0d, 0x03, 0x4f, 0xbd, 0xc4, 0x61, 0x57, 0x60, 0x41, 0x1e, 0xec, 0x0a, 0x7c, 0x6e,
	0x11, 0xd8, 0x5e, 0x52, 0x42, 0x13, 0xcd, 0x03, 0xbb, 0x39, 0xe9, 0xc1, 0x0e, 0x5d, 0xde, 0x60,
	0x31, 0x42, 0x9a, 0x87, 0xbe, 0xef, 0x4b, 0x73, 0xee, 0x77, 0x0f, 0xcd, 0x89, 0xcd, 0xc4, 0x34,
	0x8f, 0x67, 0x92, 0xa0, 0x79, 0x2c, 0xd8, 0xe3, 0x68, 0x4e, 0x42, 0x4d, 0x46, 0xf3, 0x71, 0x49,
	0x0d, 0xf9, 0x19, 0x86, 0x45, 0xfa, 0x00, 0x34, 0xa7, 0xc0, 0x88, 0x68, 0xae, 0x0b, 0x8d, 0x39,
	0x42, 0xcc, 0xa1, 0x9c, 0xbc, 0xb4, 0x41, 0xc9, 0x98, 0xf9, 0xb3, 0xb8, 0x3f, 0x4f, 0xd5, 0x2e,
	0xa6, 0x39, 0x37, 0x7c, 0xa0, 0x46, 0xb1, 0x26, 0x6e, 0x8b, 0x61, 0xab, 0xf8, 0x2d, 0xbb, 0x6b,
	0x31, 0x29, 0x7c, 0x15, 0x6b, 0x16, 0xa9, 0xe5, 0xb9, 0xa7, 0x5d, 0xe8, 0x52, 0xbb, 0xd8, 0x4c,
	0xf8, 0x4f, 0xd2, 0x30, 0x0c, 0x61, 0x83, 0x79, 0x44, 0xcb, 0xf8, 0x01, 0x3d, 0xfa, 0xb3, 0x30,
	0x63, 0xf7, 0xf0, 0x04, 0xd9, 0x7f, 0x26, 0xec, 0x4a, 0xf7, 0xd3, 0xfd, 0xb9, 0x48, 0xf7, 0x35,
	0x79, 0xae, 0xe3, 0x08, 0x6f, 0x81, 0xa2, 0x60, 0x15, 0xa7, 0xfc, 0x0b, 0x19, 0xa0, 0xdb, 0x69,
	0x51, 0x25, 0x7e, 0x9d, 0x82, 0xed, 0x94, 0x80, 0x53, 0x56, 0xad, 0x4e, 0xef, 0x09, 0x2c, 0x98,
	0x40, 0xfc, 0xa9, 0x52, 0xbb, 0x15, 0xce, 0x30, 0x8f, 0x23, 0xff, 0x41, 0x82, 0xfc, 0xaa, 0x3c,
	0xbe, 0x40, 0xff, 0xdf, 0x64, 0x29, 0x71, 0x1b, 0x9d, 0x33, 0x34, 0x60, 0x11, 0xd6, 0xc1, 0xac,
	0xd1, 0x46, 0x6c, 0x09, 0x97, 0x31, 0xfd, 0x08, 0xb6, 0x01, 0xc3, 0xff, 0xd2, 0xe9, 0x5c, 0x20,
	0x9d, 0x2c, 0xe4, 0x32, 0xe6, 0xdf, 0x70, 0x07, 0x80, 0x86, 0x56, 0xd5, 0xba, 0xdd, 0xa1, 0x37,
	0x1a, 0x51, 0x42, 0x62, 0x41, 0x12, 0xcc, 0x01, 0x35, 0x43, 0x75, 0x8e, 0x5d, 0x90, 0xe9, 0x1c,
	0xb8, 0x1c, 0x47, 0x26, 0x70, 0x13, 0xcc, 0x35, 0x3b, 0xfe, 0x97, 0x48, 0x27, 0x4f, 0x05, 0xcb,
	0x98, 0x7d, 0x05, 0x14, 0xb6, 0xfb, 0x37, 0xc3, 0xb3, 0xe4, 0xe3, 0x00, 0x15, 0x63, 0xa6, 0x0e,
	0x06, 0x34, 0x4f, 0xc2, 0x01, 0xe7, 0xc7, 0x0d, 0xc8, 0x4d, 0xe0, 0x53, 0xb0, 0x58, 0xef, 0x9f,
	0x75, 0xae, 0xd0, 0x39, 0xea, 0x16, 0x17, 0xc8, 0x98, 0x91, 0x20, 0x28, 0x48, 0xbd, 0xf3, 0xc6,
	0xbb, 0x2a, 0x2e, 0xd2, 0x82, 0x90, 0x8f, 0x40, 0x8a, 0x7a, 0xad, 0x91, 0x57, 0x04, 0xbb, 0xca,
	0xde, 0x02, 0xa6, 0x1f, 0xc1, 0x5d, 0xc6, 0x18, 0x5d, 0x16, 0xf3, 0xbb, 0xca, 0xde, 0x22, 0x0e,
	0xfe, 0x0c, 0x26, 0x63, 0x7b, 0x5f, 0x9b, 0x37, 0xd7, 0xc5, 0x25, 0x3a, 0x19, 0xfa, 0x45, 0xe4,
	0xfe, 0xe5, 0xd9, 0x57, 0x77, 0xc5, 0x65, 0x12, 0x80, 0x7d, 0x95, 0x7f, 0xaf, 0xd0, 0x0d, 0x98,
	0x2c, 0x09, 0x63, 0xe3, 0xff, 0xe6, 0x7a, 0x94, 0x7f, 0x44, 0x37, 0x8f, 0x30, 0x53, 0xc6, 0x7f,
	0x76, 0x79, 0x57, 0xa4, 0xcd, 0x3d, 0xb4, 0x22, 0x4c, 0x0f, 0x77, 0x4d, 0x22, 0x9c, 0x6c, 0xd7,
	0x8c, 0x8f, 0x12, 0x51, 0xc7, 0xa2, 0x67, 0x38, 0xa2, 0x16, 0xce, 0x61, 0x72, 0x63, 0x16, 0x10,
	0xfe, 0x40, 0x5b, 0x65, 0xdb, 0x70, 0x94, 0xda, 0x07, 0xd8, 0x86, 0x49, 0x70, 0x81, 0x87, 0x7f,
	0x60, 0x8b, 0x5e, 0xe9, 0x32, 0xe7, 0x5d, 0x90, 0x37, 0x7a, 0xfe, 0xa5, 0x7f, 0x87, 0x7a, 0x5d,
	0xef, 0xe7, 0x6c, 0xe9, 0x45, 0x11, 0x01, 0xc0, 0xed, 0x25, 0x55, 0x87, 0x00, 0x60, 0xdf, 0xe1,
	0xf5, 0x96, 0xe5, 0x9a, 0x1d, 0x7f, 0x1f, 0x16, 0xcc, 0xa4, 0x3b, 0x71, 0x6e, 0xb2, 0x3b, 0x31,
	0xa2, 0xd5, 0xaf, 0x74, 0x03, 0xa4, 0x3e, 0x2a, 0xe9, 0xf2, 0x0b, 0xda, 0x8a, 0x48, 0x28, 0x06,
	0xa5, 0x5d, 0x11, 0x4a, 0x51, 0xf5, 0x88, 0x09, 0xc5, 0x51, 0x85, 0x9e, 0x77, 0x2b, 0x5d, 0x01,
	0x44, 0xf7, 0x9c, 0x5e, 0x84, 0xe0, 0xe2, 0x61, 0x70, 0x8e, 0xea, 0xe0, 0x67, 0x12, 0x7c, 0x56,
	0x05, 0xc7, 0x89, 0xb0, 0x73, 0x45, 0xcf, 0x0e, 0x2c, 0x9d, 0x29, 0x81, 0xf3, 0x3c, 0x01, 0x9c,
	0xbc, 0x90, 0x87, 0x80, 0x9a, 0xbf, 0x28, 0x74, 0xeb, 0xae, 0x74, 0xd1, 0xf9, 0xbf, 0x05, 0x37,
	0x10, 0xe4, 0x48, 0x0b, 0xa4, 0x4f, 0x31, 0xe4, 0x6f, 0x09, 0x4b, 0xb9, 0x69, 0xb0, 0x34, 0x3b,
	0x19, 0x96, 0x5c, 0x7a, 0xc4, 0x0a, 0x66, 0xf3, 0x68, 0x34, 0xa5, 0x4d, 0xa5, 0xfc, 0xc3, 0x70,
	0x75, 0x90, 0xf0, 0x08, 0x51, 0x16, 0x31, 0xa6, 0x0a, 0x85, 0x26, 0x46, 0x14, 0x65, 0xc7, 0xb4,
	0xd1, 0x05, 0x32, 0x01, 0x67, 0xdf, 0x93, 0x71, 0xb6, 0x29, 0x7b, 0xcb, 0x48, 0x6b, 0x04, 0x09,
	0x53, 0x2d, 0xd4, 0x24, 0xac, 0xad, 0xc5, 0x9c, 0x27, 0x42, 0xdb, 0x80, 0x36, 0x51, 0x9e, 0xd6,
	0x94, 0x78, 0xfb, 0x4e, 0x02, 0x6f, 0xcb, 0xb1, 0x5c, 0x22, 0xc4, 0xed, 0xeb, 0xf4, 0xc1, 0xbb,
	0x7a, 0x7e, 0x01, 0x57, 0xc1, 0xb2, 0xd1, 0x6e, 0x9a, 0x6e, 0xf5, 0xb8, 0xe6, 0x9a, 0x96, 0x69,
	0xa8, 0x33, 0x70, 0x0d, 0xac, 0x70, 0x51, 0x43, 0x33, 0x5b, 0x5a, 0x5d, 0x55, 0x62, 0x76, 0x5a,
	0xcb, 0xb1, 0xd4, 0xcc, 0x7e, 0x87, 0x3e, 0x17, 0xd3, 0x73, 0x37, 0x54, 0xc1, 0x12, 0x31, 0xc0,
	0x4e, 0x18, 0x07, 0x82, 0x42, 0x28, 0x41, 0x8d, 0xa6, 0x85, 0x1d, 0x55, 0x11, 0x65, 0xc6, 0x4f,
	0x88, 0x2c, 0x03, 0xb7, 0xc1, 0x46, 0xdc, 0x2e, 0x54, 0x65, 0xf7, 0xbf, 0xa0, 0x43, 0xb0, 0xf3,
	0xc0, 0x3a, 0x50, 0x89, 0xa1, 0x6d, 0xb5, 0x70, 0xd5, 0x08, 0x87, 0xd9, 0x00, 0xab, 0xa2, 0xb4,
	0x6e, 0x55, 0x49, 0xc2, 0x9b, 0x00, 0x8a, 0x62, 0x6c, 0x34, 0x2c, 0xc7, 0x50, 0x33, 0xfb, 0xff,
	0xcc, 0x50, 0xb6, 0x09, 0x30, 0x0f, 0x13, 0xb0, 0x9a, 0x06, 0x76, 0x6d, 0x47, 0x73, 0x5a, 0x76,
	0x18, 0x7c, 0x0b, 0xac, 0x25, 0x54, 0xad, 0xa6, 0xaa, 0xa4, 0xfa, 0xe8, 0xd6, 0x8f, 0x4d, 0x35,
	0x03, 0x3f, 0x02, 0xdb, 0x09, 0x55, 0xcd, 0x42, 0x66, 0x2d, 0xf0, 0xcc, 0xc2, 0x67, 0xe0, 0xc9,
	0x18, 0x35, 0xf1, 0xcf, 0xa5, 0x1a, 0x68, 0x55, 0xc7, 0x3d, 0xd6, 0x50, 0xdd, 0xd0, 0xd5, 0x59,
	0xb8, 0x03, 0x4a, 0x09, 0x83, 0x2f, 0x5a, 0xc8, 0xb0, 0xab, 0xc8, 0xac, 0xa9, 0x73, 0xa9, 0x7a,
	0xd3, 0x72, 0x5c, 0x6c, 0x68, 0xfa, 0x6b, 0x75, 0x1e, 0x3e, 0x01, 0x5b, 0x09, 0x3d, 0x0b, 0xbe,
	0x90, 0x3a, 0x7a, 0x13, 0x9b, 0x74, 0x78, 0x5d, 0x5d, 0x4c, 0x35, 0x20, 0x3a, 0xb7, 0x69, 0xe0,
	0x86, 0x0a, 0xe0, 0x53, 0x50, 0x4c, 0x35, 0x08, 0x92, 0xcb, 0xef, 0xff, 0x29, 0x17, 0xd5, 0x9f,
	0x76, 0x8c, 0xb8, 0x03, 0x36, 0x34, 0xdb, 0x32, 0x5d, 0x64, 0xb6, 0xb5, 0x3a, 0xd2, 0xd5, 0x99,
	0x78, 0xa5, 0x99, 0x96, 0xac, 0x4e, 0xb4, 0xc6, 0x86, 0xe9, 0x20, 0xe7, 0x35, 0x99, 0x63, 0xab,
	0xa9, 0x66, 0x38, 0x24, 0x34, 0xbd, 0x81, 0x4c, 0xb7, 0x6a, 0x99, 0xc7, 0xa8, 0xa6, 0x66, 0x23,
	0xa0, 0x19, 0x0c, 0x14, 0x41, 0x56, 0x2d, 0x6c, 0xa8, 0x39, 0x8e, 0x79, 0xd3, 0x72, 0xd1, 0xb1,
	0x8b, 0xcc, 0x63, 0x4b, 0x9d, 0xe5, 0x42, 0xa3, 0x8d, 0xc2, 0xd8, 0x73, 0x1c, 0xc1, 0x15, 0x3d,
	0x94, 0xcd, 0xf3, 0x92, 0x98, 0x96, 0x8b, 0xad, 0x96, 0x63, 0xb8, 0x3a, 0xb2, 0x1d, 0x64, 0xd6,
	0x5a, 0xc8, 0x3e, 0x31, 0xb0, 0xba, 0x10, 0x8d, 0xcc, 0xb5, 0x6e, 0xb5, 0xae, 0xd9, 0x27, 0xea,
	0x22, 0x5c, 0x01, 0xf9, 0xd0, 0xd7, 0xb0, 0x91, 0x0a, 0x38, 0x91, 0x2a, 0x9a, 0xee, 0xb6, 0x4d,
	0xa4, 0xe6, 0xf9, 0x90, 0x6d, 0x13, 0x31, 0xb7, 0x25, 0xbe, 0xc6, 0xed, 0xba, 0x66, 0xba, 0x76,
	0xab, 0x12, 0xa4, 0x1d, 0xe4, 0x49, 0xf5, 0xcb, 0xdc, 0xc7, 0xb4, 0xdc, 0x4a, 0xad, 0xe9, 0x22,
	0x5d, 0x2d, 0xf0, 0x72, 0x61, 0xc7, 0x75, 0x5e, 0x37, 0x0d, 0x66, 0xbb, 0x02, 0x0b, 0x00, 0xf0,
	0xf4, 0x1d, 0x55, 0xe5, 0x76, 0xa8, 0xe9, 0xb6, 0xf1, 0x71, 0x38, 0xcd, 0x55, 0x2e, 0x37, 0x2d,
	0xd7, 0x7e, 0x6d, 0x3b, 0x46, 0xc3, 0x6d, 0x68, 0x55, 0x15, 0xf2, 0xde, 0x80, 0xc3, 0x59, 0xad,
	0x71, 0xde, 0x98, 0x96, 0xdb, 0xa8, 0x6a, 0xb6, 0xe3, 0xd6, 0xb0, 0xd5, 0x6a, 0xaa, 0xeb, 0x7c,
	0x69, 0x82, 0x18, 0x74, 0x11, 0x50, 0x53, 0xdd, 0xe0, 0x90, 0x0c, 0x26, 0xed, 0x98, 0x66, 0xdd,
	0xd5, 0x0d, 0x9b, 0x66, 0xa9, 0x6e, 0x8a, 0xc1, 0x48, 0x01, 0xb1, 0x4d, 0x06, 0xde, 0x3a, 0xfa,
	0x06, 0xd0, 0x46, 0x66, 0xdf, 0x9e, 0xc1, 0x57, 0xfc, 0xa1, 0xb3, 0x3a, 0xf4, 0x3a, 0xbe, 0x07,
	0xd7, 0x62, 0xaf, 0x25, 0xb4, 0x75, 0x97, 0xe2, 0x2f, 0x7a, 0xe1, 0x0e, 0x3c, 0x23, 0x78, 0xb7,
	0x06, 0xdd, 0xf7, 0xf6, 0x3e, 0xe1, 0xde, 0xf4, 0x3a, 0x0a, 0xb7, 0x45, 0xc3, 0xd8, 0x9d, 0xb7,
	0x54, 0x4a, 0x53, 0xf1, 0x48, 0x9f, 0xf1, 0x9f, 0xe0, 0x6a, 0x9e, 0x0f, 0x37, 0x45, 0xdb, 0x68,
	0xcb, 0x2a, 0x6d, 0x25, 0xe4, 0x3c, 0x40, 0x45, 0x78, 0x1f, 0x65, 0x85, 0xd8, 0x90, 0x9e, 0x8d,
	0x58, 0x90, 0x4d, 0x59, 0x9c, 0x1a, 0x83, 0x95, 0xe3, 0xbd, 0x63, 0x98, 0x42, 0x0c, 0x56, 0x94,
	0x27, 0x71, 0xe3, 0x78, 0x59, 0x9e, 0xa6, 0x2b, 0x79, 0x3c, 0x43, 0x78, 0xcf, 0x0c, 0x4a, 0x53,
	0x8c, 0xdb, 0x0b, 0xc5, 0xd9, 0x4e, 0xd1, 0xc8, 0x53, 0x23, 0x57, 0xe8, 0x44, 0x79, 0xc4, 0x1f,
	0x61, 0x4a, 0xf2, 0x63, 0x4e, 0x7a, 0x8c, 0x44, 0x79, 0x26, 0x8c, 0x61, 0x0a, 0x31, 0x12, 0xe5,
	0x49, 0xfe, 0x06, 0x22, 0x94, 0x27, 0xe5, 0x37, 0x8d, 0xa8, 0x3c, 0xe1, 0x6f, 0x0b, 0x42, 0x79,
	0xa4, 0x1f, 0x2e, 0x4a, 0xdb, 0x29, 0x1a, 0x01, 0xc8, 0xe2, 0xa3, 0x19, 0x2b, 0xd0, 0x56, 0xe2,
	0xe5, 0x81, 0x85, 0x2a, 0x26, 0x15, 0x63, 0x22, 0xb1, 0x32, 0x4d, 0x15, 0xc9, 0x89, 0x45, 0x62,
	0xc5, 0xfa, 0x48, 0x76, 0x88, 0x97, 0x6b, 0x67, 0x9c, 0x9a, 0x47, 0x3d, 0x8d, 0x3d, 0x97, 0x05,
	0x25, 0x2b, 0xc9, 0x3e, 0x42, 0xd1, 0x9e, 0xa4, 0xea, 0xe4, 0xea, 0x87, 0x77, 0x4d, 0xa1, 0xfa,
	0xd2, 0xcd, 0x58, 0xa8, 0xbe, 0x7c, 0x31, 0x25, 0x4d, 0x68, 0x91, 0x5f, 0x3b, 0x04, 0x48, 0x89,
	0xb7, 0xa2, 0xd2, 0xa6, 0x2c, 0x16, 0x60, 0x99, 0x17, 0x8e, 0x91, 0x42, 0xad, 0xe3, 0xe7, 0x5d,
	0xa1, 0xd6, 0xd2, 0x89, 0xb3, 0x3c, 0x53, 0x59, 0xfa, 0xe3, 0xbb, 0x1d, 0xe5, 0xaf, 0xef, 0x76,
	0x94, 0xbf, 0xbd, 0xdb, 0x51, 0xde, 0xcc, 0x91, 0xff, 0xa0, 0xf2, 0xe2, 0x5f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xcd, 0x2d, 0xad, 0xa6, 0xdd, 0x22, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EvpnSvcClient is the client API for EvpnSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EvpnSvcClient interface {
	EvpnEviCreate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error)
	EvpnEviUpdate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error)
	EvpnEviDelete(ctx context.Context, in *EvpnEviDeleteRequest, opts ...grpc.CallOption) (*EvpnEviDeleteResponse, error)
	EvpnEviGet(ctx context.Context, in *EvpnEviGetRequest, opts ...grpc.CallOption) (*EvpnEviGetResponse, error)
	EvpnEviRtCreate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error)
	EvpnEviRtUpdate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error)
	EvpnEviRtDelete(ctx context.Context, in *EvpnEviRtDeleteRequest, opts ...grpc.CallOption) (*EvpnEviRtDeleteResponse, error)
	EvpnEviRtGet(ctx context.Context, in *EvpnEviRtGetRequest, opts ...grpc.CallOption) (*EvpnEviRtGetResponse, error)
	EvpnIpVrfCreate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error)
	EvpnIpVrfUpdate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error)
	EvpnIpVrfDelete(ctx context.Context, in *EvpnIpVrfDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfDeleteResponse, error)
	EvpnIpVrfGet(ctx context.Context, in *EvpnIpVrfGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfGetResponse, error)
	EvpnIpVrfRtCreate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtUpdate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtDelete(ctx context.Context, in *EvpnIpVrfRtDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtDeleteResponse, error)
	EvpnIpVrfRtGet(ctx context.Context, in *EvpnIpVrfRtGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtGetResponse, error)
	EvpnMacIpGet(ctx context.Context, in *EvpnMacIpGetRequest, opts ...grpc.CallOption) (*EvpnMacIpGetResponse, error)
	EvpnBdGet(ctx context.Context, in *EvpnBdGetRequest, opts ...grpc.CallOption) (*EvpnBdGetResponse, error)
	EvpnBdIfGet(ctx context.Context, in *EvpnBdIfGetRequest, opts ...grpc.CallOption) (*EvpnBdIfGetResponse, error)
}

type evpnSvcClient struct {
	cc *grpc.ClientConn
}

func NewEvpnSvcClient(cc *grpc.ClientConn) EvpnSvcClient {
	return &evpnSvcClient{cc}
}

func (c *evpnSvcClient) EvpnEviCreate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error) {
	out := new(EvpnEviResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviUpdate(ctx context.Context, in *EvpnEviRequest, opts ...grpc.CallOption) (*EvpnEviResponse, error) {
	out := new(EvpnEviResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviDelete(ctx context.Context, in *EvpnEviDeleteRequest, opts ...grpc.CallOption) (*EvpnEviDeleteResponse, error) {
	out := new(EvpnEviDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviGet(ctx context.Context, in *EvpnEviGetRequest, opts ...grpc.CallOption) (*EvpnEviGetResponse, error) {
	out := new(EvpnEviGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtCreate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error) {
	out := new(EvpnEviRtResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtUpdate(ctx context.Context, in *EvpnEviRtRequest, opts ...grpc.CallOption) (*EvpnEviRtResponse, error) {
	out := new(EvpnEviRtResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtDelete(ctx context.Context, in *EvpnEviRtDeleteRequest, opts ...grpc.CallOption) (*EvpnEviRtDeleteResponse, error) {
	out := new(EvpnEviRtDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnEviRtGet(ctx context.Context, in *EvpnEviRtGetRequest, opts ...grpc.CallOption) (*EvpnEviRtGetResponse, error) {
	out := new(EvpnEviRtGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnEviRtGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfCreate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error) {
	out := new(EvpnIpVrfResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfUpdate(ctx context.Context, in *EvpnIpVrfRequest, opts ...grpc.CallOption) (*EvpnIpVrfResponse, error) {
	out := new(EvpnIpVrfResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfDelete(ctx context.Context, in *EvpnIpVrfDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfDeleteResponse, error) {
	out := new(EvpnIpVrfDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfGet(ctx context.Context, in *EvpnIpVrfGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfGetResponse, error) {
	out := new(EvpnIpVrfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtCreate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error) {
	out := new(EvpnIpVrfRtResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtUpdate(ctx context.Context, in *EvpnIpVrfRtRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtResponse, error) {
	out := new(EvpnIpVrfRtResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtDelete(ctx context.Context, in *EvpnIpVrfRtDeleteRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtDeleteResponse, error) {
	out := new(EvpnIpVrfRtDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnIpVrfRtGet(ctx context.Context, in *EvpnIpVrfRtGetRequest, opts ...grpc.CallOption) (*EvpnIpVrfRtGetResponse, error) {
	out := new(EvpnIpVrfRtGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnIpVrfRtGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnMacIpGet(ctx context.Context, in *EvpnMacIpGetRequest, opts ...grpc.CallOption) (*EvpnMacIpGetResponse, error) {
	out := new(EvpnMacIpGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnMacIpGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnBdGet(ctx context.Context, in *EvpnBdGetRequest, opts ...grpc.CallOption) (*EvpnBdGetResponse, error) {
	out := new(EvpnBdGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnBdGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evpnSvcClient) EvpnBdIfGet(ctx context.Context, in *EvpnBdIfGetRequest, opts ...grpc.CallOption) (*EvpnBdIfGetResponse, error) {
	out := new(EvpnBdIfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.EvpnSvc/EvpnBdIfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvpnSvcServer is the server API for EvpnSvc service.
type EvpnSvcServer interface {
	EvpnEviCreate(context.Context, *EvpnEviRequest) (*EvpnEviResponse, error)
	EvpnEviUpdate(context.Context, *EvpnEviRequest) (*EvpnEviResponse, error)
	EvpnEviDelete(context.Context, *EvpnEviDeleteRequest) (*EvpnEviDeleteResponse, error)
	EvpnEviGet(context.Context, *EvpnEviGetRequest) (*EvpnEviGetResponse, error)
	EvpnEviRtCreate(context.Context, *EvpnEviRtRequest) (*EvpnEviRtResponse, error)
	EvpnEviRtUpdate(context.Context, *EvpnEviRtRequest) (*EvpnEviRtResponse, error)
	EvpnEviRtDelete(context.Context, *EvpnEviRtDeleteRequest) (*EvpnEviRtDeleteResponse, error)
	EvpnEviRtGet(context.Context, *EvpnEviRtGetRequest) (*EvpnEviRtGetResponse, error)
	EvpnIpVrfCreate(context.Context, *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error)
	EvpnIpVrfUpdate(context.Context, *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error)
	EvpnIpVrfDelete(context.Context, *EvpnIpVrfDeleteRequest) (*EvpnIpVrfDeleteResponse, error)
	EvpnIpVrfGet(context.Context, *EvpnIpVrfGetRequest) (*EvpnIpVrfGetResponse, error)
	EvpnIpVrfRtCreate(context.Context, *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtUpdate(context.Context, *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error)
	EvpnIpVrfRtDelete(context.Context, *EvpnIpVrfRtDeleteRequest) (*EvpnIpVrfRtDeleteResponse, error)
	EvpnIpVrfRtGet(context.Context, *EvpnIpVrfRtGetRequest) (*EvpnIpVrfRtGetResponse, error)
	EvpnMacIpGet(context.Context, *EvpnMacIpGetRequest) (*EvpnMacIpGetResponse, error)
	EvpnBdGet(context.Context, *EvpnBdGetRequest) (*EvpnBdGetResponse, error)
	EvpnBdIfGet(context.Context, *EvpnBdIfGetRequest) (*EvpnBdIfGetResponse, error)
}

// UnimplementedEvpnSvcServer can be embedded to have forward compatible implementations.
type UnimplementedEvpnSvcServer struct {
}

func (*UnimplementedEvpnSvcServer) EvpnEviCreate(ctx context.Context, req *EvpnEviRequest) (*EvpnEviResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviCreate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviUpdate(ctx context.Context, req *EvpnEviRequest) (*EvpnEviResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviUpdate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviDelete(ctx context.Context, req *EvpnEviDeleteRequest) (*EvpnEviDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviDelete not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviGet(ctx context.Context, req *EvpnEviGetRequest) (*EvpnEviGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviRtCreate(ctx context.Context, req *EvpnEviRtRequest) (*EvpnEviRtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviRtCreate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviRtUpdate(ctx context.Context, req *EvpnEviRtRequest) (*EvpnEviRtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviRtUpdate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviRtDelete(ctx context.Context, req *EvpnEviRtDeleteRequest) (*EvpnEviRtDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviRtDelete not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnEviRtGet(ctx context.Context, req *EvpnEviRtGetRequest) (*EvpnEviRtGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnEviRtGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfCreate(ctx context.Context, req *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfCreate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfUpdate(ctx context.Context, req *EvpnIpVrfRequest) (*EvpnIpVrfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfUpdate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfDelete(ctx context.Context, req *EvpnIpVrfDeleteRequest) (*EvpnIpVrfDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfDelete not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfGet(ctx context.Context, req *EvpnIpVrfGetRequest) (*EvpnIpVrfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfRtCreate(ctx context.Context, req *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfRtCreate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfRtUpdate(ctx context.Context, req *EvpnIpVrfRtRequest) (*EvpnIpVrfRtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfRtUpdate not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfRtDelete(ctx context.Context, req *EvpnIpVrfRtDeleteRequest) (*EvpnIpVrfRtDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfRtDelete not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnIpVrfRtGet(ctx context.Context, req *EvpnIpVrfRtGetRequest) (*EvpnIpVrfRtGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnIpVrfRtGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnMacIpGet(ctx context.Context, req *EvpnMacIpGetRequest) (*EvpnMacIpGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnMacIpGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnBdGet(ctx context.Context, req *EvpnBdGetRequest) (*EvpnBdGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnBdGet not implemented")
}
func (*UnimplementedEvpnSvcServer) EvpnBdIfGet(ctx context.Context, req *EvpnBdIfGetRequest) (*EvpnBdIfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvpnBdIfGet not implemented")
}

func RegisterEvpnSvcServer(s *grpc.Server, srv EvpnSvcServer) {
	s.RegisterService(&_EvpnSvc_serviceDesc, srv)
}

func _EvpnSvc_EvpnEviCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviCreate(ctx, req.(*EvpnEviRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviUpdate(ctx, req.(*EvpnEviRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviDelete(ctx, req.(*EvpnEviDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviGet(ctx, req.(*EvpnEviGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtCreate(ctx, req.(*EvpnEviRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtUpdate(ctx, req.(*EvpnEviRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtDelete(ctx, req.(*EvpnEviRtDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnEviRtGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnEviRtGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnEviRtGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnEviRtGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnEviRtGet(ctx, req.(*EvpnEviRtGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfCreate(ctx, req.(*EvpnIpVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfUpdate(ctx, req.(*EvpnIpVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfDelete(ctx, req.(*EvpnIpVrfDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfGet(ctx, req.(*EvpnIpVrfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtCreate(ctx, req.(*EvpnIpVrfRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtUpdate(ctx, req.(*EvpnIpVrfRtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtDelete(ctx, req.(*EvpnIpVrfRtDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnIpVrfRtGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnIpVrfRtGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnIpVrfRtGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnIpVrfRtGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnIpVrfRtGet(ctx, req.(*EvpnIpVrfRtGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnMacIpGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnMacIpGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnMacIpGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnMacIpGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnMacIpGet(ctx, req.(*EvpnMacIpGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnBdGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnBdGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnBdGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnBdGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnBdGet(ctx, req.(*EvpnBdGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvpnSvc_EvpnBdIfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvpnBdIfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvpnSvcServer).EvpnBdIfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.EvpnSvc/EvpnBdIfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvpnSvcServer).EvpnBdIfGet(ctx, req.(*EvpnBdIfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EvpnSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.EvpnSvc",
	HandlerType: (*EvpnSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EvpnEviCreate",
			Handler:    _EvpnSvc_EvpnEviCreate_Handler,
		},
		{
			MethodName: "EvpnEviUpdate",
			Handler:    _EvpnSvc_EvpnEviUpdate_Handler,
		},
		{
			MethodName: "EvpnEviDelete",
			Handler:    _EvpnSvc_EvpnEviDelete_Handler,
		},
		{
			MethodName: "EvpnEviGet",
			Handler:    _EvpnSvc_EvpnEviGet_Handler,
		},
		{
			MethodName: "EvpnEviRtCreate",
			Handler:    _EvpnSvc_EvpnEviRtCreate_Handler,
		},
		{
			MethodName: "EvpnEviRtUpdate",
			Handler:    _EvpnSvc_EvpnEviRtUpdate_Handler,
		},
		{
			MethodName: "EvpnEviRtDelete",
			Handler:    _EvpnSvc_EvpnEviRtDelete_Handler,
		},
		{
			MethodName: "EvpnEviRtGet",
			Handler:    _EvpnSvc_EvpnEviRtGet_Handler,
		},
		{
			MethodName: "EvpnIpVrfCreate",
			Handler:    _EvpnSvc_EvpnIpVrfCreate_Handler,
		},
		{
			MethodName: "EvpnIpVrfUpdate",
			Handler:    _EvpnSvc_EvpnIpVrfUpdate_Handler,
		},
		{
			MethodName: "EvpnIpVrfDelete",
			Handler:    _EvpnSvc_EvpnIpVrfDelete_Handler,
		},
		{
			MethodName: "EvpnIpVrfGet",
			Handler:    _EvpnSvc_EvpnIpVrfGet_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtCreate",
			Handler:    _EvpnSvc_EvpnIpVrfRtCreate_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtUpdate",
			Handler:    _EvpnSvc_EvpnIpVrfRtUpdate_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtDelete",
			Handler:    _EvpnSvc_EvpnIpVrfRtDelete_Handler,
		},
		{
			MethodName: "EvpnIpVrfRtGet",
			Handler:    _EvpnSvc_EvpnIpVrfRtGet_Handler,
		},
		{
			MethodName: "EvpnMacIpGet",
			Handler:    _EvpnSvc_EvpnMacIpGet_Handler,
		},
		{
			MethodName: "EvpnBdGet",
			Handler:    _EvpnSvc_EvpnBdGet_Handler,
		},
		{
			MethodName: "EvpnBdIfGet",
			Handler:    _EvpnSvc_EvpnBdIfGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evpn.proto",
}

func (m *EvpnEviSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RTType != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
		i--
		dAtA[i] = 0x30
	}
	if m.AutoRT != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.AutoRT))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RD) > 0 {
		i -= len(m.RD)
		copy(dAtA[i:], m.RD)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i--
		dAtA[i] = 0x22
	}
	if m.AutoRD != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.AutoRD))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RD) > 0 {
		i -= len(m.RD)
		copy(dAtA[i:], m.RD)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEvi) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEvi) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEvi) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnEviKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EvpnEviKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnEviKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EvpnEviDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RD) > 0 {
		i -= len(m.RD)
		copy(dAtA[i:], m.RD)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i--
		dAtA[i] = 0x22
	}
	if m.VNI != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.VNI))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RD) > 0 {
		i -= len(m.RD)
		copy(dAtA[i:], m.RD)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnIpVrfKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EvpnIpVrfKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnIpVrfKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EvpnIpVrfDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RTType != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RT) > 0 {
		i -= len(m.RT)
		copy(dAtA[i:], m.RT)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RT) > 0 {
		i -= len(m.RT)
		copy(dAtA[i:], m.RT)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnEviRtKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EvpnEviRtKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnEviRtKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EvpnEviRtDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnEviRtGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnEviRtGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnEviRtGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RTType != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.RTType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RT) > 0 {
		i -= len(m.RT)
		copy(dAtA[i:], m.RT)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RT) > 0 {
		i -= len(m.RT)
		copy(dAtA[i:], m.RT)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.RT)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnIpVrfRtKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EvpnIpVrfRtKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EvpnIpVrfRtKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EvpnIpVrfRtDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnIpVrfRtGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnIpVrfRtGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnIpVrfRtGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sticky {
		i--
		if m.Sticky {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.SeqNum != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Esi) > 0 {
		i -= len(m.Esi)
		copy(dAtA[i:], m.Esi)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.Esi)))
		i--
		dAtA[i] = 0x5a
	}
	if m.InUse {
		i--
		if m.InUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Label != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.Label))
		i--
		dAtA[i] = 0x48
	}
	if m.LocalIfId != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.LocalIfId))
		i--
		dAtA[i] = 0x40
	}
	if m.NHAddress != nil {
		{
			size, err := m.NHAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Source != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x30
	}
	if m.PathID != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.PathID))
		i--
		dAtA[i] = 0x28
	}
	if m.IPAddress != nil {
		{
			size, err := m.IPAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MACAddress) > 0 {
		i -= len(m.MACAddress)
		copy(dAtA[i:], m.MACAddress)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.MACAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EthTagID != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EthTagID))
		i--
		dAtA[i] = 0x10
	}
	if m.EVIId != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EVIId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIpKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIpKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PathID != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.PathID))
		i--
		dAtA[i] = 0x28
	}
	if m.IPAddress != nil {
		{
			size, err := m.IPAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MACAddress) > 0 {
		i -= len(m.MACAddress)
		copy(dAtA[i:], m.MACAddress)
		i = encodeVarintEvpn(dAtA, i, uint64(len(m.MACAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EthTagID != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EthTagID))
		i--
		dAtA[i] = 0x10
	}
	if m.EVIId != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EVIId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIpKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIpKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIpGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIpGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnMacIpGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnMacIpGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnMacIpGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x20
	}
	if m.OperStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.EviIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EviIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x28
	}
	if m.OperStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.IfId != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.IfId))
		i--
		dAtA[i] = 0x18
	}
	if m.EviIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIfKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIfKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfId != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.IfId))
		i--
		dAtA[i] = 0x18
	}
	if m.EviIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EviIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIfKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIfGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvpn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvpnBdIfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvpnBdIfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvpnBdIfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvpn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintEvpn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvpn(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvpn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EvpnEviSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.AutoRD != 0 {
		n += 1 + sovEvpn(uint64(m.AutoRD))
	}
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.AutoRT != 0 {
		n += 1 + sovEvpn(uint64(m.AutoRT))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEvpn(uint64(m.Status))
	}
	if m.OperReason != 0 {
		n += 1 + sovEvpn(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEvi) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.VNI != 0 {
		n += 1 + sovEvpn(uint64(m.VNI))
	}
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RD)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEvpn(uint64(m.Status))
	}
	if m.OperReason != 0 {
		n += 1 + sovEvpn(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviRtKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnEviRtDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnEviRtGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.RTType != 0 {
		n += 1 + sovEvpn(uint64(m.RTType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	l = len(m.RT)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfRtKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	return n
}
func (m *EvpnIpVrfRtDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnIpVrfRtGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIpStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EVIId != 0 {
		n += 1 + sovEvpn(uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		n += 1 + sovEvpn(uint64(m.EthTagID))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.IPAddress != nil {
		l = m.IPAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.PathID != 0 {
		n += 1 + sovEvpn(uint64(m.PathID))
	}
	if m.Source != 0 {
		n += 1 + sovEvpn(uint64(m.Source))
	}
	if m.NHAddress != nil {
		l = m.NHAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.LocalIfId != 0 {
		n += 1 + sovEvpn(uint64(m.LocalIfId))
	}
	if m.Label != 0 {
		n += 1 + sovEvpn(uint64(m.Label))
	}
	if m.InUse {
		n += 2
	}
	l = len(m.Esi)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovEvpn(uint64(m.SeqNum))
	}
	if m.Sticky {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIpKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EVIId != 0 {
		n += 1 + sovEvpn(uint64(m.EVIId))
	}
	if m.EthTagID != 0 {
		n += 1 + sovEvpn(uint64(m.EthTagID))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.IPAddress != nil {
		l = m.IPAddress.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.PathID != 0 {
		n += 1 + sovEvpn(uint64(m.PathID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIpKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIpGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnMacIpGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovEvpn(uint64(m.OperStatus))
	}
	if m.OperReason != 0 {
		n += 1 + sovEvpn(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	if m.IfId != 0 {
		n += 1 + sovEvpn(uint64(m.IfId))
	}
	if m.OperStatus != 0 {
		n += 1 + sovEvpn(uint64(m.OperStatus))
	}
	if m.OperReason != 0 {
		n += 1 + sovEvpn(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIfKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EntityIndex))
	}
	if m.EviIndex != 0 {
		n += 1 + sovEvpn(uint64(m.EviIndex))
	}
	if m.IfId != 0 {
		n += 1 + sovEvpn(uint64(m.IfId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIfKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIfGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEvpn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EvpnBdIfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEvpn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEvpn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEvpn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvpn(x uint64) (n int) {
	return sovEvpn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EvpnEviSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRD", wireType)
			}
			m.AutoRD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRD |= EvpnCfg(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRT", wireType)
			}
			m.AutoRT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRT |= EvpnCfg(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= EvpnRtType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= EvpnOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= EvpnOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEvi) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEvi: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEvi: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnEviSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnEviStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnEviKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnEviKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnEviKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnEvi{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RD = append(m.RD[:0], dAtA[iNdEx:postIndex]...)
			if m.RD == nil {
				m.RD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= EvpnOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= EvpnOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnIpVrfSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnIpVrfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnIpVrfKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnIpVrfKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnIpVrfKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnIpVrf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= EvpnRtType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnEviRtSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnEviRtStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnEviRtKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnEviRtKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnEviRtKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnEviRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnEviRtGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnEviRtGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnEviRtGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnEviRt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTType", wireType)
			}
			m.RTType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTType |= EvpnRtType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EvpnIpVrfRtSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnIpVrfRtStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RT = append(m.RT[:0], dAtA[iNdEx:postIndex]...)
			if m.RT == nil {
				m.RT = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &EvpnIpVrfRtKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EvpnIpVrfRtKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &EvpnIpVrfRtKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnIpVrfRtKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnIpVrfRtGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnIpVrfRtGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnIpVrfRt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVIId", wireType)
			}
			m.EVIId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EVIId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTagID", wireType)
			}
			m.EthTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTagID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = append(m.MACAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.MACAddress == nil {
				m.MACAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddress == nil {
				m.IPAddress = &IPAddress{}
			}
			if err := m.IPAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= EvpnSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NHAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NHAddress == nil {
				m.NHAddress = &IPAddress{}
			}
			if err := m.NHAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIfId", wireType)
			}
			m.LocalIfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalIfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InUse = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Esi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticky", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sticky = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVIId", wireType)
			}
			m.EVIId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EVIId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTagID", wireType)
			}
			m.EthTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTagID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = append(m.MACAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.MACAddress == nil {
				m.MACAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddress == nil {
				m.IPAddress = &IPAddress{}
			}
			if err := m.IPAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &EvpnMacIpKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnMacIpKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnMacIpStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnMacIpGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnMacIpGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnMacIpGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnMacIp{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= EvpnOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= EvpnOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &EvpnBdKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnBdKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnBdStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnBd{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfId", wireType)
			}
			m.IfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= EvpnOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= EvpnOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EviIndex", wireType)
			}
			m.EviIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EviIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfId", wireType)
			}
			m.IfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &EvpnBdIfKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EvpnBdIfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EvpnBdIfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvpnBdIfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvpnBdIfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvpnBdIfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvpn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvpn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EvpnBdIf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvpn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEvpn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvpn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvpn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvpn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvpn
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthEvpn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvpn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvpn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthEvpn
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvpn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvpn   = fmt.Errorf("proto: integer overflow")
)
