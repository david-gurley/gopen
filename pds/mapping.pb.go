// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mapping.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MappingType captures the type of the mapping
type MappingType int32

const (
	MappingType_MAPPING_TYPE_NONE MappingType = 0
	// MAPPING_TYPE_VPC is used for regular VPC endpoints and is the default
	MappingType_MAPPING_TYPE_VPC MappingType = 1
	// MAPPING_TYPE_SERVICE is used for mappings that represent service endpoints
	MappingType_MAPPING_TYPE_SERVICE MappingType = 2
	// MAPPING_TYPE_LB_VIP is used for mappings that represent load balancer
	// service VIP
	MappingType_MAPPING_TYPE_LB_VIP MappingType = 3
)

var MappingType_name = map[int32]string{
	0: "MAPPING_TYPE_NONE",
	1: "MAPPING_TYPE_VPC",
	2: "MAPPING_TYPE_SERVICE",
	3: "MAPPING_TYPE_LB_VIP",
}

var MappingType_value = map[string]int32{
	"MAPPING_TYPE_NONE":    0,
	"MAPPING_TYPE_VPC":     1,
	"MAPPING_TYPE_SERVICE": 2,
	"MAPPING_TYPE_LB_VIP":  3,
}

func (x MappingType) String() string {
	return proto.EnumName(MappingType_name, int32(x))
}

func (MappingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{0}
}

// mapping key type can be L2 or L3
type MappingKeyType int32

const (
	MappingKeyType_MAPPING_KEY_TYPE_NONE MappingKeyType = 0
	MappingKeyType_MAPPING_KEY_TYPE_L2   MappingKeyType = 1
	MappingKeyType_MAPPING_KEY_TYPE_L3   MappingKeyType = 2
)

var MappingKeyType_name = map[int32]string{
	0: "MAPPING_KEY_TYPE_NONE",
	1: "MAPPING_KEY_TYPE_L2",
	2: "MAPPING_KEY_TYPE_L3",
}

var MappingKeyType_value = map[string]int32{
	"MAPPING_KEY_TYPE_NONE": 0,
	"MAPPING_KEY_TYPE_L2":   1,
	"MAPPING_KEY_TYPE_L3":   2,
}

func (x MappingKeyType) String() string {
	return proto.EnumName(MappingKeyType_name, int32(x))
}

func (MappingKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{1}
}

// L3MappingKey is the 2nd-ary key of the remote IP mapping
type L3MappingKey struct {
	// virtual private cloud of the IP mapping
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory`
	// private/overlay IP of the mapping
	IPAddr               *IPAddress `protobuf:"bytes,2,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *L3MappingKey) Reset()         { *m = L3MappingKey{} }
func (m *L3MappingKey) String() string { return proto.CompactTextString(m) }
func (*L3MappingKey) ProtoMessage()    {}
func (*L3MappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{0}
}
func (m *L3MappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3MappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3MappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3MappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3MappingKey.Merge(m, src)
}
func (m *L3MappingKey) XXX_Size() int {
	return m.Size()
}
func (m *L3MappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_L3MappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_L3MappingKey proto.InternalMessageInfo

func (m *L3MappingKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *L3MappingKey) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

// L2MappingKey is the 2nd-ary key of the remote MAC mapping
type L2MappingKey struct {
	// subnet id of this MAC
	SubnetId []byte `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	// MAC address of this mapping
	MACAddr              uint64   `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L2MappingKey) Reset()         { *m = L2MappingKey{} }
func (m *L2MappingKey) String() string { return proto.CompactTextString(m) }
func (*L2MappingKey) ProtoMessage()    {}
func (*L2MappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{1}
}
func (m *L2MappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MappingKey.Merge(m, src)
}
func (m *L2MappingKey) XXX_Size() int {
	return m.Size()
}
func (m *L2MappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_L2MappingKey proto.InternalMessageInfo

func (m *L2MappingKey) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *L2MappingKey) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

// MappingKey is the 2nd-ary key and uniquely identifies a IP/MAC mapping
type MappingKey struct {
	// Types that are valid to be assigned to Keyinfo:
	//	*MappingKey_IPKey
	//	*MappingKey_MACKey
	Keyinfo              isMappingKey_Keyinfo `protobuf_oneof:"keyinfo"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MappingKey) Reset()         { *m = MappingKey{} }
func (m *MappingKey) String() string { return proto.CompactTextString(m) }
func (*MappingKey) ProtoMessage()    {}
func (*MappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{2}
}
func (m *MappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingKey.Merge(m, src)
}
func (m *MappingKey) XXX_Size() int {
	return m.Size()
}
func (m *MappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_MappingKey proto.InternalMessageInfo

type isMappingKey_Keyinfo interface {
	isMappingKey_Keyinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MappingKey_IPKey struct {
	IPKey *L3MappingKey `protobuf:"bytes,1,opt,name=IPKey,proto3,oneof"`
}
type MappingKey_MACKey struct {
	MACKey *L2MappingKey `protobuf:"bytes,2,opt,name=MACKey,proto3,oneof"`
}

func (*MappingKey_IPKey) isMappingKey_Keyinfo()  {}
func (*MappingKey_MACKey) isMappingKey_Keyinfo() {}

func (m *MappingKey) GetKeyinfo() isMappingKey_Keyinfo {
	if m != nil {
		return m.Keyinfo
	}
	return nil
}

func (m *MappingKey) GetIPKey() *L3MappingKey {
	if x, ok := m.GetKeyinfo().(*MappingKey_IPKey); ok {
		return x.IPKey
	}
	return nil
}

func (m *MappingKey) GetMACKey() *L2MappingKey {
	if x, ok := m.GetKeyinfo().(*MappingKey_MACKey); ok {
		return x.MACKey
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MappingKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MappingKey_IPKey)(nil),
		(*MappingKey_MACKey)(nil),
	}
}

// MappingSpec captures configuration of each mapping
// NOTE: Mapping is either on the local host/TEP or remote TEP
type MappingSpec struct {
	// unique mapping id
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// along with uuid, either IPKey or MACKey attrs
	//
	// Types that are valid to be assigned to MacOrIp:
	//	*MappingSpec_IPKey
	//	*MappingSpec_MACKey
	MacOrIp isMappingSpec_MacOrIp `protobuf_oneof:"mac_or_ip"`
	// subnet this mapping is in
	SubnetId []byte `protobuf:"bytes,4,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory`
	// Types that are valid to be assigned to Dstinfo:
	//	*MappingSpec_VnicId
	//	*MappingSpec_TunnelId
	//	*MappingSpec_NexthopGroupId
	Dstinfo isMappingSpec_Dstinfo `protobuf_oneof:"dstinfo"`
	// overlay MAC address of this mapping
	MACAddr uint64 `protobuf:"varint,8,opt,name=MACAddr,proto3" json:"MACAddr,omitempty" meta:mandatory`
	// fabric encap information specific to this mapping, if any
	Encap *Encap `protobuf:"bytes,9,opt,name=Encap,proto3" json:"Encap,omitempty" meta:mandatory`
	// public IP, if overlay IP has corresponding public IP
	PublicIP *IPAddress `protobuf:"bytes,10,opt,name=PublicIP,proto3" json:"PublicIP,omitempty"`
	// tag/label/security group of this IP mapping, these tags/labels/SGs can be
	// used// in defining security policy rules
	// NOTE:
	// 1. service tag 0 is invalid
	// 2. a maximum of 5 tags are supported
	Tags []uint32 `protobuf:"varint,11,rep,packed,name=Tags,proto3" json:"Tags,omitempty"`
	// upto 4K meter classes per vnic are supported, so meter class value must be
	// between 1 to 4K - 1
	// NOTE: meter class value of 0 is reserved
	MeterClass uint32 `protobuf:"varint,12,opt,name=MeterClass,proto3" json:"MeterClass,omitempty" meta:range:1-4095`
	// SvcRewrite contains all the rewrite info for the shared services
	SvcRewrite *SvcRewriteInfo `protobuf:"bytes,13,opt,name=SvcRewrite,proto3" json:"SvcRewrite,omitempty"`
	// type of the IP mapping endpoint
	Type                 MappingType `protobuf:"varint,14,opt,name=Type,proto3,enum=pds.MappingType" json:"Type,omitempty" meta:default=MAPPING_TYPE_VPC`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MappingSpec) Reset()         { *m = MappingSpec{} }
func (m *MappingSpec) String() string { return proto.CompactTextString(m) }
func (*MappingSpec) ProtoMessage()    {}
func (*MappingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{3}
}
func (m *MappingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingSpec.Merge(m, src)
}
func (m *MappingSpec) XXX_Size() int {
	return m.Size()
}
func (m *MappingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MappingSpec proto.InternalMessageInfo

type isMappingSpec_MacOrIp interface {
	isMappingSpec_MacOrIp()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isMappingSpec_Dstinfo interface {
	isMappingSpec_Dstinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MappingSpec_IPKey struct {
	IPKey *L3MappingKey `protobuf:"bytes,2,opt,name=IPKey,proto3,oneof"`
}
type MappingSpec_MACKey struct {
	MACKey *L2MappingKey `protobuf:"bytes,3,opt,name=MACKey,proto3,oneof"`
}
type MappingSpec_VnicId struct {
	VnicId []byte `protobuf:"bytes,5,opt,name=VnicId,proto3,oneof"`
}
type MappingSpec_TunnelId struct {
	TunnelId []byte `protobuf:"bytes,6,opt,name=TunnelId,proto3,oneof"`
}
type MappingSpec_NexthopGroupId struct {
	NexthopGroupId []byte `protobuf:"bytes,7,opt,name=NexthopGroupId,proto3,oneof"`
}

func (*MappingSpec_IPKey) isMappingSpec_MacOrIp()          {}
func (*MappingSpec_MACKey) isMappingSpec_MacOrIp()         {}
func (*MappingSpec_VnicId) isMappingSpec_Dstinfo()         {}
func (*MappingSpec_TunnelId) isMappingSpec_Dstinfo()       {}
func (*MappingSpec_NexthopGroupId) isMappingSpec_Dstinfo() {}

func (m *MappingSpec) GetMacOrIp() isMappingSpec_MacOrIp {
	if m != nil {
		return m.MacOrIp
	}
	return nil
}
func (m *MappingSpec) GetDstinfo() isMappingSpec_Dstinfo {
	if m != nil {
		return m.Dstinfo
	}
	return nil
}

func (m *MappingSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MappingSpec) GetIPKey() *L3MappingKey {
	if x, ok := m.GetMacOrIp().(*MappingSpec_IPKey); ok {
		return x.IPKey
	}
	return nil
}

func (m *MappingSpec) GetMACKey() *L2MappingKey {
	if x, ok := m.GetMacOrIp().(*MappingSpec_MACKey); ok {
		return x.MACKey
	}
	return nil
}

func (m *MappingSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *MappingSpec) GetVnicId() []byte {
	if x, ok := m.GetDstinfo().(*MappingSpec_VnicId); ok {
		return x.VnicId
	}
	return nil
}

func (m *MappingSpec) GetTunnelId() []byte {
	if x, ok := m.GetDstinfo().(*MappingSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (m *MappingSpec) GetNexthopGroupId() []byte {
	if x, ok := m.GetDstinfo().(*MappingSpec_NexthopGroupId); ok {
		return x.NexthopGroupId
	}
	return nil
}

func (m *MappingSpec) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *MappingSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *MappingSpec) GetPublicIP() *IPAddress {
	if m != nil {
		return m.PublicIP
	}
	return nil
}

func (m *MappingSpec) GetTags() []uint32 {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MappingSpec) GetMeterClass() uint32 {
	if m != nil {
		return m.MeterClass
	}
	return 0
}

func (m *MappingSpec) GetSvcRewrite() *SvcRewriteInfo {
	if m != nil {
		return m.SvcRewrite
	}
	return nil
}

func (m *MappingSpec) GetType() MappingType {
	if m != nil {
		return m.Type
	}
	return MappingType_MAPPING_TYPE_NONE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MappingSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MappingSpec_IPKey)(nil),
		(*MappingSpec_MACKey)(nil),
		(*MappingSpec_VnicId)(nil),
		(*MappingSpec_TunnelId)(nil),
		(*MappingSpec_NexthopGroupId)(nil),
	}
}

// operational status of a mapping
type MappingStatus struct {
	PublicIPNatIdx       uint32       `protobuf:"varint,1,opt,name=PublicIPNatIdx,proto3" json:"PublicIPNatIdx,omitempty"`
	PrivateIPNatIdx      uint32       `protobuf:"varint,2,opt,name=PrivateIPNatIdx,proto3" json:"PrivateIPNatIdx,omitempty"`
	TunnelIP             []*IPAddress `protobuf:"bytes,3,rep,name=TunnelIP,proto3" json:"TunnelIP,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MappingStatus) Reset()         { *m = MappingStatus{} }
func (m *MappingStatus) String() string { return proto.CompactTextString(m) }
func (*MappingStatus) ProtoMessage()    {}
func (*MappingStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{4}
}
func (m *MappingStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingStatus.Merge(m, src)
}
func (m *MappingStatus) XXX_Size() int {
	return m.Size()
}
func (m *MappingStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MappingStatus proto.InternalMessageInfo

func (m *MappingStatus) GetPublicIPNatIdx() uint32 {
	if m != nil {
		return m.PublicIPNatIdx
	}
	return 0
}

func (m *MappingStatus) GetPrivateIPNatIdx() uint32 {
	if m != nil {
		return m.PrivateIPNatIdx
	}
	return 0
}

func (m *MappingStatus) GetTunnelIP() []*IPAddress {
	if m != nil {
		return m.TunnelIP
	}
	return nil
}

// stats of a mapping
type MappingStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MappingStats) Reset()         { *m = MappingStats{} }
func (m *MappingStats) String() string { return proto.CompactTextString(m) }
func (*MappingStats) ProtoMessage()    {}
func (*MappingStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{5}
}
func (m *MappingStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingStats.Merge(m, src)
}
func (m *MappingStats) XXX_Size() int {
	return m.Size()
}
func (m *MappingStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingStats.DiscardUnknown(m)
}

var xxx_messageInfo_MappingStats proto.InternalMessageInfo

// mapping object
type Mapping struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *MappingSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *MappingStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *MappingStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Mapping) Reset()         { *m = Mapping{} }
func (m *Mapping) String() string { return proto.CompactTextString(m) }
func (*Mapping) ProtoMessage()    {}
func (*Mapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{6}
}
func (m *Mapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mapping.Merge(m, src)
}
func (m *Mapping) XXX_Size() int {
	return m.Size()
}
func (m *Mapping) XXX_DiscardUnknown() {
	xxx_messageInfo_Mapping.DiscardUnknown(m)
}

var xxx_messageInfo_Mapping proto.InternalMessageInfo

func (m *Mapping) GetSpec() *MappingSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Mapping) GetStatus() *MappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Mapping) GetStats() *MappingStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// mapping create and update request
type MappingRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt     `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*MappingSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MappingRequest) Reset()         { *m = MappingRequest{} }
func (m *MappingRequest) String() string { return proto.CompactTextString(m) }
func (*MappingRequest) ProtoMessage()    {}
func (*MappingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{7}
}
func (m *MappingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingRequest.Merge(m, src)
}
func (m *MappingRequest) XXX_Size() int {
	return m.Size()
}
func (m *MappingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MappingRequest proto.InternalMessageInfo

func (m *MappingRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MappingRequest) GetRequest() []*MappingSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// mapping create and update response
type MappingResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*MappingStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MappingResponse) Reset()         { *m = MappingResponse{} }
func (m *MappingResponse) String() string { return proto.CompactTextString(m) }
func (*MappingResponse) ProtoMessage()    {}
func (*MappingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{8}
}
func (m *MappingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingResponse.Merge(m, src)
}
func (m *MappingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MappingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MappingResponse proto.InternalMessageInfo

func (m *MappingResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MappingResponse) GetResponse() []*MappingStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

type MappingFilter struct {
	// Local is set to true for local mappings or else false
	Local bool `protobuf:"varint,1,opt,name=Local,proto3" json:"Local,omitempty"`
	// KeyType is used for query based on L3 or L2 without specifically
	// providing exact key (i.e. list all L2/L3 mappings)
	KeyType MappingKeyType `protobuf:"varint,2,opt,name=KeyType,proto3,enum=pds.MappingKeyType" json:"KeyType,omitempty"`
	// Types that are valid to be assigned to Keyinfo:
	//	*MappingFilter_IPKey
	//	*MappingFilter_MACKey
	Keyinfo              isMappingFilter_Keyinfo `protobuf_oneof:"keyinfo"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MappingFilter) Reset()         { *m = MappingFilter{} }
func (m *MappingFilter) String() string { return proto.CompactTextString(m) }
func (*MappingFilter) ProtoMessage()    {}
func (*MappingFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{9}
}
func (m *MappingFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingFilter.Merge(m, src)
}
func (m *MappingFilter) XXX_Size() int {
	return m.Size()
}
func (m *MappingFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingFilter.DiscardUnknown(m)
}

var xxx_messageInfo_MappingFilter proto.InternalMessageInfo

type isMappingFilter_Keyinfo interface {
	isMappingFilter_Keyinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MappingFilter_IPKey struct {
	IPKey *L3MappingKey `protobuf:"bytes,3,opt,name=IPKey,proto3,oneof"`
}
type MappingFilter_MACKey struct {
	MACKey *L2MappingKey `protobuf:"bytes,4,opt,name=MACKey,proto3,oneof"`
}

func (*MappingFilter_IPKey) isMappingFilter_Keyinfo()  {}
func (*MappingFilter_MACKey) isMappingFilter_Keyinfo() {}

func (m *MappingFilter) GetKeyinfo() isMappingFilter_Keyinfo {
	if m != nil {
		return m.Keyinfo
	}
	return nil
}

func (m *MappingFilter) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

func (m *MappingFilter) GetKeyType() MappingKeyType {
	if m != nil {
		return m.KeyType
	}
	return MappingKeyType_MAPPING_KEY_TYPE_NONE
}

func (m *MappingFilter) GetIPKey() *L3MappingKey {
	if x, ok := m.GetKeyinfo().(*MappingFilter_IPKey); ok {
		return x.IPKey
	}
	return nil
}

func (m *MappingFilter) GetMACKey() *L2MappingKey {
	if x, ok := m.GetKeyinfo().(*MappingFilter_MACKey); ok {
		return x.MACKey
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MappingFilter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MappingFilter_IPKey)(nil),
		(*MappingFilter_MACKey)(nil),
	}
}

// mapping get request
type MappingGetRequest struct {
	Id [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	// optional filter
	Filter               *MappingFilter `protobuf:"bytes,2,opt,name=Filter,proto3" json:"Filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MappingGetRequest) Reset()         { *m = MappingGetRequest{} }
func (m *MappingGetRequest) String() string { return proto.CompactTextString(m) }
func (*MappingGetRequest) ProtoMessage()    {}
func (*MappingGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{10}
}
func (m *MappingGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingGetRequest.Merge(m, src)
}
func (m *MappingGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *MappingGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MappingGetRequest proto.InternalMessageInfo

func (m *MappingGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MappingGetRequest) GetFilter() *MappingFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// mapping get response
type MappingGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Mapping `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MappingGetResponse) Reset()         { *m = MappingGetResponse{} }
func (m *MappingGetResponse) String() string { return proto.CompactTextString(m) }
func (*MappingGetResponse) ProtoMessage()    {}
func (*MappingGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{11}
}
func (m *MappingGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingGetResponse.Merge(m, src)
}
func (m *MappingGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MappingGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MappingGetResponse proto.InternalMessageInfo

func (m *MappingGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MappingGetResponse) GetResponse() []*Mapping {
	if m != nil {
		return m.Response
	}
	return nil
}

// mapping delete request
type MappingDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MappingDeleteRequest) Reset()         { *m = MappingDeleteRequest{} }
func (m *MappingDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*MappingDeleteRequest) ProtoMessage()    {}
func (*MappingDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{12}
}
func (m *MappingDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingDeleteRequest.Merge(m, src)
}
func (m *MappingDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *MappingDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MappingDeleteRequest proto.InternalMessageInfo

func (m *MappingDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MappingDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// mapping delete response
type MappingDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MappingDeleteResponse) Reset()         { *m = MappingDeleteResponse{} }
func (m *MappingDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*MappingDeleteResponse) ProtoMessage()    {}
func (*MappingDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92521b297e0ff076, []int{13}
}
func (m *MappingDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingDeleteResponse.Merge(m, src)
}
func (m *MappingDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MappingDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MappingDeleteResponse proto.InternalMessageInfo

func (m *MappingDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.MappingType", MappingType_name, MappingType_value)
	proto.RegisterEnum("pds.MappingKeyType", MappingKeyType_name, MappingKeyType_value)
	proto.RegisterType((*L3MappingKey)(nil), "pds.L3MappingKey")
	proto.RegisterType((*L2MappingKey)(nil), "pds.L2MappingKey")
	proto.RegisterType((*MappingKey)(nil), "pds.MappingKey")
	proto.RegisterType((*MappingSpec)(nil), "pds.MappingSpec")
	proto.RegisterType((*MappingStatus)(nil), "pds.MappingStatus")
	proto.RegisterType((*MappingStats)(nil), "pds.MappingStats")
	proto.RegisterType((*Mapping)(nil), "pds.Mapping")
	proto.RegisterType((*MappingRequest)(nil), "pds.MappingRequest")
	proto.RegisterType((*MappingResponse)(nil), "pds.MappingResponse")
	proto.RegisterType((*MappingFilter)(nil), "pds.MappingFilter")
	proto.RegisterType((*MappingGetRequest)(nil), "pds.MappingGetRequest")
	proto.RegisterType((*MappingGetResponse)(nil), "pds.MappingGetResponse")
	proto.RegisterType((*MappingDeleteRequest)(nil), "pds.MappingDeleteRequest")
	proto.RegisterType((*MappingDeleteResponse)(nil), "pds.MappingDeleteResponse")
}

func init() { proto.RegisterFile("mapping.proto", fileDescriptor_92521b297e0ff076) }

var fileDescriptor_92521b297e0ff076 = []byte{
	// 1154 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcf, 0x73, 0xdb, 0x44,
	0x14, 0xae, 0xe4, 0x9f, 0x79, 0xfe, 0x11, 0x67, 0xe3, 0xb4, 0xaa, 0xa7, 0xd4, 0xc6, 0x07, 0xc6,
	0x04, 0xd7, 0x14, 0x97, 0x32, 0x50, 0xca, 0x94, 0xc8, 0x35, 0xae, 0x48, 0x9c, 0x6a, 0xd6, 0xc1,
	0x33, 0x3d, 0x30, 0x19, 0xd9, 0xda, 0xa4, 0x02, 0x5b, 0x52, 0xa5, 0x75, 0x88, 0xff, 0x0a, 0xfe,
	0x1c, 0xce, 0xdc, 0x38, 0xf6, 0xc8, 0xc9, 0x30, 0x39, 0xe6, 0x98, 0xbf, 0x80, 0xd1, 0x6a, 0x25,
	0x4b, 0xae, 0x43, 0x27, 0xbd, 0x64, 0xa2, 0xef, 0x7d, 0xdf, 0x7b, 0xbb, 0xef, 0x7d, 0xbb, 0x6b,
	0x28, 0x4c, 0x35, 0xdb, 0x36, 0xcc, 0xd3, 0x96, 0xed, 0x58, 0xd4, 0x42, 0x09, 0x5b, 0x77, 0x2b,
	0x70, 0x6a, 0x9d, 0x5a, 0x3e, 0x50, 0xd9, 0x9c, 0x12, 0xaa, 0x7d, 0xee, 0xfd, 0xe1, 0x40, 0x8e,
	0xce, 0x6d, 0xe2, 0xfa, 0x1f, 0xf5, 0x11, 0xe4, 0x0f, 0x1e, 0xf5, 0xfd, 0x0c, 0xfb, 0x64, 0x8e,
	0x1a, 0x90, 0x1a, 0xaa, 0x1d, 0x45, 0x97, 0x84, 0x9a, 0xd0, 0xc8, 0xcb, 0xe8, 0x6a, 0x51, 0x2d,
	0x7a, 0xda, 0x27, 0x53, 0xcd, 0xd4, 0x35, 0x6a, 0x39, 0x73, 0xec, 0x13, 0x50, 0x03, 0xd2, 0x8a,
	0xba, 0xa7, 0xeb, 0x8e, 0x24, 0xd6, 0x84, 0x46, 0xae, 0x5d, 0x6a, 0xf9, 0x79, 0x7d, 0x90, 0xb8,
	0x2e, 0xe6, 0xf1, 0xfa, 0x73, 0xc8, 0x1f, 0xb4, 0x23, 0x35, 0x2a, 0x90, 0x1d, 0xcc, 0x46, 0x26,
	0xa1, 0x41, 0x19, 0x1c, 0x7e, 0x23, 0x09, 0x32, 0xfd, 0xbd, 0x4e, 0x98, 0x36, 0x89, 0x83, 0xcf,
	0xba, 0x05, 0x10, 0xc9, 0xf1, 0x29, 0xa4, 0x14, 0x75, 0x9f, 0xcc, 0x59, 0x82, 0x5c, 0x7b, 0xab,
	0x65, 0xeb, 0x6e, 0x2b, 0xba, 0x93, 0x17, 0xb7, 0xb0, 0xcf, 0x40, 0x9f, 0x41, 0xba, 0xbf, 0xd7,
	0xf1, 0xb8, 0x62, 0x94, 0xdb, 0x8e, 0x71, 0x39, 0x45, 0xde, 0x80, 0xcc, 0xaf, 0x64, 0x6e, 0x98,
	0x27, 0x56, 0xfd, 0xef, 0x14, 0xe4, 0x38, 0x67, 0x60, 0x93, 0x31, 0x6a, 0x82, 0x18, 0xf6, 0xe5,
	0xde, 0xd5, 0xa2, 0x2a, 0xc5, 0xfb, 0xd2, 0x34, 0xa6, 0xd3, 0x19, 0xd5, 0x46, 0x13, 0x82, 0x45,
	0x45, 0x47, 0xbd, 0x60, 0x81, 0xe2, 0x35, 0x0b, 0xfc, 0xff, 0x1c, 0xcb, 0xe5, 0x2b, 0xe1, 0xf2,
	0x13, 0xd7, 0x2c, 0xff, 0xbd, 0x99, 0x78, 0x02, 0xd4, 0x8a, 0x34, 0x3e, 0x79, 0xed, 0x7c, 0xa3,
	0xc3, 0x48, 0x0f, 0x4d, 0x63, 0xac, 0xe8, 0x52, 0xca, 0x63, 0xbf, 0x10, 0x30, 0xff, 0x46, 0xf7,
	0x20, 0x7b, 0x34, 0x33, 0x4d, 0x32, 0x51, 0x74, 0x29, 0xcd, 0x63, 0x21, 0x82, 0x1a, 0x50, 0x3c,
	0x24, 0xe7, 0xf4, 0xb5, 0x65, 0xf7, 0x1c, 0x6b, 0x66, 0x2b, 0xba, 0x94, 0xe1, 0x9c, 0x15, 0x1c,
	0x35, 0x97, 0xe3, 0xce, 0x7a, 0xe3, 0x5e, 0xbb, 0xa0, 0x80, 0x82, 0xbe, 0x82, 0x54, 0xd7, 0x1c,
	0x6b, 0xb6, 0xb4, 0xc1, 0x3a, 0x91, 0xe7, 0x8e, 0x63, 0xd8, 0x7a, 0xab, 0xb2, 0x10, 0x6a, 0x42,
	0x56, 0x9d, 0x8d, 0x26, 0xc6, 0x58, 0x51, 0x25, 0xb8, 0xc6, 0xac, 0x21, 0x03, 0x21, 0x48, 0x1e,
	0x69, 0xa7, 0xae, 0x94, 0xab, 0x25, 0x1a, 0x05, 0xcc, 0xfe, 0x47, 0x8f, 0x01, 0xfa, 0x84, 0x12,
	0xa7, 0x33, 0xd1, 0x5c, 0x57, 0xca, 0xd7, 0x84, 0x46, 0x41, 0xde, 0xb9, 0x5a, 0x54, 0xb7, 0x58,
	0x41, 0x47, 0x33, 0x4f, 0xc9, 0x93, 0x2f, 0x1e, 0x7c, 0xf9, 0xf0, 0x9b, 0xc7, 0x38, 0x42, 0xf4,
	0x64, 0x83, 0xb3, 0x31, 0x26, 0xbf, 0x39, 0x06, 0x25, 0x52, 0x81, 0x95, 0xde, 0xe1, 0xa5, 0x97,
	0x01, 0xc5, 0x3c, 0xb1, 0x70, 0x84, 0x88, 0x7a, 0x90, 0x3c, 0x9a, 0xdb, 0x44, 0x2a, 0xd6, 0x84,
	0x46, 0xb1, 0x5d, 0x62, 0x03, 0xe7, 0xe3, 0xf6, 0x70, 0xf9, 0xe3, 0xab, 0x45, 0xf5, 0x23, 0x56,
	0x59, 0x27, 0x27, 0xda, 0x6c, 0x42, 0xbf, 0xeb, 0xef, 0xa9, 0xaa, 0x72, 0xd8, 0x3b, 0x3e, 0x7a,
	0xa5, 0x76, 0x8f, 0x87, 0x6a, 0x07, 0xb3, 0x04, 0x72, 0x0e, 0x36, 0xa6, 0xda, 0xf8, 0xd8, 0x72,
	0x8e, 0x0d, 0xdb, 0xb3, 0xb6, 0xee, 0x52, 0x66, 0xed, 0xdf, 0x05, 0x28, 0x04, 0xd6, 0xa6, 0x1a,
	0x9d, 0xb9, 0xe8, 0x13, 0x28, 0x06, 0x0d, 0x38, 0xd4, 0xa8, 0xa2, 0x9f, 0x33, 0xa3, 0x17, 0xf0,
	0x0a, 0x8a, 0x1a, 0xb0, 0xa9, 0x3a, 0xc6, 0x99, 0x46, 0x49, 0x48, 0x14, 0x19, 0x71, 0x15, 0xf6,
	0x9a, 0xce, 0x0d, 0xa1, 0x4a, 0x89, 0x5a, 0x62, 0x7d, 0xd3, 0x03, 0x46, 0xbd, 0x08, 0xf9, 0xc8,
	0x82, 0xdc, 0xfa, 0x9f, 0x22, 0x64, 0x38, 0x80, 0xbe, 0x85, 0xac, 0xb7, 0x9b, 0x3e, 0xa1, 0x1a,
	0x3f, 0xee, 0xc5, 0x16, 0xbb, 0xcf, 0x02, 0x54, 0xde, 0x7c, 0xbb, 0xa8, 0x0a, 0x97, 0x8b, 0x6a,
	0xa6, 0x69, 0x98, 0x13, 0xc3, 0x24, 0x38, 0x14, 0xa0, 0x67, 0x90, 0x79, 0x39, 0xfa, 0x85, 0x69,
	0xfd, 0x93, 0x58, 0xf0, 0xb5, 0x1c, 0x94, 0x6f, 0x73, 0x29, 0xb3, 0x4e, 0xd3, 0x9a, 0x1a, 0x94,
	0x4c, 0x6d, 0x3a, 0xc7, 0x81, 0x0a, 0x7d, 0x0d, 0x49, 0xef, 0xf8, 0xf3, 0xd3, 0x17, 0x1b, 0x86,
	0x87, 0xcb, 0xc8, 0x13, 0xbb, 0x36, 0x19, 0x47, 0xc4, 0x4c, 0x81, 0xbe, 0x87, 0xb4, 0xdf, 0x5d,
	0x76, 0xd8, 0x72, 0x6d, 0x14, 0xd3, 0xb2, 0x88, 0x5c, 0xbe, 0x5c, 0x54, 0x4b, 0x2e, 0xfb, 0x3f,
	0xa2, 0xe7, 0x3a, 0xf4, 0x14, 0x52, 0xac, 0x1d, 0xec, 0xfc, 0x05, 0x47, 0x3f, 0xda, 0x27, 0x79,
	0xfb, 0x72, 0x51, 0xdd, 0xf4, 0xf4, 0x51, 0xb9, 0x2f, 0xaa, 0x4f, 0xa0, 0xc8, 0xb9, 0x98, 0xbc,
	0x99, 0x11, 0x97, 0xa2, 0x16, 0x6c, 0xc8, 0x1a, 0x1d, 0xbf, 0xee, 0xd0, 0x73, 0xca, 0x5b, 0x19,
	0x0c, 0x25, 0xc4, 0xf1, 0x92, 0x82, 0x76, 0x21, 0xc3, 0xa5, 0x92, 0xc8, 0x47, 0xb8, 0xb2, 0x7d,
	0x1c, 0x10, 0xea, 0x6f, 0x60, 0x33, 0xac, 0xe6, 0xda, 0x96, 0xe9, 0x12, 0xaf, 0xdc, 0x9e, 0x6d,
	0xf0, 0x1e, 0x08, 0xdc, 0xcc, 0x7e, 0xb9, 0x10, 0xc7, 0x4b, 0x8a, 0x77, 0x3f, 0x05, 0x5a, 0x5e,
	0x6f, 0x4d, 0xcb, 0x70, 0xc8, 0xa9, 0xff, 0xb1, 0xb4, 0xf1, 0x0f, 0xc6, 0x84, 0x12, 0x07, 0x95,
	0x21, 0x75, 0x60, 0x8d, 0xb5, 0x09, 0xab, 0x96, 0xc5, 0xfe, 0x07, 0x7a, 0x00, 0x99, 0x7d, 0x32,
	0x67, 0x47, 0x4a, 0x64, 0xab, 0xd8, 0x8e, 0xa6, 0xe5, 0x21, 0x1c, 0x70, 0x96, 0x6f, 0x4b, 0xe2,
	0x06, 0x6f, 0x4b, 0xf2, 0x46, 0x6f, 0xcb, 0x4b, 0xd8, 0xe2, 0x94, 0x1e, 0xa1, 0xc1, 0x74, 0x8a,
	0xfc, 0x81, 0x49, 0x34, 0xf2, 0xec, 0x09, 0xd9, 0x85, 0xb4, 0xbf, 0x2d, 0xee, 0xdc, 0x58, 0x33,
	0xfc, 0x08, 0xe6, 0x8c, 0xba, 0x09, 0x28, 0x9a, 0xf0, 0x03, 0x07, 0xd0, 0x78, 0x67, 0x00, 0xf9,
	0x68, 0xcd, 0x48, 0xeb, 0x87, 0x50, 0xe6, 0xe0, 0x73, 0x32, 0x21, 0x94, 0x7c, 0xa8, 0xc3, 0xfc,
	0x3d, 0x8b, 0xc1, 0x9e, 0xeb, 0x3d, 0xd8, 0x59, 0xc9, 0xbb, 0x7e, 0x2b, 0x89, 0xf7, 0x6c, 0x65,
	0x77, 0x1a, 0x3e, 0xde, 0x6c, 0xa6, 0x3b, 0xb0, 0x15, 0xbb, 0x23, 0x0f, 0x5f, 0x1e, 0x76, 0x4b,
	0xb7, 0x50, 0x19, 0x4a, 0xab, 0x57, 0x67, 0x49, 0x40, 0x12, 0x94, 0x63, 0xe8, 0xa0, 0x8b, 0x87,
	0x4a, 0xa7, 0x5b, 0x12, 0xd1, 0x1d, 0xd8, 0x8e, 0x45, 0x0e, 0xe4, 0xe3, 0xa1, 0xa2, 0x96, 0x12,
	0xbb, 0x3f, 0x87, 0x67, 0x2d, 0x70, 0xd1, 0x5d, 0xd8, 0x09, 0xa8, 0xfb, 0xdd, 0x57, 0xb1, 0xaa,
	0x91, 0x2c, 0x61, 0xe8, 0xa0, 0x5d, 0x12, 0xd6, 0x07, 0x1e, 0x95, 0xc4, 0xf6, 0x3f, 0x62, 0xf8,
	0xeb, 0x67, 0x70, 0x36, 0x46, 0x4f, 0x43, 0xdf, 0x77, 0x1c, 0xa2, 0x51, 0x82, 0x62, 0x86, 0xe6,
	0xb3, 0xa8, 0x94, 0xe3, 0x20, 0x9f, 0xdc, 0xad, 0x88, 0xfa, 0x27, 0x5b, 0xbf, 0xb1, 0xfa, 0x59,
	0xb8, 0x92, 0x1e, 0xa1, 0xe8, 0x76, 0x94, 0xb5, 0xf4, 0x72, 0xe5, 0xce, 0x3b, 0x78, 0x98, 0xe0,
	0x47, 0xd8, 0x5e, 0xe2, 0x03, 0xea, 0x10, 0x6d, 0xea, 0xdd, 0xf2, 0x37, 0xcf, 0xf4, 0x50, 0x40,
	0x2f, 0xc2, 0xad, 0xf8, 0x76, 0x41, 0x77, 0xa3, 0xec, 0x98, 0x35, 0x2b, 0x95, 0x75, 0xa1, 0x20,
	0x97, 0x9c, 0xff, 0xeb, 0xe2, 0xbe, 0xf0, 0xf6, 0xe2, 0xbe, 0xf0, 0xef, 0xc5, 0x7d, 0x61, 0x94,
	0x66, 0xbf, 0x8e, 0x1f, 0xfd, 0x17, 0x00, 0x00, 0xff, 0xff, 0x35, 0x91, 0x79, 0x9c, 0x5d, 0x0b,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MappingSvcClient is the client API for MappingSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MappingSvcClient interface {
	MappingCreate(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	MappingUpdate(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	MappingGet(ctx context.Context, in *MappingGetRequest, opts ...grpc.CallOption) (*MappingGetResponse, error)
	MappingGetStreaming(ctx context.Context, in *MappingGetRequest, opts ...grpc.CallOption) (MappingSvc_MappingGetStreamingClient, error)
	MappingDelete(ctx context.Context, in *MappingDeleteRequest, opts ...grpc.CallOption) (*MappingDeleteResponse, error)
}

type mappingSvcClient struct {
	cc *grpc.ClientConn
}

func NewMappingSvcClient(cc *grpc.ClientConn) MappingSvcClient {
	return &mappingSvcClient{cc}
}

func (c *mappingSvcClient) MappingCreate(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, "/pds.MappingSvc/MappingCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingSvcClient) MappingUpdate(ctx context.Context, in *MappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, "/pds.MappingSvc/MappingUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingSvcClient) MappingGet(ctx context.Context, in *MappingGetRequest, opts ...grpc.CallOption) (*MappingGetResponse, error) {
	out := new(MappingGetResponse)
	err := c.cc.Invoke(ctx, "/pds.MappingSvc/MappingGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mappingSvcClient) MappingGetStreaming(ctx context.Context, in *MappingGetRequest, opts ...grpc.CallOption) (MappingSvc_MappingGetStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MappingSvc_serviceDesc.Streams[0], "/pds.MappingSvc/MappingGetStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &mappingSvcMappingGetStreamingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MappingSvc_MappingGetStreamingClient interface {
	Recv() (*MappingGetResponse, error)
	grpc.ClientStream
}

type mappingSvcMappingGetStreamingClient struct {
	grpc.ClientStream
}

func (x *mappingSvcMappingGetStreamingClient) Recv() (*MappingGetResponse, error) {
	m := new(MappingGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mappingSvcClient) MappingDelete(ctx context.Context, in *MappingDeleteRequest, opts ...grpc.CallOption) (*MappingDeleteResponse, error) {
	out := new(MappingDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.MappingSvc/MappingDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MappingSvcServer is the server API for MappingSvc service.
type MappingSvcServer interface {
	MappingCreate(context.Context, *MappingRequest) (*MappingResponse, error)
	MappingUpdate(context.Context, *MappingRequest) (*MappingResponse, error)
	MappingGet(context.Context, *MappingGetRequest) (*MappingGetResponse, error)
	MappingGetStreaming(*MappingGetRequest, MappingSvc_MappingGetStreamingServer) error
	MappingDelete(context.Context, *MappingDeleteRequest) (*MappingDeleteResponse, error)
}

// UnimplementedMappingSvcServer can be embedded to have forward compatible implementations.
type UnimplementedMappingSvcServer struct {
}

func (*UnimplementedMappingSvcServer) MappingCreate(ctx context.Context, req *MappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MappingCreate not implemented")
}
func (*UnimplementedMappingSvcServer) MappingUpdate(ctx context.Context, req *MappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MappingUpdate not implemented")
}
func (*UnimplementedMappingSvcServer) MappingGet(ctx context.Context, req *MappingGetRequest) (*MappingGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MappingGet not implemented")
}
func (*UnimplementedMappingSvcServer) MappingGetStreaming(req *MappingGetRequest, srv MappingSvc_MappingGetStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method MappingGetStreaming not implemented")
}
func (*UnimplementedMappingSvcServer) MappingDelete(ctx context.Context, req *MappingDeleteRequest) (*MappingDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MappingDelete not implemented")
}

func RegisterMappingSvcServer(s *grpc.Server, srv MappingSvcServer) {
	s.RegisterService(&_MappingSvc_serviceDesc, srv)
}

func _MappingSvc_MappingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingSvcServer).MappingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MappingSvc/MappingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingSvcServer).MappingCreate(ctx, req.(*MappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingSvc_MappingUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingSvcServer).MappingUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MappingSvc/MappingUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingSvcServer).MappingUpdate(ctx, req.(*MappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingSvc_MappingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MappingGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingSvcServer).MappingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MappingSvc/MappingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingSvcServer).MappingGet(ctx, req.(*MappingGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MappingSvc_MappingGetStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MappingGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MappingSvcServer).MappingGetStreaming(m, &mappingSvcMappingGetStreamingServer{stream})
}

type MappingSvc_MappingGetStreamingServer interface {
	Send(*MappingGetResponse) error
	grpc.ServerStream
}

type mappingSvcMappingGetStreamingServer struct {
	grpc.ServerStream
}

func (x *mappingSvcMappingGetStreamingServer) Send(m *MappingGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MappingSvc_MappingDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MappingDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MappingSvcServer).MappingDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MappingSvc/MappingDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MappingSvcServer).MappingDelete(ctx, req.(*MappingDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MappingSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.MappingSvc",
	HandlerType: (*MappingSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MappingCreate",
			Handler:    _MappingSvc_MappingCreate_Handler,
		},
		{
			MethodName: "MappingUpdate",
			Handler:    _MappingSvc_MappingUpdate_Handler,
		},
		{
			MethodName: "MappingGet",
			Handler:    _MappingSvc_MappingGet_Handler,
		},
		{
			MethodName: "MappingDelete",
			Handler:    _MappingSvc_MappingDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MappingGetStreaming",
			Handler:       _MappingSvc_MappingGetStreaming_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mapping.proto",
}

func (m *L3MappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3MappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3MappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L2MappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddr != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keyinfo != nil {
		{
			size := m.Keyinfo.Size()
			i -= size
			if _, err := m.Keyinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MappingKey_IPKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingKey_IPKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPKey != nil {
		{
			size, err := m.IPKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MappingKey_MACKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingKey_MACKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MACKey != nil {
		{
			size, err := m.MACKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x70
	}
	if m.SvcRewrite != nil {
		{
			size, err := m.SvcRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.MeterClass != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.MeterClass))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Tags) > 0 {
		dAtA6 := make([]byte, len(m.Tags)*10)
		var j5 int
		for _, num := range m.Tags {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintMapping(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x5a
	}
	if m.PublicIP != nil {
		{
			size, err := m.PublicIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.MACAddr != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x40
	}
	if m.Dstinfo != nil {
		{
			size := m.Dstinfo.Size()
			i -= size
			if _, err := m.Dstinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x22
	}
	if m.MacOrIp != nil {
		{
			size := m.MacOrIp.Size()
			i -= size
			if _, err := m.MacOrIp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MappingSpec_IPKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingSpec_IPKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPKey != nil {
		{
			size, err := m.IPKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MappingSpec_MACKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingSpec_MACKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MACKey != nil {
		{
			size, err := m.MACKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MappingSpec_VnicId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingSpec_VnicId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnicId != nil {
		i -= len(m.VnicId)
		copy(dAtA[i:], m.VnicId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.VnicId)))
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MappingSpec_TunnelId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingSpec_TunnelId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelId != nil {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MappingSpec_NexthopGroupId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingSpec_NexthopGroupId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NexthopGroupId != nil {
		i -= len(m.NexthopGroupId)
		copy(dAtA[i:], m.NexthopGroupId)
		i = encodeVarintMapping(dAtA, i, uint64(len(m.NexthopGroupId)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *MappingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TunnelIP) > 0 {
		for iNdEx := len(m.TunnelIP) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TunnelIP[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapping(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PrivateIPNatIdx != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.PrivateIPNatIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.PublicIPNatIdx != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.PublicIPNatIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MappingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Mapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MappingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapping(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MappingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapping(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MappingFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keyinfo != nil {
		{
			size := m.Keyinfo.Size()
			i -= size
			if _, err := m.Keyinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.KeyType != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x10
	}
	if m.Local {
		i--
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MappingFilter_IPKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingFilter_IPKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPKey != nil {
		{
			size, err := m.IPKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MappingFilter_MACKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MappingFilter_MACKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MACKey != nil {
		{
			size, err := m.MACKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MappingGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMapping(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MappingGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMapping(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMapping(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MappingDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMapping(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMapping(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MappingDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA22 := make([]byte, len(m.ApiStatus)*10)
		var j21 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintMapping(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMapping(dAtA []byte, offset int, v uint64) int {
	offset -= sovMapping(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *L3MappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L2MappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovMapping(uint64(m.MACAddr))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Keyinfo != nil {
		n += m.Keyinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingKey_IPKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPKey != nil {
		l = m.IPKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingKey_MACKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MACKey != nil {
		l = m.MACKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.MacOrIp != nil {
		n += m.MacOrIp.Size()
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.Dstinfo != nil {
		n += m.Dstinfo.Size()
	}
	if m.MACAddr != 0 {
		n += 1 + sovMapping(uint64(m.MACAddr))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.PublicIP != nil {
		l = m.PublicIP.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if len(m.Tags) > 0 {
		l = 0
		for _, e := range m.Tags {
			l += sovMapping(uint64(e))
		}
		n += 1 + sovMapping(uint64(l)) + l
	}
	if m.MeterClass != 0 {
		n += 1 + sovMapping(uint64(m.MeterClass))
	}
	if m.SvcRewrite != nil {
		l = m.SvcRewrite.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMapping(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingSpec_IPKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPKey != nil {
		l = m.IPKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingSpec_MACKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MACKey != nil {
		l = m.MACKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingSpec_VnicId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnicId != nil {
		l = len(m.VnicId)
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingSpec_TunnelId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		l = len(m.TunnelId)
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingSpec_NexthopGroupId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NexthopGroupId != nil {
		l = len(m.NexthopGroupId)
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicIPNatIdx != 0 {
		n += 1 + sovMapping(uint64(m.PublicIPNatIdx))
	}
	if m.PrivateIPNatIdx != 0 {
		n += 1 + sovMapping(uint64(m.PrivateIPNatIdx))
	}
	if len(m.TunnelIP) > 0 {
		for _, e := range m.TunnelIP {
			l = e.Size()
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMapping(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local {
		n += 2
	}
	if m.KeyType != 0 {
		n += 1 + sovMapping(uint64(m.KeyType))
	}
	if m.Keyinfo != nil {
		n += m.Keyinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingFilter_IPKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPKey != nil {
		l = m.IPKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingFilter_MACKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MACKey != nil {
		l = m.MACKey.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	return n
}
func (m *MappingGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMapping(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMapping(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMapping(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MappingDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovMapping(uint64(e))
		}
		n += 1 + sovMapping(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMapping(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMapping(x uint64) (n int) {
	return sovMapping(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *L3MappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3MappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3MappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &MappingKey_IPKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &MappingKey_MACKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MacOrIp = &MappingSpec_IPKey{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MacOrIp = &MappingSpec_MACKey{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Dstinfo = &MappingSpec_VnicId{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Dstinfo = &MappingSpec_TunnelId{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopGroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Dstinfo = &MappingSpec_NexthopGroupId{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicIP == nil {
				m.PublicIP = &IPAddress{}
			}
			if err := m.PublicIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapping
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tags = append(m.Tags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapping
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapping
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapping
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Tags) == 0 {
					m.Tags = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapping
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tags = append(m.Tags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterClass", wireType)
			}
			m.MeterClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterClass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvcRewrite == nil {
				m.SvcRewrite = &SvcRewriteInfo{}
			}
			if err := m.SvcRewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MappingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIPNatIdx", wireType)
			}
			m.PublicIPNatIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicIPNatIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateIPNatIdx", wireType)
			}
			m.PrivateIPNatIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivateIPNatIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelIP = append(m.TunnelIP, &IPAddress{})
			if err := m.TunnelIP[len(m.TunnelIP)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MappingSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MappingStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MappingSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MappingStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= MappingKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &MappingFilter_IPKey{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2MappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &MappingFilter_MACKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &MappingFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Mapping{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMapping
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMapping
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapping
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMapping
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMapping
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMapping
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMapping
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMapping(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMapping
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMapping(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMapping
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMapping
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMapping
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMapping
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMapping
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMapping(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMapping
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMapping = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMapping   = fmt.Errorf("proto: integer overflow")
)
