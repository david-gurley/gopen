// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: device.proto

package pds

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MemoryProfile int32

const (
	MemoryProfile_MEMORY_PROFILE_DEFAULT MemoryProfile = 0
	// router profile will support 256K routes per IPv4
	// route table and a total of 32 such route tables
	MemoryProfile_MEMORY_PROFILE_ROUTER MemoryProfile = 1
	// use IPSEC memory profile for IPSec feature
	MemoryProfile_MEMORY_PROFILE_IPSEC MemoryProfile = 2
)

var MemoryProfile_name = map[int32]string{
	0: "MEMORY_PROFILE_DEFAULT",
	1: "MEMORY_PROFILE_ROUTER",
	2: "MEMORY_PROFILE_IPSEC",
}

var MemoryProfile_value = map[string]int32{
	"MEMORY_PROFILE_DEFAULT": 0,
	"MEMORY_PROFILE_ROUTER":  1,
	"MEMORY_PROFILE_IPSEC":   2,
}

func (x MemoryProfile) String() string {
	return proto.EnumName(MemoryProfile_name, int32(x))
}

func (MemoryProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{0}
}

type DeviceProfile int32

const (
	DeviceProfile_DEVICE_PROFILE_DEFAULT            DeviceProfile = 0
	DeviceProfile_DEVICE_PROFILE_1PF                DeviceProfile = 1
	DeviceProfile_DEVICE_PROFILE_2PF                DeviceProfile = 2
	DeviceProfile_DEVICE_PROFILE_3PF                DeviceProfile = 3
	DeviceProfile_DEVICE_PROFILE_4PF                DeviceProfile = 4
	DeviceProfile_DEVICE_PROFILE_5PF                DeviceProfile = 5
	DeviceProfile_DEVICE_PROFILE_6PF                DeviceProfile = 6
	DeviceProfile_DEVICE_PROFILE_7PF                DeviceProfile = 7
	DeviceProfile_DEVICE_PROFILE_8PF                DeviceProfile = 8
	DeviceProfile_DEVICE_PROFILE_16PF               DeviceProfile = 9
	DeviceProfile_DEVICE_PROFILE_32VF               DeviceProfile = 10
	DeviceProfile_DEVICE_PROFILE_64VF               DeviceProfile = 11
	DeviceProfile_DEVICE_PROFILE_BITW_SMART_SERVICE DeviceProfile = 12
	DeviceProfile_DEVICE_PROFILE_BITW_SMART_SWITCH  DeviceProfile = 13
)

var DeviceProfile_name = map[int32]string{
	0:  "DEVICE_PROFILE_DEFAULT",
	1:  "DEVICE_PROFILE_1PF",
	2:  "DEVICE_PROFILE_2PF",
	3:  "DEVICE_PROFILE_3PF",
	4:  "DEVICE_PROFILE_4PF",
	5:  "DEVICE_PROFILE_5PF",
	6:  "DEVICE_PROFILE_6PF",
	7:  "DEVICE_PROFILE_7PF",
	8:  "DEVICE_PROFILE_8PF",
	9:  "DEVICE_PROFILE_16PF",
	10: "DEVICE_PROFILE_32VF",
	11: "DEVICE_PROFILE_64VF",
	12: "DEVICE_PROFILE_BITW_SMART_SERVICE",
	13: "DEVICE_PROFILE_BITW_SMART_SWITCH",
}

var DeviceProfile_value = map[string]int32{
	"DEVICE_PROFILE_DEFAULT":            0,
	"DEVICE_PROFILE_1PF":                1,
	"DEVICE_PROFILE_2PF":                2,
	"DEVICE_PROFILE_3PF":                3,
	"DEVICE_PROFILE_4PF":                4,
	"DEVICE_PROFILE_5PF":                5,
	"DEVICE_PROFILE_6PF":                6,
	"DEVICE_PROFILE_7PF":                7,
	"DEVICE_PROFILE_8PF":                8,
	"DEVICE_PROFILE_16PF":               9,
	"DEVICE_PROFILE_32VF":               10,
	"DEVICE_PROFILE_64VF":               11,
	"DEVICE_PROFILE_BITW_SMART_SERVICE": 12,
	"DEVICE_PROFILE_BITW_SMART_SWITCH":  13,
}

func (x DeviceProfile) String() string {
	return proto.EnumName(DeviceProfile_name, int32(x))
}

func (DeviceProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{1}
}

// operational mode of the device
// NOTE:
// multiple connectivity models are possible in SMART_SWITCH and SMART_SERVICE
// modes:
//     a. one uplink handles traffic from/to host side and other uplink handles
//        traffic from/to fabric/sdn
//     b. both uplinks can send and receive traffic from/to host and from/to
//        fabric side (i.e., both links are treated the same way and probably
//        ECMP-ed), this connectivity model is useful when DSC is deployed
//        behind/alongside a switch and switch is redirecting traffic to DSCs
//        (aka. sidecar model) and making forwarding decisions
type DeviceOperMode int32

const (
	DeviceOperMode_DEVICE_OPER_MODE_NONE DeviceOperMode = 0
	// HOST mode with workloads on pcie; it is flow based and supports all
	// features (IP services like firewall, NAT etc.) depending on the memory
	// profile configured
	DeviceOperMode_DEVICE_OPER_MODE_HOST DeviceOperMode = 1
	// in SMART_SWITCH mode, DSC acts as bump-in-the-wire device; it is flow
	// based and does forwarding (based on mappings and routes) while
	// supporting all IP (smart) service features (and is flow based) depending
	// on the memory profile configured; the switch connected via the sdn
	// port(s) will do only underlay routing on the encapped (by DSC) traiffc
	DeviceOperMode_DEVICE_OPER_MODE_BITW_SMART_SWITCH DeviceOperMode = 2
	// in SMART_SERVICE mode, DSC is flow based and provides IP service
	// features; it doesn't do forwarding (i.e. L2 or L3 lookups), i.e. no
	// L2/L3 mappings need to be configured and IP routing is not enabled
	DeviceOperMode_DEVICE_OPER_MODE_BITW_SMART_SERVICE DeviceOperMode = 3
	// in CLASSIC_SWITCH mode, DSC performs routing and no IP services are
	// performed; additionally this is not flow based mode and hence every
	// packet is subjected to route table and/or mapping lookups (routes are
	// either programmed via grpc or distributed via control protocol like BGP)
	DeviceOperMode_DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH DeviceOperMode = 4
)

var DeviceOperMode_name = map[int32]string{
	0: "DEVICE_OPER_MODE_NONE",
	1: "DEVICE_OPER_MODE_HOST",
	2: "DEVICE_OPER_MODE_BITW_SMART_SWITCH",
	3: "DEVICE_OPER_MODE_BITW_SMART_SERVICE",
	4: "DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH",
}

var DeviceOperMode_value = map[string]int32{
	"DEVICE_OPER_MODE_NONE":                0,
	"DEVICE_OPER_MODE_HOST":                1,
	"DEVICE_OPER_MODE_BITW_SMART_SWITCH":   2,
	"DEVICE_OPER_MODE_BITW_SMART_SERVICE":  3,
	"DEVICE_OPER_MODE_BITW_CLASSIC_SWITCH": 4,
}

func (x DeviceOperMode) String() string {
	return proto.EnumName(DeviceOperMode_name, int32(x))
}

func (DeviceOperMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{2}
}

// HARole defines the role of the DSC when HA is enabled
type HARole int32

const (
	// HA_ROLE_NONE is used when HA feature is not enabled
	HARole_HA_ROLE_NONE HARole = 0
	// HA_ROLE_ACTIVE is configured on the DSC that is active DSC w.r.t forwaring
	// and flow sync
	HARole_HA_ROLE_ACTIVE HARole = 1
	// HA_ROLE_STANDBY is configured on DSC that is in standby mode receiving
	// flow informtion from ACTIVE node and not forwarding traffic
	HARole_HA_ROLE_STANDBY HARole = 2
)

var HARole_name = map[int32]string{
	0: "HA_ROLE_NONE",
	1: "HA_ROLE_ACTIVE",
	2: "HA_ROLE_STANDBY",
}

var HARole_value = map[string]int32{
	"HA_ROLE_NONE":    0,
	"HA_ROLE_ACTIVE":  1,
	"HA_ROLE_STANDBY": 2,
}

func (x HARole) String() string {
	return proto.EnumName(HARole_name, int32(x))
}

func (HARole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{3}
}

// device health status, multiple conditions can happen
type DeviceHealth int32

const (
	DeviceHealth_DEVICE_HEALTH_NONE            DeviceHealth = 0
	DeviceHealth_DEVICE_HEALTH_OK              DeviceHealth = 1
	DeviceHealth_DEVICE_HEALTH_SERVICE_DOWN    DeviceHealth = 2
	DeviceHealth_DEVICE_HEALTH_REBOOT_REQUIRED DeviceHealth = 3
	DeviceHealth_DEVICE_HEALTH_LOW_MEMORY      DeviceHealth = 4
	DeviceHealth_DEVICE_HEALTH_HARDWARE_ERROR  DeviceHealth = 5
)

var DeviceHealth_name = map[int32]string{
	0: "DEVICE_HEALTH_NONE",
	1: "DEVICE_HEALTH_OK",
	2: "DEVICE_HEALTH_SERVICE_DOWN",
	3: "DEVICE_HEALTH_REBOOT_REQUIRED",
	4: "DEVICE_HEALTH_LOW_MEMORY",
	5: "DEVICE_HEALTH_HARDWARE_ERROR",
}

var DeviceHealth_value = map[string]int32{
	"DEVICE_HEALTH_NONE":            0,
	"DEVICE_HEALTH_OK":              1,
	"DEVICE_HEALTH_SERVICE_DOWN":    2,
	"DEVICE_HEALTH_REBOOT_REQUIRED": 3,
	"DEVICE_HEALTH_LOW_MEMORY":      4,
	"DEVICE_HEALTH_HARDWARE_ERROR":  5,
}

func (x DeviceHealth) String() string {
	return proto.EnumName(DeviceHealth_name, int32(x))
}

func (DeviceHealth) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{4}
}

// different initialization modes of the firmware
type FirmwareInitMode int32

const (
	FirmwareInitMode_FIRMWARE_INIT_MODE_NONE FirmwareInitMode = 0
	// firmware initialized due to cold reboot
	FirmwareInitMode_FIRMWARE_INIT_MODE_DEFAULT FirmwareInitMode = 1
	// firmware initialized due to graceful upgrade
	FirmwareInitMode_FIRMWARE_INIT_MODE_GRACEFUL FirmwareInitMode = 2
	// firmware initialized due to hitless upgrade
	FirmwareInitMode_FIRMWARE_INIT_MODE_HITLESS FirmwareInitMode = 3
	// firmware initialized due to stateful upgrade
	FirmwareInitMode_FIRMWARE_INIT_MODE_STATEFUL FirmwareInitMode = 4
	// firmware initialized due to failure recovery
	FirmwareInitMode_FIRMWARE_INIT_MODE_RECOVERY FirmwareInitMode = 5
)

var FirmwareInitMode_name = map[int32]string{
	0: "FIRMWARE_INIT_MODE_NONE",
	1: "FIRMWARE_INIT_MODE_DEFAULT",
	2: "FIRMWARE_INIT_MODE_GRACEFUL",
	3: "FIRMWARE_INIT_MODE_HITLESS",
	4: "FIRMWARE_INIT_MODE_STATEFUL",
	5: "FIRMWARE_INIT_MODE_RECOVERY",
}

var FirmwareInitMode_value = map[string]int32{
	"FIRMWARE_INIT_MODE_NONE":     0,
	"FIRMWARE_INIT_MODE_DEFAULT":  1,
	"FIRMWARE_INIT_MODE_GRACEFUL": 2,
	"FIRMWARE_INIT_MODE_HITLESS":  3,
	"FIRMWARE_INIT_MODE_STATEFUL": 4,
	"FIRMWARE_INIT_MODE_RECOVERY": 5,
}

func (x FirmwareInitMode) String() string {
	return proto.EnumName(FirmwareInitMode_name, int32(x))
}

func (FirmwareInitMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{5}
}

// penvisor instance in which firware is running
type FirmwareInstance int32

const (
	FirmwareInstance_FIRMWARE_INSTANCE_NONE FirmwareInstance = 0
	FirmwareInstance_FIRMWARE_INSTANCE_A    FirmwareInstance = 1
	FirmwareInstance_FIRMWARE_INSTANCE_B    FirmwareInstance = 2
)

var FirmwareInstance_name = map[int32]string{
	0: "FIRMWARE_INSTANCE_NONE",
	1: "FIRMWARE_INSTANCE_A",
	2: "FIRMWARE_INSTANCE_B",
}

var FirmwareInstance_value = map[string]int32{
	"FIRMWARE_INSTANCE_NONE": 0,
	"FIRMWARE_INSTANCE_A":    1,
	"FIRMWARE_INSTANCE_B":    2,
}

func (x FirmwareInstance) String() string {
	return proto.EnumName(FirmwareInstance_name, int32(x))
}

func (FirmwareInstance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{6}
}

// VNIRange captures a VxLAN VNI (or GRE key) range
type VNIRange struct {
	// low end of the VNI range
	VNILow uint32 `protobuf:"varint,1,opt,name=VNILow,proto3" json:"VNILow,omitempty"`
	// high end of the VNI range
	VNIHigh              uint32   `protobuf:"varint,2,opt,name=VNIHigh,proto3" json:"VNIHigh,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNIRange) Reset()         { *m = VNIRange{} }
func (m *VNIRange) String() string { return proto.CompactTextString(m) }
func (*VNIRange) ProtoMessage()    {}
func (*VNIRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{0}
}
func (m *VNIRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VNIRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VNIRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VNIRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNIRange.Merge(m, src)
}
func (m *VNIRange) XXX_Size() int {
	return m.Size()
}
func (m *VNIRange) XXX_DiscardUnknown() {
	xxx_messageInfo_VNIRange.DiscardUnknown(m)
}

var xxx_messageInfo_VNIRange proto.InternalMessageInfo

func (m *VNIRange) GetVNILow() uint32 {
	if m != nil {
		return m.VNILow
	}
	return 0
}

func (m *VNIRange) GetVNIHigh() uint32 {
	if m != nil {
		return m.VNIHigh
	}
	return 0
}

// ControlNetworkSpec captures all the configuration required for control
// network conectivity used for flow sync (and any associated state) etc. to
// peer DSC
// NOTE: this information can be used to generate ping-pongs for liveness
//       detection as well to perform faster failover for convergence
type ControlNetworkSpec struct {
	// LocalIP is the underlay IP address of this DSC that is used while
	// exchanging flow related state with the peer
	// NOTE: this IP address can be different from that IPAddr attribute of
	//       DeviceSpec
	LocalIP *IPAddress `protobuf:"bytes,1,opt,name=LocalIP,proto3" json:"LocalIP,omitempty"`
	// PeerIPAddr is the underlay IP address of the peer DSC device with which
	// control msgs are exchanged (e.g. flow information and associated state
	// sync messages)
	PeerIP *IPAddress `protobuf:"bytes,2,opt,name=PeerIP,proto3" json:"PeerIP,omitempty"`
	// Vlan, if non-zero, to be used for peer-to-peer control messages between
	// the nodes
	// NOTE: if Vlan is not configured, peer-to-peer control traffic goes untaggd
	Vlan uint32 `protobuf:"varint,3,opt,name=Vlan,proto3" json:"Vlan,omitempty" meta:range:0-4095,default=0`
	// BGP communities attached with the route advertisement corresponding to
	// the LocalIP
	// NOTE: only one community is supported currently
	BGPCommunity         []*BGPCommunity `protobuf:"bytes,4,rep,name=BGPCommunity,proto3" json:"BGPCommunity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ControlNetworkSpec) Reset()         { *m = ControlNetworkSpec{} }
func (m *ControlNetworkSpec) String() string { return proto.CompactTextString(m) }
func (*ControlNetworkSpec) ProtoMessage()    {}
func (*ControlNetworkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{1}
}
func (m *ControlNetworkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlNetworkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlNetworkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlNetworkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlNetworkSpec.Merge(m, src)
}
func (m *ControlNetworkSpec) XXX_Size() int {
	return m.Size()
}
func (m *ControlNetworkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlNetworkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ControlNetworkSpec proto.InternalMessageInfo

func (m *ControlNetworkSpec) GetLocalIP() *IPAddress {
	if m != nil {
		return m.LocalIP
	}
	return nil
}

func (m *ControlNetworkSpec) GetPeerIP() *IPAddress {
	if m != nil {
		return m.PeerIP
	}
	return nil
}

func (m *ControlNetworkSpec) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *ControlNetworkSpec) GetBGPCommunity() []*BGPCommunity {
	if m != nil {
		return m.BGPCommunity
	}
	return nil
}

// MgmtNetworkSpec captures all the management network related parameters
type MgmtNetworkSpec struct {
	// LLDPMgmtIP, if configured, will be used to advertise in LLDP's management
	// address TLV
	LLDPMgmtIP *IPAddress `protobuf:"bytes,1,opt,name=LLDPMgmtIP,proto3" json:"LLDPMgmtIP,omitempty"`
	// MgmtIP is the management IP address of the DSC
	// NOTE:
	// 1. if configured, this IP is used for generating flow logs
	MgmtIP *IPAddress `protobuf:"bytes,2,opt,name=MgmtIP,proto3" json:"MgmtIP,omitempty"`
	// Vlan, if non-zero, is the management vlan id
	// NOTE: if Vlan is not configured, mgmt. traffic goes untagged
	Vlan uint32 `protobuf:"varint,3,opt,name=Vlan,proto3" json:"Vlan,omitempty" meta:range:0-4095,default=0`
	// IP address of the default gateway in the management vlan
	DefaultGatewayIP     *IPAddress `protobuf:"bytes,4,opt,name=DefaultGatewayIP,proto3" json:"DefaultGatewayIP,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MgmtNetworkSpec) Reset()         { *m = MgmtNetworkSpec{} }
func (m *MgmtNetworkSpec) String() string { return proto.CompactTextString(m) }
func (*MgmtNetworkSpec) ProtoMessage()    {}
func (*MgmtNetworkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{2}
}
func (m *MgmtNetworkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MgmtNetworkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MgmtNetworkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MgmtNetworkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MgmtNetworkSpec.Merge(m, src)
}
func (m *MgmtNetworkSpec) XXX_Size() int {
	return m.Size()
}
func (m *MgmtNetworkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MgmtNetworkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MgmtNetworkSpec proto.InternalMessageInfo

func (m *MgmtNetworkSpec) GetLLDPMgmtIP() *IPAddress {
	if m != nil {
		return m.LLDPMgmtIP
	}
	return nil
}

func (m *MgmtNetworkSpec) GetMgmtIP() *IPAddress {
	if m != nil {
		return m.MgmtIP
	}
	return nil
}

func (m *MgmtNetworkSpec) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *MgmtNetworkSpec) GetDefaultGatewayIP() *IPAddress {
	if m != nil {
		return m.DefaultGatewayIP
	}
	return nil
}

// VNICs send traffic to the VIP addresses configured on the host side. Traffic
// from the vnics is sent over VxLAN tunnel with DIPo as the VIP IP vnics are
// bound to. These VIPs are hosted on the DSCs and for a given VIP at any point
// in time, there is one DSC that is primary for that VIP and the other DSC acts
// as seconaary. A given DSC can be primary for multiple virtual IPs and
// secondary for some other virtual IPs.
type HAVirtualIP struct {
	// Virtual IP address
	VirtualIP *IPAddress `protobuf:"bytes,1,opt,name=VirtualIP,proto3" json:"VirtualIP,omitempty" meta:mandatory`
	// High-Availability role of the DSC for the VirtualIP
	HARole               HARole   `protobuf:"varint,2,opt,name=HARole,proto3,enum=pds.HARole" json:"HARole,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAVirtualIP) Reset()         { *m = HAVirtualIP{} }
func (m *HAVirtualIP) String() string { return proto.CompactTextString(m) }
func (*HAVirtualIP) ProtoMessage()    {}
func (*HAVirtualIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{3}
}
func (m *HAVirtualIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAVirtualIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAVirtualIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HAVirtualIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAVirtualIP.Merge(m, src)
}
func (m *HAVirtualIP) XXX_Size() int {
	return m.Size()
}
func (m *HAVirtualIP) XXX_DiscardUnknown() {
	xxx_messageInfo_HAVirtualIP.DiscardUnknown(m)
}

var xxx_messageInfo_HAVirtualIP proto.InternalMessageInfo

func (m *HAVirtualIP) GetVirtualIP() *IPAddress {
	if m != nil {
		return m.VirtualIP
	}
	return nil
}

func (m *HAVirtualIP) GetHARole() HARole {
	if m != nil {
		return m.HARole
	}
	return HARole_HA_ROLE_NONE
}

// HASpec is the configuration for High Availability feature
type HASpec struct {
	// Virtual IP configuration
	// NOTE: currently only one VIP per per address family per DSC is supported
	VIPInfo []*HAVirtualIP `protobuf:"bytes,1,rep,name=VIPInfo,proto3" json:"VIPInfo,omitempty"`
	// PreemptionTimeout is the time in seconds that a DSC in STANDBY role
	// will wait before taking over ACTIVE role
	// NOTE:
	// if PreemptionTimeout is 0 then preemption is not enabled, so if an ACTIVE
	// DSC goes down and comes back up (e.g. reboot/upgrade etc.), it will assume
	// PASSIVE role as the peer would have taken over as ACTIVE in that time
	PreemptionTimeout uint32 `protobuf:"varint,2,opt,name=PreemptionTimeout,proto3" json:"PreemptionTimeout,omitempty"`
	// if the communication (e.g. keepalives or hearbeats) with its ACTIVE peer
	// DSC is lost, STANDBY DSC will takeover by promoting itself to ACTIVE role
	// after PromotionToActiveTimeout (in milliseconds)
	PromotionToActiveTimeout uint32   `protobuf:"varint,3,opt,name=PromotionToActiveTimeout,proto3" json:"PromotionToActiveTimeout,omitempty" meta:range:default=100`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *HASpec) Reset()         { *m = HASpec{} }
func (m *HASpec) String() string { return proto.CompactTextString(m) }
func (*HASpec) ProtoMessage()    {}
func (*HASpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{4}
}
func (m *HASpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HASpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HASpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HASpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HASpec.Merge(m, src)
}
func (m *HASpec) XXX_Size() int {
	return m.Size()
}
func (m *HASpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HASpec.DiscardUnknown(m)
}

var xxx_messageInfo_HASpec proto.InternalMessageInfo

func (m *HASpec) GetVIPInfo() []*HAVirtualIP {
	if m != nil {
		return m.VIPInfo
	}
	return nil
}

func (m *HASpec) GetPreemptionTimeout() uint32 {
	if m != nil {
		return m.PreemptionTimeout
	}
	return 0
}

func (m *HASpec) GetPromotionToActiveTimeout() uint32 {
	if m != nil {
		return m.PromotionToActiveTimeout
	}
	return 0
}

type DeviceSpec struct {
	// local IPv4 address in the underlay (i.e. MyTEP IP or local TEP IP)
	// IPv4Addr is the outer destination IPv4 address in the VxLAN header
	// of the traffic received by the DSC to terminate the VxLAN tunnel and
	// similarly DSC uses this address as outer source IPv4 in the VxLAN header
	// of the traffic sent by DSC
	// NOTE: this is used in non-HA deployments and for HA deployments this
	//       information must be configured in the HASpec
	IPv4Addr *IPAddress `protobuf:"bytes,1,opt,name=IPv4Addr,proto3" json:"IPv4Addr,omitempty"`
	// local IPv6 address in the underlay (i.e. MyTEP IP or local TEP IP)
	// IPv6Addr is the outer destination IPv6 address in the VxLAN header
	// of the traffic received by the DSC to terminate the VxLAN tunnel and
	// similarly DSC uses this address as outer source IPv6 in the VxLAN header
	// of the traffic sent by DSC
	// NOTE: this is used in non-HA deployments and for HA deployments this
	//       information must be configured in the HASpec
	IPv6Addr *IPAddress `protobuf:"bytes,2,opt,name=IPv6Addr,proto3" json:"IPv6Addr,omitempty"`
	// system MAC (DSC's system MAC will be used if not provided)
	MACAddr uint64 `protobuf:"varint,3,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	// IP address of the gateway in the underlay
	GatewayIP *IPAddress `protobuf:"bytes,4,opt,name=GatewayIP,proto3" json:"GatewayIP,omitempty"`
	// operational mode of the device
	// NOTE: when operational mode is modified, it will take affect only after
	//       next reboot of DSC
	DevOperMode DeviceOperMode `protobuf:"varint,5,opt,name=DevOperMode,proto3,enum=pds.DeviceOperMode" json:"DevOperMode,omitempty" meta:mandatory, persisted`
	// Memory Profile (only MEMORY_PROFILE_DEFAULT is supported)
	// NOTE: when a device profile is changed, it will take affect after next
	// reboot of DSC
	MemoryProfile MemoryProfile `protobuf:"varint,6,opt,name=MemoryProfile,proto3,enum=pds.MemoryProfile" json:"MemoryProfile,omitempty" meta:mandatory,persisted`
	// Device Profile
	DeviceProfile DeviceProfile `protobuf:"varint,7,opt,name=DeviceProfile,proto3,enum=pds.DeviceProfile" json:"DeviceProfile,omitempty" meta:mandatory,persisted`
	// device_profile_upd_wait_timeout specifies the time in seconds to wait
	// for the final device_profile configuration
	// NOTE:
	// 1. if DeviceProfileUpdWaitTimeout is non-zero in device object
	//    create or update, a timer will be started with the duration specified
	//    (in seconds) for the final host PF/VF DeviceProfile to be specified
	//    in subsequent update call of this object
	// 2. if the timer expires, before the device object update is received,
	//    default device profile will be used to create host PF/VF devices (and
	//    the default depends on the pipeline and DevOperMode attribute)
	// 3. if DeviceProfileUpdWaitTimeout is zero, the DeviceProfile passed
	//    in the object will take affect immediately
	// 4. device object can be updated multiple times with non-zero timeout
	//    until final DeviceProfile is known and eveytime timer is reset
	//    with specified value
	// 5. once final DeviceProfile is picked (either because timer expired
	//    or object is updated with DeviceProfile and zero timeout value), further
	//    updates to the DeviceProfile will not take affect until next reboot
	DeviceProfileUpdWaitTimeout uint32 `protobuf:"varint,8,opt,name=DeviceProfileUpdWaitTimeout,proto3" json:"DeviceProfileUpdWaitTimeout,omitempty"`
	// if BridgingEn is true, L2 functionality based on MAC addresses kicks in
	BridgingEn bool `protobuf:"varint,9,opt,name=BridgingEn,proto3" json:"BridgingEn,omitempty" meta:immutable`
	// MAC/IP learning controls
	// NOTE: if LearnSpec is not configured, learning is disabled by default
	LearnSpec *LearnSpec `protobuf:"bytes,10,opt,name=LearnSpec,proto3" json:"LearnSpec,omitempty"`
	// priority class of IP mapping entries, is used to break the tie in case
	// both LPM/prefix and a mapping entry are hit in the datapath (i.e., /32 IP
	// mapping entry is also in some LPM prefix) for the same packet.
	// NOTE:
	// 1. by default IP mapping always takes precedence over LPM hit as the
	//    default value of this attribute is 0 (and lower the numerical value,
	//    higher the priority, hence 0 is the highest priority)
	// 2. valid priority value range is 0 to 31
	// 3. if mapping and route are both hit and both have same class priority,
	//    mapping result will take precedence over route (even if it is /32 route)
	// 4. if the value of this attribute is updated on the fly, it will not
	//    affect the flows/sessions that are already created, but it will take
	//    affect only on the new sessions/flows created after such an update
	IPMappingClassPriority uint32 `protobuf:"varint,11,opt,name=IPMappingClassPriority,proto3" json:"IPMappingClassPriority,omitempty" meta:range:0-31,default=0`
	// firewall (if enabled) action transposition logic dictates how the policy
	// lookup results are processed when multiple security policies are applied
	// on a packet
	FwPolicyXposnScheme FwPolicyXposn `protobuf:"varint,12,opt,name=FwPolicyXposnScheme,proto3,enum=types.FwPolicyXposn" json:"FwPolicyXposnScheme,omitempty" meta:default=FW_POLICY_XPOSN_GLOBAL_PRIORITY`
	// enable the control plane stack for overlay routing
	// NOTE: when OverlayRoutingEn is modified, it will take affect only after
	//       next reboot of DSC
	OverlayRoutingEn bool `protobuf:"varint,13,opt,name=OverlayRoutingEn,proto3" json:"OverlayRoutingEn,omitempty" meta:mandatory`
	// when SymmetricRoutingEn is set to true, its called symmetric routing and
	// SymmetricRoutingEn is set to false, it is called asymmetric routing
	// Below is the datapath behavior in various cases:
	// 1. mapping is hit (or mapping hit result is picked over route hit),
	//    intra-subnet traffic, SymmetricRoutingEn = true or false:
	//    a. encapped packets are sent out with destination subnet's vnid
	//    b. incoming encapped packets are expected with destination subnet's vnid
	// 2. mapping is hit (or mapping hit result is picked over route hit),
	//    inter-subnet traffic, SymmetricRoutingEn = true:
	//    a. encapped packets are sent out with destination vpc's vnid
	//    b. incoming encapped packets are expected with destination vpc's vnid
	// 3. mapping is hit (or mapping hit result is picked over route hit),
	//    inter-subnet traffic, SymmetricRoutingEn = false:
	//    a. encapped packets are sent out with destination subnet's vnid
	//    b. incoming encapped packets are expected with destination subnet's vnid
	// 4. route is hit (route hit result is picked over mapping),
	//    SymmetricRoutingEn = false:
	//    a. encapped packets are sent out with vpc's vnid
	//    b. incoming encapped packets are expected with destination subnet's vnid
	// 5. route is hit (route hit result is picked over mapping),
	//    SymmetricRoutingEn = true:
	//    a. encapped packets are sent out with destination vpc's vnid
	//    b. incoming encapped packets are expected with destination vpc's vnid
	// NOTE:
	// 1. by default SymmetricRoutingEn is false i.e., DSC is in asymmetric
	//    routing mode
	// 2. if the value of this attribute is updated on the fly, it will not
	//    affect the flows/sessions that are already created, but it will take
	//    affect only on the new sessions/flows created after such an update
	SymmetricRoutingEn bool `protobuf:"varint,14,opt,name=SymmetricRoutingEn,proto3" json:"SymmetricRoutingEn,omitempty" meta:default=false`
	// TxPolicerId, if configured, will rate limit the Tx bandwidth (bytes per
	// second) or PPS (packets per second) of all host interfaces put together
	// to the configured value
	TxPolicerId []byte `protobuf:"bytes,15,opt,name=TxPolicerId,proto3" json:"TxPolicerId,omitempty"`
	// LongLivedFlowDuration is the time in seconds after which an existing
	// flow/session is categorized as "long lived"
	LongLivedFlowDuration uint32 `protobuf:"varint,16,opt,name=LongLivedFlowDuration,proto3" json:"LongLivedFlowDuration,omitempty" meta:range:30-3600,default=300`
	// controls for flow logging
	FlowLogSpec *FlowLogSpec `protobuf:"bytes,17,opt,name=FlowLogSpec,proto3" json:"FlowLogSpec,omitempty"`
	// if FlowRefresh is set to true, whenever a policy or routing table
	// changes happen, flows are re-evaluated and fixed up with appropriate
	// action (deny/allow) and any change in forwarding information (encap, TEP
	// etc.) and by default FlowRefresh is set to false (i.e., existing
	// sessions won't be updated and the policy/routing updates apply only to
	// future sessions only
	// NOTE:
	// to use User Defined Route (UDR) specific features, this must be set to true
	FlowRefresh bool `protobuf:"varint,18,opt,name=FlowRefresh,proto3" json:"FlowRefresh,omitempty"`
	// SysName, if configured, will be used to advertise as system name in
	// protocols like LLDP etc. it cannot be longer than 64 bytes
	SysName string `protobuf:"bytes,19,opt,name=SysName,proto3" json:"SysName,omitempty"`
	// MgmtNwSpec, if configured, will contain all the mgmt. network related
	// configuration
	MgmtNwSpec *MgmtNetworkSpec `protobuf:"bytes,20,opt,name=MgmtNwSpec,proto3" json:"MgmtNwSpec,omitempty"`
	// ControlNetworkSpec, if configured, will be used for control traffic
	// (e.g. flow sync messages to/from peer DSC)
	ControlNwSpec *ControlNetworkSpec `protobuf:"bytes,21,opt,name=ControlNwSpec,proto3" json:"ControlNwSpec,omitempty"`
	// to mirror all the packets that are dropped in the datapath, user can
	// create a mirror session and attach to this object
	DropMirrorSession []byte `protobuf:"bytes,22,opt,name=DropMirrorSession,proto3" json:"DropMirrorSession,omitempty"`
	// delay bringup of host interfaces
	DelayHostBringup bool `protobuf:"varint,23,opt,name=DelayHostBringup,proto3" json:"DelayHostBringup,omitempty"`
	// service virtual IP of this DSC used in some cases to send/receive traffic
	// to/from service endpoints
	ServiceVIP *IPAddress `protobuf:"bytes,24,opt,name=ServiceVIP,proto3" json:"ServiceVIP,omitempty"`
	// UDP destination port number to be considered as VxLAN packet if VxLAN is
	// used on non-standard VxLAN port
	VxLANPort uint32 `protobuf:"varint,25,opt,name=VxLANPort,proto3" json:"VxLANPort,omitempty"`
	// if VxLANSrcPorts is configured, all encapped VxLAN packets will carry
	// outgoing UDP source port assigned in the range specified, picked randomly
	// (or based on flow hash)
	VxLANSrcPorts *PortRange `protobuf:"bytes,26,opt,name=VxLANSrcPorts,proto3" json:"VxLANSrcPorts,omitempty"`
	// TrustedVNIs is a lsit of VNI ranges that are well-known, trusted and all
	// VPCs are implicitly peer-ed with them
	TrustedVNIs []*VNIRange `protobuf:"bytes,27,rep,name=TrustedVNIs,proto3" json:"TrustedVNIs,omitempty" meta:immutable`
	// HASpec captures the high-availability related configuration
	HASpec               *HASpec  `protobuf:"bytes,28,opt,name=HASpec,proto3" json:"HASpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceSpec) Reset()         { *m = DeviceSpec{} }
func (m *DeviceSpec) String() string { return proto.CompactTextString(m) }
func (*DeviceSpec) ProtoMessage()    {}
func (*DeviceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{5}
}
func (m *DeviceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceSpec.Merge(m, src)
}
func (m *DeviceSpec) XXX_Size() int {
	return m.Size()
}
func (m *DeviceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceSpec proto.InternalMessageInfo

func (m *DeviceSpec) GetIPv4Addr() *IPAddress {
	if m != nil {
		return m.IPv4Addr
	}
	return nil
}

func (m *DeviceSpec) GetIPv6Addr() *IPAddress {
	if m != nil {
		return m.IPv6Addr
	}
	return nil
}

func (m *DeviceSpec) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *DeviceSpec) GetGatewayIP() *IPAddress {
	if m != nil {
		return m.GatewayIP
	}
	return nil
}

func (m *DeviceSpec) GetDevOperMode() DeviceOperMode {
	if m != nil {
		return m.DevOperMode
	}
	return DeviceOperMode_DEVICE_OPER_MODE_NONE
}

func (m *DeviceSpec) GetMemoryProfile() MemoryProfile {
	if m != nil {
		return m.MemoryProfile
	}
	return MemoryProfile_MEMORY_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetDeviceProfile() DeviceProfile {
	if m != nil {
		return m.DeviceProfile
	}
	return DeviceProfile_DEVICE_PROFILE_DEFAULT
}

func (m *DeviceSpec) GetDeviceProfileUpdWaitTimeout() uint32 {
	if m != nil {
		return m.DeviceProfileUpdWaitTimeout
	}
	return 0
}

func (m *DeviceSpec) GetBridgingEn() bool {
	if m != nil {
		return m.BridgingEn
	}
	return false
}

func (m *DeviceSpec) GetLearnSpec() *LearnSpec {
	if m != nil {
		return m.LearnSpec
	}
	return nil
}

func (m *DeviceSpec) GetIPMappingClassPriority() uint32 {
	if m != nil {
		return m.IPMappingClassPriority
	}
	return 0
}

func (m *DeviceSpec) GetFwPolicyXposnScheme() FwPolicyXposn {
	if m != nil {
		return m.FwPolicyXposnScheme
	}
	return FwPolicyXposn_FW_POLICY_XPOSN_NONE
}

func (m *DeviceSpec) GetOverlayRoutingEn() bool {
	if m != nil {
		return m.OverlayRoutingEn
	}
	return false
}

func (m *DeviceSpec) GetSymmetricRoutingEn() bool {
	if m != nil {
		return m.SymmetricRoutingEn
	}
	return false
}

func (m *DeviceSpec) GetTxPolicerId() []byte {
	if m != nil {
		return m.TxPolicerId
	}
	return nil
}

func (m *DeviceSpec) GetLongLivedFlowDuration() uint32 {
	if m != nil {
		return m.LongLivedFlowDuration
	}
	return 0
}

func (m *DeviceSpec) GetFlowLogSpec() *FlowLogSpec {
	if m != nil {
		return m.FlowLogSpec
	}
	return nil
}

func (m *DeviceSpec) GetFlowRefresh() bool {
	if m != nil {
		return m.FlowRefresh
	}
	return false
}

func (m *DeviceSpec) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *DeviceSpec) GetMgmtNwSpec() *MgmtNetworkSpec {
	if m != nil {
		return m.MgmtNwSpec
	}
	return nil
}

func (m *DeviceSpec) GetControlNwSpec() *ControlNetworkSpec {
	if m != nil {
		return m.ControlNwSpec
	}
	return nil
}

func (m *DeviceSpec) GetDropMirrorSession() []byte {
	if m != nil {
		return m.DropMirrorSession
	}
	return nil
}

func (m *DeviceSpec) GetDelayHostBringup() bool {
	if m != nil {
		return m.DelayHostBringup
	}
	return false
}

func (m *DeviceSpec) GetServiceVIP() *IPAddress {
	if m != nil {
		return m.ServiceVIP
	}
	return nil
}

func (m *DeviceSpec) GetVxLANPort() uint32 {
	if m != nil {
		return m.VxLANPort
	}
	return 0
}

func (m *DeviceSpec) GetVxLANSrcPorts() *PortRange {
	if m != nil {
		return m.VxLANSrcPorts
	}
	return nil
}

func (m *DeviceSpec) GetTrustedVNIs() []*VNIRange {
	if m != nil {
		return m.TrustedVNIs
	}
	return nil
}

func (m *DeviceSpec) GetHASpec() *HASpec {
	if m != nil {
		return m.HASpec
	}
	return nil
}

// ControlNetworkStatus captures operational status of
// control network configuration
type ControlNetworkStatus struct {
	// h/w index of reserved vnic used by control vlan
	ControlVlanVnicHwId uint32 `protobuf:"varint,1,opt,name=ControlVlanVnicHwId,proto3" json:"ControlVlanVnicHwId,omitempty"`
	/// h/w index of nacl entry used by control network for p4 to arm path
	RxNaclHwId           uint32   `protobuf:"varint,2,opt,name=RxNaclHwId,proto3" json:"RxNaclHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControlNetworkStatus) Reset()         { *m = ControlNetworkStatus{} }
func (m *ControlNetworkStatus) String() string { return proto.CompactTextString(m) }
func (*ControlNetworkStatus) ProtoMessage()    {}
func (*ControlNetworkStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{6}
}
func (m *ControlNetworkStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlNetworkStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlNetworkStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlNetworkStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlNetworkStatus.Merge(m, src)
}
func (m *ControlNetworkStatus) XXX_Size() int {
	return m.Size()
}
func (m *ControlNetworkStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlNetworkStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ControlNetworkStatus proto.InternalMessageInfo

func (m *ControlNetworkStatus) GetControlVlanVnicHwId() uint32 {
	if m != nil {
		return m.ControlVlanVnicHwId
	}
	return 0
}

func (m *ControlNetworkStatus) GetRxNaclHwId() uint32 {
	if m != nil {
		return m.RxNaclHwId
	}
	return 0
}

// MgmtNetworkStatus captures operational status of
// management network configuration
type MgmtNetworkStatus struct {
	// h/w index of reserved vnic used by mgmt. vlan
	MgmtVlanVnicHwId uint32 `protobuf:"varint,1,opt,name=MgmtVlanVnicHwId,proto3" json:"MgmtVlanVnicHwId,omitempty"`
	/// h/w index of nacl entry used by mgmt. network for p4 to arm path
	RxNaclHwId           uint32   `protobuf:"varint,2,opt,name=RxNaclHwId,proto3" json:"RxNaclHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MgmtNetworkStatus) Reset()         { *m = MgmtNetworkStatus{} }
func (m *MgmtNetworkStatus) String() string { return proto.CompactTextString(m) }
func (*MgmtNetworkStatus) ProtoMessage()    {}
func (*MgmtNetworkStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{7}
}
func (m *MgmtNetworkStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MgmtNetworkStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MgmtNetworkStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MgmtNetworkStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MgmtNetworkStatus.Merge(m, src)
}
func (m *MgmtNetworkStatus) XXX_Size() int {
	return m.Size()
}
func (m *MgmtNetworkStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MgmtNetworkStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MgmtNetworkStatus proto.InternalMessageInfo

func (m *MgmtNetworkStatus) GetMgmtVlanVnicHwId() uint32 {
	if m != nil {
		return m.MgmtVlanVnicHwId
	}
	return 0
}

func (m *MgmtNetworkStatus) GetRxNaclHwId() uint32 {
	if m != nil {
		return m.RxNaclHwId
	}
	return 0
}

// operational status of High Availability (HA) feature
type HAStatus struct {
	// operational role of DSC when HA is deployed
	Role HARole `protobuf:"varint,1,opt,name=Role,proto3,enum=pds.HARole" json:"Role,omitempty"`
	// HA version DSC negotiated with the peer
	DSCHAVersion uint32 `protobuf:"varint,2,opt,name=DSCHAVersion,proto3" json:"DSCHAVersion,omitempty"`
	// Inter-DSC tunnel h/w id
	InterDSCTunnelHwId   uint32   `protobuf:"varint,3,opt,name=InterDSCTunnelHwId,proto3" json:"InterDSCTunnelHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAStatus) Reset()         { *m = HAStatus{} }
func (m *HAStatus) String() string { return proto.CompactTextString(m) }
func (*HAStatus) ProtoMessage()    {}
func (*HAStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{8}
}
func (m *HAStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HAStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAStatus.Merge(m, src)
}
func (m *HAStatus) XXX_Size() int {
	return m.Size()
}
func (m *HAStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_HAStatus.DiscardUnknown(m)
}

var xxx_messageInfo_HAStatus proto.InternalMessageInfo

func (m *HAStatus) GetRole() HARole {
	if m != nil {
		return m.Role
	}
	return HARole_HA_ROLE_NONE
}

func (m *HAStatus) GetDSCHAVersion() uint32 {
	if m != nil {
		return m.DSCHAVersion
	}
	return 0
}

func (m *HAStatus) GetInterDSCTunnelHwId() uint32 {
	if m != nil {
		return m.InterDSCTunnelHwId
	}
	return 0
}

// operational status of the device, if any
type DeviceStatus struct {
	// system MAC address (can be used to uniquely identify the device in cluster)
	SystemMACAddress uint64 `protobuf:"varint,1,opt,name=SystemMACAddress,proto3" json:"SystemMACAddress,omitempty"`
	// serial number of the device
	SerialNumber string `protobuf:"bytes,2,opt,name=SerialNumber,proto3" json:"SerialNumber,omitempty"`
	// SKU/part numnber
	Sku string `protobuf:"bytes,3,opt,name=Sku,proto3" json:"Sku,omitempty"`
	// version of the firmware running
	FirmwareVersion string `protobuf:"bytes,4,opt,name=FirmwareVersion,proto3" json:"FirmwareVersion,omitempty"`
	// memory capacity
	Memory uint32 `protobuf:"varint,5,opt,name=Memory,proto3" json:"Memory,omitempty"`
	// product name
	ProductName string `protobuf:"bytes,6,opt,name=ProductName,proto3" json:"ProductName,omitempty"`
	// manufacturing date
	ManufacturingDate string `protobuf:"bytes,7,opt,name=ManufacturingDate,proto3" json:"ManufacturingDate,omitempty"`
	// device description
	Description string `protobuf:"bytes,8,opt,name=Description,proto3" json:"Description,omitempty"`
	// vendor identifier
	VendorID string `protobuf:"bytes,9,opt,name=VendorID,proto3" json:"VendorID,omitempty"`
	// chip type
	ChipType AsicType `protobuf:"varint,10,opt,name=ChipType,proto3,enum=types.AsicType" json:"ChipType,omitempty"`
	// hardware revision
	HardwareRevision string `protobuf:"bytes,11,opt,name=HardwareRevision,proto3" json:"HardwareRevision,omitempty"`
	// CPU vendor
	CpuVendor string `protobuf:"bytes,12,opt,name=CpuVendor,proto3" json:"CpuVendor,omitempty"`
	// CPU specification
	CpuSpecification string `protobuf:"bytes,13,opt,name=CpuSpecification,proto3" json:"CpuSpecification,omitempty"`
	// SoC OS version
	SocOSVersion string `protobuf:"bytes,14,opt,name=SocOSVersion,proto3" json:"SocOSVersion,omitempty"`
	// SoC disk size
	SocDiskSize string `protobuf:"bytes,15,opt,name=SocDiskSize,proto3" json:"SocDiskSize,omitempty"`
	// PCIe capability string (not the runtime negotiated status)
	PCIeCapability string `protobuf:"bytes,16,opt,name=PCIeCapability,proto3" json:"PCIeCapability,omitempty"`
	// PCIe bus information for the DSC
	PCIeBusInfo string `protobuf:"bytes,17,opt,name=PCIeBusInfo,proto3" json:"PCIeBusInfo,omitempty"`
	// number of PCIe ports
	NumPCIePorts uint32 `protobuf:"varint,18,opt,name=NumPCIePorts,proto3" json:"NumPCIePorts,omitempty"`
	// Number of uplink ports
	NumPorts uint32 `protobuf:"varint,19,opt,name=NumPorts,proto3" json:"NumPorts,omitempty"`
	// vendor name
	VendorName string `protobuf:"bytes,20,opt,name=VendorName,proto3" json:"VendorName,omitempty"`
	// PXE version
	PXEVersion float32 `protobuf:"fixed32,21,opt,name=PXEVersion,proto3" json:"PXEVersion,omitempty"`
	// UEFI version
	UEFIVersion float32 `protobuf:"fixed32,22,opt,name=UEFIVersion,proto3" json:"UEFIVersion,omitempty"`
	// number of host interfaces
	NumHostIf uint32 `protobuf:"varint,23,opt,name=NumHostIf,proto3" json:"NumHostIf,omitempty"`
	// version of the firmware running
	FirmwareDescription string `protobuf:"bytes,24,opt,name=FirmwareDescription,proto3" json:"FirmwareDescription,omitempty"`
	// version of the firmware running
	FirmwareBuildTime string `protobuf:"bytes,25,opt,name=FirmwareBuildTime,proto3" json:"FirmwareBuildTime,omitempty"`
	// Pipeline
	Pipeline string `protobuf:"bytes,26,opt,name=Pipeline,proto3" json:"Pipeline,omitempty"`
	// control network status
	ControlNwStatus *ControlNetworkStatus `protobuf:"bytes,27,opt,name=ControlNwStatus,proto3" json:"ControlNwStatus,omitempty"`
	// management network status
	MgmtNwStatus *MgmtNetworkStatus `protobuf:"bytes,28,opt,name=MgmtNwStatus,proto3" json:"MgmtNwStatus,omitempty"`
	// firmware initialization mode
	InitMode FirmwareInitMode `protobuf:"varint,29,opt,name=InitMode,proto3,enum=pds.FirmwareInitMode" json:"InitMode,omitempty"`
	// firmware/instance in which current firmware is running
	Instance FirmwareInstance `protobuf:"varint,30,opt,name=Instance,proto3,enum=pds.FirmwareInstance" json:"Instance,omitempty"`
	// operational status of DSC when HA is deployed
	HAStatus *HAStatus `protobuf:"bytes,31,opt,name=HAStatus,proto3" json:"HAStatus,omitempty"`
	// current epoch of grpc client
	CurrentConfigEpoch   uint32   `protobuf:"varint,32,opt,name=CurrentConfigEpoch,proto3" json:"CurrentConfigEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStatus) Reset()         { *m = DeviceStatus{} }
func (m *DeviceStatus) String() string { return proto.CompactTextString(m) }
func (*DeviceStatus) ProtoMessage()    {}
func (*DeviceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{9}
}
func (m *DeviceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStatus.Merge(m, src)
}
func (m *DeviceStatus) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStatus proto.InternalMessageInfo

func (m *DeviceStatus) GetSystemMACAddress() uint64 {
	if m != nil {
		return m.SystemMACAddress
	}
	return 0
}

func (m *DeviceStatus) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *DeviceStatus) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *DeviceStatus) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *DeviceStatus) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DeviceStatus) GetManufacturingDate() string {
	if m != nil {
		return m.ManufacturingDate
	}
	return ""
}

func (m *DeviceStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DeviceStatus) GetVendorID() string {
	if m != nil {
		return m.VendorID
	}
	return ""
}

func (m *DeviceStatus) GetChipType() AsicType {
	if m != nil {
		return m.ChipType
	}
	return AsicType_ASIC_TYPE_NONE
}

func (m *DeviceStatus) GetHardwareRevision() string {
	if m != nil {
		return m.HardwareRevision
	}
	return ""
}

func (m *DeviceStatus) GetCpuVendor() string {
	if m != nil {
		return m.CpuVendor
	}
	return ""
}

func (m *DeviceStatus) GetCpuSpecification() string {
	if m != nil {
		return m.CpuSpecification
	}
	return ""
}

func (m *DeviceStatus) GetSocOSVersion() string {
	if m != nil {
		return m.SocOSVersion
	}
	return ""
}

func (m *DeviceStatus) GetSocDiskSize() string {
	if m != nil {
		return m.SocDiskSize
	}
	return ""
}

func (m *DeviceStatus) GetPCIeCapability() string {
	if m != nil {
		return m.PCIeCapability
	}
	return ""
}

func (m *DeviceStatus) GetPCIeBusInfo() string {
	if m != nil {
		return m.PCIeBusInfo
	}
	return ""
}

func (m *DeviceStatus) GetNumPCIePorts() uint32 {
	if m != nil {
		return m.NumPCIePorts
	}
	return 0
}

func (m *DeviceStatus) GetNumPorts() uint32 {
	if m != nil {
		return m.NumPorts
	}
	return 0
}

func (m *DeviceStatus) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *DeviceStatus) GetPXEVersion() float32 {
	if m != nil {
		return m.PXEVersion
	}
	return 0
}

func (m *DeviceStatus) GetUEFIVersion() float32 {
	if m != nil {
		return m.UEFIVersion
	}
	return 0
}

func (m *DeviceStatus) GetNumHostIf() uint32 {
	if m != nil {
		return m.NumHostIf
	}
	return 0
}

func (m *DeviceStatus) GetFirmwareDescription() string {
	if m != nil {
		return m.FirmwareDescription
	}
	return ""
}

func (m *DeviceStatus) GetFirmwareBuildTime() string {
	if m != nil {
		return m.FirmwareBuildTime
	}
	return ""
}

func (m *DeviceStatus) GetPipeline() string {
	if m != nil {
		return m.Pipeline
	}
	return ""
}

func (m *DeviceStatus) GetControlNwStatus() *ControlNetworkStatus {
	if m != nil {
		return m.ControlNwStatus
	}
	return nil
}

func (m *DeviceStatus) GetMgmtNwStatus() *MgmtNetworkStatus {
	if m != nil {
		return m.MgmtNwStatus
	}
	return nil
}

func (m *DeviceStatus) GetInitMode() FirmwareInitMode {
	if m != nil {
		return m.InitMode
	}
	return FirmwareInitMode_FIRMWARE_INIT_MODE_NONE
}

func (m *DeviceStatus) GetInstance() FirmwareInstance {
	if m != nil {
		return m.Instance
	}
	return FirmwareInstance_FIRMWARE_INSTANCE_NONE
}

func (m *DeviceStatus) GetHAStatus() *HAStatus {
	if m != nil {
		return m.HAStatus
	}
	return nil
}

func (m *DeviceStatus) GetCurrentConfigEpoch() uint32 {
	if m != nil {
		return m.CurrentConfigEpoch
	}
	return 0
}

// stats of the device, if any
type DeviceStatsEntry struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Count                uint64   `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStatsEntry) Reset()         { *m = DeviceStatsEntry{} }
func (m *DeviceStatsEntry) String() string { return proto.CompactTextString(m) }
func (*DeviceStatsEntry) ProtoMessage()    {}
func (*DeviceStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{10}
}
func (m *DeviceStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStatsEntry.Merge(m, src)
}
func (m *DeviceStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStatsEntry proto.InternalMessageInfo

func (m *DeviceStatsEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceStatsEntry) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DeviceStats struct {
	Ingress              []*DeviceStatsEntry `protobuf:"bytes,1,rep,name=Ingress,proto3" json:"Ingress,omitempty"`
	Egress               []*DeviceStatsEntry `protobuf:"bytes,2,rep,name=Egress,proto3" json:"Egress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *DeviceStats) Reset()         { *m = DeviceStats{} }
func (m *DeviceStats) String() string { return proto.CompactTextString(m) }
func (*DeviceStats) ProtoMessage()    {}
func (*DeviceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{11}
}
func (m *DeviceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStats.Merge(m, src)
}
func (m *DeviceStats) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStats.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStats proto.InternalMessageInfo

func (m *DeviceStats) GetIngress() []*DeviceStatsEntry {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *DeviceStats) GetEgress() []*DeviceStatsEntry {
	if m != nil {
		return m.Egress
	}
	return nil
}

// device object
type Device struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *DeviceSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *DeviceStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *DeviceStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{12}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Device.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetSpec() *DeviceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Device) GetStatus() *DeviceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Device) GetStats() *DeviceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// device create and update request
type DeviceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt  `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              *DeviceSpec `protobuf:"bytes,2,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DeviceRequest) Reset()         { *m = DeviceRequest{} }
func (m *DeviceRequest) String() string { return proto.CompactTextString(m) }
func (*DeviceRequest) ProtoMessage()    {}
func (*DeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{13}
}
func (m *DeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceRequest.Merge(m, src)
}
func (m *DeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceRequest proto.InternalMessageInfo

func (m *DeviceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *DeviceRequest) GetRequest() *DeviceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// device create and update response
type DeviceResponse struct {
	ApiStatus            ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *DeviceStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DeviceResponse) Reset()         { *m = DeviceResponse{} }
func (m *DeviceResponse) String() string { return proto.CompactTextString(m) }
func (*DeviceResponse) ProtoMessage()    {}
func (*DeviceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{14}
}
func (m *DeviceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceResponse.Merge(m, src)
}
func (m *DeviceResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeviceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceResponse proto.InternalMessageInfo

func (m *DeviceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceResponse) GetResponse() *DeviceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// device get request
type DeviceGetRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceGetRequest) Reset()         { *m = DeviceGetRequest{} }
func (m *DeviceGetRequest) String() string { return proto.CompactTextString(m) }
func (*DeviceGetRequest) ProtoMessage()    {}
func (*DeviceGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{15}
}
func (m *DeviceGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceGetRequest.Merge(m, src)
}
func (m *DeviceGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeviceGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceGetRequest proto.InternalMessageInfo

// device get response
type DeviceGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *Device   `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeviceGetResponse) Reset()         { *m = DeviceGetResponse{} }
func (m *DeviceGetResponse) String() string { return proto.CompactTextString(m) }
func (*DeviceGetResponse) ProtoMessage()    {}
func (*DeviceGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{16}
}
func (m *DeviceGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceGetResponse.Merge(m, src)
}
func (m *DeviceGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeviceGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceGetResponse proto.InternalMessageInfo

func (m *DeviceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DeviceGetResponse) GetResponse() *Device {
	if m != nil {
		return m.Response
	}
	return nil
}

// device delete request
type DeviceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeviceDeleteRequest) Reset()         { *m = DeviceDeleteRequest{} }
func (m *DeviceDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeviceDeleteRequest) ProtoMessage()    {}
func (*DeviceDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{17}
}
func (m *DeviceDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceDeleteRequest.Merge(m, src)
}
func (m *DeviceDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeviceDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceDeleteRequest proto.InternalMessageInfo

func (m *DeviceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

// device delete response
type DeviceDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeviceDeleteResponse) Reset()         { *m = DeviceDeleteResponse{} }
func (m *DeviceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeviceDeleteResponse) ProtoMessage()    {}
func (*DeviceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_870276a56ac00da5, []int{18}
}
func (m *DeviceDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceDeleteResponse.Merge(m, src)
}
func (m *DeviceDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeviceDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceDeleteResponse proto.InternalMessageInfo

func (m *DeviceDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterEnum("pds.MemoryProfile", MemoryProfile_name, MemoryProfile_value)
	proto.RegisterEnum("pds.DeviceProfile", DeviceProfile_name, DeviceProfile_value)
	proto.RegisterEnum("pds.DeviceOperMode", DeviceOperMode_name, DeviceOperMode_value)
	proto.RegisterEnum("pds.HARole", HARole_name, HARole_value)
	proto.RegisterEnum("pds.DeviceHealth", DeviceHealth_name, DeviceHealth_value)
	proto.RegisterEnum("pds.FirmwareInitMode", FirmwareInitMode_name, FirmwareInitMode_value)
	proto.RegisterEnum("pds.FirmwareInstance", FirmwareInstance_name, FirmwareInstance_value)
	proto.RegisterType((*VNIRange)(nil), "pds.VNIRange")
	proto.RegisterType((*ControlNetworkSpec)(nil), "pds.ControlNetworkSpec")
	proto.RegisterType((*MgmtNetworkSpec)(nil), "pds.MgmtNetworkSpec")
	proto.RegisterType((*HAVirtualIP)(nil), "pds.HAVirtualIP")
	proto.RegisterType((*HASpec)(nil), "pds.HASpec")
	proto.RegisterType((*DeviceSpec)(nil), "pds.DeviceSpec")
	proto.RegisterType((*ControlNetworkStatus)(nil), "pds.ControlNetworkStatus")
	proto.RegisterType((*MgmtNetworkStatus)(nil), "pds.MgmtNetworkStatus")
	proto.RegisterType((*HAStatus)(nil), "pds.HAStatus")
	proto.RegisterType((*DeviceStatus)(nil), "pds.DeviceStatus")
	proto.RegisterType((*DeviceStatsEntry)(nil), "pds.DeviceStatsEntry")
	proto.RegisterType((*DeviceStats)(nil), "pds.DeviceStats")
	proto.RegisterType((*Device)(nil), "pds.Device")
	proto.RegisterType((*DeviceRequest)(nil), "pds.DeviceRequest")
	proto.RegisterType((*DeviceResponse)(nil), "pds.DeviceResponse")
	proto.RegisterType((*DeviceGetRequest)(nil), "pds.DeviceGetRequest")
	proto.RegisterType((*DeviceGetResponse)(nil), "pds.DeviceGetResponse")
	proto.RegisterType((*DeviceDeleteRequest)(nil), "pds.DeviceDeleteRequest")
	proto.RegisterType((*DeviceDeleteResponse)(nil), "pds.DeviceDeleteResponse")
}

func init() { proto.RegisterFile("device.proto", fileDescriptor_870276a56ac00da5) }

var fileDescriptor_870276a56ac00da5 = []byte{
	// 2630 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x59, 0xcb, 0x73, 0xdb, 0xc6,
	0x19, 0x0f, 0x28, 0x5a, 0x12, 0x3f, 0xbd, 0xe0, 0x95, 0x2c, 0xc3, 0xb2, 0x23, 0x2a, 0x4c, 0x9a,
	0x28, 0xaa, 0xad, 0xd0, 0x92, 0x63, 0x37, 0xaf, 0xa6, 0x24, 0x08, 0x9a, 0x98, 0xf2, 0x81, 0x2e,
	0x28, 0xca, 0x3e, 0x31, 0x30, 0xb9, 0xa2, 0x90, 0x90, 0x00, 0x8a, 0x87, 0x64, 0xf6, 0xd2, 0x43,
	0x6f, 0xfd, 0x8b, 0x3a, 0x9d, 0xe9, 0x74, 0x7a, 0xeb, 0x31, 0xd3, 0x53, 0x4f, 0x9a, 0x4c, 0x0e,
	0x3d, 0xe4, 0x56, 0xfd, 0x05, 0x9d, 0x5d, 0x60, 0x49, 0x80, 0x84, 0x9c, 0xa9, 0x2f, 0x1e, 0xed,
	0xef, 0xfb, 0x7d, 0xcf, 0xdd, 0xfd, 0xbe, 0x05, 0x0d, 0xab, 0x7d, 0x72, 0x61, 0xf6, 0xc8, 0xa1,
	0xe3, 0xda, 0xbe, 0x8d, 0x16, 0x9c, 0xbe, 0xb7, 0x03, 0x03, 0x7b, 0x60, 0x87, 0xc0, 0xce, 0xc6,
	0x88, 0xf8, 0xc6, 0x27, 0xf4, 0x9f, 0x08, 0x58, 0xf1, 0xc7, 0x0e, 0xf1, 0xc2, 0x45, 0xe1, 0x4b,
	0x58, 0xee, 0x34, 0x55, 0x6c, 0x58, 0x03, 0x82, 0xb6, 0x61, 0xb1, 0xd3, 0x54, 0xeb, 0xf6, 0xa5,
	0x24, 0xec, 0x09, 0xfb, 0x6b, 0x38, 0x5a, 0x21, 0x09, 0x96, 0x3a, 0x4d, 0xb5, 0x66, 0x0e, 0xce,
	0xa5, 0x0c, 0x13, 0xf0, 0x65, 0xe1, 0xdf, 0x02, 0x20, 0xd9, 0xb6, 0x7c, 0xd7, 0x1e, 0x36, 0x89,
	0x7f, 0x69, 0xbb, 0xdf, 0xe9, 0x0e, 0xe9, 0xa1, 0x03, 0x58, 0xaa, 0xdb, 0x3d, 0x63, 0xa8, 0x6a,
	0xcc, 0xd2, 0xca, 0x91, 0x78, 0x18, 0xfa, 0x54, 0xb5, 0x52, 0xbf, 0xef, 0x12, 0xcf, 0xc3, 0x9c,
	0x80, 0xf6, 0x61, 0x51, 0x23, 0xc4, 0x55, 0x35, 0x66, 0x3b, 0x8d, 0x1a, 0xc9, 0xd1, 0x31, 0x64,
	0x3b, 0x43, 0xc3, 0x92, 0x16, 0x68, 0x0c, 0xe5, 0xfc, 0xf5, 0x55, 0xfe, 0x3e, 0xcd, 0xea, 0x73,
	0x97, 0x06, 0xff, 0x79, 0xf1, 0xd1, 0x93, 0xe2, 0x67, 0x9f, 0x3e, 0xec, 0x93, 0x33, 0x23, 0x18,
	0xfa, 0x5f, 0x15, 0x31, 0x23, 0xa3, 0x67, 0xb0, 0x5a, 0x7e, 0xae, 0xc9, 0xf6, 0x68, 0x14, 0x58,
	0xa6, 0x3f, 0x96, 0xb2, 0x7b, 0x0b, 0xfb, 0x2b, 0x47, 0x9b, 0x91, 0x93, 0xb8, 0x08, 0x27, 0x88,
	0x85, 0x1f, 0x04, 0xd8, 0x68, 0x0c, 0x46, 0x7e, 0x3c, 0xaf, 0x22, 0x40, 0xbd, 0x5e, 0xd1, 0x28,
	0xfc, 0x86, 0xd4, 0x62, 0x1c, 0x9a, 0x5d, 0xc4, 0xbe, 0x31, 0xbb, 0x88, 0xf9, 0x56, 0xd9, 0x7d,
	0x09, 0x62, 0x25, 0x84, 0x9e, 0x1b, 0x3e, 0xb9, 0x34, 0xc6, 0xaa, 0x26, 0x65, 0x6f, 0x70, 0x34,
	0xc7, 0x2c, 0xfc, 0x59, 0x80, 0x95, 0x5a, 0xa9, 0x63, 0xba, 0x7e, 0xc0, 0xb6, 0xa2, 0x0c, 0xb9,
	0xc9, 0xe2, 0xa6, 0xec, 0xca, 0xe8, 0xfa, 0x2a, 0xbf, 0xce, 0x22, 0x1b, 0x19, 0x56, 0xdf, 0xf0,
	0x6d, 0x77, 0x8c, 0xa7, 0x6a, 0xe8, 0x19, 0x2c, 0xd6, 0x4a, 0xd8, 0x1e, 0x12, 0x96, 0xf0, 0xfa,
	0xd1, 0xca, 0xa1, 0xd3, 0xf7, 0x0e, 0x43, 0x28, 0x55, 0x37, 0xa2, 0x17, 0xfe, 0x2a, 0x50, 0x4d,
	0x7e, 0x7c, 0x3a, 0xaa, 0xa6, 0x5a, 0x67, 0xb6, 0x24, 0xb0, 0xed, 0x12, 0x23, 0x23, 0x13, 0x37,
	0x98, 0x13, 0xd0, 0x43, 0xb8, 0xad, 0xb9, 0x84, 0x8c, 0x1c, 0xdf, 0xb4, 0xad, 0xb6, 0x39, 0x22,
	0x76, 0xe0, 0x47, 0xa7, 0x74, 0x5e, 0x80, 0x3a, 0x20, 0x69, 0xae, 0x3d, 0xb2, 0x19, 0x66, 0x97,
	0x7a, 0xbe, 0x79, 0x41, 0xb8, 0x52, 0x58, 0xf8, 0x9d, 0xeb, 0xab, 0xfc, 0x76, 0xac, 0xf0, 0xbc,
	0xe2, 0x8f, 0x8b, 0x45, 0x7c, 0xa3, 0x6e, 0xe1, 0x3f, 0xab, 0x00, 0x15, 0x76, 0x0b, 0x59, 0x02,
	0x0f, 0x61, 0x59, 0xd5, 0x2e, 0x9e, 0xd0, 0x92, 0xdd, 0x78, 0x4a, 0x26, 0x8c, 0x88, 0xfd, 0x94,
	0xb1, 0x33, 0x6f, 0x60, 0x33, 0x06, 0xbd, 0x8c, 0x8d, 0x92, 0xcc, 0xc8, 0x34, 0xe2, 0x2c, 0xe6,
	0x4b, 0x74, 0x08, 0xb9, 0x9f, 0x3f, 0x05, 0x53, 0x0a, 0x6a, 0xc3, 0x4a, 0x85, 0x5c, 0xb4, 0x1c,
	0xe2, 0x36, 0xec, 0x3e, 0x91, 0x6e, 0xb1, 0xfd, 0xda, 0x64, 0xa5, 0x0e, 0x73, 0xe1, 0xa2, 0xf2,
	0xbb, 0xd7, 0x57, 0xf9, 0x7b, 0xc9, 0x7d, 0x7b, 0xb8, 0xe7, 0x10, 0xd7, 0x33, 0x3d, 0x9f, 0xf4,
	0x71, 0xdc, 0x0c, 0xea, 0xc0, 0x5a, 0x83, 0x8c, 0x6c, 0x77, 0xac, 0xb9, 0xf6, 0x99, 0x39, 0x24,
	0xd2, 0x22, 0xb3, 0x8b, 0x98, 0xdd, 0x84, 0xa4, 0xfc, 0xe0, 0xfa, 0x2a, 0x2f, 0xcd, 0x98, 0x9d,
	0x5a, 0x4d, 0x9a, 0xa1, 0x76, 0xc3, 0xa8, 0xb8, 0xdd, 0xa5, 0x98, 0xdd, 0x84, 0xe4, 0xe7, 0xec,
	0x26, 0xc8, 0xe8, 0x37, 0x70, 0x3f, 0x01, 0x9c, 0x38, 0xfd, 0x53, 0xc3, 0xf4, 0xf9, 0xa9, 0x58,
	0x66, 0x47, 0xe9, 0x4d, 0x14, 0x74, 0x04, 0x50, 0x76, 0xcd, 0xfe, 0xc0, 0xb4, 0x06, 0x8a, 0x25,
	0xe5, 0xf6, 0x84, 0xfd, 0xe5, 0xd8, 0x49, 0x37, 0x47, 0xa3, 0xc0, 0x37, 0x5e, 0x0d, 0x09, 0x8e,
	0xb1, 0xe8, 0x5e, 0xd5, 0x89, 0xe1, 0x5a, 0xf4, 0xb8, 0x48, 0x90, 0xd8, 0xab, 0x09, 0x8e, 0xa7,
	0x14, 0x74, 0x02, 0xdb, 0xaa, 0xd6, 0x30, 0x1c, 0xc7, 0xb4, 0x06, 0xf2, 0xd0, 0xf0, 0x3c, 0xcd,
	0x35, 0x6d, 0x97, 0x36, 0xb4, 0x15, 0x76, 0x6c, 0xa7, 0x3b, 0xc4, 0xfb, 0xc5, 0xf1, 0xe3, 0x58,
	0xb7, 0xb8, 0x41, 0x19, 0xbd, 0x86, 0xcd, 0xea, 0xa5, 0x66, 0x0f, 0xcd, 0xde, 0xf8, 0x85, 0x63,
	0x7b, 0x96, 0xde, 0x3b, 0x27, 0x23, 0x22, 0xad, 0xb2, 0xd2, 0x6e, 0x45, 0x01, 0x25, 0x18, 0xe5,
	0xe2, 0xf5, 0x55, 0xfe, 0x21, 0xf3, 0xc4, 0xcd, 0x57, 0x4f, 0xbb, 0x5a, 0xab, 0xae, 0xca, 0x2f,
	0xbb, 0x2f, 0xb4, 0x96, 0xde, 0xec, 0x3e, 0xaf, 0xb7, 0xca, 0xa5, 0x7a, 0x57, 0xc3, 0x6a, 0x0b,
	0xab, 0xed, 0x97, 0x38, 0xcd, 0x05, 0xfa, 0x35, 0x88, 0xad, 0x0b, 0xe2, 0x0e, 0x8d, 0x31, 0xb6,
	0x03, 0x3f, 0x2c, 0xdd, 0xda, 0x4c, 0xe9, 0xa6, 0x4d, 0x62, 0x8e, 0x8b, 0xaa, 0x80, 0xf4, 0xf1,
	0x68, 0x44, 0x7c, 0xd7, 0xec, 0x4d, 0x2d, 0xac, 0x33, 0x0b, 0xdb, 0xd7, 0x57, 0x79, 0x94, 0x08,
	0xf1, 0xcc, 0x18, 0x7a, 0x04, 0xa7, 0x68, 0xa0, 0x3d, 0x58, 0x69, 0xbf, 0x66, 0xe1, 0x11, 0x57,
	0xed, 0x4b, 0x1b, 0x7b, 0xc2, 0xfe, 0x2a, 0x8e, 0x43, 0xe8, 0x05, 0xdc, 0xa9, 0xdb, 0xd6, 0xa0,
	0x6e, 0x5e, 0x90, 0x7e, 0x75, 0x68, 0x5f, 0x56, 0x02, 0xd7, 0xa0, 0x3d, 0x40, 0x12, 0x59, 0xe5,
	0x0b, 0xd7, 0x57, 0xf9, 0xdd, 0x58, 0xe5, 0x8f, 0x8b, 0x8f, 0x8e, 0x9f, 0x16, 0x8b, 0x93, 0xe2,
	0x1f, 0x17, 0x8b, 0x38, 0xdd, 0x00, 0x7a, 0x02, 0x2b, 0x74, 0x5d, 0xb7, 0x07, 0xec, 0x18, 0xdc,
	0x66, 0xc7, 0x00, 0xf1, 0xaa, 0x4f, 0x25, 0x38, 0x4e, 0xa3, 0x11, 0xd3, 0x25, 0x26, 0x67, 0x2e,
	0xf1, 0xce, 0x25, 0x44, 0x53, 0xc6, 0x71, 0x88, 0xb6, 0x08, 0x7d, 0xec, 0x35, 0x8d, 0x11, 0x91,
	0x36, 0xf7, 0x84, 0xfd, 0x1c, 0xe6, 0x4b, 0xf4, 0x04, 0x80, 0xcd, 0xb4, 0x4b, 0xe6, 0x70, 0x8b,
	0x39, 0xdc, 0x0a, 0x6f, 0x66, 0x72, 0xd4, 0xe1, 0x18, 0x0f, 0x7d, 0x05, 0x6b, 0x7c, 0xc8, 0x87,
	0x8a, 0x77, 0x98, 0xe2, 0x5d, 0xa6, 0x38, 0x3f, 0xfe, 0x71, 0x92, 0x4d, 0x5b, 0x74, 0xc5, 0xb5,
	0x9d, 0x86, 0xe9, 0xba, 0xb6, 0xab, 0x13, 0xcf, 0xa3, 0xc5, 0xdb, 0x66, 0x85, 0x9e, 0x17, 0xa0,
	0x03, 0x3a, 0xd2, 0x86, 0xc6, 0xb8, 0x66, 0x7b, 0x7e, 0xd9, 0x35, 0xad, 0x41, 0xe0, 0x48, 0x77,
	0x59, 0x8e, 0x73, 0x38, 0x9d, 0xc7, 0x3a, 0x71, 0xe9, 0xcd, 0xec, 0xa8, 0x9a, 0x24, 0xdd, 0x34,
	0x8f, 0xa7, 0x1c, 0xf4, 0x00, 0x72, 0x9d, 0xd7, 0xf5, 0x52, 0x53, 0xb3, 0x5d, 0x5f, 0xba, 0xc7,
	0xee, 0xf6, 0x14, 0x40, 0x4f, 0x61, 0x8d, 0x2d, 0x74, 0xb7, 0x47, 0xd7, 0x9e, 0xb4, 0x93, 0x30,
	0x49, 0x31, 0xf6, 0x52, 0xc2, 0x49, 0x1a, 0x92, 0x61, 0xa5, 0xed, 0x06, 0xb4, 0xbb, 0x74, 0x9a,
	0xaa, 0x27, 0xdd, 0x67, 0x43, 0x6b, 0x8d, 0x95, 0x87, 0x3f, 0xae, 0x52, 0x3b, 0x42, 0x5c, 0x0b,
	0xbd, 0xcf, 0xe7, 0x9f, 0xf4, 0x80, 0x79, 0xe5, 0x93, 0x93, 0x95, 0x34, 0x12, 0x15, 0xce, 0x61,
	0x6b, 0xa6, 0xe0, 0xbe, 0xe1, 0x07, 0x1e, 0x2a, 0xc2, 0x66, 0x84, 0xd3, 0x77, 0x41, 0xc7, 0x32,
	0x7b, 0xb5, 0x4b, 0xb5, 0x1f, 0xbd, 0xe3, 0xd2, 0x44, 0x68, 0x17, 0x00, 0xbf, 0x6e, 0x1a, 0xbd,
	0x21, 0x23, 0x86, 0x13, 0x33, 0x86, 0x14, 0xba, 0x70, 0x3b, 0x7e, 0x26, 0x42, 0x37, 0x07, 0x20,
	0x52, 0x30, 0xc5, 0xc7, 0x1c, 0xfe, 0xb3, 0x0e, 0xfe, 0x08, 0xcb, 0xb5, 0x52, 0x64, 0x37, 0x0f,
	0x59, 0xf6, 0x66, 0x10, 0xe6, 0xde, 0x0c, 0x98, 0x09, 0x50, 0x01, 0x56, 0x2b, 0xba, 0x5c, 0x2b,
	0x75, 0x68, 0x1b, 0xb7, 0xad, 0xc8, 0x5c, 0x02, 0x43, 0x87, 0x80, 0x54, 0xcb, 0x27, 0x6e, 0x45,
	0x97, 0xdb, 0x81, 0x65, 0x91, 0xd0, 0x31, 0x1b, 0xeb, 0x38, 0x45, 0x52, 0xf8, 0x6f, 0x0e, 0x56,
	0xa3, 0xa1, 0x3d, 0xc9, 0x4e, 0x1f, 0x7b, 0x3e, 0x19, 0x45, 0x13, 0x95, 0x78, 0x1e, 0x8b, 0x28,
	0x8b, 0xe7, 0x70, 0x1a, 0x90, 0x4e, 0x5c, 0xd3, 0x18, 0x36, 0x83, 0xd1, 0x2b, 0x12, 0x0e, 0xee,
	0x1c, 0x4e, 0x60, 0x48, 0x84, 0x05, 0xfd, 0xbb, 0x80, 0x45, 0x90, 0xc3, 0xf4, 0x4f, 0xb4, 0x0f,
	0x1b, 0x55, 0xd3, 0x1d, 0x5d, 0x1a, 0x2e, 0xe1, 0x99, 0x64, 0x99, 0x74, 0x16, 0xa6, 0x6f, 0xf1,
	0x70, 0xfe, 0xb1, 0xb9, 0xbc, 0x86, 0xa3, 0x15, 0xbd, 0xfd, 0x9a, 0x6b, 0xf7, 0x83, 0x9e, 0xcf,
	0xee, 0xf7, 0x22, 0xd3, 0x8e, 0x43, 0xf4, 0xba, 0x35, 0x0c, 0x2b, 0x38, 0x33, 0x7a, 0x7e, 0x40,
	0xef, 0x49, 0xc5, 0xf0, 0xc3, 0x61, 0x99, 0xc3, 0xf3, 0x02, 0x6a, 0xaf, 0x42, 0xbc, 0x9e, 0x6b,
	0xb2, 0x77, 0x12, 0x1b, 0x77, 0x39, 0x1c, 0x87, 0xd0, 0x0e, 0x2c, 0x77, 0x88, 0xd5, 0xb7, 0x5d,
	0xb5, 0xc2, 0x86, 0x5b, 0x0e, 0x4f, 0xd6, 0xe8, 0x97, 0xb0, 0x2c, 0x9f, 0x9b, 0x4e, 0x7b, 0xec,
	0x10, 0x36, 0xc5, 0xd6, 0x8f, 0x36, 0xa2, 0xbb, 0x52, 0xf2, 0xcc, 0x1e, 0x85, 0xf1, 0x84, 0x40,
	0xcb, 0x5b, 0x33, 0xdc, 0x3e, 0xcd, 0x12, 0x93, 0x0b, 0x93, 0x65, 0xbf, 0xc2, 0x0c, 0xce, 0xe1,
	0xf4, 0x9e, 0xca, 0x4e, 0x10, 0xfa, 0x61, 0xe3, 0x28, 0x87, 0xa7, 0x00, 0xb5, 0x24, 0x3b, 0x01,
	0xbd, 0x10, 0xe6, 0x99, 0xd9, 0x0b, 0xbb, 0xf1, 0x5a, 0x68, 0x69, 0x16, 0x67, 0x1b, 0x65, 0xf7,
	0x5a, 0x3a, 0xaf, 0xf7, 0x7a, 0xb4, 0x51, 0x31, 0x8c, 0x16, 0x41, 0xb7, 0x7b, 0x15, 0xd3, 0xfb,
	0x4e, 0x37, 0xff, 0x40, 0xd8, 0x10, 0xc8, 0xe1, 0x38, 0x84, 0x3e, 0x84, 0x75, 0x4d, 0x56, 0x89,
	0x6c, 0x38, 0xc6, 0x2b, 0x73, 0x48, 0xe7, 0xae, 0xc8, 0x48, 0x33, 0x28, 0xdb, 0x1e, 0x59, 0x25,
	0xe5, 0xc0, 0x63, 0xcf, 0xd7, 0xdb, 0xd1, 0xf6, 0x4c, 0x21, 0x1a, 0x4f, 0x33, 0x18, 0x51, 0x24,
	0x6c, 0x31, 0x28, 0x3c, 0xc9, 0x71, 0x8c, 0x96, 0x9c, 0xae, 0x99, 0x7c, 0x93, 0xc9, 0x27, 0x6b,
	0x7a, 0xad, 0xc2, 0x2a, 0xb0, 0xfd, 0xdf, 0x62, 0x0e, 0x62, 0x08, 0x95, 0x6b, 0x2f, 0x14, 0x9e,
	0x2d, 0xed, 0xd4, 0x19, 0x1c, 0x43, 0x68, 0x84, 0x27, 0x4a, 0x55, 0xe5, 0x84, 0x6d, 0x46, 0x88,
	0x43, 0xb4, 0xf6, 0xcd, 0x60, 0x44, 0xfb, 0xac, 0x7a, 0xc6, 0x5a, 0xef, 0x1a, 0x9e, 0x02, 0xb4,
	0xd3, 0xf0, 0xb3, 0x1a, 0x3f, 0x38, 0x12, 0x0b, 0x24, 0x4d, 0x44, 0x0f, 0x24, 0x87, 0xcb, 0x81,
	0x39, 0xec, 0xd3, 0x77, 0x13, 0xeb, 0xbd, 0x39, 0x3c, 0x2f, 0xa0, 0xb9, 0x6b, 0xa6, 0x43, 0x86,
	0xa6, 0x45, 0x58, 0xfb, 0xcd, 0xe1, 0xc9, 0x1a, 0xc9, 0xb0, 0x31, 0x1d, 0x2d, 0xec, 0xce, 0x4a,
	0xf7, 0x59, 0xaf, 0xbc, 0x97, 0x36, 0x8a, 0x18, 0x01, 0xcf, 0x6a, 0xa0, 0xcf, 0x61, 0x35, 0x9a,
	0x6d, 0xa1, 0x85, 0xb0, 0xdb, 0x6e, 0xcf, 0x4d, 0xc1, 0x50, 0x3d, 0xc1, 0x45, 0x8f, 0x61, 0x59,
	0xb5, 0x4c, 0x9f, 0xbd, 0x97, 0xdf, 0x65, 0xe7, 0xfd, 0x0e, 0xd3, 0xe3, 0x69, 0x70, 0x21, 0x9e,
	0xd0, 0x42, 0x15, 0xcf, 0x37, 0xac, 0x1e, 0x91, 0x76, 0x53, 0x55, 0x42, 0x21, 0x9e, 0xd0, 0xd0,
	0xc7, 0xd3, 0xce, 0x28, 0xe5, 0x59, 0x74, 0x6b, 0x7c, 0x16, 0x84, 0x41, 0x4d, 0x1b, 0xe7, 0x21,
	0x20, 0x39, 0x70, 0x5d, 0x62, 0xf9, 0xb2, 0x6d, 0x9d, 0x99, 0x03, 0xc5, 0xb1, 0x7b, 0xe7, 0xd2,
	0x5e, 0xd8, 0xf3, 0xe6, 0x25, 0x05, 0xf6, 0xc1, 0xc8, 0x5b, 0x9e, 0xa7, 0x58, 0xbe, 0x3b, 0x46,
	0x08, 0xb2, 0xec, 0x2c, 0x09, 0xac, 0xda, 0xec, 0x6f, 0xb4, 0x05, 0xb7, 0x64, 0x3b, 0xb0, 0xc2,
	0x4f, 0xa9, 0x2c, 0x0e, 0x17, 0x85, 0x11, 0xfb, 0x62, 0xe0, 0xda, 0xe8, 0x13, 0x58, 0x52, 0xad,
	0x41, 0xd4, 0x26, 0xe9, 0xc8, 0xbb, 0x13, 0x7b, 0x8c, 0x4f, 0x1d, 0x60, 0xce, 0x42, 0x8f, 0x60,
	0x51, 0x09, 0xf9, 0x99, 0x37, 0xf1, 0x23, 0x52, 0xe1, 0x6f, 0x19, 0x58, 0x0c, 0x85, 0xe8, 0x0b,
	0x58, 0xa6, 0x3d, 0xa4, 0x41, 0x7c, 0x23, 0xfa, 0xa2, 0x5a, 0x3f, 0x64, 0x3f, 0x69, 0x70, 0xb4,
	0xbc, 0xf1, 0xfd, 0x55, 0x5e, 0xf8, 0xe9, 0x2a, 0xbf, 0xf4, 0xd0, 0xb4, 0xe8, 0x61, 0xc1, 0x13,
	0x05, 0xf4, 0x35, 0x2c, 0xb5, 0x5e, 0x7d, 0xcb, 0x74, 0x33, 0x51, 0x39, 0x99, 0x6e, 0x04, 0x96,
	0xb7, 0x23, 0x55, 0x36, 0x9e, 0x1f, 0xda, 0x23, 0xd3, 0xa7, 0x9f, 0x8d, 0x63, 0xcc, 0xb5, 0xd0,
	0x33, 0xc8, 0xb2, 0xc1, 0xbc, 0xc0, 0xb4, 0x37, 0xe2, 0x51, 0x3b, 0xa4, 0x57, 0x46, 0x54, 0xd7,
	0x73, 0x48, 0x2f, 0xa6, 0xcb, 0x14, 0xd0, 0xd7, 0xb0, 0x18, 0xed, 0x63, 0xf8, 0x3d, 0x76, 0x7b,
	0x26, 0xe1, 0xc0, 0x2b, 0x6f, 0xfd, 0x74, 0x95, 0x17, 0x3d, 0xf6, 0x77, 0x4c, 0x3d, 0x52, 0x43,
	0x5f, 0xc0, 0x2d, 0x56, 0x18, 0x36, 0x05, 0xf8, 0x87, 0x70, 0xac, 0x60, 0xe5, 0xcd, 0x9f, 0xae,
	0xf2, 0x1b, 0x54, 0x3d, 0xae, 0x1d, 0xea, 0x14, 0xbe, 0xe5, 0x9f, 0x4c, 0x98, 0xfc, 0x3e, 0x20,
	0x9e, 0x4f, 0xbf, 0x3a, 0xca, 0x86, 0xdf, 0x3b, 0x97, 0xfd, 0xd7, 0xfe, 0xcc, 0x87, 0xe9, 0x04,
	0xc7, 0x53, 0x0a, 0xfa, 0x18, 0x96, 0x22, 0xd5, 0xa8, 0x70, 0xb3, 0xa9, 0x63, 0x2e, 0x2f, 0xd8,
	0xb0, 0xce, 0x7d, 0x79, 0x8e, 0x6d, 0x79, 0x84, 0x3a, 0x2b, 0x39, 0x66, 0x94, 0x7e, 0x38, 0xd8,
	0xb9, 0xb3, 0x09, 0x8e, 0xa7, 0x14, 0xf4, 0x08, 0x96, 0xb9, 0x6e, 0xe4, 0x6d, 0xbe, 0x5a, 0x78,
	0x42, 0x29, 0x20, 0x7e, 0x92, 0x9f, 0x13, 0x9f, 0x07, 0x31, 0x84, 0xdb, 0x31, 0xec, 0x2d, 0xe3,
	0xf8, 0x68, 0x2e, 0x8e, 0x95, 0x58, 0x1c, 0xb1, 0x08, 0x14, 0xd8, 0x0c, 0xb1, 0x0a, 0x19, 0x12,
	0xff, 0x6d, 0x8b, 0x5c, 0xa8, 0xc2, 0x56, 0xd2, 0xcc, 0xdb, 0xc5, 0x7d, 0xf0, 0xcd, 0xcc, 0x87,
	0x37, 0xda, 0x81, 0xed, 0x86, 0xd2, 0x68, 0xe1, 0x97, 0x5d, 0x0d, 0xb7, 0xaa, 0x6a, 0x5d, 0xe9,
	0x56, 0x94, 0x6a, 0xe9, 0xa4, 0xde, 0x16, 0xdf, 0x41, 0xf7, 0xe0, 0xce, 0x8c, 0x0c, 0xb7, 0x4e,
	0xda, 0x0a, 0x16, 0x05, 0x24, 0xc1, 0xd6, 0x8c, 0x48, 0xd5, 0x74, 0x45, 0x16, 0x33, 0x07, 0x7f,
	0x5a, 0x98, 0xf9, 0x06, 0xa7, 0x2e, 0x2a, 0x4a, 0x47, 0x95, 0x95, 0x14, 0x17, 0xdb, 0x80, 0x66,
	0x64, 0x8f, 0xb5, 0xaa, 0x28, 0xa4, 0xe0, 0x47, 0x5a, 0x55, 0xcc, 0xa4, 0xe0, 0xc7, 0x5a, 0x55,
	0x5c, 0x48, 0xc1, 0x9f, 0x68, 0x55, 0x31, 0x9b, 0x82, 0x7f, 0xaa, 0x55, 0xc5, 0x5b, 0x29, 0xf8,
	0x53, 0xad, 0x2a, 0x2e, 0xa6, 0xe0, 0xcf, 0xb4, 0xaa, 0xb8, 0x94, 0x82, 0xff, 0x4a, 0xab, 0x8a,
	0xcb, 0xe8, 0x2e, 0x6c, 0xce, 0xc6, 0x4f, 0x0d, 0xe5, 0x52, 0x04, 0xc7, 0x47, 0x9d, 0xaa, 0x08,
	0x29, 0x82, 0xa7, 0x4f, 0x3a, 0x55, 0x71, 0x05, 0xfd, 0x02, 0xde, 0x9b, 0x11, 0x94, 0xd5, 0xf6,
	0x69, 0x57, 0x6f, 0x94, 0x70, 0xbb, 0xab, 0x2b, 0x98, 0x8a, 0xc4, 0x55, 0xf4, 0x01, 0xec, 0xbd,
	0x81, 0x76, 0xaa, 0xb6, 0xe5, 0x9a, 0xb8, 0x76, 0xf0, 0x0f, 0x81, 0x5f, 0xb5, 0xc9, 0x6f, 0x2e,
	0xf7, 0xe0, 0x4e, 0xa4, 0xd8, 0xd2, 0x14, 0xdc, 0x6d, 0xb4, 0x2a, 0x4a, 0xb7, 0xd9, 0x6a, 0x2a,
	0xe1, 0x46, 0xcf, 0x89, 0x6a, 0x2d, 0xbd, 0x2d, 0x0a, 0xe8, 0x43, 0x28, 0xcc, 0x89, 0xe6, 0x1d,
	0x66, 0xd0, 0x47, 0xf0, 0xfe, 0x1b, 0x79, 0x51, 0xfc, 0x0b, 0x68, 0x1f, 0x3e, 0x48, 0x27, 0xca,
	0xf5, 0x92, 0xae, 0xab, 0x32, 0x37, 0x99, 0x3d, 0x90, 0xf9, 0xaf, 0x84, 0x48, 0x84, 0xd5, 0x5a,
	0xa9, 0x8b, 0x5b, 0xf5, 0x49, 0xc4, 0x08, 0xd6, 0x39, 0x52, 0x92, 0xdb, 0x6a, 0x47, 0x11, 0x05,
	0xb4, 0x09, 0x1b, 0x1c, 0xd3, 0xdb, 0xa5, 0x66, 0xa5, 0xfc, 0x52, 0xcc, 0x1c, 0xfc, 0x5d, 0xe0,
	0xef, 0xf7, 0x1a, 0x31, 0x86, 0xfe, 0x79, 0x6c, 0x27, 0x6b, 0x4a, 0xa9, 0xde, 0xae, 0x71, 0x8b,
	0x5b, 0x20, 0x26, 0xf1, 0xd6, 0x6f, 0x45, 0x01, 0xed, 0xc2, 0x4e, 0x12, 0x8d, 0x12, 0xe9, 0x56,
	0x5a, 0xa7, 0x4d, 0x31, 0x83, 0xde, 0x83, 0x77, 0x93, 0x72, 0xac, 0x94, 0x5b, 0xad, 0x76, 0x17,
	0x2b, 0xbf, 0x3b, 0x51, 0xb1, 0x52, 0x11, 0x17, 0xd0, 0x03, 0x90, 0x92, 0x94, 0x7a, 0xeb, 0xb4,
	0x1b, 0x5e, 0x1e, 0x31, 0x8b, 0xf6, 0xe0, 0x41, 0x52, 0x5a, 0x2b, 0xe1, 0xca, 0x69, 0x09, 0x2b,
	0x5d, 0x05, 0xe3, 0x16, 0x16, 0x6f, 0x1d, 0xfc, 0x4b, 0x00, 0x71, 0xf6, 0xe9, 0x80, 0xee, 0xc3,
	0xdd, 0xaa, 0x8a, 0x1b, 0x8c, 0xa8, 0x36, 0xd5, 0x76, 0x62, 0x3b, 0x77, 0x61, 0x27, 0x45, 0xc8,
	0x2f, 0x9d, 0x80, 0xf2, 0x70, 0x3f, 0x45, 0xfe, 0x1c, 0x97, 0x64, 0xa5, 0x7a, 0x52, 0x17, 0x33,
	0x37, 0x18, 0xa8, 0xa9, 0xed, 0xba, 0xa2, 0xeb, 0xe2, 0xc2, 0x0d, 0x06, 0xf4, 0x76, 0xa9, 0xcd,
	0x0c, 0x64, 0x6f, 0x20, 0x60, 0x45, 0x6e, 0x75, 0x14, 0xfc, 0x52, 0xbc, 0x75, 0xf0, 0x4d, 0x3c,
	0xa7, 0xe8, 0x45, 0xb3, 0x03, 0xdb, 0x31, 0x25, 0xba, 0x85, 0xf2, 0x24, 0xa5, 0xbb, 0xb0, 0x39,
	0x2f, 0x2b, 0x89, 0x42, 0xba, 0xa0, 0x2c, 0x66, 0x8e, 0xfe, 0x92, 0x81, 0x5c, 0x34, 0x15, 0x2e,
	0x7a, 0xe8, 0x33, 0x7e, 0x0a, 0x64, 0x97, 0xd0, 0x2f, 0x9a, 0xf8, 0x2f, 0x82, 0x51, 0x4f, 0xde,
	0xd9, 0x4c, 0x60, 0x51, 0xff, 0x7e, 0x67, 0xaa, 0x7a, 0xe2, 0xf4, 0xff, 0x4f, 0xd5, 0x2f, 0x79,
	0x08, 0xcf, 0x89, 0x8f, 0xe2, 0xef, 0x98, 0xe9, 0x38, 0xda, 0xd9, 0x9e, 0x85, 0x27, 0xda, 0x0a,
	0x77, 0x1c, 0xf6, 0x7c, 0x24, 0xc5, 0x98, 0x89, 0x69, 0xb2, 0x73, 0x2f, 0x45, 0x32, 0x31, 0x53,
	0x4c, 0xbc, 0xe6, 0x30, 0xf1, 0x88, 0x8f, 0x56, 0xa3, 0x19, 0xa1, 0xd0, 0x97, 0xc0, 0x4e, 0x62,
	0x55, 0x78, 0xa7, 0xbc, 0xfa, 0xcf, 0x1f, 0x77, 0x85, 0xef, 0x7f, 0xdc, 0x15, 0x7e, 0xf8, 0x71,
	0x57, 0x78, 0xb5, 0xc8, 0xfe, 0x0f, 0xe8, 0xf8, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x49, 0xaa,
	0x07, 0xd1, 0x42, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DeviceSvcClient is the client API for DeviceSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DeviceSvcClient interface {
	DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error)
	DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error)
	DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error)
	DeviceStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type deviceSvcClient struct {
	cc *grpc.ClientConn
}

func NewDeviceSvcClient(cc *grpc.ClientConn) DeviceSvcClient {
	return &deviceSvcClient{cc}
}

func (c *deviceSvcClient) DeviceCreate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := c.cc.Invoke(ctx, "/pds.DeviceSvc/DeviceCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceUpdate(ctx context.Context, in *DeviceRequest, opts ...grpc.CallOption) (*DeviceResponse, error) {
	out := new(DeviceResponse)
	err := c.cc.Invoke(ctx, "/pds.DeviceSvc/DeviceUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceGet(ctx context.Context, in *DeviceGetRequest, opts ...grpc.CallOption) (*DeviceGetResponse, error) {
	out := new(DeviceGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DeviceSvc/DeviceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceDelete(ctx context.Context, in *DeviceDeleteRequest, opts ...grpc.CallOption) (*DeviceDeleteResponse, error) {
	out := new(DeviceDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.DeviceSvc/DeviceDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceSvcClient) DeviceStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DeviceSvc/DeviceStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeviceSvcServer is the server API for DeviceSvc service.
type DeviceSvcServer interface {
	DeviceCreate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceUpdate(context.Context, *DeviceRequest) (*DeviceResponse, error)
	DeviceGet(context.Context, *DeviceGetRequest) (*DeviceGetResponse, error)
	DeviceDelete(context.Context, *DeviceDeleteRequest) (*DeviceDeleteResponse, error)
	DeviceStatsReset(context.Context, *Empty) (*Empty, error)
}

// UnimplementedDeviceSvcServer can be embedded to have forward compatible implementations.
type UnimplementedDeviceSvcServer struct {
}

func (*UnimplementedDeviceSvcServer) DeviceCreate(ctx context.Context, req *DeviceRequest) (*DeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceCreate not implemented")
}
func (*UnimplementedDeviceSvcServer) DeviceUpdate(ctx context.Context, req *DeviceRequest) (*DeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceUpdate not implemented")
}
func (*UnimplementedDeviceSvcServer) DeviceGet(ctx context.Context, req *DeviceGetRequest) (*DeviceGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceGet not implemented")
}
func (*UnimplementedDeviceSvcServer) DeviceDelete(ctx context.Context, req *DeviceDeleteRequest) (*DeviceDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceDelete not implemented")
}
func (*UnimplementedDeviceSvcServer) DeviceStatsReset(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceStatsReset not implemented")
}

func RegisterDeviceSvcServer(s *grpc.Server, srv DeviceSvcServer) {
	s.RegisterService(&_DeviceSvc_serviceDesc, srv)
}

func _DeviceSvc_DeviceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceCreate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceUpdate(ctx, req.(*DeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceGet(ctx, req.(*DeviceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceDelete(ctx, req.(*DeviceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceSvc_DeviceStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceSvcServer).DeviceStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DeviceSvc/DeviceStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceSvcServer).DeviceStatsReset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeviceSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.DeviceSvc",
	HandlerType: (*DeviceSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeviceCreate",
			Handler:    _DeviceSvc_DeviceCreate_Handler,
		},
		{
			MethodName: "DeviceUpdate",
			Handler:    _DeviceSvc_DeviceUpdate_Handler,
		},
		{
			MethodName: "DeviceGet",
			Handler:    _DeviceSvc_DeviceGet_Handler,
		},
		{
			MethodName: "DeviceDelete",
			Handler:    _DeviceSvc_DeviceDelete_Handler,
		},
		{
			MethodName: "DeviceStatsReset",
			Handler:    _DeviceSvc_DeviceStatsReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "device.proto",
}

func (m *VNIRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VNIRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VNIRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VNIHigh != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.VNIHigh))
		i--
		dAtA[i] = 0x10
	}
	if m.VNILow != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.VNILow))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlNetworkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlNetworkSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlNetworkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BGPCommunity) > 0 {
		for iNdEx := len(m.BGPCommunity) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BGPCommunity[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Vlan != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerIP != nil {
		{
			size, err := m.PeerIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LocalIP != nil {
		{
			size, err := m.LocalIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MgmtNetworkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MgmtNetworkSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MgmtNetworkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DefaultGatewayIP != nil {
		{
			size, err := m.DefaultGatewayIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vlan != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x18
	}
	if m.MgmtIP != nil {
		{
			size, err := m.MgmtIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LLDPMgmtIP != nil {
		{
			size, err := m.LLDPMgmtIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HAVirtualIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAVirtualIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HAVirtualIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HARole != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.HARole))
		i--
		dAtA[i] = 0x10
	}
	if m.VirtualIP != nil {
		{
			size, err := m.VirtualIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HASpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HASpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HASpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PromotionToActiveTimeout != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.PromotionToActiveTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.PreemptionTimeout != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.PreemptionTimeout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.VIPInfo) > 0 {
		for iNdEx := len(m.VIPInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VIPInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeviceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HASpec != nil {
		{
			size, err := m.HASpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.TrustedVNIs) > 0 {
		for iNdEx := len(m.TrustedVNIs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustedVNIs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.VxLANSrcPorts != nil {
		{
			size, err := m.VxLANSrcPorts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.VxLANPort != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.VxLANPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.ServiceVIP != nil {
		{
			size, err := m.ServiceVIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.DelayHostBringup {
		i--
		if m.DelayHostBringup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.DropMirrorSession) > 0 {
		i -= len(m.DropMirrorSession)
		copy(dAtA[i:], m.DropMirrorSession)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.DropMirrorSession)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ControlNwSpec != nil {
		{
			size, err := m.ControlNwSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MgmtNwSpec != nil {
		{
			size, err := m.MgmtNwSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SysName) > 0 {
		i -= len(m.SysName)
		copy(dAtA[i:], m.SysName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SysName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.FlowRefresh {
		i--
		if m.FlowRefresh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.FlowLogSpec != nil {
		{
			size, err := m.FlowLogSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.LongLivedFlowDuration != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.LongLivedFlowDuration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.TxPolicerId) > 0 {
		i -= len(m.TxPolicerId)
		copy(dAtA[i:], m.TxPolicerId)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.TxPolicerId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.SymmetricRoutingEn {
		i--
		if m.SymmetricRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.OverlayRoutingEn {
		i--
		if m.OverlayRoutingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.FwPolicyXposnScheme != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.FwPolicyXposnScheme))
		i--
		dAtA[i] = 0x60
	}
	if m.IPMappingClassPriority != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.IPMappingClassPriority))
		i--
		dAtA[i] = 0x58
	}
	if m.LearnSpec != nil {
		{
			size, err := m.LearnSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.BridgingEn {
		i--
		if m.BridgingEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DeviceProfileUpdWaitTimeout != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.DeviceProfileUpdWaitTimeout))
		i--
		dAtA[i] = 0x40
	}
	if m.DeviceProfile != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.DeviceProfile))
		i--
		dAtA[i] = 0x38
	}
	if m.MemoryProfile != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.MemoryProfile))
		i--
		dAtA[i] = 0x30
	}
	if m.DevOperMode != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.DevOperMode))
		i--
		dAtA[i] = 0x28
	}
	if m.GatewayIP != nil {
		{
			size, err := m.GatewayIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MACAddr != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x18
	}
	if m.IPv6Addr != nil {
		{
			size, err := m.IPv6Addr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IPv4Addr != nil {
		{
			size, err := m.IPv4Addr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlNetworkStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlNetworkStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlNetworkStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RxNaclHwId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.RxNaclHwId))
		i--
		dAtA[i] = 0x10
	}
	if m.ControlVlanVnicHwId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ControlVlanVnicHwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MgmtNetworkStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MgmtNetworkStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MgmtNetworkStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RxNaclHwId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.RxNaclHwId))
		i--
		dAtA[i] = 0x10
	}
	if m.MgmtVlanVnicHwId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.MgmtVlanVnicHwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HAStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HAStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InterDSCTunnelHwId != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.InterDSCTunnelHwId))
		i--
		dAtA[i] = 0x18
	}
	if m.DSCHAVersion != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.DSCHAVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.Role != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurrentConfigEpoch != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.CurrentConfigEpoch))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.HAStatus != nil {
		{
			size, err := m.HAStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Instance != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Instance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.InitMode != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.InitMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.MgmtNwStatus != nil {
		{
			size, err := m.MgmtNwStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.ControlNwStatus != nil {
		{
			size, err := m.ControlNwStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.Pipeline) > 0 {
		i -= len(m.Pipeline)
		copy(dAtA[i:], m.Pipeline)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Pipeline)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.FirmwareBuildTime) > 0 {
		i -= len(m.FirmwareBuildTime)
		copy(dAtA[i:], m.FirmwareBuildTime)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareBuildTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.FirmwareDescription) > 0 {
		i -= len(m.FirmwareDescription)
		copy(dAtA[i:], m.FirmwareDescription)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareDescription)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.NumHostIf != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.NumHostIf))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.UEFIVersion != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UEFIVersion))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.PXEVersion != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PXEVersion))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if len(m.VendorName) > 0 {
		i -= len(m.VendorName)
		copy(dAtA[i:], m.VendorName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.NumPorts != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPorts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NumPCIePorts != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.NumPCIePorts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.PCIeBusInfo) > 0 {
		i -= len(m.PCIeBusInfo)
		copy(dAtA[i:], m.PCIeBusInfo)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeBusInfo)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PCIeCapability) > 0 {
		i -= len(m.PCIeCapability)
		copy(dAtA[i:], m.PCIeCapability)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.PCIeCapability)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.SocDiskSize) > 0 {
		i -= len(m.SocDiskSize)
		copy(dAtA[i:], m.SocDiskSize)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocDiskSize)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SocOSVersion) > 0 {
		i -= len(m.SocOSVersion)
		copy(dAtA[i:], m.SocOSVersion)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SocOSVersion)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.CpuSpecification) > 0 {
		i -= len(m.CpuSpecification)
		copy(dAtA[i:], m.CpuSpecification)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuSpecification)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CpuVendor) > 0 {
		i -= len(m.CpuVendor)
		copy(dAtA[i:], m.CpuVendor)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.CpuVendor)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.HardwareRevision) > 0 {
		i -= len(m.HardwareRevision)
		copy(dAtA[i:], m.HardwareRevision)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.HardwareRevision)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ChipType != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ChipType))
		i--
		dAtA[i] = 0x50
	}
	if len(m.VendorID) > 0 {
		i -= len(m.VendorID)
		copy(dAtA[i:], m.VendorID)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.VendorID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ManufacturingDate) > 0 {
		i -= len(m.ManufacturingDate)
		copy(dAtA[i:], m.ManufacturingDate)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ManufacturingDate)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ProductName) > 0 {
		i -= len(m.ProductName)
		copy(dAtA[i:], m.ProductName)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.ProductName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Memory != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FirmwareVersion) > 0 {
		i -= len(m.FirmwareVersion)
		copy(dAtA[i:], m.FirmwareVersion)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.FirmwareVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sku) > 0 {
		i -= len(m.Sku)
		copy(dAtA[i:], m.Sku)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Sku)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x12
	}
	if m.SystemMACAddress != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.SystemMACAddress))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDevice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Egress) > 0 {
		for iNdEx := len(m.Egress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Egress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDevice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeviceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDevice(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDevice(dAtA []byte, offset int, v uint64) int {
	offset -= sovDevice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VNIRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VNILow != 0 {
		n += 1 + sovDevice(uint64(m.VNILow))
	}
	if m.VNIHigh != 0 {
		n += 1 + sovDevice(uint64(m.VNIHigh))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ControlNetworkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalIP != nil {
		l = m.LocalIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.PeerIP != nil {
		l = m.PeerIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Vlan != 0 {
		n += 1 + sovDevice(uint64(m.Vlan))
	}
	if len(m.BGPCommunity) > 0 {
		for _, e := range m.BGPCommunity {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MgmtNetworkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LLDPMgmtIP != nil {
		l = m.LLDPMgmtIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.MgmtIP != nil {
		l = m.MgmtIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Vlan != 0 {
		n += 1 + sovDevice(uint64(m.Vlan))
	}
	if m.DefaultGatewayIP != nil {
		l = m.DefaultGatewayIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAVirtualIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualIP != nil {
		l = m.VirtualIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.HARole != 0 {
		n += 1 + sovDevice(uint64(m.HARole))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HASpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VIPInfo) > 0 {
		for _, e := range m.VIPInfo {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if m.PreemptionTimeout != 0 {
		n += 1 + sovDevice(uint64(m.PreemptionTimeout))
	}
	if m.PromotionToActiveTimeout != 0 {
		n += 1 + sovDevice(uint64(m.PromotionToActiveTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPv4Addr != nil {
		l = m.IPv4Addr.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.IPv6Addr != nil {
		l = m.IPv6Addr.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovDevice(uint64(m.MACAddr))
	}
	if m.GatewayIP != nil {
		l = m.GatewayIP.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.DevOperMode != 0 {
		n += 1 + sovDevice(uint64(m.DevOperMode))
	}
	if m.MemoryProfile != 0 {
		n += 1 + sovDevice(uint64(m.MemoryProfile))
	}
	if m.DeviceProfile != 0 {
		n += 1 + sovDevice(uint64(m.DeviceProfile))
	}
	if m.DeviceProfileUpdWaitTimeout != 0 {
		n += 1 + sovDevice(uint64(m.DeviceProfileUpdWaitTimeout))
	}
	if m.BridgingEn {
		n += 2
	}
	if m.LearnSpec != nil {
		l = m.LearnSpec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.IPMappingClassPriority != 0 {
		n += 1 + sovDevice(uint64(m.IPMappingClassPriority))
	}
	if m.FwPolicyXposnScheme != 0 {
		n += 1 + sovDevice(uint64(m.FwPolicyXposnScheme))
	}
	if m.OverlayRoutingEn {
		n += 2
	}
	if m.SymmetricRoutingEn {
		n += 2
	}
	l = len(m.TxPolicerId)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.LongLivedFlowDuration != 0 {
		n += 2 + sovDevice(uint64(m.LongLivedFlowDuration))
	}
	if m.FlowLogSpec != nil {
		l = m.FlowLogSpec.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.FlowRefresh {
		n += 3
	}
	l = len(m.SysName)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.MgmtNwSpec != nil {
		l = m.MgmtNwSpec.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.ControlNwSpec != nil {
		l = m.ControlNwSpec.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.DropMirrorSession)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.DelayHostBringup {
		n += 3
	}
	if m.ServiceVIP != nil {
		l = m.ServiceVIP.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.VxLANPort != 0 {
		n += 2 + sovDevice(uint64(m.VxLANPort))
	}
	if m.VxLANSrcPorts != nil {
		l = m.VxLANSrcPorts.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if len(m.TrustedVNIs) > 0 {
		for _, e := range m.TrustedVNIs {
			l = e.Size()
			n += 2 + l + sovDevice(uint64(l))
		}
	}
	if m.HASpec != nil {
		l = m.HASpec.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ControlNetworkStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlVlanVnicHwId != 0 {
		n += 1 + sovDevice(uint64(m.ControlVlanVnicHwId))
	}
	if m.RxNaclHwId != 0 {
		n += 1 + sovDevice(uint64(m.RxNaclHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MgmtNetworkStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MgmtVlanVnicHwId != 0 {
		n += 1 + sovDevice(uint64(m.MgmtVlanVnicHwId))
	}
	if m.RxNaclHwId != 0 {
		n += 1 + sovDevice(uint64(m.RxNaclHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovDevice(uint64(m.Role))
	}
	if m.DSCHAVersion != 0 {
		n += 1 + sovDevice(uint64(m.DSCHAVersion))
	}
	if m.InterDSCTunnelHwId != 0 {
		n += 1 + sovDevice(uint64(m.InterDSCTunnelHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemMACAddress != 0 {
		n += 1 + sovDevice(uint64(m.SystemMACAddress))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovDevice(uint64(m.Memory))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.ManufacturingDate)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ChipType != 0 {
		n += 1 + sovDevice(uint64(m.ChipType))
	}
	l = len(m.HardwareRevision)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuVendor)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.CpuSpecification)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocOSVersion)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.SocDiskSize)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeCapability)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.PCIeBusInfo)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.NumPCIePorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPCIePorts))
	}
	if m.NumPorts != 0 {
		n += 2 + sovDevice(uint64(m.NumPorts))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.PXEVersion != 0 {
		n += 6
	}
	if m.UEFIVersion != 0 {
		n += 6
	}
	if m.NumHostIf != 0 {
		n += 2 + sovDevice(uint64(m.NumHostIf))
	}
	l = len(m.FirmwareDescription)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.FirmwareBuildTime)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	l = len(m.Pipeline)
	if l > 0 {
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.ControlNwStatus != nil {
		l = m.ControlNwStatus.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.MgmtNwStatus != nil {
		l = m.MgmtNwStatus.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.InitMode != 0 {
		n += 2 + sovDevice(uint64(m.InitMode))
	}
	if m.Instance != 0 {
		n += 2 + sovDevice(uint64(m.Instance))
	}
	if m.HAStatus != nil {
		l = m.HAStatus.Size()
		n += 2 + l + sovDevice(uint64(l))
	}
	if m.CurrentConfigEpoch != 0 {
		n += 2 + sovDevice(uint64(m.CurrentConfigEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovDevice(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovDevice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDevice(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDevice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDevice(x uint64) (n int) {
	return sovDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VNIRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VNIRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VNIRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNILow", wireType)
			}
			m.VNILow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNILow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNIHigh", wireType)
			}
			m.VNIHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNIHigh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlNetworkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlNetworkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlNetworkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIP == nil {
				m.LocalIP = &IPAddress{}
			}
			if err := m.LocalIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerIP == nil {
				m.PeerIP = &IPAddress{}
			}
			if err := m.PeerIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPCommunity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BGPCommunity = append(m.BGPCommunity, &BGPCommunity{})
			if err := m.BGPCommunity[len(m.BGPCommunity)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MgmtNetworkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MgmtNetworkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MgmtNetworkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLDPMgmtIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LLDPMgmtIP == nil {
				m.LLDPMgmtIP = &IPAddress{}
			}
			if err := m.LLDPMgmtIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtIP == nil {
				m.MgmtIP = &IPAddress{}
			}
			if err := m.MgmtIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGatewayIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGatewayIP == nil {
				m.DefaultGatewayIP = &IPAddress{}
			}
			if err := m.DefaultGatewayIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAVirtualIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HAVirtualIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HAVirtualIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualIP == nil {
				m.VirtualIP = &IPAddress{}
			}
			if err := m.VirtualIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HARole", wireType)
			}
			m.HARole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HARole |= HARole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HASpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HASpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HASpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VIPInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VIPInfo = append(m.VIPInfo, &HAVirtualIP{})
			if err := m.VIPInfo[len(m.VIPInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptionTimeout", wireType)
			}
			m.PreemptionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreemptionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToActiveTimeout", wireType)
			}
			m.PromotionToActiveTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToActiveTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPv4Addr == nil {
				m.IPv4Addr = &IPAddress{}
			}
			if err := m.IPv4Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPv6Addr == nil {
				m.IPv6Addr = &IPAddress{}
			}
			if err := m.IPv6Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayIP == nil {
				m.GatewayIP = &IPAddress{}
			}
			if err := m.GatewayIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevOperMode", wireType)
			}
			m.DevOperMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevOperMode |= DeviceOperMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryProfile", wireType)
			}
			m.MemoryProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryProfile |= MemoryProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfile", wireType)
			}
			m.DeviceProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceProfile |= DeviceProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfileUpdWaitTimeout", wireType)
			}
			m.DeviceProfileUpdWaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceProfileUpdWaitTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BridgingEn = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnSpec == nil {
				m.LearnSpec = &LearnSpec{}
			}
			if err := m.LearnSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMappingClassPriority", wireType)
			}
			m.IPMappingClassPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPMappingClassPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwPolicyXposnScheme", wireType)
			}
			m.FwPolicyXposnScheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwPolicyXposnScheme |= FwPolicyXposn(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlayRoutingEn = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymmetricRoutingEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SymmetricRoutingEn = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPolicerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxPolicerId = append(m.TxPolicerId[:0], dAtA[iNdEx:postIndex]...)
			if m.TxPolicerId == nil {
				m.TxPolicerId = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongLivedFlowDuration", wireType)
			}
			m.LongLivedFlowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongLivedFlowDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLogSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowLogSpec == nil {
				m.FlowLogSpec = &FlowLogSpec{}
			}
			if err := m.FlowLogSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRefresh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowRefresh = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtNwSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtNwSpec == nil {
				m.MgmtNwSpec = &MgmtNetworkSpec{}
			}
			if err := m.MgmtNwSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlNwSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlNwSpec == nil {
				m.ControlNwSpec = &ControlNetworkSpec{}
			}
			if err := m.ControlNwSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMirrorSession", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropMirrorSession = append(m.DropMirrorSession[:0], dAtA[iNdEx:postIndex]...)
			if m.DropMirrorSession == nil {
				m.DropMirrorSession = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayHostBringup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayHostBringup = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceVIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceVIP == nil {
				m.ServiceVIP = &IPAddress{}
			}
			if err := m.ServiceVIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxLANPort", wireType)
			}
			m.VxLANPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VxLANPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxLANSrcPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VxLANSrcPorts == nil {
				m.VxLANSrcPorts = &PortRange{}
			}
			if err := m.VxLANSrcPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedVNIs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedVNIs = append(m.TrustedVNIs, &VNIRange{})
			if err := m.TrustedVNIs[len(m.TrustedVNIs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HASpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HASpec == nil {
				m.HASpec = &HASpec{}
			}
			if err := m.HASpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlNetworkStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlNetworkStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlNetworkStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlVlanVnicHwId", wireType)
			}
			m.ControlVlanVnicHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ControlVlanVnicHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxNaclHwId", wireType)
			}
			m.RxNaclHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxNaclHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MgmtNetworkStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MgmtNetworkStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MgmtNetworkStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtVlanVnicHwId", wireType)
			}
			m.MgmtVlanVnicHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtVlanVnicHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxNaclHwId", wireType)
			}
			m.RxNaclHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxNaclHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HAStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HAStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= HARole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCHAVersion", wireType)
			}
			m.DSCHAVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSCHAVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterDSCTunnelHwId", wireType)
			}
			m.InterDSCTunnelHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterDSCTunnelHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMACAddress", wireType)
			}
			m.SystemMACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemMACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManufacturingDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManufacturingDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChipType", wireType)
			}
			m.ChipType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChipType |= AsicType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareRevision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareRevision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpecification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSpecification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocOSVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocOSVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocDiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocDiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeCapability", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeCapability = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PCIeBusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PCIeBusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPCIePorts", wireType)
			}
			m.NumPCIePorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPCIePorts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPorts", wireType)
			}
			m.NumPorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPorts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PXEVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PXEVersion = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEFIVersion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UEFIVersion = float32(math.Float32frombits(v))
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHostIf", wireType)
			}
			m.NumHostIf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumHostIf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareBuildTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareBuildTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pipeline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlNwStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlNwStatus == nil {
				m.ControlNwStatus = &ControlNetworkStatus{}
			}
			if err := m.ControlNwStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtNwStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtNwStatus == nil {
				m.MgmtNwStatus = &MgmtNetworkStatus{}
			}
			if err := m.MgmtNwStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitMode", wireType)
			}
			m.InitMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitMode |= FirmwareInitMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instance |= FirmwareInstance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HAStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HAStatus == nil {
				m.HAStatus = &HAStatus{}
			}
			if err := m.HAStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentConfigEpoch", wireType)
			}
			m.CurrentConfigEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentConfigEpoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &DeviceStatsEntry{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &DeviceStatsEntry{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DeviceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DeviceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DeviceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeviceSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &DeviceStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Device{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDevice
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDevice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDevice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDevice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDevice
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDevice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDevice   = fmt.Errorf("proto: integer overflow")
)
