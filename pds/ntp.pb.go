// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ntp.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NTPSpec captures NTP configuration
type NTPSpec struct {
	NTPServer            []string `protobuf:"bytes,1,rep,name=NTPServer,proto3" json:"NTPServer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTPSpec) Reset()         { *m = NTPSpec{} }
func (m *NTPSpec) String() string { return proto.CompactTextString(m) }
func (*NTPSpec) ProtoMessage()    {}
func (*NTPSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{0}
}
func (m *NTPSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPSpec.Merge(m, src)
}
func (m *NTPSpec) XXX_Size() int {
	return m.Size()
}
func (m *NTPSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NTPSpec proto.InternalMessageInfo

func (m *NTPSpec) GetNTPServer() []string {
	if m != nil {
		return m.NTPServer
	}
	return nil
}

// operational status of a NTP, if any
type NTPStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTPStatus) Reset()         { *m = NTPStatus{} }
func (m *NTPStatus) String() string { return proto.CompactTextString(m) }
func (*NTPStatus) ProtoMessage()    {}
func (*NTPStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{1}
}
func (m *NTPStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPStatus.Merge(m, src)
}
func (m *NTPStatus) XXX_Size() int {
	return m.Size()
}
func (m *NTPStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NTPStatus proto.InternalMessageInfo

// stats for a NTP, if any
type NTPStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTPStats) Reset()         { *m = NTPStats{} }
func (m *NTPStats) String() string { return proto.CompactTextString(m) }
func (*NTPStats) ProtoMessage()    {}
func (*NTPStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{2}
}
func (m *NTPStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPStats.Merge(m, src)
}
func (m *NTPStats) XXX_Size() int {
	return m.Size()
}
func (m *NTPStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPStats.DiscardUnknown(m)
}

var xxx_messageInfo_NTPStats proto.InternalMessageInfo

// NTP object
type NTP struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *NTPSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *NTPStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *NTPStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NTP) Reset()         { *m = NTP{} }
func (m *NTP) String() string { return proto.CompactTextString(m) }
func (*NTP) ProtoMessage()    {}
func (*NTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{3}
}
func (m *NTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTP.Merge(m, src)
}
func (m *NTP) XXX_Size() int {
	return m.Size()
}
func (m *NTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NTP.DiscardUnknown(m)
}

var xxx_messageInfo_NTP proto.InternalMessageInfo

func (m *NTP) GetSpec() *NTPSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NTP) GetStatus() *NTPStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NTP) GetStats() *NTPStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NTP create and update request
type NTPRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// NTP configuration
	Request              *NTPSpec `protobuf:"bytes,2,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTPRequest) Reset()         { *m = NTPRequest{} }
func (m *NTPRequest) String() string { return proto.CompactTextString(m) }
func (*NTPRequest) ProtoMessage()    {}
func (*NTPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{4}
}
func (m *NTPRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPRequest.Merge(m, src)
}
func (m *NTPRequest) XXX_Size() int {
	return m.Size()
}
func (m *NTPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NTPRequest proto.InternalMessageInfo

func (m *NTPRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NTPRequest) GetRequest() *NTPSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NTP create and update response
type NTPResponse struct {
	// API status code
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *NTPStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NTPResponse) Reset()         { *m = NTPResponse{} }
func (m *NTPResponse) String() string { return proto.CompactTextString(m) }
func (*NTPResponse) ProtoMessage()    {}
func (*NTPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{5}
}
func (m *NTPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPResponse.Merge(m, src)
}
func (m *NTPResponse) XXX_Size() int {
	return m.Size()
}
func (m *NTPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NTPResponse proto.InternalMessageInfo

func (m *NTPResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NTPResponse) GetResponse() *NTPStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// NTP get request
type NTPGetRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTPGetRequest) Reset()         { *m = NTPGetRequest{} }
func (m *NTPGetRequest) String() string { return proto.CompactTextString(m) }
func (*NTPGetRequest) ProtoMessage()    {}
func (*NTPGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{6}
}
func (m *NTPGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPGetRequest.Merge(m, src)
}
func (m *NTPGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *NTPGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NTPGetRequest proto.InternalMessageInfo

// NTP get response
type NTPGetResponse struct {
	// API status code
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *NTP      `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NTPGetResponse) Reset()         { *m = NTPGetResponse{} }
func (m *NTPGetResponse) String() string { return proto.CompactTextString(m) }
func (*NTPGetResponse) ProtoMessage()    {}
func (*NTPGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{7}
}
func (m *NTPGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPGetResponse.Merge(m, src)
}
func (m *NTPGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *NTPGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NTPGetResponse proto.InternalMessageInfo

func (m *NTPGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NTPGetResponse) GetResponse() *NTP {
	if m != nil {
		return m.Response
	}
	return nil
}

// NTP delete request
type NTPDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NTPDeleteRequest) Reset()         { *m = NTPDeleteRequest{} }
func (m *NTPDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NTPDeleteRequest) ProtoMessage()    {}
func (*NTPDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{8}
}
func (m *NTPDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPDeleteRequest.Merge(m, src)
}
func (m *NTPDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NTPDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NTPDeleteRequest proto.InternalMessageInfo

func (m *NTPDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

// NTP delete response
type NTPDeleteResponse struct {
	// API status code
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NTPDeleteResponse) Reset()         { *m = NTPDeleteResponse{} }
func (m *NTPDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NTPDeleteResponse) ProtoMessage()    {}
func (*NTPDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_92c80f41404b64e3, []int{9}
}
func (m *NTPDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTPDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTPDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTPDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTPDeleteResponse.Merge(m, src)
}
func (m *NTPDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NTPDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NTPDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NTPDeleteResponse proto.InternalMessageInfo

func (m *NTPDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterType((*NTPSpec)(nil), "pds.NTPSpec")
	proto.RegisterType((*NTPStatus)(nil), "pds.NTPStatus")
	proto.RegisterType((*NTPStats)(nil), "pds.NTPStats")
	proto.RegisterType((*NTP)(nil), "pds.NTP")
	proto.RegisterType((*NTPRequest)(nil), "pds.NTPRequest")
	proto.RegisterType((*NTPResponse)(nil), "pds.NTPResponse")
	proto.RegisterType((*NTPGetRequest)(nil), "pds.NTPGetRequest")
	proto.RegisterType((*NTPGetResponse)(nil), "pds.NTPGetResponse")
	proto.RegisterType((*NTPDeleteRequest)(nil), "pds.NTPDeleteRequest")
	proto.RegisterType((*NTPDeleteResponse)(nil), "pds.NTPDeleteResponse")
}

func init() { proto.RegisterFile("ntp.proto", fileDescriptor_92c80f41404b64e3) }

var fileDescriptor_92c80f41404b64e3 = []byte{
	// 500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0xd3, 0xe6, 0xcf, 0xa4, 0x8d, 0xc3, 0x16, 0x2a, 0xcb, 0x42, 0x49, 0x65, 0x21,
	0xa8, 0x50, 0x65, 0x50, 0xcb, 0x01, 0x89, 0x4a, 0x08, 0x07, 0xa9, 0x27, 0x8c, 0x65, 0xcc, 0x03,
	0xb8, 0xc9, 0x50, 0x8c, 0x9a, 0x78, 0xc9, 0x6e, 0x2b, 0xf2, 0x58, 0xbc, 0x05, 0xc7, 0x3e, 0x81,
	0x41, 0x39, 0xe6, 0x29, 0xd0, 0xfe, 0xb3, 0x9d, 0x72, 0xa9, 0x72, 0x89, 0x76, 0xbf, 0x99, 0x5f,
	0xbe, 0x99, 0xcf, 0xb2, 0xa1, 0x33, 0xe3, 0xd4, 0xa7, 0xf3, 0x9c, 0xe7, 0xa4, 0x41, 0x27, 0xcc,
	0x85, 0xcb, 0xfc, 0x32, 0x57, 0x82, 0x6b, 0x4f, 0x91, 0xa7, 0x2f, 0xc5, 0x8f, 0x16, 0xba, 0x7c,
	0x41, 0x91, 0xa9, 0x8b, 0xf7, 0x1c, 0x5a, 0x61, 0x12, 0x7d, 0xa6, 0x38, 0x26, 0x4f, 0xa0, 0x23,
	0x8e, 0x38, 0xbf, 0xc1, 0xb9, 0x63, 0x1d, 0x36, 0x8e, 0x3a, 0x71, 0x25, 0x78, 0x5d, 0x55, 0xe5,
	0x29, 0xbf, 0x66, 0x1e, 0x40, 0x5b, 0x5f, 0x98, 0xf7, 0x6b, 0x0b, 0x1a, 0x61, 0x12, 0x91, 0xb7,
	0xd0, 0x4e, 0x16, 0x14, 0x3f, 0x22, 0x4f, 0x1d, 0xeb, 0xd0, 0x3a, 0xea, 0x9e, 0xf4, 0x7c, 0xe9,
	0x6a, 0xd4, 0xc0, 0xbe, 0x2d, 0x86, 0xd6, 0xaa, 0x18, 0xb6, 0x8e, 0xb3, 0xd9, 0x55, 0x36, 0xc3,
	0xb8, 0x04, 0xc8, 0x3b, 0x68, 0x7d, 0xba, 0xf8, 0x2e, 0xd9, 0x2d, 0xc9, 0xee, 0x29, 0x56, 0x8b,
	0xc1, 0x81, 0x46, 0x7b, 0x42, 0x3d, 0xce, 0xa7, 0x19, 0xc7, 0x29, 0xe5, 0x8b, 0xd8, 0x50, 0xe4,
	0x35, 0x6c, 0x8b, 0x25, 0x9c, 0x86, 0xa4, 0x77, 0x7d, 0x3a, 0x61, 0xbe, 0x5e, 0x2c, 0x20, 0x02,
	0x64, 0x14, 0xc7, 0x35, 0x50, 0x76, 0x93, 0x33, 0x68, 0xaa, 0x8d, 0x9c, 0x6d, 0x3d, 0xb1, 0xe1,
	0xa4, 0x1a, 0x3c, 0x5a, 0x15, 0xc3, 0x3e, 0x93, 0xe7, 0x1a, 0xab, 0x19, 0xf2, 0x06, 0x76, 0x64,
	0x04, 0xce, 0x8e, 0x1e, 0xb9, 0x06, 0xb3, 0x60, 0x7f, 0x55, 0x0c, 0x6d, 0xc1, 0xd6, 0x51, 0x05,
	0x78, 0x13, 0x80, 0x30, 0x89, 0x62, 0xfc, 0x71, 0x8d, 0x8c, 0x13, 0x1f, 0x3a, 0x41, 0xca, 0xc7,
	0xdf, 0x46, 0xfc, 0x27, 0xd7, 0xd1, 0xf5, 0x7d, 0xf5, 0x90, 0x4a, 0x3d, 0xae, 0x5a, 0xc8, 0x33,
	0x68, 0x69, 0x54, 0x87, 0xb5, 0xb6, 0x6e, 0x6c, 0x8a, 0x5e, 0x06, 0x5d, 0xe9, 0xc2, 0x68, 0x3e,
	0x63, 0x28, 0x6c, 0xde, 0xd3, 0x4c, 0xef, 0x2b, 0x6c, 0x7a, 0xa5, 0x4d, 0xa9, 0xc7, 0x55, 0x0b,
	0x79, 0x01, 0x6d, 0xc3, 0x6a, 0x9f, 0x3b, 0xf1, 0xc4, 0x65, 0xdd, 0xb3, 0x61, 0x2f, 0x4c, 0xa2,
	0x73, 0xe4, 0xc6, 0xfb, 0x2b, 0xf4, 0x8c, 0xb0, 0xa1, 0xfd, 0xd3, 0xff, 0xec, 0xdb, 0xc6, 0xbe,
	0x66, 0x1c, 0x40, 0x3f, 0x4c, 0xa2, 0x0f, 0x78, 0x85, 0x1c, 0x37, 0xcc, 0xd3, 0x1b, 0xc1, 0xc3,
	0xda, 0x7f, 0x6c, 0x36, 0xee, 0xc9, 0x1f, 0x0b, 0x9a, 0x22, 0x99, 0x9b, 0x31, 0x79, 0x25, 0x5f,
	0x95, 0xd1, 0x1c, 0x53, 0x8e, 0xc4, 0x2e, 0x87, 0x56, 0xd3, 0xb9, 0xfd, 0x4a, 0xd0, 0x3b, 0x3c,
	0xd0, 0xc4, 0x17, 0x3a, 0xb9, 0x37, 0x71, 0x2a, 0xdd, 0xce, 0x91, 0x13, 0x62, 0xaa, 0x55, 0xfa,
	0xee, 0xfe, 0x9a, 0x56, 0x42, 0x67, 0xd2, 0x46, 0x2d, 0x4a, 0x1e, 0x9b, 0x9e, 0xb5, 0xf0, 0xdc,
	0x83, 0xbb, 0xb2, 0xa1, 0x83, 0xdd, 0xdf, 0xcb, 0x81, 0x75, 0xbb, 0x1c, 0x58, 0x7f, 0x97, 0x03,
	0xeb, 0xa2, 0x29, 0xbf, 0x1f, 0xa7, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x12, 0x73, 0x97, 0xaf,
	0x7b, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NTPSvcClient is the client API for NTPSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NTPSvcClient interface {
	NTPCreate(ctx context.Context, in *NTPRequest, opts ...grpc.CallOption) (*NTPResponse, error)
	NTPUpdate(ctx context.Context, in *NTPRequest, opts ...grpc.CallOption) (*NTPResponse, error)
	NTPGet(ctx context.Context, in *NTPGetRequest, opts ...grpc.CallOption) (*NTPGetResponse, error)
	NTPDelete(ctx context.Context, in *NTPDeleteRequest, opts ...grpc.CallOption) (*NTPDeleteResponse, error)
}

type nTPSvcClient struct {
	cc *grpc.ClientConn
}

func NewNTPSvcClient(cc *grpc.ClientConn) NTPSvcClient {
	return &nTPSvcClient{cc}
}

func (c *nTPSvcClient) NTPCreate(ctx context.Context, in *NTPRequest, opts ...grpc.CallOption) (*NTPResponse, error) {
	out := new(NTPResponse)
	err := c.cc.Invoke(ctx, "/pds.NTPSvc/NTPCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nTPSvcClient) NTPUpdate(ctx context.Context, in *NTPRequest, opts ...grpc.CallOption) (*NTPResponse, error) {
	out := new(NTPResponse)
	err := c.cc.Invoke(ctx, "/pds.NTPSvc/NTPUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nTPSvcClient) NTPGet(ctx context.Context, in *NTPGetRequest, opts ...grpc.CallOption) (*NTPGetResponse, error) {
	out := new(NTPGetResponse)
	err := c.cc.Invoke(ctx, "/pds.NTPSvc/NTPGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nTPSvcClient) NTPDelete(ctx context.Context, in *NTPDeleteRequest, opts ...grpc.CallOption) (*NTPDeleteResponse, error) {
	out := new(NTPDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.NTPSvc/NTPDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NTPSvcServer is the server API for NTPSvc service.
type NTPSvcServer interface {
	NTPCreate(context.Context, *NTPRequest) (*NTPResponse, error)
	NTPUpdate(context.Context, *NTPRequest) (*NTPResponse, error)
	NTPGet(context.Context, *NTPGetRequest) (*NTPGetResponse, error)
	NTPDelete(context.Context, *NTPDeleteRequest) (*NTPDeleteResponse, error)
}

// UnimplementedNTPSvcServer can be embedded to have forward compatible implementations.
type UnimplementedNTPSvcServer struct {
}

func (*UnimplementedNTPSvcServer) NTPCreate(ctx context.Context, req *NTPRequest) (*NTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NTPCreate not implemented")
}
func (*UnimplementedNTPSvcServer) NTPUpdate(ctx context.Context, req *NTPRequest) (*NTPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NTPUpdate not implemented")
}
func (*UnimplementedNTPSvcServer) NTPGet(ctx context.Context, req *NTPGetRequest) (*NTPGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NTPGet not implemented")
}
func (*UnimplementedNTPSvcServer) NTPDelete(ctx context.Context, req *NTPDeleteRequest) (*NTPDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NTPDelete not implemented")
}

func RegisterNTPSvcServer(s *grpc.Server, srv NTPSvcServer) {
	s.RegisterService(&_NTPSvc_serviceDesc, srv)
}

func _NTPSvc_NTPCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NTPSvcServer).NTPCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NTPSvc/NTPCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NTPSvcServer).NTPCreate(ctx, req.(*NTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NTPSvc_NTPUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NTPSvcServer).NTPUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NTPSvc/NTPUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NTPSvcServer).NTPUpdate(ctx, req.(*NTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NTPSvc_NTPGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NTPGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NTPSvcServer).NTPGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NTPSvc/NTPGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NTPSvcServer).NTPGet(ctx, req.(*NTPGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NTPSvc_NTPDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NTPDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NTPSvcServer).NTPDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NTPSvc/NTPDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NTPSvcServer).NTPDelete(ctx, req.(*NTPDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NTPSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.NTPSvc",
	HandlerType: (*NTPSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NTPCreate",
			Handler:    _NTPSvc_NTPCreate_Handler,
		},
		{
			MethodName: "NTPUpdate",
			Handler:    _NTPSvc_NTPUpdate_Handler,
		},
		{
			MethodName: "NTPGet",
			Handler:    _NTPSvc_NTPGet_Handler,
		},
		{
			MethodName: "NTPDelete",
			Handler:    _NTPSvc_NTPDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ntp.proto",
}

func (m *NTPSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NTPServer) > 0 {
		for iNdEx := len(m.NTPServer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NTPServer[iNdEx])
			copy(dAtA[i:], m.NTPServer[iNdEx])
			i = encodeVarintNtp(dAtA, i, uint64(len(m.NTPServer[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NTPStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NTPStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NTPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NTPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNtp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NTPGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NTPGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNtp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NTPDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NTPDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTPDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTPDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNtp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNtp(dAtA []byte, offset int, v uint64) int {
	offset -= sovNtp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NTPSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NTPServer) > 0 {
		for _, s := range m.NTPServer {
			l = len(s)
			n += 1 + l + sovNtp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNtp(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNtp(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNtp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NTPDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNtp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNtp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNtp(x uint64) (n int) {
	return sovNtp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NTPSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServer = append(m.NTPServer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NTPSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NTPStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NTPStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &NTPSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &NTPStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &NTP{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTPDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTPDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTPDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNtp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNtp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNtp
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNtp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNtp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNtp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNtp
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNtp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNtp   = fmt.Errorf("proto: integer overflow")
)
