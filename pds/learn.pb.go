// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: learn.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EpState int32

const (
	EpState_EP_STATE_NONE     EpState = 0
	EpState_EP_STATE_LEARNING EpState = 1
	EpState_EP_STATE_CREATED  EpState = 2
	EpState_EP_STATE_PROBING  EpState = 3
	EpState_EP_STATE_UPDATING EpState = 4
	EpState_EP_STATE_DELETING EpState = 5
	EpState_EP_STATE_DELETED  EpState = 6
)

var EpState_name = map[int32]string{
	0: "EP_STATE_NONE",
	1: "EP_STATE_LEARNING",
	2: "EP_STATE_CREATED",
	3: "EP_STATE_PROBING",
	4: "EP_STATE_UPDATING",
	5: "EP_STATE_DELETING",
	6: "EP_STATE_DELETED",
}

var EpState_value = map[string]int32{
	"EP_STATE_NONE":     0,
	"EP_STATE_LEARNING": 1,
	"EP_STATE_CREATED":  2,
	"EP_STATE_PROBING":  3,
	"EP_STATE_UPDATING": 4,
	"EP_STATE_DELETING": 5,
	"EP_STATE_DELETED":  6,
}

func (x EpState) String() string {
	return proto.EnumName(EpState_name, int32(x))
}

func (EpState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{0}
}

type LearnPktType int32

const (
	LearnPktType_LEARN_PKT_TYPE_NONE          LearnPktType = 0
	LearnPktType_LEARN_PKT_TYPE_GARP_ANNOUNCE LearnPktType = 1
	// and tgt MAC = ZERO
	LearnPktType_LEARN_PKT_TYPE_ARP_PROBE         LearnPktType = 2
	LearnPktType_LEARN_PKT_TYPE_ARP_REQUEST       LearnPktType = 3
	LearnPktType_LEARN_PKT_TYPE_GARP_REPLY        LearnPktType = 4
	LearnPktType_LEARN_PKT_TYPE_ARP_REPLY         LearnPktType = 5
	LearnPktType_LEARN_PKT_TYPE_RARP_REQUEST      LearnPktType = 6
	LearnPktType_LEARN_PKT_TYPE_RARP_REPLY        LearnPktType = 7
	LearnPktType_LEARN_PKT_TYPE_DHCP_DISCOVER     LearnPktType = 8
	LearnPktType_LEARN_PKT_TYPE_DHCP_REQUEST      LearnPktType = 9
	LearnPktType_LEARN_PKT_TYPE_DHCP_ACK          LearnPktType = 10
	LearnPktType_LEARN_PKT_TYPE_DHCP_RELEASE      LearnPktType = 11
	LearnPktType_LEARN_PKT_TYPE_DHCP_DECLINE      LearnPktType = 12
	LearnPktType_LEARN_PKT_TYPE_DHCP_UNCLASSIFIED LearnPktType = 13
	LearnPktType_LEARN_PKT_TYPE_IPV4              LearnPktType = 14
)

var LearnPktType_name = map[int32]string{
	0:  "LEARN_PKT_TYPE_NONE",
	1:  "LEARN_PKT_TYPE_GARP_ANNOUNCE",
	2:  "LEARN_PKT_TYPE_ARP_PROBE",
	3:  "LEARN_PKT_TYPE_ARP_REQUEST",
	4:  "LEARN_PKT_TYPE_GARP_REPLY",
	5:  "LEARN_PKT_TYPE_ARP_REPLY",
	6:  "LEARN_PKT_TYPE_RARP_REQUEST",
	7:  "LEARN_PKT_TYPE_RARP_REPLY",
	8:  "LEARN_PKT_TYPE_DHCP_DISCOVER",
	9:  "LEARN_PKT_TYPE_DHCP_REQUEST",
	10: "LEARN_PKT_TYPE_DHCP_ACK",
	11: "LEARN_PKT_TYPE_DHCP_RELEASE",
	12: "LEARN_PKT_TYPE_DHCP_DECLINE",
	13: "LEARN_PKT_TYPE_DHCP_UNCLASSIFIED",
	14: "LEARN_PKT_TYPE_IPV4",
}

var LearnPktType_value = map[string]int32{
	"LEARN_PKT_TYPE_NONE":              0,
	"LEARN_PKT_TYPE_GARP_ANNOUNCE":     1,
	"LEARN_PKT_TYPE_ARP_PROBE":         2,
	"LEARN_PKT_TYPE_ARP_REQUEST":       3,
	"LEARN_PKT_TYPE_GARP_REPLY":        4,
	"LEARN_PKT_TYPE_ARP_REPLY":         5,
	"LEARN_PKT_TYPE_RARP_REQUEST":      6,
	"LEARN_PKT_TYPE_RARP_REPLY":        7,
	"LEARN_PKT_TYPE_DHCP_DISCOVER":     8,
	"LEARN_PKT_TYPE_DHCP_REQUEST":      9,
	"LEARN_PKT_TYPE_DHCP_ACK":          10,
	"LEARN_PKT_TYPE_DHCP_RELEASE":      11,
	"LEARN_PKT_TYPE_DHCP_DECLINE":      12,
	"LEARN_PKT_TYPE_DHCP_UNCLASSIFIED": 13,
	"LEARN_PKT_TYPE_IPV4":              14,
}

func (x LearnPktType) String() string {
	return proto.EnumName(LearnPktType_name, int32(x))
}

func (LearnPktType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{1}
}

type LearnPktDropReason int32

const (
	LearnPktDropReason_LEARN_PKTDROP_REASON_NONE           LearnPktDropReason = 0
	LearnPktDropReason_LEARN_PKTDROP_REASON_PARSE_ERR      LearnPktDropReason = 1
	LearnPktDropReason_LEARN_PKTDROP_REASON_RES_ALLOC_FAIL LearnPktDropReason = 2
	LearnPktDropReason_LEARN_PKTDROP_REASON_LEARNING_FAIL  LearnPktDropReason = 3
	LearnPktDropReason_LEARN_PKTDROP_REASON_MBUF_ERR       LearnPktDropReason = 4
	LearnPktDropReason_LEARN_PKTDROP_REASON_TX_FAIL        LearnPktDropReason = 5
	LearnPktDropReason_LEARN_PKTDROP_REASON_ARP_REPLY      LearnPktDropReason = 6
	LearnPktDropReason_LEARN_PKTDROP_REASON_RARP           LearnPktDropReason = 7
)

var LearnPktDropReason_name = map[int32]string{
	0: "LEARN_PKTDROP_REASON_NONE",
	1: "LEARN_PKTDROP_REASON_PARSE_ERR",
	2: "LEARN_PKTDROP_REASON_RES_ALLOC_FAIL",
	3: "LEARN_PKTDROP_REASON_LEARNING_FAIL",
	4: "LEARN_PKTDROP_REASON_MBUF_ERR",
	5: "LEARN_PKTDROP_REASON_TX_FAIL",
	6: "LEARN_PKTDROP_REASON_ARP_REPLY",
	7: "LEARN_PKTDROP_REASON_RARP",
}

var LearnPktDropReason_value = map[string]int32{
	"LEARN_PKTDROP_REASON_NONE":           0,
	"LEARN_PKTDROP_REASON_PARSE_ERR":      1,
	"LEARN_PKTDROP_REASON_RES_ALLOC_FAIL": 2,
	"LEARN_PKTDROP_REASON_LEARNING_FAIL":  3,
	"LEARN_PKTDROP_REASON_MBUF_ERR":       4,
	"LEARN_PKTDROP_REASON_TX_FAIL":        5,
	"LEARN_PKTDROP_REASON_ARP_REPLY":      6,
	"LEARN_PKTDROP_REASON_RARP":           7,
}

func (x LearnPktDropReason) String() string {
	return proto.EnumName(LearnPktDropReason_name, int32(x))
}

func (LearnPktDropReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{2}
}

type LearnEventType int32

const (
	LearnEventType_LEARN_EVENT_NONE       LearnEventType = 0
	LearnEventType_LEARN_EVENT_NEW_LOCAL  LearnEventType = 1
	LearnEventType_LEARN_EVENT_NEW_REMOTE LearnEventType = 2
	LearnEventType_LEARN_EVENT_L2L_MOVE   LearnEventType = 3
	LearnEventType_LEARN_EVENT_R2L_MOVE   LearnEventType = 4
	LearnEventType_LEARN_EVENT_L2R_MOVE   LearnEventType = 5
	LearnEventType_LEARN_EVENT_R2R_MOVE   LearnEventType = 6
	LearnEventType_LEARN_EVENT_DELETE     LearnEventType = 7
)

var LearnEventType_name = map[int32]string{
	0: "LEARN_EVENT_NONE",
	1: "LEARN_EVENT_NEW_LOCAL",
	2: "LEARN_EVENT_NEW_REMOTE",
	3: "LEARN_EVENT_L2L_MOVE",
	4: "LEARN_EVENT_R2L_MOVE",
	5: "LEARN_EVENT_L2R_MOVE",
	6: "LEARN_EVENT_R2R_MOVE",
	7: "LEARN_EVENT_DELETE",
}

var LearnEventType_value = map[string]int32{
	"LEARN_EVENT_NONE":       0,
	"LEARN_EVENT_NEW_LOCAL":  1,
	"LEARN_EVENT_NEW_REMOTE": 2,
	"LEARN_EVENT_L2L_MOVE":   3,
	"LEARN_EVENT_R2L_MOVE":   4,
	"LEARN_EVENT_L2R_MOVE":   5,
	"LEARN_EVENT_R2R_MOVE":   6,
	"LEARN_EVENT_DELETE":     7,
}

func (x LearnEventType) String() string {
	return proto.EnumName(LearnEventType_name, int32(x))
}

func (LearnEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{3}
}

type LearnValidationType int32

const (
	LearnValidationType_LEARN_CHECK_NONE                   LearnValidationType = 0
	LearnValidationType_LEARN_CHECK_MAC_LIMIT              LearnValidationType = 1
	LearnValidationType_LEARN_CHECK_IP_LIMIT               LearnValidationType = 2
	LearnValidationType_LEARN_CHECK_IP_IN_SUBNET           LearnValidationType = 3
	LearnValidationType_LEARN_CHECK_DATA_PKT_DETECTED_MOVE LearnValidationType = 4
)

var LearnValidationType_name = map[int32]string{
	0: "LEARN_CHECK_NONE",
	1: "LEARN_CHECK_MAC_LIMIT",
	2: "LEARN_CHECK_IP_LIMIT",
	3: "LEARN_CHECK_IP_IN_SUBNET",
	4: "LEARN_CHECK_DATA_PKT_DETECTED_MOVE",
}

var LearnValidationType_value = map[string]int32{
	"LEARN_CHECK_NONE":                   0,
	"LEARN_CHECK_MAC_LIMIT":              1,
	"LEARN_CHECK_IP_LIMIT":               2,
	"LEARN_CHECK_IP_IN_SUBNET":           3,
	"LEARN_CHECK_DATA_PKT_DETECTED_MOVE": 4,
}

func (x LearnValidationType) String() string {
	return proto.EnumName(LearnValidationType_name, int32(x))
}

func (LearnValidationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{4}
}

type LearnApiOpType int32

const (
	LearnApiOpType_LEARN_API_OP_NONE   LearnApiOpType = 0
	LearnApiOpType_LEARN_API_OP_CREATE LearnApiOpType = 1
	LearnApiOpType_LEARN_API_OP_DELETE LearnApiOpType = 2
	LearnApiOpType_LEARN_API_OP_UPDATE LearnApiOpType = 3
)

var LearnApiOpType_name = map[int32]string{
	0: "LEARN_API_OP_NONE",
	1: "LEARN_API_OP_CREATE",
	2: "LEARN_API_OP_DELETE",
	3: "LEARN_API_OP_UPDATE",
}

var LearnApiOpType_value = map[string]int32{
	"LEARN_API_OP_NONE":   0,
	"LEARN_API_OP_CREATE": 1,
	"LEARN_API_OP_DELETE": 2,
	"LEARN_API_OP_UPDATE": 3,
}

func (x LearnApiOpType) String() string {
	return proto.EnumName(LearnApiOpType_name, int32(x))
}

func (LearnApiOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{5}
}

// key for endpoint IP in auto learning mode
type LearnIPKeyAuto struct {
	VPCId                []byte     `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	IPAddr               *IPAddress `protobuf:"bytes,2,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LearnIPKeyAuto) Reset()         { *m = LearnIPKeyAuto{} }
func (m *LearnIPKeyAuto) String() string { return proto.CompactTextString(m) }
func (*LearnIPKeyAuto) ProtoMessage()    {}
func (*LearnIPKeyAuto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{0}
}
func (m *LearnIPKeyAuto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPKeyAuto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPKeyAuto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPKeyAuto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPKeyAuto.Merge(m, src)
}
func (m *LearnIPKeyAuto) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPKeyAuto) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPKeyAuto.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPKeyAuto proto.InternalMessageInfo

func (m *LearnIPKeyAuto) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *LearnIPKeyAuto) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

// key for endpoint MAC in auto learning mode
type LearnMACKeyAuto struct {
	SubnetId             []byte   `protobuf:"bytes,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	MACAddr              uint64   `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LearnMACKeyAuto) Reset()         { *m = LearnMACKeyAuto{} }
func (m *LearnMACKeyAuto) String() string { return proto.CompactTextString(m) }
func (*LearnMACKeyAuto) ProtoMessage()    {}
func (*LearnMACKeyAuto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{1}
}
func (m *LearnMACKeyAuto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACKeyAuto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACKeyAuto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACKeyAuto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACKeyAuto.Merge(m, src)
}
func (m *LearnMACKeyAuto) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACKeyAuto) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACKeyAuto.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACKeyAuto proto.InternalMessageInfo

func (m *LearnMACKeyAuto) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *LearnMACKeyAuto) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

// key for endpoint IP in notify learning mode
type LearnIPKeyNotify struct {
	HostIf               []byte     `protobuf:"bytes,1,opt,name=HostIf,proto3" json:"HostIf,omitempty"`
	IPAddr               *IPAddress `protobuf:"bytes,2,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LearnIPKeyNotify) Reset()         { *m = LearnIPKeyNotify{} }
func (m *LearnIPKeyNotify) String() string { return proto.CompactTextString(m) }
func (*LearnIPKeyNotify) ProtoMessage()    {}
func (*LearnIPKeyNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{2}
}
func (m *LearnIPKeyNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPKeyNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPKeyNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPKeyNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPKeyNotify.Merge(m, src)
}
func (m *LearnIPKeyNotify) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPKeyNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPKeyNotify.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPKeyNotify proto.InternalMessageInfo

func (m *LearnIPKeyNotify) GetHostIf() []byte {
	if m != nil {
		return m.HostIf
	}
	return nil
}

func (m *LearnIPKeyNotify) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

// key for endpoint MAC in notify learning mode
type LearnMACKeyNotify struct {
	HostIf               []byte   `protobuf:"bytes,1,opt,name=HostIf,proto3" json:"HostIf,omitempty"`
	MACAddr              uint64   `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LearnMACKeyNotify) Reset()         { *m = LearnMACKeyNotify{} }
func (m *LearnMACKeyNotify) String() string { return proto.CompactTextString(m) }
func (*LearnMACKeyNotify) ProtoMessage()    {}
func (*LearnMACKeyNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{3}
}
func (m *LearnMACKeyNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACKeyNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACKeyNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACKeyNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACKeyNotify.Merge(m, src)
}
func (m *LearnMACKeyNotify) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACKeyNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACKeyNotify.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACKeyNotify proto.InternalMessageInfo

func (m *LearnMACKeyNotify) GetHostIf() []byte {
	if m != nil {
		return m.HostIf
	}
	return nil
}

func (m *LearnMACKeyNotify) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

// key to uniquely identify endpoint IP in all learning modes
type LearnIPKey struct {
	// Types that are valid to be assigned to Ipkey:
	//	*LearnIPKey_KeyAuto
	//	*LearnIPKey_KeyNotify
	Ipkey                isLearnIPKey_Ipkey `protobuf_oneof:"ipkey"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LearnIPKey) Reset()         { *m = LearnIPKey{} }
func (m *LearnIPKey) String() string { return proto.CompactTextString(m) }
func (*LearnIPKey) ProtoMessage()    {}
func (*LearnIPKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{4}
}
func (m *LearnIPKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPKey.Merge(m, src)
}
func (m *LearnIPKey) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPKey.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPKey proto.InternalMessageInfo

type isLearnIPKey_Ipkey interface {
	isLearnIPKey_Ipkey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnIPKey_KeyAuto struct {
	KeyAuto *LearnIPKeyAuto `protobuf:"bytes,1,opt,name=KeyAuto,proto3,oneof"`
}
type LearnIPKey_KeyNotify struct {
	KeyNotify *LearnIPKeyNotify `protobuf:"bytes,2,opt,name=KeyNotify,proto3,oneof"`
}

func (*LearnIPKey_KeyAuto) isLearnIPKey_Ipkey()   {}
func (*LearnIPKey_KeyNotify) isLearnIPKey_Ipkey() {}

func (m *LearnIPKey) GetIpkey() isLearnIPKey_Ipkey {
	if m != nil {
		return m.Ipkey
	}
	return nil
}

func (m *LearnIPKey) GetKeyAuto() *LearnIPKeyAuto {
	if x, ok := m.GetIpkey().(*LearnIPKey_KeyAuto); ok {
		return x.KeyAuto
	}
	return nil
}

func (m *LearnIPKey) GetKeyNotify() *LearnIPKeyNotify {
	if x, ok := m.GetIpkey().(*LearnIPKey_KeyNotify); ok {
		return x.KeyNotify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LearnIPKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LearnIPKey_KeyAuto)(nil),
		(*LearnIPKey_KeyNotify)(nil),
	}
}

// key to uniquely identify endpoint MAC in all learn modes
type LearnMACKey struct {
	// Types that are valid to be assigned to Mackey:
	//	*LearnMACKey_KeyAuto
	//	*LearnMACKey_KeyNotify
	Mackey               isLearnMACKey_Mackey `protobuf_oneof:"mackey"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *LearnMACKey) Reset()         { *m = LearnMACKey{} }
func (m *LearnMACKey) String() string { return proto.CompactTextString(m) }
func (*LearnMACKey) ProtoMessage()    {}
func (*LearnMACKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{5}
}
func (m *LearnMACKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACKey.Merge(m, src)
}
func (m *LearnMACKey) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACKey.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACKey proto.InternalMessageInfo

type isLearnMACKey_Mackey interface {
	isLearnMACKey_Mackey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnMACKey_KeyAuto struct {
	KeyAuto *LearnMACKeyAuto `protobuf:"bytes,1,opt,name=KeyAuto,proto3,oneof"`
}
type LearnMACKey_KeyNotify struct {
	KeyNotify *LearnMACKeyNotify `protobuf:"bytes,2,opt,name=KeyNotify,proto3,oneof"`
}

func (*LearnMACKey_KeyAuto) isLearnMACKey_Mackey()   {}
func (*LearnMACKey_KeyNotify) isLearnMACKey_Mackey() {}

func (m *LearnMACKey) GetMackey() isLearnMACKey_Mackey {
	if m != nil {
		return m.Mackey
	}
	return nil
}

func (m *LearnMACKey) GetKeyAuto() *LearnMACKeyAuto {
	if x, ok := m.GetMackey().(*LearnMACKey_KeyAuto); ok {
		return x.KeyAuto
	}
	return nil
}

func (m *LearnMACKey) GetKeyNotify() *LearnMACKeyNotify {
	if x, ok := m.GetMackey().(*LearnMACKey_KeyNotify); ok {
		return x.KeyNotify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LearnMACKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LearnMACKey_KeyAuto)(nil),
		(*LearnMACKey_KeyNotify)(nil),
	}
}

// endpoint IP information used in auto learning mode
type LearnIPEntryAuto struct {
	Key                  *LearnIPKeyAuto  `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	MACInfo              *LearnMACKeyAuto `protobuf:"bytes,2,opt,name=MACInfo,proto3" json:"MACInfo,omitempty"`
	State                EpState          `protobuf:"varint,3,opt,name=State,proto3,enum=pds.EpState" json:"State,omitempty"`
	TTL                  uint32           `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LearnIPEntryAuto) Reset()         { *m = LearnIPEntryAuto{} }
func (m *LearnIPEntryAuto) String() string { return proto.CompactTextString(m) }
func (*LearnIPEntryAuto) ProtoMessage()    {}
func (*LearnIPEntryAuto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{6}
}
func (m *LearnIPEntryAuto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPEntryAuto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPEntryAuto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPEntryAuto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPEntryAuto.Merge(m, src)
}
func (m *LearnIPEntryAuto) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPEntryAuto) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPEntryAuto.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPEntryAuto proto.InternalMessageInfo

func (m *LearnIPEntryAuto) GetKey() *LearnIPKeyAuto {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LearnIPEntryAuto) GetMACInfo() *LearnMACKeyAuto {
	if m != nil {
		return m.MACInfo
	}
	return nil
}

func (m *LearnIPEntryAuto) GetState() EpState {
	if m != nil {
		return m.State
	}
	return EpState_EP_STATE_NONE
}

func (m *LearnIPEntryAuto) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// endpoint MAC information used in auto learning mode
type LearnMACEntryAuto struct {
	Key                  *LearnMACKeyAuto  `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	VnicId               []byte            `protobuf:"bytes,2,opt,name=VnicId,proto3" json:"VnicId,omitempty"`
	State                EpState           `protobuf:"varint,3,opt,name=State,proto3,enum=pds.EpState" json:"State,omitempty"`
	TTL                  uint32            `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	IPInfo               []*LearnIPKeyAuto `protobuf:"bytes,5,rep,name=IPInfo,proto3" json:"IPInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LearnMACEntryAuto) Reset()         { *m = LearnMACEntryAuto{} }
func (m *LearnMACEntryAuto) String() string { return proto.CompactTextString(m) }
func (*LearnMACEntryAuto) ProtoMessage()    {}
func (*LearnMACEntryAuto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{7}
}
func (m *LearnMACEntryAuto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACEntryAuto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACEntryAuto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACEntryAuto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACEntryAuto.Merge(m, src)
}
func (m *LearnMACEntryAuto) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACEntryAuto) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACEntryAuto.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACEntryAuto proto.InternalMessageInfo

func (m *LearnMACEntryAuto) GetKey() *LearnMACKeyAuto {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LearnMACEntryAuto) GetVnicId() []byte {
	if m != nil {
		return m.VnicId
	}
	return nil
}

func (m *LearnMACEntryAuto) GetState() EpState {
	if m != nil {
		return m.State
	}
	return EpState_EP_STATE_NONE
}

func (m *LearnMACEntryAuto) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *LearnMACEntryAuto) GetIPInfo() []*LearnIPKeyAuto {
	if m != nil {
		return m.IPInfo
	}
	return nil
}

// endpoint IP information used in notify learning mode
type LearnIPEntryNotify struct {
	// unique key to identify endpoint IP
	Key *LearnIPKeyNotify `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// MAC address associated with this IP
	MACAddr uint64 `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	// number of seconds this entry is valid upto
	TTL                  uint32   `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LearnIPEntryNotify) Reset()         { *m = LearnIPEntryNotify{} }
func (m *LearnIPEntryNotify) String() string { return proto.CompactTextString(m) }
func (*LearnIPEntryNotify) ProtoMessage()    {}
func (*LearnIPEntryNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{8}
}
func (m *LearnIPEntryNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPEntryNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPEntryNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPEntryNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPEntryNotify.Merge(m, src)
}
func (m *LearnIPEntryNotify) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPEntryNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPEntryNotify.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPEntryNotify proto.InternalMessageInfo

func (m *LearnIPEntryNotify) GetKey() *LearnIPKeyNotify {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LearnIPEntryNotify) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

func (m *LearnIPEntryNotify) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// endpoint MAC information used in notify learning mode
type LearnMACEntryNotify struct {
	// unique key to identify endpoint MAC
	Key *LearnMACKeyNotify `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// encapsulation used by this endpoint
	Encap *Encap `protobuf:"bytes,2,opt,name=Encap,proto3" json:"Encap,omitempty"`
	// number of seconds this entry is valid upto
	TTL uint32 `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	// list of IP addresses associated with this MAC
	IPInfo               []*LearnIPKeyNotify `protobuf:"bytes,4,rep,name=IPInfo,proto3" json:"IPInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LearnMACEntryNotify) Reset()         { *m = LearnMACEntryNotify{} }
func (m *LearnMACEntryNotify) String() string { return proto.CompactTextString(m) }
func (*LearnMACEntryNotify) ProtoMessage()    {}
func (*LearnMACEntryNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{9}
}
func (m *LearnMACEntryNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACEntryNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACEntryNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACEntryNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACEntryNotify.Merge(m, src)
}
func (m *LearnMACEntryNotify) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACEntryNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACEntryNotify.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACEntryNotify proto.InternalMessageInfo

func (m *LearnMACEntryNotify) GetKey() *LearnMACKeyNotify {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LearnMACEntryNotify) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *LearnMACEntryNotify) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *LearnMACEntryNotify) GetIPInfo() []*LearnIPKeyNotify {
	if m != nil {
		return m.IPInfo
	}
	return nil
}

// generic endpoint IP information used in all learning modes
type LearnIPEntry struct {
	// Types that are valid to be assigned to Ipentry:
	//	*LearnIPEntry_EntryAuto
	//	*LearnIPEntry_EntryNotify
	Ipentry              isLearnIPEntry_Ipentry `protobuf_oneof:"ipentry"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *LearnIPEntry) Reset()         { *m = LearnIPEntry{} }
func (m *LearnIPEntry) String() string { return proto.CompactTextString(m) }
func (*LearnIPEntry) ProtoMessage()    {}
func (*LearnIPEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{10}
}
func (m *LearnIPEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPEntry.Merge(m, src)
}
func (m *LearnIPEntry) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPEntry proto.InternalMessageInfo

type isLearnIPEntry_Ipentry interface {
	isLearnIPEntry_Ipentry()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnIPEntry_EntryAuto struct {
	EntryAuto *LearnIPEntryAuto `protobuf:"bytes,1,opt,name=EntryAuto,proto3,oneof"`
}
type LearnIPEntry_EntryNotify struct {
	EntryNotify *LearnIPEntryNotify `protobuf:"bytes,2,opt,name=EntryNotify,proto3,oneof"`
}

func (*LearnIPEntry_EntryAuto) isLearnIPEntry_Ipentry()   {}
func (*LearnIPEntry_EntryNotify) isLearnIPEntry_Ipentry() {}

func (m *LearnIPEntry) GetIpentry() isLearnIPEntry_Ipentry {
	if m != nil {
		return m.Ipentry
	}
	return nil
}

func (m *LearnIPEntry) GetEntryAuto() *LearnIPEntryAuto {
	if x, ok := m.GetIpentry().(*LearnIPEntry_EntryAuto); ok {
		return x.EntryAuto
	}
	return nil
}

func (m *LearnIPEntry) GetEntryNotify() *LearnIPEntryNotify {
	if x, ok := m.GetIpentry().(*LearnIPEntry_EntryNotify); ok {
		return x.EntryNotify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LearnIPEntry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LearnIPEntry_EntryAuto)(nil),
		(*LearnIPEntry_EntryNotify)(nil),
	}
}

// generic endpoint MAC information used in all learning modes
type LearnMACEntry struct {
	// Types that are valid to be assigned to Macentry:
	//	*LearnMACEntry_EntryAuto
	//	*LearnMACEntry_EntryNotify
	Macentry             isLearnMACEntry_Macentry `protobuf_oneof:"macentry"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LearnMACEntry) Reset()         { *m = LearnMACEntry{} }
func (m *LearnMACEntry) String() string { return proto.CompactTextString(m) }
func (*LearnMACEntry) ProtoMessage()    {}
func (*LearnMACEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{11}
}
func (m *LearnMACEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACEntry.Merge(m, src)
}
func (m *LearnMACEntry) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACEntry proto.InternalMessageInfo

type isLearnMACEntry_Macentry interface {
	isLearnMACEntry_Macentry()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnMACEntry_EntryAuto struct {
	EntryAuto *LearnMACEntryAuto `protobuf:"bytes,1,opt,name=EntryAuto,proto3,oneof"`
}
type LearnMACEntry_EntryNotify struct {
	EntryNotify *LearnMACEntryNotify `protobuf:"bytes,2,opt,name=EntryNotify,proto3,oneof"`
}

func (*LearnMACEntry_EntryAuto) isLearnMACEntry_Macentry()   {}
func (*LearnMACEntry_EntryNotify) isLearnMACEntry_Macentry() {}

func (m *LearnMACEntry) GetMacentry() isLearnMACEntry_Macentry {
	if m != nil {
		return m.Macentry
	}
	return nil
}

func (m *LearnMACEntry) GetEntryAuto() *LearnMACEntryAuto {
	if x, ok := m.GetMacentry().(*LearnMACEntry_EntryAuto); ok {
		return x.EntryAuto
	}
	return nil
}

func (m *LearnMACEntry) GetEntryNotify() *LearnMACEntryNotify {
	if x, ok := m.GetMacentry().(*LearnMACEntry_EntryNotify); ok {
		return x.EntryNotify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LearnMACEntry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LearnMACEntry_EntryAuto)(nil),
		(*LearnMACEntry_EntryNotify)(nil),
	}
}

type LearnPktTypeCounter struct {
	PktType              LearnPktType `protobuf:"varint,1,opt,name=PktType,proto3,enum=pds.LearnPktType" json:"PktType,omitempty"`
	Count                uint64       `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LearnPktTypeCounter) Reset()         { *m = LearnPktTypeCounter{} }
func (m *LearnPktTypeCounter) String() string { return proto.CompactTextString(m) }
func (*LearnPktTypeCounter) ProtoMessage()    {}
func (*LearnPktTypeCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{12}
}
func (m *LearnPktTypeCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnPktTypeCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnPktTypeCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnPktTypeCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnPktTypeCounter.Merge(m, src)
}
func (m *LearnPktTypeCounter) XXX_Size() int {
	return m.Size()
}
func (m *LearnPktTypeCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnPktTypeCounter.DiscardUnknown(m)
}

var xxx_messageInfo_LearnPktTypeCounter proto.InternalMessageInfo

func (m *LearnPktTypeCounter) GetPktType() LearnPktType {
	if m != nil {
		return m.PktType
	}
	return LearnPktType_LEARN_PKT_TYPE_NONE
}

func (m *LearnPktTypeCounter) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type LearnPktDropStats struct {
	Reason               LearnPktDropReason `protobuf:"varint,1,opt,name=Reason,proto3,enum=pds.LearnPktDropReason" json:"Reason,omitempty"`
	NumDrops             uint64             `protobuf:"varint,2,opt,name=NumDrops,proto3" json:"NumDrops,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LearnPktDropStats) Reset()         { *m = LearnPktDropStats{} }
func (m *LearnPktDropStats) String() string { return proto.CompactTextString(m) }
func (*LearnPktDropStats) ProtoMessage()    {}
func (*LearnPktDropStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{13}
}
func (m *LearnPktDropStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnPktDropStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnPktDropStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnPktDropStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnPktDropStats.Merge(m, src)
}
func (m *LearnPktDropStats) XXX_Size() int {
	return m.Size()
}
func (m *LearnPktDropStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnPktDropStats.DiscardUnknown(m)
}

var xxx_messageInfo_LearnPktDropStats proto.InternalMessageInfo

func (m *LearnPktDropStats) GetReason() LearnPktDropReason {
	if m != nil {
		return m.Reason
	}
	return LearnPktDropReason_LEARN_PKTDROP_REASON_NONE
}

func (m *LearnPktDropStats) GetNumDrops() uint64 {
	if m != nil {
		return m.NumDrops
	}
	return 0
}

type LearnEvents struct {
	EventType            LearnEventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=pds.LearnEventType" json:"EventType,omitempty"`
	Count                uint64         `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LearnEvents) Reset()         { *m = LearnEvents{} }
func (m *LearnEvents) String() string { return proto.CompactTextString(m) }
func (*LearnEvents) ProtoMessage()    {}
func (*LearnEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{14}
}
func (m *LearnEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnEvents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnEvents.Merge(m, src)
}
func (m *LearnEvents) XXX_Size() int {
	return m.Size()
}
func (m *LearnEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnEvents.DiscardUnknown(m)
}

var xxx_messageInfo_LearnEvents proto.InternalMessageInfo

func (m *LearnEvents) GetEventType() LearnEventType {
	if m != nil {
		return m.EventType
	}
	return LearnEventType_LEARN_EVENT_NONE
}

func (m *LearnEvents) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type LearnValidations struct {
	ValidationType       LearnValidationType `protobuf:"varint,1,opt,name=ValidationType,proto3,enum=pds.LearnValidationType" json:"ValidationType,omitempty"`
	Count                uint64              `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LearnValidations) Reset()         { *m = LearnValidations{} }
func (m *LearnValidations) String() string { return proto.CompactTextString(m) }
func (*LearnValidations) ProtoMessage()    {}
func (*LearnValidations) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{15}
}
func (m *LearnValidations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnValidations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnValidations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnValidations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnValidations.Merge(m, src)
}
func (m *LearnValidations) XXX_Size() int {
	return m.Size()
}
func (m *LearnValidations) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnValidations.DiscardUnknown(m)
}

var xxx_messageInfo_LearnValidations proto.InternalMessageInfo

func (m *LearnValidations) GetValidationType() LearnValidationType {
	if m != nil {
		return m.ValidationType
	}
	return LearnValidationType_LEARN_CHECK_NONE
}

func (m *LearnValidations) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type LearnApiOps struct {
	ApiOpType            LearnApiOpType `protobuf:"varint,1,opt,name=ApiOpType,proto3,enum=pds.LearnApiOpType" json:"ApiOpType,omitempty"`
	Count                uint64         `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LearnApiOps) Reset()         { *m = LearnApiOps{} }
func (m *LearnApiOps) String() string { return proto.CompactTextString(m) }
func (*LearnApiOps) ProtoMessage()    {}
func (*LearnApiOps) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{16}
}
func (m *LearnApiOps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnApiOps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnApiOps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnApiOps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnApiOps.Merge(m, src)
}
func (m *LearnApiOps) XXX_Size() int {
	return m.Size()
}
func (m *LearnApiOps) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnApiOps.DiscardUnknown(m)
}

var xxx_messageInfo_LearnApiOps proto.InternalMessageInfo

func (m *LearnApiOps) GetApiOpType() LearnApiOpType {
	if m != nil {
		return m.ApiOpType
	}
	return LearnApiOpType_LEARN_API_OP_NONE
}

func (m *LearnApiOps) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type LearnStats struct {
	PktsRcvd              uint64                 `protobuf:"varint,1,opt,name=PktsRcvd,proto3" json:"PktsRcvd,omitempty"`
	PktsSent              uint64                 `protobuf:"varint,2,opt,name=PktsSent,proto3" json:"PktsSent,omitempty"`
	PktSendErrors         uint64                 `protobuf:"varint,3,opt,name=PktSendErrors,proto3" json:"PktSendErrors,omitempty"`
	ArpProbesSent         uint64                 `protobuf:"varint,4,opt,name=ArpProbesSent,proto3" json:"ArpProbesSent,omitempty"`
	ArpProbeSendErrors    uint64                 `protobuf:"varint,5,opt,name=ArpProbeSendErrors,proto3" json:"ArpProbeSendErrors,omitempty"`
	GarpReplySent         uint64                 `protobuf:"varint,6,opt,name=GarpReplySent,proto3" json:"GarpReplySent,omitempty"`
	GarpReplySendErrors   uint64                 `protobuf:"varint,7,opt,name=GarpReplySendErrors,proto3" json:"GarpReplySendErrors,omitempty"`
	PktBufferAlloc        uint64                 `protobuf:"varint,8,opt,name=PktBufferAlloc,proto3" json:"PktBufferAlloc,omitempty"`
	PktBufferAllocErrors  uint64                 `protobuf:"varint,9,opt,name=PktBufferAllocErrors,proto3" json:"PktBufferAllocErrors,omitempty"`
	PktBufferAvailable    uint64                 `protobuf:"varint,10,opt,name=PktBufferAvailable,proto3" json:"PktBufferAvailable,omitempty"`
	DropStats             []*LearnPktDropStats   `protobuf:"bytes,11,rep,name=DropStats,proto3" json:"DropStats,omitempty"`
	IpAgeouts             uint64                 `protobuf:"varint,12,opt,name=IpAgeouts,proto3" json:"IpAgeouts,omitempty"`
	IpAgeoutErrors        uint64                 `protobuf:"varint,13,opt,name=IpAgeoutErrors,proto3" json:"IpAgeoutErrors,omitempty"`
	MacAgeouts            uint64                 `protobuf:"varint,14,opt,name=MacAgeouts,proto3" json:"MacAgeouts,omitempty"`
	MacAgeoutErrors       uint64                 `protobuf:"varint,15,opt,name=MacAgeoutErrors,proto3" json:"MacAgeoutErrors,omitempty"`
	MacLearnEvents        []*LearnEvents         `protobuf:"bytes,16,rep,name=MacLearnEvents,proto3" json:"MacLearnEvents,omitempty"`
	MacLearnErrors        []*LearnEvents         `protobuf:"bytes,17,rep,name=MacLearnErrors,proto3" json:"MacLearnErrors,omitempty"`
	IpLearnEvents         []*LearnEvents         `protobuf:"bytes,18,rep,name=IpLearnEvents,proto3" json:"IpLearnEvents,omitempty"`
	IpLearnErrors         []*LearnEvents         `protobuf:"bytes,19,rep,name=IpLearnErrors,proto3" json:"IpLearnErrors,omitempty"`
	ValidationErrors      []*LearnValidations    `protobuf:"bytes,20,rep,name=ValidationErrors,proto3" json:"ValidationErrors,omitempty"`
	VnicOps               []*LearnApiOps         `protobuf:"bytes,21,rep,name=VnicOps,proto3" json:"VnicOps,omitempty"`
	VnicOpErrors          []*LearnApiOps         `protobuf:"bytes,22,rep,name=VnicOpErrors,proto3" json:"VnicOpErrors,omitempty"`
	RemoteL2Mappings      []*LearnApiOps         `protobuf:"bytes,23,rep,name=RemoteL2Mappings,proto3" json:"RemoteL2Mappings,omitempty"`
	RemoteL2MappingErrors []*LearnApiOps         `protobuf:"bytes,24,rep,name=RemoteL2MappingErrors,proto3" json:"RemoteL2MappingErrors,omitempty"`
	LocalL3Mappings       []*LearnApiOps         `protobuf:"bytes,25,rep,name=LocalL3Mappings,proto3" json:"LocalL3Mappings,omitempty"`
	LocalL3MappingErrors  []*LearnApiOps         `protobuf:"bytes,26,rep,name=LocalL3MappingErrors,proto3" json:"LocalL3MappingErrors,omitempty"`
	RemoteL3Mappings      []*LearnApiOps         `protobuf:"bytes,27,rep,name=RemoteL3Mappings,proto3" json:"RemoteL3Mappings,omitempty"`
	RemoteL3MappingErrors []*LearnApiOps         `protobuf:"bytes,28,rep,name=RemoteL3MappingErrors,proto3" json:"RemoteL3MappingErrors,omitempty"`
	RcvdPktTypes          []*LearnPktTypeCounter `protobuf:"bytes,29,rep,name=RcvdPktTypes,proto3" json:"RcvdPktTypes,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
	XXX_unrecognized      []byte                 `json:"-"`
	XXX_sizecache         int32                  `json:"-"`
}

func (m *LearnStats) Reset()         { *m = LearnStats{} }
func (m *LearnStats) String() string { return proto.CompactTextString(m) }
func (*LearnStats) ProtoMessage()    {}
func (*LearnStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{17}
}
func (m *LearnStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnStats.Merge(m, src)
}
func (m *LearnStats) XXX_Size() int {
	return m.Size()
}
func (m *LearnStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnStats.DiscardUnknown(m)
}

var xxx_messageInfo_LearnStats proto.InternalMessageInfo

func (m *LearnStats) GetPktsRcvd() uint64 {
	if m != nil {
		return m.PktsRcvd
	}
	return 0
}

func (m *LearnStats) GetPktsSent() uint64 {
	if m != nil {
		return m.PktsSent
	}
	return 0
}

func (m *LearnStats) GetPktSendErrors() uint64 {
	if m != nil {
		return m.PktSendErrors
	}
	return 0
}

func (m *LearnStats) GetArpProbesSent() uint64 {
	if m != nil {
		return m.ArpProbesSent
	}
	return 0
}

func (m *LearnStats) GetArpProbeSendErrors() uint64 {
	if m != nil {
		return m.ArpProbeSendErrors
	}
	return 0
}

func (m *LearnStats) GetGarpReplySent() uint64 {
	if m != nil {
		return m.GarpReplySent
	}
	return 0
}

func (m *LearnStats) GetGarpReplySendErrors() uint64 {
	if m != nil {
		return m.GarpReplySendErrors
	}
	return 0
}

func (m *LearnStats) GetPktBufferAlloc() uint64 {
	if m != nil {
		return m.PktBufferAlloc
	}
	return 0
}

func (m *LearnStats) GetPktBufferAllocErrors() uint64 {
	if m != nil {
		return m.PktBufferAllocErrors
	}
	return 0
}

func (m *LearnStats) GetPktBufferAvailable() uint64 {
	if m != nil {
		return m.PktBufferAvailable
	}
	return 0
}

func (m *LearnStats) GetDropStats() []*LearnPktDropStats {
	if m != nil {
		return m.DropStats
	}
	return nil
}

func (m *LearnStats) GetIpAgeouts() uint64 {
	if m != nil {
		return m.IpAgeouts
	}
	return 0
}

func (m *LearnStats) GetIpAgeoutErrors() uint64 {
	if m != nil {
		return m.IpAgeoutErrors
	}
	return 0
}

func (m *LearnStats) GetMacAgeouts() uint64 {
	if m != nil {
		return m.MacAgeouts
	}
	return 0
}

func (m *LearnStats) GetMacAgeoutErrors() uint64 {
	if m != nil {
		return m.MacAgeoutErrors
	}
	return 0
}

func (m *LearnStats) GetMacLearnEvents() []*LearnEvents {
	if m != nil {
		return m.MacLearnEvents
	}
	return nil
}

func (m *LearnStats) GetMacLearnErrors() []*LearnEvents {
	if m != nil {
		return m.MacLearnErrors
	}
	return nil
}

func (m *LearnStats) GetIpLearnEvents() []*LearnEvents {
	if m != nil {
		return m.IpLearnEvents
	}
	return nil
}

func (m *LearnStats) GetIpLearnErrors() []*LearnEvents {
	if m != nil {
		return m.IpLearnErrors
	}
	return nil
}

func (m *LearnStats) GetValidationErrors() []*LearnValidations {
	if m != nil {
		return m.ValidationErrors
	}
	return nil
}

func (m *LearnStats) GetVnicOps() []*LearnApiOps {
	if m != nil {
		return m.VnicOps
	}
	return nil
}

func (m *LearnStats) GetVnicOpErrors() []*LearnApiOps {
	if m != nil {
		return m.VnicOpErrors
	}
	return nil
}

func (m *LearnStats) GetRemoteL2Mappings() []*LearnApiOps {
	if m != nil {
		return m.RemoteL2Mappings
	}
	return nil
}

func (m *LearnStats) GetRemoteL2MappingErrors() []*LearnApiOps {
	if m != nil {
		return m.RemoteL2MappingErrors
	}
	return nil
}

func (m *LearnStats) GetLocalL3Mappings() []*LearnApiOps {
	if m != nil {
		return m.LocalL3Mappings
	}
	return nil
}

func (m *LearnStats) GetLocalL3MappingErrors() []*LearnApiOps {
	if m != nil {
		return m.LocalL3MappingErrors
	}
	return nil
}

func (m *LearnStats) GetRemoteL3Mappings() []*LearnApiOps {
	if m != nil {
		return m.RemoteL3Mappings
	}
	return nil
}

func (m *LearnStats) GetRemoteL3MappingErrors() []*LearnApiOps {
	if m != nil {
		return m.RemoteL3MappingErrors
	}
	return nil
}

func (m *LearnStats) GetRcvdPktTypes() []*LearnPktTypeCounter {
	if m != nil {
		return m.RcvdPktTypes
	}
	return nil
}

type LearnMACRequest struct {
	Key                  []*LearnMACKey `protobuf:"bytes,1,rep,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LearnMACRequest) Reset()         { *m = LearnMACRequest{} }
func (m *LearnMACRequest) String() string { return proto.CompactTextString(m) }
func (*LearnMACRequest) ProtoMessage()    {}
func (*LearnMACRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{18}
}
func (m *LearnMACRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACRequest.Merge(m, src)
}
func (m *LearnMACRequest) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACRequest proto.InternalMessageInfo

func (m *LearnMACRequest) GetKey() []*LearnMACKey {
	if m != nil {
		return m.Key
	}
	return nil
}

type LearnIPRequest struct {
	Key                  []*LearnIPKey `protobuf:"bytes,1,rep,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LearnIPRequest) Reset()         { *m = LearnIPRequest{} }
func (m *LearnIPRequest) String() string { return proto.CompactTextString(m) }
func (*LearnIPRequest) ProtoMessage()    {}
func (*LearnIPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{19}
}
func (m *LearnIPRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPRequest.Merge(m, src)
}
func (m *LearnIPRequest) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPRequest proto.InternalMessageInfo

func (m *LearnIPRequest) GetKey() []*LearnIPKey {
	if m != nil {
		return m.Key
	}
	return nil
}

type LearnIPGetRequest struct {
	// Types that are valid to be assigned to Filter:
	//	*LearnIPGetRequest_Key
	//	*LearnIPGetRequest_SubnetId
	Filter               isLearnIPGetRequest_Filter `protobuf_oneof:"filter"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *LearnIPGetRequest) Reset()         { *m = LearnIPGetRequest{} }
func (m *LearnIPGetRequest) String() string { return proto.CompactTextString(m) }
func (*LearnIPGetRequest) ProtoMessage()    {}
func (*LearnIPGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{20}
}
func (m *LearnIPGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPGetRequest.Merge(m, src)
}
func (m *LearnIPGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPGetRequest proto.InternalMessageInfo

type isLearnIPGetRequest_Filter interface {
	isLearnIPGetRequest_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnIPGetRequest_Key struct {
	Key *LearnIPKey `protobuf:"bytes,1,opt,name=Key,proto3,oneof"`
}
type LearnIPGetRequest_SubnetId struct {
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3,oneof"`
}

func (*LearnIPGetRequest_Key) isLearnIPGetRequest_Filter()      {}
func (*LearnIPGetRequest_SubnetId) isLearnIPGetRequest_Filter() {}

func (m *LearnIPGetRequest) GetFilter() isLearnIPGetRequest_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *LearnIPGetRequest) GetKey() *LearnIPKey {
	if x, ok := m.GetFilter().(*LearnIPGetRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *LearnIPGetRequest) GetSubnetId() []byte {
	if x, ok := m.GetFilter().(*LearnIPGetRequest_SubnetId); ok {
		return x.SubnetId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LearnIPGetRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LearnIPGetRequest_Key)(nil),
		(*LearnIPGetRequest_SubnetId)(nil),
	}
}

type LearnMACGetResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LearnMACEntry `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LearnMACGetResponse) Reset()         { *m = LearnMACGetResponse{} }
func (m *LearnMACGetResponse) String() string { return proto.CompactTextString(m) }
func (*LearnMACGetResponse) ProtoMessage()    {}
func (*LearnMACGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{21}
}
func (m *LearnMACGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnMACGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnMACGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnMACGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnMACGetResponse.Merge(m, src)
}
func (m *LearnMACGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LearnMACGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnMACGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LearnMACGetResponse proto.InternalMessageInfo

func (m *LearnMACGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LearnMACGetResponse) GetResponse() []*LearnMACEntry {
	if m != nil {
		return m.Response
	}
	return nil
}

type LearnIPGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LearnIPEntry `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LearnIPGetResponse) Reset()         { *m = LearnIPGetResponse{} }
func (m *LearnIPGetResponse) String() string { return proto.CompactTextString(m) }
func (*LearnIPGetResponse) ProtoMessage()    {}
func (*LearnIPGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{22}
}
func (m *LearnIPGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnIPGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnIPGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnIPGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnIPGetResponse.Merge(m, src)
}
func (m *LearnIPGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LearnIPGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnIPGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LearnIPGetResponse proto.InternalMessageInfo

func (m *LearnIPGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LearnIPGetResponse) GetResponse() []*LearnIPEntry {
	if m != nil {
		return m.Response
	}
	return nil
}

type LearnStatsGetResponse struct {
	ApiStatus            ApiStatus   `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Stats                *LearnStats `protobuf:"bytes,2,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LearnStatsGetResponse) Reset()         { *m = LearnStatsGetResponse{} }
func (m *LearnStatsGetResponse) String() string { return proto.CompactTextString(m) }
func (*LearnStatsGetResponse) ProtoMessage()    {}
func (*LearnStatsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{23}
}
func (m *LearnStatsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnStatsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnStatsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnStatsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnStatsGetResponse.Merge(m, src)
}
func (m *LearnStatsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LearnStatsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnStatsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LearnStatsGetResponse proto.InternalMessageInfo

func (m *LearnStatsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LearnStatsGetResponse) GetStats() *LearnStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type LearnClearResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LearnClearResponse) Reset()         { *m = LearnClearResponse{} }
func (m *LearnClearResponse) String() string { return proto.CompactTextString(m) }
func (*LearnClearResponse) ProtoMessage()    {}
func (*LearnClearResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c158be602b81b4f, []int{24}
}
func (m *LearnClearResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnClearResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnClearResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnClearResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnClearResponse.Merge(m, src)
}
func (m *LearnClearResponse) XXX_Size() int {
	return m.Size()
}
func (m *LearnClearResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnClearResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LearnClearResponse proto.InternalMessageInfo

func (m *LearnClearResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterEnum("pds.EpState", EpState_name, EpState_value)
	proto.RegisterEnum("pds.LearnPktType", LearnPktType_name, LearnPktType_value)
	proto.RegisterEnum("pds.LearnPktDropReason", LearnPktDropReason_name, LearnPktDropReason_value)
	proto.RegisterEnum("pds.LearnEventType", LearnEventType_name, LearnEventType_value)
	proto.RegisterEnum("pds.LearnValidationType", LearnValidationType_name, LearnValidationType_value)
	proto.RegisterEnum("pds.LearnApiOpType", LearnApiOpType_name, LearnApiOpType_value)
	proto.RegisterType((*LearnIPKeyAuto)(nil), "pds.LearnIPKeyAuto")
	proto.RegisterType((*LearnMACKeyAuto)(nil), "pds.LearnMACKeyAuto")
	proto.RegisterType((*LearnIPKeyNotify)(nil), "pds.LearnIPKeyNotify")
	proto.RegisterType((*LearnMACKeyNotify)(nil), "pds.LearnMACKeyNotify")
	proto.RegisterType((*LearnIPKey)(nil), "pds.LearnIPKey")
	proto.RegisterType((*LearnMACKey)(nil), "pds.LearnMACKey")
	proto.RegisterType((*LearnIPEntryAuto)(nil), "pds.LearnIPEntryAuto")
	proto.RegisterType((*LearnMACEntryAuto)(nil), "pds.LearnMACEntryAuto")
	proto.RegisterType((*LearnIPEntryNotify)(nil), "pds.LearnIPEntryNotify")
	proto.RegisterType((*LearnMACEntryNotify)(nil), "pds.LearnMACEntryNotify")
	proto.RegisterType((*LearnIPEntry)(nil), "pds.LearnIPEntry")
	proto.RegisterType((*LearnMACEntry)(nil), "pds.LearnMACEntry")
	proto.RegisterType((*LearnPktTypeCounter)(nil), "pds.LearnPktTypeCounter")
	proto.RegisterType((*LearnPktDropStats)(nil), "pds.LearnPktDropStats")
	proto.RegisterType((*LearnEvents)(nil), "pds.LearnEvents")
	proto.RegisterType((*LearnValidations)(nil), "pds.LearnValidations")
	proto.RegisterType((*LearnApiOps)(nil), "pds.LearnApiOps")
	proto.RegisterType((*LearnStats)(nil), "pds.LearnStats")
	proto.RegisterType((*LearnMACRequest)(nil), "pds.LearnMACRequest")
	proto.RegisterType((*LearnIPRequest)(nil), "pds.LearnIPRequest")
	proto.RegisterType((*LearnIPGetRequest)(nil), "pds.LearnIPGetRequest")
	proto.RegisterType((*LearnMACGetResponse)(nil), "pds.LearnMACGetResponse")
	proto.RegisterType((*LearnIPGetResponse)(nil), "pds.LearnIPGetResponse")
	proto.RegisterType((*LearnStatsGetResponse)(nil), "pds.LearnStatsGetResponse")
	proto.RegisterType((*LearnClearResponse)(nil), "pds.LearnClearResponse")
}

func init() { proto.RegisterFile("learn.proto", fileDescriptor_6c158be602b81b4f) }

var fileDescriptor_6c158be602b81b4f = []byte{
	// 1935 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x72, 0xe3, 0xc6,
	0x11, 0x16, 0xc4, 0x3f, 0xa9, 0x49, 0x49, 0xd0, 0xac, 0x7e, 0xb0, 0x5c, 0xad, 0x22, 0xc3, 0xf6,
	0x5a, 0x25, 0x97, 0xb5, 0x8e, 0x76, 0xed, 0x4a, 0xc5, 0xae, 0xd8, 0x10, 0x38, 0x2b, 0xa1, 0x04,
	0x92, 0xc8, 0x10, 0x52, 0xec, 0x13, 0xc3, 0xa5, 0xa0, 0x2d, 0x46, 0x14, 0x81, 0x10, 0xe0, 0x56,
	0xe9, 0x90, 0x43, 0x1e, 0x20, 0x87, 0x3c, 0x41, 0x0e, 0x49, 0xe5, 0x9c, 0x53, 0xae, 0xb9, 0xe6,
	0x98, 0x17, 0x48, 0x55, 0x6a, 0xab, 0xf2, 0x16, 0x39, 0xa4, 0x30, 0x33, 0x00, 0x06, 0x7f, 0x51,
	0x6c, 0x5f, 0x58, 0x9c, 0xee, 0xaf, 0xbb, 0xbf, 0xee, 0x99, 0x41, 0xcf, 0x0c, 0x34, 0xa7, 0xce,
	0x68, 0x3e, 0x3b, 0xf6, 0xe6, 0x6e, 0xe0, 0xa2, 0x8a, 0x77, 0xed, 0xb7, 0xe1, 0x8d, 0xfb, 0xc6,
	0x65, 0x82, 0xf6, 0xc6, 0x9d, 0x13, 0x8c, 0x9e, 0x87, 0x3f, 0x5c, 0xd0, 0x0c, 0xee, 0x3d, 0xc7,
	0x67, 0x03, 0xd5, 0x82, 0x75, 0x33, 0xb4, 0x36, 0xac, 0x0b, 0xe7, 0x5e, 0x5b, 0x04, 0x2e, 0xda,
	0x82, 0xda, 0x95, 0xa5, 0x1b, 0xd7, 0x8a, 0x74, 0x20, 0x1d, 0xb6, 0x08, 0x1b, 0xa0, 0x43, 0xa8,
	0x1b, 0x96, 0x76, 0x7d, 0x3d, 0x57, 0x96, 0x0f, 0xa4, 0xc3, 0xe6, 0x89, 0x7c, 0xcc, 0xbc, 0x30,
	0xa1, 0xe3, 0xfb, 0x84, 0xeb, 0xd5, 0x33, 0xd8, 0xa0, 0x1e, 0xbb, 0x9a, 0x1e, 0xb9, 0x6c, 0xc3,
	0xca, 0x60, 0xf1, 0x7a, 0xe6, 0x04, 0xb1, 0xd7, 0x78, 0x8c, 0x14, 0x68, 0x74, 0x35, 0x3d, 0xf6,
	0x5c, 0x25, 0xd1, 0x50, 0xb5, 0x41, 0x4e, 0xa8, 0xf5, 0xdc, 0x60, 0x72, 0x73, 0x8f, 0x76, 0xa0,
	0x7e, 0xee, 0xfa, 0x81, 0x71, 0xc3, 0xfd, 0xf0, 0xd1, 0x77, 0xa0, 0x87, 0x61, 0x53, 0xa0, 0xf7,
	0x80, 0xdb, 0x72, 0x72, 0xbf, 0x01, 0x48, 0xc8, 0xa1, 0xe7, 0xd0, 0xe0, 0xb9, 0x52, 0x07, 0xcd,
	0x93, 0x47, 0xc7, 0xde, 0xb5, 0x7f, 0x9c, 0xae, 0xec, 0xf9, 0x12, 0x89, 0x50, 0xe8, 0x33, 0x58,
	0x8d, 0xa3, 0x73, 0xca, 0xdb, 0x19, 0x13, 0xa6, 0x3c, 0x5f, 0x22, 0x09, 0xf2, 0xb4, 0x01, 0xb5,
	0x89, 0x77, 0xeb, 0xdc, 0xab, 0xbf, 0x95, 0xa0, 0x29, 0xa4, 0x81, 0x3e, 0xcd, 0x12, 0xd8, 0x4a,
	0xbc, 0x25, 0x13, 0x21, 0x32, 0xf8, 0x3c, 0xcf, 0x60, 0x27, 0x6b, 0x53, 0x44, 0x61, 0x05, 0xea,
	0x77, 0xa3, 0x71, 0xc8, 0xe1, 0x0f, 0x52, 0x3c, 0x41, 0x78, 0x16, 0xcc, 0x99, 0xdb, 0x0f, 0xa1,
	0x72, 0xe1, 0xdc, 0xff, 0x8f, 0x2a, 0x90, 0x50, 0x8f, 0x8e, 0x69, 0x61, 0x8d, 0xd9, 0x8d, 0xcb,
	0x63, 0x17, 0xf2, 0x25, 0x11, 0x08, 0xa9, 0x50, 0x1b, 0x04, 0xa3, 0xc0, 0x51, 0x2a, 0x07, 0xd2,
	0xe1, 0xfa, 0x49, 0x8b, 0xa2, 0xb1, 0x47, 0x65, 0x84, 0xa9, 0x90, 0x0c, 0x15, 0xdb, 0x36, 0x95,
	0xea, 0x81, 0x74, 0xb8, 0x46, 0xc2, 0xbf, 0xea, 0x5f, 0xa5, 0x64, 0xb2, 0x13, 0x8a, 0xcf, 0x44,
	0x8a, 0xc5, 0x71, 0x29, 0xc7, 0x1d, 0xa8, 0x5f, 0xcd, 0x26, 0x63, 0xe3, 0x9a, 0x52, 0x6c, 0x11,
	0x3e, 0xfa, 0x7e, 0x5c, 0xd0, 0xc7, 0xe1, 0x0a, 0xa5, 0x09, 0xd7, 0x0e, 0x2a, 0x65, 0xb5, 0xe1,
	0x10, 0x75, 0x02, 0x48, 0xac, 0x2c, 0x5f, 0xa5, 0x1f, 0x89, 0xc4, 0x8b, 0x97, 0x0b, 0x63, 0x5e,
	0xba, 0x6c, 0x23, 0x5e, 0x95, 0xa4, 0x46, 0x7f, 0x92, 0xe0, 0x51, 0xaa, 0x46, 0x3c, 0xd8, 0xa1,
	0x18, 0xac, 0x64, 0x65, 0xb0, 0x68, 0x2a, 0xd4, 0xf0, 0x6c, 0x3c, 0xf2, 0xf8, 0x4c, 0xb6, 0xf8,
	0xd6, 0xa3, 0x32, 0xc2, 0x54, 0xf9, 0xb8, 0xe8, 0x93, 0xb8, 0x1e, 0x55, 0x5a, 0x8f, 0x92, 0x7c,
	0xa2, 0x8a, 0xfc, 0x4e, 0x82, 0x96, 0x58, 0x92, 0x70, 0x07, 0xc5, 0x53, 0x5a, 0x54, 0x92, 0x58,
	0x19, 0x2e, 0xdf, 0x64, 0xf2, 0xbf, 0x80, 0xa6, 0x90, 0x25, 0xa7, 0xbc, 0x9b, 0x33, 0x8c, 0x57,
	0xbe, 0x88, 0x3e, 0x5d, 0x85, 0xc6, 0xc4, 0x73, 0x42, 0x81, 0xfa, 0x7b, 0x09, 0xd6, 0x52, 0x65,
	0x0b, 0x37, 0x54, 0x96, 0x50, 0xba, 0x6c, 0x25, 0x8c, 0xbe, 0x2c, 0x62, 0xa4, 0xe4, 0x2d, 0x8b,
	0x29, 0x01, 0xac, 0xdc, 0x8d, 0xc6, 0x8c, 0xd3, 0x37, 0x7c, 0x26, 0xad, 0xdb, 0xc0, 0xbe, 0xf7,
	0x1c, 0xdd, 0x5d, 0xcc, 0x02, 0x67, 0x8e, 0x3e, 0x86, 0x06, 0x97, 0x50, 0x5a, 0xeb, 0x27, 0x9b,
	0x89, 0x73, 0xae, 0x20, 0x11, 0x22, 0xfc, 0xfa, 0x53, 0x3b, 0xbe, 0x70, 0xd8, 0x40, 0xfd, 0x25,
	0xdf, 0x47, 0xd6, 0x6d, 0xd0, 0x99, 0xbb, 0x74, 0xa9, 0xfb, 0xe8, 0x39, 0xd4, 0x89, 0x33, 0xf2,
	0xdd, 0x19, 0x77, 0xbb, 0x9b, 0x72, 0x1b, 0xe2, 0x98, 0x9a, 0x70, 0x58, 0xd8, 0x06, 0x7a, 0x8b,
	0xbb, 0x50, 0xe1, 0x73, 0xf7, 0xf1, 0x58, 0xbd, 0xe2, 0xdf, 0x33, 0xfc, 0xd6, 0x99, 0x05, 0x3e,
	0xfa, 0x31, 0xac, 0xd2, 0x7f, 0x02, 0x6b, 0x61, 0xc3, 0xc4, 0x2a, 0x92, 0xa0, 0x4a, 0x98, 0xff,
	0x8a, 0x7f, 0xa3, 0xae, 0x46, 0xd3, 0xc9, 0xf5, 0x28, 0x98, 0xb8, 0x33, 0x1f, 0x7d, 0x0d, 0xeb,
	0xc9, 0x50, 0x88, 0x20, 0x14, 0x3d, 0xad, 0x27, 0x19, 0x7c, 0x49, 0xac, 0x28, 0x07, 0xcd, 0x9b,
	0xf4, 0x3d, 0x9a, 0x03, 0xfd, 0x57, 0x9c, 0x43, 0xac, 0x22, 0x09, 0xaa, 0xc4, 0xef, 0xdf, 0x9a,
	0xbc, 0xd9, 0xb0, 0xba, 0xb7, 0x61, 0xc5, 0xba, 0x0d, 0x7c, 0x32, 0x7e, 0xcb, 0xba, 0x69, 0x95,
	0xc4, 0xe3, 0x48, 0x37, 0x70, 0x62, 0x1f, 0xf1, 0x18, 0x7d, 0x00, 0x6b, 0xd6, 0x6d, 0x30, 0x70,
	0x66, 0xd7, 0x78, 0x3e, 0x77, 0xe7, 0x3e, 0xdd, 0x8d, 0x55, 0x92, 0x16, 0x86, 0x28, 0x6d, 0xee,
	0x59, 0x73, 0xf7, 0xb5, 0xc3, 0xdc, 0x54, 0x19, 0x2a, 0x25, 0x44, 0xc7, 0x80, 0x22, 0x81, 0xe0,
	0xb0, 0x46, 0xa1, 0x05, 0x9a, 0xd0, 0xeb, 0xd9, 0x68, 0xee, 0x11, 0xc7, 0x9b, 0xde, 0x53, 0xaf,
	0x75, 0xe6, 0x35, 0x25, 0x44, 0x9f, 0xc2, 0x23, 0x51, 0x10, 0xb9, 0x6d, 0x50, 0x6c, 0x91, 0x0a,
	0x3d, 0x83, 0x75, 0xeb, 0x36, 0x38, 0x5d, 0xdc, 0xdc, 0x38, 0x73, 0x6d, 0x3a, 0x75, 0xc7, 0xca,
	0x0a, 0x05, 0x67, 0xa4, 0xe8, 0x04, 0xb6, 0xd2, 0x12, 0xee, 0x7a, 0x95, 0xa2, 0x0b, 0x75, 0x61,
	0x8e, 0x89, 0xfc, 0xed, 0x68, 0x32, 0x1d, 0xbd, 0x9e, 0x3a, 0x0a, 0xb0, 0x1c, 0xf3, 0x1a, 0xf4,
	0x12, 0x56, 0xe3, 0xcd, 0xa1, 0x34, 0xe9, 0x47, 0x6d, 0x27, 0xb7, 0x25, 0xa8, 0x96, 0x24, 0x40,
	0xb4, 0x07, 0xab, 0x86, 0xa7, 0xbd, 0x71, 0xdc, 0x45, 0xe0, 0x2b, 0x2d, 0xea, 0x3c, 0x11, 0x84,
	0xf9, 0x45, 0x03, 0xce, 0x78, 0x8d, 0xe5, 0x97, 0x96, 0xa2, 0x7d, 0x80, 0xee, 0x68, 0x1c, 0xb9,
	0x59, 0xa7, 0x18, 0x41, 0x82, 0x0e, 0x61, 0x23, 0x1e, 0x71, 0x47, 0x1b, 0x14, 0x94, 0x15, 0xa3,
	0x9f, 0xc0, 0x7a, 0x77, 0x34, 0x16, 0xf6, 0xa2, 0x22, 0xd3, 0x54, 0xe4, 0xcc, 0xf6, 0xf3, 0x49,
	0x06, 0x97, 0xb2, 0x64, 0x21, 0x36, 0x1f, 0xb4, 0x64, 0x31, 0x3f, 0x87, 0x35, 0xc3, 0x13, 0x43,
	0xa2, 0x12, 0xc3, 0x34, 0x4c, 0xb4, 0x63, 0x01, 0x1f, 0x3d, 0x64, 0xc7, 0xe2, 0x69, 0x20, 0x27,
	0x1b, 0x9a, 0x9b, 0x6e, 0x65, 0xbb, 0x90, 0xf0, 0xc5, 0x20, 0x39, 0x38, 0x3a, 0x82, 0x46, 0x78,
	0x1c, 0xe8, 0x7b, 0xbe, 0xb2, 0x9d, 0x0d, 0xca, 0xf6, 0x3f, 0x89, 0x00, 0xe8, 0x25, 0xb4, 0xd8,
	0x5f, 0x1e, 0x6a, 0xa7, 0xc4, 0x20, 0x85, 0x42, 0x5f, 0x82, 0x4c, 0x9c, 0x3b, 0x37, 0x70, 0xcc,
	0x93, 0xee, 0xc8, 0xf3, 0x26, 0xb3, 0x37, 0xbe, 0xb2, 0x5b, 0x62, 0x99, 0x43, 0xa2, 0x57, 0xb0,
	0x9d, 0x91, 0xf1, 0xe0, 0x4a, 0x89, 0x8b, 0x62, 0x38, 0xfa, 0x29, 0x6c, 0x98, 0xee, 0x78, 0x34,
	0x35, 0x5f, 0xc4, 0x24, 0x1e, 0x97, 0x78, 0xc8, 0x02, 0x51, 0x07, 0xb6, 0xd2, 0x22, 0x4e, 0xa1,
	0x5d, 0xe2, 0xa0, 0x10, 0x2d, 0xd4, 0x21, 0xa1, 0xf0, 0xe4, 0x81, 0x3a, 0xbc, 0x28, 0xa8, 0x43,
	0x86, 0xc4, 0xde, 0x03, 0x75, 0xc8, 0xb1, 0x68, 0x85, 0x1f, 0x58, 0xde, 0x26, 0x7d, 0xe5, 0x29,
	0x35, 0x57, 0x72, 0x9d, 0x94, 0x37, 0x5d, 0x92, 0x42, 0xab, 0x9f, 0x25, 0x77, 0x22, 0xe2, 0xfc,
	0x7a, 0xe1, 0xf8, 0x01, 0x52, 0xa3, 0xf3, 0x55, 0x86, 0x06, 0x3b, 0x5f, 0xd1, 0x93, 0x95, 0xfa,
	0x22, 0xbe, 0x9c, 0x45, 0x56, 0xef, 0x89, 0x56, 0x1b, 0x99, 0x23, 0x13, 0x33, 0x8a, 0x7a, 0xb5,
	0x61, 0x9d, 0x39, 0x41, 0x64, 0xf7, 0xbe, 0x78, 0x9a, 0xcb, 0xda, 0x9d, 0x2f, 0xb1, 0x83, 0xdc,
	0x9e, 0x70, 0x4d, 0xa3, 0x47, 0xde, 0xf3, 0xa5, 0xe4, 0xa2, 0x16, 0x1e, 0xfc, 0x6f, 0x26, 0xd3,
	0xc0, 0x99, 0xab, 0x8b, 0xe4, 0xc4, 0x48, 0x43, 0xf8, 0x9e, 0x3b, 0xf3, 0x1d, 0x74, 0x4c, 0xfb,
	0x5d, 0xf8, 0x55, 0x5b, 0xf8, 0xbc, 0xdf, 0x45, 0xd7, 0xb0, 0x58, 0x4e, 0x12, 0x08, 0x3a, 0x86,
	0x95, 0xc8, 0x56, 0x59, 0xa6, 0x09, 0xa1, 0xfc, 0xa9, 0x87, 0xc4, 0x18, 0xd5, 0x8f, 0x0f, 0xc5,
	0x3f, 0x24, 0xea, 0x27, 0xb9, 0xa8, 0x9b, 0xb9, 0xd3, 0x9f, 0x10, 0x74, 0x06, 0xdb, 0x49, 0xeb,
	0xfd, 0x21, 0x71, 0x3f, 0x64, 0xb7, 0x06, 0x9f, 0x1f, 0xf0, 0x84, 0x39, 0x60, 0x2d, 0x81, 0x69,
	0xd5, 0x0e, 0x4f, 0x52, 0x0f, 0xef, 0xf4, 0xdf, 0x37, 0xd8, 0xd1, 0x1f, 0x25, 0x68, 0xf0, 0x1b,
	0x09, 0xda, 0x84, 0x35, 0x6c, 0x0d, 0x07, 0xb6, 0x66, 0xe3, 0x61, 0xaf, 0xdf, 0xc3, 0xf2, 0x12,
	0xda, 0x86, 0xcd, 0x58, 0x64, 0x62, 0x8d, 0xf4, 0x8c, 0xde, 0x99, 0x2c, 0xa1, 0x2d, 0x90, 0x63,
	0xb1, 0x4e, 0xb0, 0x66, 0xe3, 0x8e, 0xbc, 0x9c, 0x92, 0x5a, 0xa4, 0x7f, 0x1a, 0x62, 0x2b, 0x29,
	0x17, 0x97, 0x56, 0x47, 0xb3, 0x43, 0x71, 0x35, 0x25, 0xee, 0x60, 0x13, 0x53, 0x71, 0x2d, 0xe5,
	0x83, 0x8a, 0x71, 0x47, 0xae, 0x1f, 0xfd, 0xbb, 0xc2, 0xcf, 0xf4, 0xd1, 0xe1, 0x73, 0x17, 0x1e,
	0x51, 0x3a, 0x43, 0xeb, 0xc2, 0x1e, 0xda, 0xdf, 0x5a, 0x31, 0xe1, 0x03, 0xd8, 0xcb, 0x28, 0xce,
	0x34, 0x62, 0x0d, 0xb5, 0x5e, 0xaf, 0x7f, 0xd9, 0xd3, 0xb1, 0x2c, 0xa1, 0x3d, 0x50, 0x32, 0x88,
	0x10, 0x10, 0xf2, 0xc5, 0xf2, 0x32, 0xda, 0x87, 0x76, 0x81, 0x96, 0xe0, 0x9f, 0x5f, 0xe2, 0x81,
	0x2d, 0x57, 0xd0, 0x53, 0x78, 0x5c, 0xe4, 0x9f, 0x60, 0xcb, 0xfc, 0x56, 0xae, 0x96, 0x38, 0x67,
	0xda, 0x1a, 0xfa, 0x11, 0x3c, 0xc9, 0x68, 0x89, 0xe8, 0xbd, 0x5e, 0xe0, 0x9d, 0x24, 0xf6, 0x8d,
	0x82, 0xe4, 0x3a, 0xe7, 0xba, 0x35, 0xec, 0x18, 0x03, 0xbd, 0x7f, 0x85, 0x89, 0xbc, 0x52, 0x10,
	0x81, 0x22, 0xa2, 0x08, 0xab, 0xe8, 0x09, 0xec, 0x16, 0x01, 0x34, 0xfd, 0x42, 0x86, 0x72, 0x6b,
	0x13, 0x6b, 0x03, 0x2c, 0x37, 0xcb, 0x00, 0x1d, 0xac, 0x9b, 0x46, 0x0f, 0xcb, 0x2d, 0xf4, 0x01,
	0x1c, 0x14, 0x01, 0x2e, 0x7b, 0xba, 0xa9, 0x0d, 0x06, 0xc6, 0x2b, 0x03, 0x77, 0xe4, 0xb5, 0x82,
	0xd9, 0x33, 0xac, 0xab, 0x97, 0xf2, 0xfa, 0xd1, 0x5f, 0x96, 0xf9, 0xa2, 0x4e, 0x5d, 0x0b, 0x52,
	0x65, 0xe9, 0x90, 0x7e, 0xc8, 0x48, 0x1b, 0xf4, 0x7b, 0xd1, 0x9c, 0xab, 0xb0, 0x5f, 0xa8, 0xb6,
	0x34, 0x32, 0xc0, 0x43, 0x4c, 0x88, 0x2c, 0xa1, 0x8f, 0xe0, 0xfd, 0x42, 0x0c, 0xc1, 0x83, 0xa1,
	0x66, 0x9a, 0x7d, 0x7d, 0xf8, 0x4a, 0x33, 0x4c, 0x79, 0x19, 0x3d, 0x03, 0xb5, 0x10, 0x18, 0xad,
	0x7e, 0x86, 0xab, 0xa0, 0xf7, 0xe0, 0x69, 0x21, 0xae, 0x7b, 0x7a, 0xf9, 0x8a, 0xc6, 0xac, 0xa6,
	0xa6, 0x4b, 0x84, 0xd8, 0xdf, 0x30, 0x27, 0xb5, 0x52, 0xe6, 0xc9, 0xa4, 0xd7, 0x4b, 0x93, 0x0f,
	0x57, 0x86, 0xdc, 0x38, 0xfa, 0xa7, 0xc4, 0x3f, 0xfd, 0xe2, 0xfd, 0x46, 0x66, 0x16, 0xf8, 0x0a,
	0xf7, 0xec, 0xa8, 0x4a, 0x8f, 0x61, 0x3b, 0x25, 0xc5, 0xbf, 0x18, 0x9a, 0x7d, 0x5d, 0x33, 0x65,
	0x09, 0xb5, 0x61, 0x27, 0xab, 0x22, 0xb8, 0xdb, 0xb7, 0xc3, 0x0d, 0xa1, 0xc0, 0x96, 0xa8, 0x33,
	0x4f, 0xcc, 0x61, 0xb7, 0x7f, 0x85, 0xe5, 0x4a, 0x56, 0x43, 0x22, 0x4d, 0x35, 0x6f, 0x43, 0x98,
	0xa6, 0x96, 0xb7, 0xe1, 0x9a, 0x3a, 0xda, 0x01, 0x24, 0x6a, 0xd8, 0xde, 0x97, 0x1b, 0x47, 0x7f,
	0x8e, 0x5e, 0x1d, 0x72, 0x17, 0x2b, 0x9e, 0xa4, 0x7e, 0x8e, 0xf5, 0x8b, 0x5c, 0x92, 0x4c, 0xda,
	0xd5, 0xf4, 0xa1, 0x69, 0x74, 0x0d, 0x5b, 0x96, 0x92, 0xd0, 0x4c, 0x65, 0x58, 0x5c, 0xb3, 0x9c,
	0x6c, 0xda, 0x58, 0x63, 0xf4, 0x86, 0x83, 0xcb, 0xd3, 0x1e, 0x0e, 0x77, 0x7c, 0xbc, 0x20, 0x98,
	0xb6, 0xa3, 0xd9, 0x1a, 0x5d, 0xb7, 0x1d, 0x6c, 0x63, 0xdd, 0xc6, 0x1d, 0x9e, 0xf4, 0xd1, 0x9c,
	0xcf, 0x43, 0x72, 0x47, 0xdb, 0x86, 0x4d, 0x66, 0xa9, 0x59, 0xc6, 0xb0, 0x6f, 0x45, 0x1c, 0xe3,
	0xd5, 0xcf, 0xc5, 0xec, 0x03, 0x2a, 0x4b, 0x39, 0x05, 0xaf, 0xc1, 0x72, 0x4e, 0x41, 0x3f, 0xa3,
	0x58, 0xae, 0x9c, 0xfc, 0x67, 0x19, 0x56, 0x58, 0x67, 0x78, 0x3b, 0x46, 0x5f, 0x25, 0x0f, 0x7d,
	0x67, 0x4e, 0x80, 0xd2, 0xef, 0x55, 0xbc, 0xbd, 0xb7, 0xd3, 0xcf, 0x05, 0x42, 0x9b, 0x52, 0x97,
	0xd0, 0x57, 0xf1, 0x4b, 0x65, 0x68, 0xbf, 0x23, 0x36, 0xbb, 0xe4, 0x80, 0xd0, 0xde, 0xcd, 0xc9,
	0x63, 0x07, 0x5f, 0xf0, 0x97, 0x8e, 0xa8, 0x05, 0xa2, 0xf8, 0x85, 0xe7, 0xce, 0x0b, 0xee, 0xdb,
	0xed, 0x4c, 0x27, 0x4b, 0x1b, 0x7f, 0x9d, 0x3c, 0x93, 0xd0, 0x96, 0x56, 0x92, 0x80, 0x10, 0x3e,
	0xd5, 0xf9, 0xd4, 0x25, 0xf4, 0xb3, 0xf8, 0xe1, 0x87, 0x39, 0x48, 0x3d, 0x9c, 0xfd, 0x1f, 0xf6,
	0xcf, 0xf9, 0xd9, 0x8b, 0x92, 0x63, 0x2e, 0xd2, 0x09, 0xa4, 0x46, 0xea, 0xd2, 0x69, 0xeb, 0xef,
	0xef, 0xf6, 0xa5, 0x7f, 0xbc, 0xdb, 0x97, 0xfe, 0xf5, 0x6e, 0x5f, 0x7a, 0x5d, 0xa7, 0xef, 0xe4,
	0x2f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x09, 0x0f, 0xa7, 0x3b, 0x65, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LearnSvcClient is the client API for LearnSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LearnSvcClient interface {
	LearnMACGet(ctx context.Context, in *LearnMACRequest, opts ...grpc.CallOption) (*LearnMACGetResponse, error)
	LearnIPGet(ctx context.Context, in *LearnIPGetRequest, opts ...grpc.CallOption) (*LearnIPGetResponse, error)
	LearnStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LearnStatsGetResponse, error)
	LearnMACClear(ctx context.Context, in *LearnMACRequest, opts ...grpc.CallOption) (*LearnClearResponse, error)
	LearnIPClear(ctx context.Context, in *LearnIPRequest, opts ...grpc.CallOption) (*LearnClearResponse, error)
	LearnStatsClear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type learnSvcClient struct {
	cc *grpc.ClientConn
}

func NewLearnSvcClient(cc *grpc.ClientConn) LearnSvcClient {
	return &learnSvcClient{cc}
}

func (c *learnSvcClient) LearnMACGet(ctx context.Context, in *LearnMACRequest, opts ...grpc.CallOption) (*LearnMACGetResponse, error) {
	out := new(LearnMACGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnMACGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *learnSvcClient) LearnIPGet(ctx context.Context, in *LearnIPGetRequest, opts ...grpc.CallOption) (*LearnIPGetResponse, error) {
	out := new(LearnIPGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnIPGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *learnSvcClient) LearnStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LearnStatsGetResponse, error) {
	out := new(LearnStatsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *learnSvcClient) LearnMACClear(ctx context.Context, in *LearnMACRequest, opts ...grpc.CallOption) (*LearnClearResponse, error) {
	out := new(LearnClearResponse)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnMACClear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *learnSvcClient) LearnIPClear(ctx context.Context, in *LearnIPRequest, opts ...grpc.CallOption) (*LearnClearResponse, error) {
	out := new(LearnClearResponse)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnIPClear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *learnSvcClient) LearnStatsClear(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.LearnSvc/LearnStatsClear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LearnSvcServer is the server API for LearnSvc service.
type LearnSvcServer interface {
	LearnMACGet(context.Context, *LearnMACRequest) (*LearnMACGetResponse, error)
	LearnIPGet(context.Context, *LearnIPGetRequest) (*LearnIPGetResponse, error)
	LearnStatsGet(context.Context, *Empty) (*LearnStatsGetResponse, error)
	LearnMACClear(context.Context, *LearnMACRequest) (*LearnClearResponse, error)
	LearnIPClear(context.Context, *LearnIPRequest) (*LearnClearResponse, error)
	LearnStatsClear(context.Context, *Empty) (*Empty, error)
}

// UnimplementedLearnSvcServer can be embedded to have forward compatible implementations.
type UnimplementedLearnSvcServer struct {
}

func (*UnimplementedLearnSvcServer) LearnMACGet(ctx context.Context, req *LearnMACRequest) (*LearnMACGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnMACGet not implemented")
}
func (*UnimplementedLearnSvcServer) LearnIPGet(ctx context.Context, req *LearnIPGetRequest) (*LearnIPGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnIPGet not implemented")
}
func (*UnimplementedLearnSvcServer) LearnStatsGet(ctx context.Context, req *Empty) (*LearnStatsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnStatsGet not implemented")
}
func (*UnimplementedLearnSvcServer) LearnMACClear(ctx context.Context, req *LearnMACRequest) (*LearnClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnMACClear not implemented")
}
func (*UnimplementedLearnSvcServer) LearnIPClear(ctx context.Context, req *LearnIPRequest) (*LearnClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnIPClear not implemented")
}
func (*UnimplementedLearnSvcServer) LearnStatsClear(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnStatsClear not implemented")
}

func RegisterLearnSvcServer(s *grpc.Server, srv LearnSvcServer) {
	s.RegisterService(&_LearnSvc_serviceDesc, srv)
}

func _LearnSvc_LearnMACGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnMACRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnMACGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnMACGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnMACGet(ctx, req.(*LearnMACRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LearnSvc_LearnIPGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnIPGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnIPGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnIPGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnIPGet(ctx, req.(*LearnIPGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LearnSvc_LearnStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnStatsGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LearnSvc_LearnMACClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnMACRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnMACClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnMACClear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnMACClear(ctx, req.(*LearnMACRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LearnSvc_LearnIPClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnIPClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnIPClear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnIPClear(ctx, req.(*LearnIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LearnSvc_LearnStatsClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LearnSvcServer).LearnStatsClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LearnSvc/LearnStatsClear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LearnSvcServer).LearnStatsClear(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _LearnSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.LearnSvc",
	HandlerType: (*LearnSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LearnMACGet",
			Handler:    _LearnSvc_LearnMACGet_Handler,
		},
		{
			MethodName: "LearnIPGet",
			Handler:    _LearnSvc_LearnIPGet_Handler,
		},
		{
			MethodName: "LearnStatsGet",
			Handler:    _LearnSvc_LearnStatsGet_Handler,
		},
		{
			MethodName: "LearnMACClear",
			Handler:    _LearnSvc_LearnMACClear_Handler,
		},
		{
			MethodName: "LearnIPClear",
			Handler:    _LearnSvc_LearnIPClear_Handler,
		},
		{
			MethodName: "LearnStatsClear",
			Handler:    _LearnSvc_LearnStatsClear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "learn.proto",
}

func (m *LearnIPKeyAuto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPKeyAuto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPKeyAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACKeyAuto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACKeyAuto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACKeyAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddr != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPKeyNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPKeyNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPKeyNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostIf) > 0 {
		i -= len(m.HostIf)
		copy(dAtA[i:], m.HostIf)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.HostIf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACKeyNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACKeyNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACKeyNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddr != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x10
	}
	if len(m.HostIf) > 0 {
		i -= len(m.HostIf)
		copy(dAtA[i:], m.HostIf)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.HostIf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ipkey != nil {
		{
			size := m.Ipkey.Size()
			i -= size
			if _, err := m.Ipkey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPKey_KeyAuto) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPKey_KeyAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyAuto != nil {
		{
			size, err := m.KeyAuto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LearnIPKey_KeyNotify) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPKey_KeyNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyNotify != nil {
		{
			size, err := m.KeyNotify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LearnMACKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mackey != nil {
		{
			size := m.Mackey.Size()
			i -= size
			if _, err := m.Mackey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACKey_KeyAuto) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnMACKey_KeyAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyAuto != nil {
		{
			size, err := m.KeyAuto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LearnMACKey_KeyNotify) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnMACKey_KeyNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyNotify != nil {
		{
			size, err := m.KeyNotify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LearnIPEntryAuto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPEntryAuto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPEntryAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TTL != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.MACInfo != nil {
		{
			size, err := m.MACInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACEntryAuto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACEntryAuto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACEntryAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPInfo) > 0 {
		for iNdEx := len(m.IPInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IPInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TTL != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VnicId) > 0 {
		i -= len(m.VnicId)
		copy(dAtA[i:], m.VnicId)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.VnicId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPEntryNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPEntryNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPEntryNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TTL != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if m.MACAddr != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x10
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACEntryNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACEntryNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACEntryNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPInfo) > 0 {
		for iNdEx := len(m.IPInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IPInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TTL != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ipentry != nil {
		{
			size := m.Ipentry.Size()
			i -= size
			if _, err := m.Ipentry.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPEntry_EntryAuto) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPEntry_EntryAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntryAuto != nil {
		{
			size, err := m.EntryAuto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LearnIPEntry_EntryNotify) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPEntry_EntryNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntryNotify != nil {
		{
			size, err := m.EntryNotify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LearnMACEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Macentry != nil {
		{
			size := m.Macentry.Size()
			i -= size
			if _, err := m.Macentry.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACEntry_EntryAuto) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnMACEntry_EntryAuto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntryAuto != nil {
		{
			size, err := m.EntryAuto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LearnMACEntry_EntryNotify) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnMACEntry_EntryNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntryNotify != nil {
		{
			size, err := m.EntryNotify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LearnPktTypeCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnPktTypeCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnPktTypeCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.PktType != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnPktDropStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnPktDropStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnPktDropStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumDrops != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.NumDrops))
		i--
		dAtA[i] = 0x10
	}
	if m.Reason != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.EventType != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnValidations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnValidations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnValidations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidationType != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ValidationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnApiOps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnApiOps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnApiOps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.ApiOpType != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ApiOpType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RcvdPktTypes) > 0 {
		for iNdEx := len(m.RcvdPktTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RcvdPktTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RemoteL3MappingErrors) > 0 {
		for iNdEx := len(m.RemoteL3MappingErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteL3MappingErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RemoteL3Mappings) > 0 {
		for iNdEx := len(m.RemoteL3Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteL3Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.LocalL3MappingErrors) > 0 {
		for iNdEx := len(m.LocalL3MappingErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalL3MappingErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.LocalL3Mappings) > 0 {
		for iNdEx := len(m.LocalL3Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalL3Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RemoteL2MappingErrors) > 0 {
		for iNdEx := len(m.RemoteL2MappingErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteL2MappingErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RemoteL2Mappings) > 0 {
		for iNdEx := len(m.RemoteL2Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteL2Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.VnicOpErrors) > 0 {
		for iNdEx := len(m.VnicOpErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VnicOpErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.VnicOps) > 0 {
		for iNdEx := len(m.VnicOps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VnicOps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.ValidationErrors) > 0 {
		for iNdEx := len(m.ValidationErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidationErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.IpLearnErrors) > 0 {
		for iNdEx := len(m.IpLearnErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpLearnErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.IpLearnEvents) > 0 {
		for iNdEx := len(m.IpLearnEvents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpLearnEvents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MacLearnErrors) > 0 {
		for iNdEx := len(m.MacLearnErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MacLearnErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MacLearnEvents) > 0 {
		for iNdEx := len(m.MacLearnEvents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MacLearnEvents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.MacAgeoutErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.MacAgeoutErrors))
		i--
		dAtA[i] = 0x78
	}
	if m.MacAgeouts != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.MacAgeouts))
		i--
		dAtA[i] = 0x70
	}
	if m.IpAgeoutErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.IpAgeoutErrors))
		i--
		dAtA[i] = 0x68
	}
	if m.IpAgeouts != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.IpAgeouts))
		i--
		dAtA[i] = 0x60
	}
	if len(m.DropStats) > 0 {
		for iNdEx := len(m.DropStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DropStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.PktBufferAvailable != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktBufferAvailable))
		i--
		dAtA[i] = 0x50
	}
	if m.PktBufferAllocErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktBufferAllocErrors))
		i--
		dAtA[i] = 0x48
	}
	if m.PktBufferAlloc != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktBufferAlloc))
		i--
		dAtA[i] = 0x40
	}
	if m.GarpReplySendErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.GarpReplySendErrors))
		i--
		dAtA[i] = 0x38
	}
	if m.GarpReplySent != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.GarpReplySent))
		i--
		dAtA[i] = 0x30
	}
	if m.ArpProbeSendErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ArpProbeSendErrors))
		i--
		dAtA[i] = 0x28
	}
	if m.ArpProbesSent != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ArpProbesSent))
		i--
		dAtA[i] = 0x20
	}
	if m.PktSendErrors != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktSendErrors))
		i--
		dAtA[i] = 0x18
	}
	if m.PktsSent != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktsSent))
		i--
		dAtA[i] = 0x10
	}
	if m.PktsRcvd != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.PktsRcvd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnMACRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Key[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		for iNdEx := len(m.Key) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Key[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size := m.Filter.Size()
			i -= size
			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPGetRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPGetRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LearnIPGetRequest_SubnetId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LearnIPGetRequest_SubnetId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetId != nil {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintLearn(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LearnMACGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMACGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnMACGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnIPGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnIPGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnIPGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLearn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnStatsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnStatsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnStatsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLearn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnClearResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnClearResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnClearResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLearn(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLearn(dAtA []byte, offset int, v uint64) int {
	offset -= sovLearn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LearnIPKeyAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACKeyAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovLearn(uint64(m.MACAddr))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPKeyNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostIf)
	if l > 0 {
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACKeyNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostIf)
	if l > 0 {
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovLearn(uint64(m.MACAddr))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipkey != nil {
		n += m.Ipkey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPKey_KeyAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyAuto != nil {
		l = m.KeyAuto.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnIPKey_KeyNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyNotify != nil {
		l = m.KeyNotify.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnMACKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mackey != nil {
		n += m.Mackey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACKey_KeyAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyAuto != nil {
		l = m.KeyAuto.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnMACKey_KeyNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyNotify != nil {
		l = m.KeyNotify.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnIPEntryAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.MACInfo != nil {
		l = m.MACInfo.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovLearn(uint64(m.State))
	}
	if m.TTL != 0 {
		n += 1 + sovLearn(uint64(m.TTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACEntryAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	l = len(m.VnicId)
	if l > 0 {
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovLearn(uint64(m.State))
	}
	if m.TTL != 0 {
		n += 1 + sovLearn(uint64(m.TTL))
	}
	if len(m.IPInfo) > 0 {
		for _, e := range m.IPInfo {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPEntryNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.MACAddr != 0 {
		n += 1 + sovLearn(uint64(m.MACAddr))
	}
	if m.TTL != 0 {
		n += 1 + sovLearn(uint64(m.TTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACEntryNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovLearn(uint64(m.TTL))
	}
	if len(m.IPInfo) > 0 {
		for _, e := range m.IPInfo {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipentry != nil {
		n += m.Ipentry.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPEntry_EntryAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryAuto != nil {
		l = m.EntryAuto.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnIPEntry_EntryNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryNotify != nil {
		l = m.EntryNotify.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnMACEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Macentry != nil {
		n += m.Macentry.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACEntry_EntryAuto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryAuto != nil {
		l = m.EntryAuto.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnMACEntry_EntryNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryNotify != nil {
		l = m.EntryNotify.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnPktTypeCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PktType != 0 {
		n += 1 + sovLearn(uint64(m.PktType))
	}
	if m.Count != 0 {
		n += 1 + sovLearn(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnPktDropStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovLearn(uint64(m.Reason))
	}
	if m.NumDrops != 0 {
		n += 1 + sovLearn(uint64(m.NumDrops))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovLearn(uint64(m.EventType))
	}
	if m.Count != 0 {
		n += 1 + sovLearn(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnValidations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidationType != 0 {
		n += 1 + sovLearn(uint64(m.ValidationType))
	}
	if m.Count != 0 {
		n += 1 + sovLearn(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnApiOps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiOpType != 0 {
		n += 1 + sovLearn(uint64(m.ApiOpType))
	}
	if m.Count != 0 {
		n += 1 + sovLearn(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PktsRcvd != 0 {
		n += 1 + sovLearn(uint64(m.PktsRcvd))
	}
	if m.PktsSent != 0 {
		n += 1 + sovLearn(uint64(m.PktsSent))
	}
	if m.PktSendErrors != 0 {
		n += 1 + sovLearn(uint64(m.PktSendErrors))
	}
	if m.ArpProbesSent != 0 {
		n += 1 + sovLearn(uint64(m.ArpProbesSent))
	}
	if m.ArpProbeSendErrors != 0 {
		n += 1 + sovLearn(uint64(m.ArpProbeSendErrors))
	}
	if m.GarpReplySent != 0 {
		n += 1 + sovLearn(uint64(m.GarpReplySent))
	}
	if m.GarpReplySendErrors != 0 {
		n += 1 + sovLearn(uint64(m.GarpReplySendErrors))
	}
	if m.PktBufferAlloc != 0 {
		n += 1 + sovLearn(uint64(m.PktBufferAlloc))
	}
	if m.PktBufferAllocErrors != 0 {
		n += 1 + sovLearn(uint64(m.PktBufferAllocErrors))
	}
	if m.PktBufferAvailable != 0 {
		n += 1 + sovLearn(uint64(m.PktBufferAvailable))
	}
	if len(m.DropStats) > 0 {
		for _, e := range m.DropStats {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.IpAgeouts != 0 {
		n += 1 + sovLearn(uint64(m.IpAgeouts))
	}
	if m.IpAgeoutErrors != 0 {
		n += 1 + sovLearn(uint64(m.IpAgeoutErrors))
	}
	if m.MacAgeouts != 0 {
		n += 1 + sovLearn(uint64(m.MacAgeouts))
	}
	if m.MacAgeoutErrors != 0 {
		n += 1 + sovLearn(uint64(m.MacAgeoutErrors))
	}
	if len(m.MacLearnEvents) > 0 {
		for _, e := range m.MacLearnEvents {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.MacLearnErrors) > 0 {
		for _, e := range m.MacLearnErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.IpLearnEvents) > 0 {
		for _, e := range m.IpLearnEvents {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.IpLearnErrors) > 0 {
		for _, e := range m.IpLearnErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.ValidationErrors) > 0 {
		for _, e := range m.ValidationErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.VnicOps) > 0 {
		for _, e := range m.VnicOps {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.VnicOpErrors) > 0 {
		for _, e := range m.VnicOpErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.RemoteL2Mappings) > 0 {
		for _, e := range m.RemoteL2Mappings {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.RemoteL2MappingErrors) > 0 {
		for _, e := range m.RemoteL2MappingErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.LocalL3Mappings) > 0 {
		for _, e := range m.LocalL3Mappings {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.LocalL3MappingErrors) > 0 {
		for _, e := range m.LocalL3MappingErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.RemoteL3Mappings) > 0 {
		for _, e := range m.RemoteL3Mappings {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.RemoteL3MappingErrors) > 0 {
		for _, e := range m.RemoteL3MappingErrors {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if len(m.RcvdPktTypes) > 0 {
		for _, e := range m.RcvdPktTypes {
			l = e.Size()
			n += 2 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnMACRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		for _, e := range m.Key {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		for _, e := range m.Key {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPGetRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnIPGetRequest_SubnetId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetId != nil {
		l = len(m.SubnetId)
		n += 1 + l + sovLearn(uint64(l))
	}
	return n
}
func (m *LearnMACGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLearn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnIPGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLearn(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLearn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnStatsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLearn(uint64(m.ApiStatus))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovLearn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnClearResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLearn(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLearn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLearn(x uint64) (n int) {
	return sovLearn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LearnIPKeyAuto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPKeyAuto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPKeyAuto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACKeyAuto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACKeyAuto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACKeyAuto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPKeyNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPKeyNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPKeyNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIf = append(m.HostIf[:0], dAtA[iNdEx:postIndex]...)
			if m.HostIf == nil {
				m.HostIf = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACKeyNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACKeyNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACKeyNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIf = append(m.HostIf[:0], dAtA[iNdEx:postIndex]...)
			if m.HostIf == nil {
				m.HostIf = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAuto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnIPKeyAuto{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipkey = &LearnIPKey_KeyAuto{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyNotify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnIPKeyNotify{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipkey = &LearnIPKey_KeyNotify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAuto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnMACKeyAuto{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mackey = &LearnMACKey_KeyAuto{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyNotify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnMACKeyNotify{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mackey = &LearnMACKey_KeyNotify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPEntryAuto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPEntryAuto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPEntryAuto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LearnIPKeyAuto{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MACInfo == nil {
				m.MACInfo = &LearnMACKeyAuto{}
			}
			if err := m.MACInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= EpState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACEntryAuto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACEntryAuto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACEntryAuto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LearnMACKeyAuto{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnicId = append(m.VnicId[:0], dAtA[iNdEx:postIndex]...)
			if m.VnicId == nil {
				m.VnicId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= EpState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPInfo = append(m.IPInfo, &LearnIPKeyAuto{})
			if err := m.IPInfo[len(m.IPInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPEntryNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPEntryNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPEntryNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LearnIPKeyNotify{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACEntryNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACEntryNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACEntryNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LearnMACKeyNotify{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPInfo = append(m.IPInfo, &LearnIPKeyNotify{})
			if err := m.IPInfo[len(m.IPInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryAuto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnIPEntryAuto{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipentry = &LearnIPEntry_EntryAuto{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryNotify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnIPEntryNotify{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipentry = &LearnIPEntry_EntryNotify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryAuto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnMACEntryAuto{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Macentry = &LearnMACEntry_EntryAuto{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryNotify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnMACEntryNotify{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Macentry = &LearnMACEntry_EntryNotify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnPktTypeCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnPktTypeCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnPktTypeCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktType", wireType)
			}
			m.PktType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktType |= LearnPktType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnPktDropStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnPktDropStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnPktDropStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= LearnPktDropReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDrops", wireType)
			}
			m.NumDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= LearnEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnValidations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnValidations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnValidations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationType", wireType)
			}
			m.ValidationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidationType |= LearnValidationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnApiOps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnApiOps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnApiOps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiOpType", wireType)
			}
			m.ApiOpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiOpType |= LearnApiOpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsRcvd", wireType)
			}
			m.PktsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsRcvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsSent", wireType)
			}
			m.PktsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktSendErrors", wireType)
			}
			m.PktSendErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktSendErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpProbesSent", wireType)
			}
			m.ArpProbesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArpProbesSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpProbeSendErrors", wireType)
			}
			m.ArpProbeSendErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArpProbeSendErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GarpReplySent", wireType)
			}
			m.GarpReplySent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GarpReplySent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GarpReplySendErrors", wireType)
			}
			m.GarpReplySendErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GarpReplySendErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktBufferAlloc", wireType)
			}
			m.PktBufferAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktBufferAlloc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktBufferAllocErrors", wireType)
			}
			m.PktBufferAllocErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktBufferAllocErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktBufferAvailable", wireType)
			}
			m.PktBufferAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktBufferAvailable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropStats = append(m.DropStats, &LearnPktDropStats{})
			if err := m.DropStats[len(m.DropStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAgeouts", wireType)
			}
			m.IpAgeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAgeouts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAgeoutErrors", wireType)
			}
			m.IpAgeoutErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAgeoutErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAgeouts", wireType)
			}
			m.MacAgeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAgeouts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAgeoutErrors", wireType)
			}
			m.MacAgeoutErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAgeoutErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLearnEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacLearnEvents = append(m.MacLearnEvents, &LearnEvents{})
			if err := m.MacLearnEvents[len(m.MacLearnEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLearnErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacLearnErrors = append(m.MacLearnErrors, &LearnEvents{})
			if err := m.MacLearnErrors[len(m.MacLearnErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLearnEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpLearnEvents = append(m.IpLearnEvents, &LearnEvents{})
			if err := m.IpLearnEvents[len(m.IpLearnEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLearnErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpLearnErrors = append(m.IpLearnErrors, &LearnEvents{})
			if err := m.IpLearnErrors[len(m.IpLearnErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidationErrors = append(m.ValidationErrors, &LearnValidations{})
			if err := m.ValidationErrors[len(m.ValidationErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicOps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnicOps = append(m.VnicOps, &LearnApiOps{})
			if err := m.VnicOps[len(m.VnicOps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicOpErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnicOpErrors = append(m.VnicOpErrors, &LearnApiOps{})
			if err := m.VnicOpErrors[len(m.VnicOpErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteL2Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteL2Mappings = append(m.RemoteL2Mappings, &LearnApiOps{})
			if err := m.RemoteL2Mappings[len(m.RemoteL2Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteL2MappingErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteL2MappingErrors = append(m.RemoteL2MappingErrors, &LearnApiOps{})
			if err := m.RemoteL2MappingErrors[len(m.RemoteL2MappingErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalL3Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalL3Mappings = append(m.LocalL3Mappings, &LearnApiOps{})
			if err := m.LocalL3Mappings[len(m.LocalL3Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalL3MappingErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalL3MappingErrors = append(m.LocalL3MappingErrors, &LearnApiOps{})
			if err := m.LocalL3MappingErrors[len(m.LocalL3MappingErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteL3Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteL3Mappings = append(m.RemoteL3Mappings, &LearnApiOps{})
			if err := m.RemoteL3Mappings[len(m.RemoteL3Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteL3MappingErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteL3MappingErrors = append(m.RemoteL3MappingErrors, &LearnApiOps{})
			if err := m.RemoteL3MappingErrors[len(m.RemoteL3MappingErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvdPktTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RcvdPktTypes = append(m.RcvdPktTypes, &LearnPktTypeCounter{})
			if err := m.RcvdPktTypes[len(m.RcvdPktTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, &LearnMACKey{})
			if err := m.Key[len(m.Key)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, &LearnIPKey{})
			if err := m.Key[len(m.Key)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearnIPKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &LearnIPGetRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Filter = &LearnIPGetRequest_SubnetId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMACGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMACGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMACGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LearnMACEntry{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnIPGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnIPGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnIPGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LearnIPEntry{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnStatsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnStatsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnStatsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLearn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &LearnStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnClearResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnClearResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnClearResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLearn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLearn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLearn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLearn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLearn
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLearn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLearn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLearn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLearn
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLearn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLearn   = fmt.Errorf("proto: integer overflow")
)
