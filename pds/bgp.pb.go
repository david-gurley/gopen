// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bgp.proto

package pds

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BGP address family identifier
type BGPAfi int32

const (
	BGPAfi_BGP_AFI_NONE  BGPAfi = 0
	BGPAfi_BGP_AFI_IPV4  BGPAfi = 1
	BGPAfi_BGP_AFI_IPV6  BGPAfi = 2
	BGPAfi_BGP_AFI_L2VPN BGPAfi = 25
)

var BGPAfi_name = map[int32]string{
	0:  "BGP_AFI_NONE",
	1:  "BGP_AFI_IPV4",
	2:  "BGP_AFI_IPV6",
	25: "BGP_AFI_L2VPN",
}

var BGPAfi_value = map[string]int32{
	"BGP_AFI_NONE":  0,
	"BGP_AFI_IPV4":  1,
	"BGP_AFI_IPV6":  2,
	"BGP_AFI_L2VPN": 25,
}

func (x BGPAfi) String() string {
	return proto.EnumName(BGPAfi_name, int32(x))
}

func (BGPAfi) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{0}
}

// BGP sub-address family identitfier
type BGPSafi int32

const (
	BGPSafi_BGP_SAFI_NONE    BGPSafi = 0
	BGPSafi_BGP_SAFI_UNICAST BGPSafi = 1
	BGPSafi_BGP_SAFI_EVPN    BGPSafi = 70
)

var BGPSafi_name = map[int32]string{
	0:  "BGP_SAFI_NONE",
	1:  "BGP_SAFI_UNICAST",
	70: "BGP_SAFI_EVPN",
}

var BGPSafi_value = map[string]int32{
	"BGP_SAFI_NONE":    0,
	"BGP_SAFI_UNICAST": 1,
	"BGP_SAFI_EVPN":    70,
}

func (x BGPSafi) String() string {
	return proto.EnumName(BGPSafi_name, int32(x))
}

func (BGPSafi) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{1}
}

// BGP peer RR client
type BGPPeerRRClient int32

const (
	BGPPeerRRClient_BGP_PEER_RR_NONE          BGPPeerRRClient = 0
	BGPPeerRRClient_BGP_PEER_RR_CLIENT        BGPPeerRRClient = 1
	BGPPeerRRClient_BGP_PEER_RR_MESHED_CLIENT BGPPeerRRClient = 2
)

var BGPPeerRRClient_name = map[int32]string{
	0: "BGP_PEER_RR_NONE",
	1: "BGP_PEER_RR_CLIENT",
	2: "BGP_PEER_RR_MESHED_CLIENT",
}

var BGPPeerRRClient_value = map[string]int32{
	"BGP_PEER_RR_NONE":          0,
	"BGP_PEER_RR_CLIENT":        1,
	"BGP_PEER_RR_MESHED_CLIENT": 2,
}

func (x BGPPeerRRClient) String() string {
	return proto.EnumName(BGPPeerRRClient_name, int32(x))
}

func (BGPPeerRRClient) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{2}
}

// BGP peer last_state
type BGPPeerState int32

const (
	BGPPeerState_BGP_PEER_STATE_NONE        BGPPeerState = 0
	BGPPeerState_BGP_PEER_STATE_IDLE        BGPPeerState = 1
	BGPPeerState_BGP_PEER_STATE_CONNECT     BGPPeerState = 2
	BGPPeerState_BGP_PEER_STATE_ACTIVE      BGPPeerState = 3
	BGPPeerState_BGP_PEER_STATE_OPENSENT    BGPPeerState = 4
	BGPPeerState_BGP_PEER_STATE_OPENCONFIRM BGPPeerState = 5
	BGPPeerState_BGP_PEER_STATE_ESTABLISHED BGPPeerState = 6
)

var BGPPeerState_name = map[int32]string{
	0: "BGP_PEER_STATE_NONE",
	1: "BGP_PEER_STATE_IDLE",
	2: "BGP_PEER_STATE_CONNECT",
	3: "BGP_PEER_STATE_ACTIVE",
	4: "BGP_PEER_STATE_OPENSENT",
	5: "BGP_PEER_STATE_OPENCONFIRM",
	6: "BGP_PEER_STATE_ESTABLISHED",
}

var BGPPeerState_value = map[string]int32{
	"BGP_PEER_STATE_NONE":        0,
	"BGP_PEER_STATE_IDLE":        1,
	"BGP_PEER_STATE_CONNECT":     2,
	"BGP_PEER_STATE_ACTIVE":      3,
	"BGP_PEER_STATE_OPENSENT":    4,
	"BGP_PEER_STATE_OPENCONFIRM": 5,
	"BGP_PEER_STATE_ESTABLISHED": 6,
}

func (x BGPPeerState) String() string {
	return proto.EnumName(BGPPeerState_name, int32(x))
}

func (BGPPeerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{3}
}

type BGPASSize int32

const (
	BGPASSize_BGP_AS_SIZE_NONE       BGPASSize = 0
	BGPASSize_BGP_AS_SIZE_TWO_OCTET  BGPASSize = 1
	BGPASSize_BGP_AS_SIZE_FOUR_OCTET BGPASSize = 2
)

var BGPASSize_name = map[int32]string{
	0: "BGP_AS_SIZE_NONE",
	1: "BGP_AS_SIZE_TWO_OCTET",
	2: "BGP_AS_SIZE_FOUR_OCTET",
}

var BGPASSize_value = map[string]int32{
	"BGP_AS_SIZE_NONE":       0,
	"BGP_AS_SIZE_TWO_OCTET":  1,
	"BGP_AS_SIZE_FOUR_OCTET": 2,
}

func (x BGPASSize) String() string {
	return proto.EnumName(BGPASSize_name, int32(x))
}

func (BGPASSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{4}
}

type BGPAddrType int32

const (
	BGPAddrType_BGP_ADDR_TYPE_OTHER     BGPAddrType = 0
	BGPAddrType_BGP_ADDR_TYPE_IPV4      BGPAddrType = 1
	BGPAddrType_BGP_ADDR_TYPE_IPV6      BGPAddrType = 2
	BGPAddrType_BGP_ADDR_TYPE_NSAP      BGPAddrType = 3
	BGPAddrType_BGP_ADDR_TYPE_HDLC      BGPAddrType = 4
	BGPAddrType_BGP_ADDR_TYPE_BBN1822   BGPAddrType = 5
	BGPAddrType_BGP_ADDR_TYPE_IEEE802   BGPAddrType = 6
	BGPAddrType_BGP_ADDR_TYPE_E163      BGPAddrType = 7
	BGPAddrType_BGP_ADDR_TYPE_E164      BGPAddrType = 8
	BGPAddrType_BGP_ADDR_TYPE_F69       BGPAddrType = 9
	BGPAddrType_BGP_ADDR_TYPE_X121      BGPAddrType = 10
	BGPAddrType_BGP_ADDR_TYPE_IPX       BGPAddrType = 11
	BGPAddrType_BGP_ADDR_TYPE_APPLETALK BGPAddrType = 12
	BGPAddrType_BGP_ADDR_TYPE_DECNETIV  BGPAddrType = 13
	BGPAddrType_BGP_ADDR_TYPE_BANYANVIN BGPAddrType = 14
	BGPAddrType_BGP_ADDR_TYPE_E164_NSAP BGPAddrType = 15
	BGPAddrType_BGP_ADDR_TYPE_IPV4_TNA  BGPAddrType = 16
	BGPAddrType_BGP_ADDR_TYPE_IPV6_TNA  BGPAddrType = 17
	BGPAddrType_BGP_ADDR_TYPE_NSAP_TNA  BGPAddrType = 18
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV4  BGPAddrType = 19
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV6  BGPAddrType = 20
	BGPAddrType_BGP_ADDR_TYPE_L2VPN     BGPAddrType = 25
)

var BGPAddrType_name = map[int32]string{
	0:  "BGP_ADDR_TYPE_OTHER",
	1:  "BGP_ADDR_TYPE_IPV4",
	2:  "BGP_ADDR_TYPE_IPV6",
	3:  "BGP_ADDR_TYPE_NSAP",
	4:  "BGP_ADDR_TYPE_HDLC",
	5:  "BGP_ADDR_TYPE_BBN1822",
	6:  "BGP_ADDR_TYPE_IEEE802",
	7:  "BGP_ADDR_TYPE_E163",
	8:  "BGP_ADDR_TYPE_E164",
	9:  "BGP_ADDR_TYPE_F69",
	10: "BGP_ADDR_TYPE_X121",
	11: "BGP_ADDR_TYPE_IPX",
	12: "BGP_ADDR_TYPE_APPLETALK",
	13: "BGP_ADDR_TYPE_DECNETIV",
	14: "BGP_ADDR_TYPE_BANYANVIN",
	15: "BGP_ADDR_TYPE_E164_NSAP",
	16: "BGP_ADDR_TYPE_IPV4_TNA",
	17: "BGP_ADDR_TYPE_IPV6_TNA",
	18: "BGP_ADDR_TYPE_NSAP_TNA",
	19: "BGP_ADDR_TYPE_VPN_IPV4",
	20: "BGP_ADDR_TYPE_VPN_IPV6",
	25: "BGP_ADDR_TYPE_L2VPN",
}

var BGPAddrType_value = map[string]int32{
	"BGP_ADDR_TYPE_OTHER":     0,
	"BGP_ADDR_TYPE_IPV4":      1,
	"BGP_ADDR_TYPE_IPV6":      2,
	"BGP_ADDR_TYPE_NSAP":      3,
	"BGP_ADDR_TYPE_HDLC":      4,
	"BGP_ADDR_TYPE_BBN1822":   5,
	"BGP_ADDR_TYPE_IEEE802":   6,
	"BGP_ADDR_TYPE_E163":      7,
	"BGP_ADDR_TYPE_E164":      8,
	"BGP_ADDR_TYPE_F69":       9,
	"BGP_ADDR_TYPE_X121":      10,
	"BGP_ADDR_TYPE_IPX":       11,
	"BGP_ADDR_TYPE_APPLETALK": 12,
	"BGP_ADDR_TYPE_DECNETIV":  13,
	"BGP_ADDR_TYPE_BANYANVIN": 14,
	"BGP_ADDR_TYPE_E164_NSAP": 15,
	"BGP_ADDR_TYPE_IPV4_TNA":  16,
	"BGP_ADDR_TYPE_IPV6_TNA":  17,
	"BGP_ADDR_TYPE_NSAP_TNA":  18,
	"BGP_ADDR_TYPE_VPN_IPV4":  19,
	"BGP_ADDR_TYPE_VPN_IPV6":  20,
	"BGP_ADDR_TYPE_L2VPN":     25,
}

func (x BGPAddrType) String() string {
	return proto.EnumName(BGPAddrType_name, int32(x))
}

func (BGPAddrType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{5}
}

type BGPOperStatus int32

const (
	BGPOperStatus_BGP_OPER_STATUS_NONE       BGPOperStatus = 0
	BGPOperStatus_BGP_OPER_STATUS_UP         BGPOperStatus = 1
	BGPOperStatus_BGP_OPER_STATUS_DOWN       BGPOperStatus = 2
	BGPOperStatus_BGP_OPER_STATUS_GOING_UP   BGPOperStatus = 3
	BGPOperStatus_BGP_OPER_STATUS_GOING_DOWN BGPOperStatus = 4
	BGPOperStatus_BGP_OPER_STATUS_ACT_FAILED BGPOperStatus = 5
)

var BGPOperStatus_name = map[int32]string{
	0: "BGP_OPER_STATUS_NONE",
	1: "BGP_OPER_STATUS_UP",
	2: "BGP_OPER_STATUS_DOWN",
	3: "BGP_OPER_STATUS_GOING_UP",
	4: "BGP_OPER_STATUS_GOING_DOWN",
	5: "BGP_OPER_STATUS_ACT_FAILED",
}

var BGPOperStatus_value = map[string]int32{
	"BGP_OPER_STATUS_NONE":       0,
	"BGP_OPER_STATUS_UP":         1,
	"BGP_OPER_STATUS_DOWN":       2,
	"BGP_OPER_STATUS_GOING_UP":   3,
	"BGP_OPER_STATUS_GOING_DOWN": 4,
	"BGP_OPER_STATUS_ACT_FAILED": 5,
}

func (x BGPOperStatus) String() string {
	return proto.EnumName(BGPOperStatus_name, int32(x))
}

func (BGPOperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{6}
}

type BgpAddPathCapNegCap int32

const (
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_DISABLE BgpAddPathCapNegCap = 0
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_RECEIVE BgpAddPathCapNegCap = 1
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_SEND    BgpAddPathCapNegCap = 2
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_BOTH    BgpAddPathCapNegCap = 3
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_INHERIT BgpAddPathCapNegCap = 4
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_UNKNOWN BgpAddPathCapNegCap = 5
)

var BgpAddPathCapNegCap_name = map[int32]string{
	0: "BGP_ADD_PATH_SR_DISABLE",
	1: "BGP_ADD_PATH_SR_RECEIVE",
	2: "BGP_ADD_PATH_SR_SEND",
	3: "BGP_ADD_PATH_SR_BOTH",
	4: "BGP_ADD_PATH_SR_INHERIT",
	5: "BGP_ADD_PATH_SR_UNKNOWN",
}

var BgpAddPathCapNegCap_value = map[string]int32{
	"BGP_ADD_PATH_SR_DISABLE": 0,
	"BGP_ADD_PATH_SR_RECEIVE": 1,
	"BGP_ADD_PATH_SR_SEND":    2,
	"BGP_ADD_PATH_SR_BOTH":    3,
	"BGP_ADD_PATH_SR_INHERIT": 4,
	"BGP_ADD_PATH_SR_UNKNOWN": 5,
}

func (x BgpAddPathCapNegCap) String() string {
	return proto.EnumName(BgpAddPathCapNegCap_name, int32(x))
}

func (BgpAddPathCapNegCap) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{7}
}

type BGPClearRouteOptions int32

const (
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE         BGPClearRouteOptions = 0
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_HARD         BGPClearRouteOptions = 1
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_IN   BGPClearRouteOptions = 2
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_OUT  BGPClearRouteOptions = 3
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_BOTH BGPClearRouteOptions = 4
)

var BGPClearRouteOptions_name = map[int32]string{
	0: "BGP_CLEAR_ROUTE_NONE",
	1: "BGP_CLEAR_ROUTE_HARD",
	2: "BGP_CLEAR_ROUTE_REFRESH_IN",
	3: "BGP_CLEAR_ROUTE_REFRESH_OUT",
	4: "BGP_CLEAR_ROUTE_REFRESH_BOTH",
}

var BGPClearRouteOptions_value = map[string]int32{
	"BGP_CLEAR_ROUTE_NONE":         0,
	"BGP_CLEAR_ROUTE_HARD":         1,
	"BGP_CLEAR_ROUTE_REFRESH_IN":   2,
	"BGP_CLEAR_ROUTE_REFRESH_OUT":  3,
	"BGP_CLEAR_ROUTE_REFRESH_BOTH": 4,
}

func (x BGPClearRouteOptions) String() string {
	return proto.EnumName(BGPClearRouteOptions_name, int32(x))
}

func (BGPClearRouteOptions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{8}
}

// NLRI source
type NLRISrc int32

const (
	NLRISrc_NLRI_NONE NLRISrc = 0
	NLRISrc_NLRI_PEER NLRISrc = 1
	NLRISrc_NLRI_AFM  NLRISrc = 2
	NLRISrc_NLRI_SELF NLRISrc = 3
)

var NLRISrc_name = map[int32]string{
	0: "NLRI_NONE",
	1: "NLRI_PEER",
	2: "NLRI_AFM",
	3: "NLRI_SELF",
}

var NLRISrc_value = map[string]int32{
	"NLRI_NONE": 0,
	"NLRI_PEER": 1,
	"NLRI_AFM":  2,
	"NLRI_SELF": 3,
}

func (x NLRISrc) String() string {
	return proto.EnumName(NLRISrc_name, int32(x))
}

func (NLRISrc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{9}
}

type BGPNLRIIsActive int32

const (
	BGPNLRIIsActive_BGP_NLRI_ISA_NONE        BGPNLRIIsActive = 0
	BGPNLRIIsActive_BGP_NLRI_ISA_NOT_TRACKED BGPNLRIIsActive = 1
	BGPNLRIIsActive_BGP_NLRI_ISA_INACTIVE    BGPNLRIIsActive = 2
	BGPNLRIIsActive_BGP_NLRI_ISA_ACTIVE      BGPNLRIIsActive = 3
)

var BGPNLRIIsActive_name = map[int32]string{
	0: "BGP_NLRI_ISA_NONE",
	1: "BGP_NLRI_ISA_NOT_TRACKED",
	2: "BGP_NLRI_ISA_INACTIVE",
	3: "BGP_NLRI_ISA_ACTIVE",
}

var BGPNLRIIsActive_value = map[string]int32{
	"BGP_NLRI_ISA_NONE":        0,
	"BGP_NLRI_ISA_NOT_TRACKED": 1,
	"BGP_NLRI_ISA_INACTIVE":    2,
	"BGP_NLRI_ISA_ACTIVE":      3,
}

func (x BGPNLRIIsActive) String() string {
	return proto.EnumName(BGPNLRIIsActive_name, int32(x))
}

func (BGPNLRIIsActive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{10}
}

type BGPRsnNotBest int32

const (
	BGPRsnNotBest_BGP_REASON_NOT_CONSIDERED   BGPRsnNotBest = 0
	BGPRsnNotBest_BGP_REASON_ROUTE_IS_BEST    BGPRsnNotBest = 1
	BGPRsnNotBest_BGP_REASON_WEIGHT           BGPRsnNotBest = 2
	BGPRsnNotBest_BGP_REASON_LOCAL_PREF       BGPRsnNotBest = 3
	BGPRsnNotBest_BGP_REASON_LCL_ORIG_PRFRRED BGPRsnNotBest = 4
	BGPRsnNotBest_BGP_REASON_AS_PATH_LEN      BGPRsnNotBest = 5
	BGPRsnNotBest_BGP_REASON_ORIGIN           BGPRsnNotBest = 6
	BGPRsnNotBest_BGP_REASON_MED              BGPRsnNotBest = 7
	BGPRsnNotBest_BGP_REASON_LOCAL_ORIG_TIE   BGPRsnNotBest = 8
	BGPRsnNotBest_BGP_REASON_EBGP_V_IBGP_PEER BGPRsnNotBest = 9
	BGPRsnNotBest_BGP_REASON_ADMIN_DISTANCE   BGPRsnNotBest = 10
	BGPRsnNotBest_BGP_REASON_PATH_TO_NEXT_CST BGPRsnNotBest = 11
	BGPRsnNotBest_BGP_REASON_PREF_EXISTING    BGPRsnNotBest = 12
	BGPRsnNotBest_BGP_REASON_IDENTIFIER       BGPRsnNotBest = 13
	BGPRsnNotBest_BGP_REASON_CLUSTER_LEN      BGPRsnNotBest = 14
	BGPRsnNotBest_BGP_REASON_PEER_ADDR_TYPE   BGPRsnNotBest = 15
	BGPRsnNotBest_BGP_REASON_PEER_ADDR        BGPRsnNotBest = 16
	BGPRsnNotBest_BGP_REASON_PEER_PORT        BGPRsnNotBest = 17
	BGPRsnNotBest_BGP_REASON_PATH_ID          BGPRsnNotBest = 18
)

var BGPRsnNotBest_name = map[int32]string{
	0:  "BGP_REASON_NOT_CONSIDERED",
	1:  "BGP_REASON_ROUTE_IS_BEST",
	2:  "BGP_REASON_WEIGHT",
	3:  "BGP_REASON_LOCAL_PREF",
	4:  "BGP_REASON_LCL_ORIG_PRFRRED",
	5:  "BGP_REASON_AS_PATH_LEN",
	6:  "BGP_REASON_ORIGIN",
	7:  "BGP_REASON_MED",
	8:  "BGP_REASON_LOCAL_ORIG_TIE",
	9:  "BGP_REASON_EBGP_V_IBGP_PEER",
	10: "BGP_REASON_ADMIN_DISTANCE",
	11: "BGP_REASON_PATH_TO_NEXT_CST",
	12: "BGP_REASON_PREF_EXISTING",
	13: "BGP_REASON_IDENTIFIER",
	14: "BGP_REASON_CLUSTER_LEN",
	15: "BGP_REASON_PEER_ADDR_TYPE",
	16: "BGP_REASON_PEER_ADDR",
	17: "BGP_REASON_PEER_PORT",
	18: "BGP_REASON_PATH_ID",
}

var BGPRsnNotBest_value = map[string]int32{
	"BGP_REASON_NOT_CONSIDERED":   0,
	"BGP_REASON_ROUTE_IS_BEST":    1,
	"BGP_REASON_WEIGHT":           2,
	"BGP_REASON_LOCAL_PREF":       3,
	"BGP_REASON_LCL_ORIG_PRFRRED": 4,
	"BGP_REASON_AS_PATH_LEN":      5,
	"BGP_REASON_ORIGIN":           6,
	"BGP_REASON_MED":              7,
	"BGP_REASON_LOCAL_ORIG_TIE":   8,
	"BGP_REASON_EBGP_V_IBGP_PEER": 9,
	"BGP_REASON_ADMIN_DISTANCE":   10,
	"BGP_REASON_PATH_TO_NEXT_CST": 11,
	"BGP_REASON_PREF_EXISTING":    12,
	"BGP_REASON_IDENTIFIER":       13,
	"BGP_REASON_CLUSTER_LEN":      14,
	"BGP_REASON_PEER_ADDR_TYPE":   15,
	"BGP_REASON_PEER_ADDR":        16,
	"BGP_REASON_PEER_PORT":        17,
	"BGP_REASON_PATH_ID":          18,
}

func (x BGPRsnNotBest) String() string {
	return proto.EnumName(BGPRsnNotBest_name, int32(x))
}

func (BGPRsnNotBest) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{11}
}

// BGP configuration
type BGPSpec struct {
	// unique key/identifier of BGP config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// the local autonomous system number
	LocalASN uint32 `protobuf:"varint,2,opt,name=LocalASN,proto3" json:"LocalASN,omitempty"`
	// router ID for this bgp instance
	RouterId uint32 `protobuf:"fixed32,3,opt,name=RouterId,proto3" json:"RouterId,omitempty"`
	// cluster ID of the local router. router ID will be used as cluster ID
	// if cluster ID is not configured or configured to zero
	ClusterId uint32 `protobuf:"fixed32,4,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
	// disable/enable BGP
	Disable bool `protobuf:"varint,5,opt,name=Disable,proto3" json:"Disable,omitempty"`
	// exclude default route from being used to resolve nexthop reachability in the underlay
	// changing this will deactivate and activate the routing stack RIB
	SuppressDefaultResolution bool     `protobuf:"varint,6,opt,name=SuppressDefaultResolution,proto3" json:"SuppressDefaultResolution,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *BGPSpec) Reset()         { *m = BGPSpec{} }
func (m *BGPSpec) String() string { return proto.CompactTextString(m) }
func (*BGPSpec) ProtoMessage()    {}
func (*BGPSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{0}
}
func (m *BGPSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPSpec.Merge(m, src)
}
func (m *BGPSpec) XXX_Size() int {
	return m.Size()
}
func (m *BGPSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BGPSpec proto.InternalMessageInfo

func (m *BGPSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPSpec) GetLocalASN() uint32 {
	if m != nil {
		return m.LocalASN
	}
	return 0
}

func (m *BGPSpec) GetRouterId() uint32 {
	if m != nil {
		return m.RouterId
	}
	return 0
}

func (m *BGPSpec) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *BGPSpec) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

func (m *BGPSpec) GetSuppressDefaultResolution() bool {
	if m != nil {
		return m.SuppressDefaultResolution
	}
	return false
}

// operational status of BGP
type BGPStatus struct {
	// BGP current oper status
	Status BGPOperStatus `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPOperStatus" json:"Status,omitempty"`
	// The total number of Adj-RIB-Out routes currently allocated
	NumAdjRibOutRoutes uint32 `protobuf:"varint,2,opt,name=NumAdjRibOutRoutes,proto3" json:"NumAdjRibOutRoutes,omitempty"`
	// The peak number of Adj-RIB-Out routes that have been allocated at any one time
	PeakNumAdjRibOutRoutes uint32 `protobuf:"varint,3,opt,name=PeakNumAdjRibOutRoutes,proto3" json:"PeakNumAdjRibOutRoutes,omitempty"`
	// The maximum time remaining until route selection takes place following a restart, in hundredths of a second.
	RemDelayTime uint32 `protobuf:"varint,4,opt,name=RemDelayTime,proto3" json:"RemDelayTime,omitempty"`
	// The table version number of the Loc-RIB
	TableVer             uint32   `protobuf:"varint,5,opt,name=TableVer,proto3" json:"TableVer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPStatus) Reset()         { *m = BGPStatus{} }
func (m *BGPStatus) String() string { return proto.CompactTextString(m) }
func (*BGPStatus) ProtoMessage()    {}
func (*BGPStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{1}
}
func (m *BGPStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPStatus.Merge(m, src)
}
func (m *BGPStatus) XXX_Size() int {
	return m.Size()
}
func (m *BGPStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BGPStatus proto.InternalMessageInfo

func (m *BGPStatus) GetStatus() BGPOperStatus {
	if m != nil {
		return m.Status
	}
	return BGPOperStatus_BGP_OPER_STATUS_NONE
}

func (m *BGPStatus) GetNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.NumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetPeakNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.PeakNumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetRemDelayTime() uint32 {
	if m != nil {
		return m.RemDelayTime
	}
	return 0
}

func (m *BGPStatus) GetTableVer() uint32 {
	if m != nil {
		return m.TableVer
	}
	return 0
}

// BGP address family counters table
type BGPAfStats struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// total number of IBGP routes received for this address family
	IBGPPrefixes uint32 `protobuf:"varint,3,opt,name=IBGPPrefixes,proto3" json:"IBGPPrefixes,omitempty"`
	// total number of EBGP routes received for this address family
	EBGPPrefixes uint32 `protobuf:"varint,4,opt,name=EBGPPrefixes,proto3" json:"EBGPPrefixes,omitempty"`
	// number of prefixes received for this address family that are stored in Adj-RIB-In
	InPrfxes uint32 `protobuf:"varint,5,opt,name=InPrfxes,proto3" json:"InPrfxes,omitempty"`
	// number of prefixes received for this address family that are installed in the Adj-RIB-In and are eligible to become active in the Loc-Rib
	InPrfxesAccepted uint32 `protobuf:"varint,6,opt,name=InPrfxesAccepted,proto3" json:"InPrfxesAccepted,omitempty"`
	// number of prefixes for this address family that are installed in the Adj-RIB-In and are not eligible to become active in the Loc-Rib
	InPrfxesRejected uint32 `protobuf:"varint,7,opt,name=InPrfxesRejected,proto3" json:"InPrfxesRejected,omitempty"`
	// The number of prefixes for this address famaily that are installed in AAdj-RIB-Out
	OutPrfxes uint32 `protobuf:"varint,8,opt,name=OutPrfxes,proto3" json:"OutPrfxes,omitempty"`
	// number of advertised prefixes for this address family currently associated with any peer
	OutPrfxesAdvertised uint32 `protobuf:"varint,9,opt,name=OutPrfxesAdvertised,proto3" json:"OutPrfxesAdvertised,omitempty"`
	// number of prefixes received for this address family that are stored, but not installed in the Adj-RIB-In, because of local filter policy
	InPrfxesDeniedByPol uint32 `protobuf:"varint,10,opt,name=InPrfxesDeniedByPol,proto3" json:"InPrfxesDeniedByPol,omitempty"`
	// number of prefixes for this address family that are installed in the Adj-RIB-In and included in the Loc-RIB
	NumLocRibRoutes uint32 `protobuf:"varint,11,opt,name=NumLocRibRoutes,proto3" json:"NumLocRibRoutes,omitempty"`
	// number of prefixes for this address family that are installed in the Adj-RIB-In and included in the Loc-RIB as 'best' routes
	NumLocRibBestRoutes uint32 `protobuf:"varint,12,opt,name=NumLocRibBestRoutes,proto3" json:"NumLocRibBestRoutes,omitempty"`
	// number of next hops for all routes installed in the Loc-RIB for this address family
	NumLocRibNextHops uint32 `protobuf:"varint,13,opt,name=NumLocRibNextHops,proto3" json:"NumLocRibNextHops,omitempty"`
	// number of routes installed in the Loc-RIB for this address family for which there are multiple ECMP next hops
	NumLocRibECMPRoutes  uint32   `protobuf:"varint,14,opt,name=NumLocRibECMPRoutes,proto3" json:"NumLocRibECMPRoutes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPAfStats) Reset()         { *m = BGPAfStats{} }
func (m *BGPAfStats) String() string { return proto.CompactTextString(m) }
func (*BGPAfStats) ProtoMessage()    {}
func (*BGPAfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{2}
}
func (m *BGPAfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPAfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPAfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPAfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPAfStats.Merge(m, src)
}
func (m *BGPAfStats) XXX_Size() int {
	return m.Size()
}
func (m *BGPAfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPAfStats.DiscardUnknown(m)
}

var xxx_messageInfo_BGPAfStats proto.InternalMessageInfo

func (m *BGPAfStats) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPAfStats) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPAfStats) GetIBGPPrefixes() uint32 {
	if m != nil {
		return m.IBGPPrefixes
	}
	return 0
}

func (m *BGPAfStats) GetEBGPPrefixes() uint32 {
	if m != nil {
		return m.EBGPPrefixes
	}
	return 0
}

func (m *BGPAfStats) GetInPrfxes() uint32 {
	if m != nil {
		return m.InPrfxes
	}
	return 0
}

func (m *BGPAfStats) GetInPrfxesAccepted() uint32 {
	if m != nil {
		return m.InPrfxesAccepted
	}
	return 0
}

func (m *BGPAfStats) GetInPrfxesRejected() uint32 {
	if m != nil {
		return m.InPrfxesRejected
	}
	return 0
}

func (m *BGPAfStats) GetOutPrfxes() uint32 {
	if m != nil {
		return m.OutPrfxes
	}
	return 0
}

func (m *BGPAfStats) GetOutPrfxesAdvertised() uint32 {
	if m != nil {
		return m.OutPrfxesAdvertised
	}
	return 0
}

func (m *BGPAfStats) GetInPrfxesDeniedByPol() uint32 {
	if m != nil {
		return m.InPrfxesDeniedByPol
	}
	return 0
}

func (m *BGPAfStats) GetNumLocRibRoutes() uint32 {
	if m != nil {
		return m.NumLocRibRoutes
	}
	return 0
}

func (m *BGPAfStats) GetNumLocRibBestRoutes() uint32 {
	if m != nil {
		return m.NumLocRibBestRoutes
	}
	return 0
}

func (m *BGPAfStats) GetNumLocRibNextHops() uint32 {
	if m != nil {
		return m.NumLocRibNextHops
	}
	return 0
}

func (m *BGPAfStats) GetNumLocRibECMPRoutes() uint32 {
	if m != nil {
		return m.NumLocRibECMPRoutes
	}
	return 0
}

type BGPStats struct {
	// BGP address family statistics
	AfStats              []*BGPAfStats `protobuf:"bytes,1,rep,name=AfStats,proto3" json:"AfStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BGPStats) Reset()         { *m = BGPStats{} }
func (m *BGPStats) String() string { return proto.CompactTextString(m) }
func (*BGPStats) ProtoMessage()    {}
func (*BGPStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{3}
}
func (m *BGPStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPStats.Merge(m, src)
}
func (m *BGPStats) XXX_Size() int {
	return m.Size()
}
func (m *BGPStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPStats.DiscardUnknown(m)
}

var xxx_messageInfo_BGPStats proto.InternalMessageInfo

func (m *BGPStats) GetAfStats() []*BGPAfStats {
	if m != nil {
		return m.AfStats
	}
	return nil
}

// BGP object
type BGP struct {
	Spec                 *BGPSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *BGPStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *BGPStats  `protobuf:"bytes,3,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BGP) Reset()         { *m = BGP{} }
func (m *BGP) String() string { return proto.CompactTextString(m) }
func (*BGP) ProtoMessage()    {}
func (*BGP) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{4}
}
func (m *BGP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGP.Merge(m, src)
}
func (m *BGP) XXX_Size() int {
	return m.Size()
}
func (m *BGP) XXX_DiscardUnknown() {
	xxx_messageInfo_BGP.DiscardUnknown(m)
}

var xxx_messageInfo_BGP proto.InternalMessageInfo

func (m *BGP) GetSpec() *BGPSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGP) GetStatus() *BGPStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BGP) GetStats() *BGPStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// BGP create and update request
type BGPRequest struct {
	Request              *BGPSpec `protobuf:"bytes,1,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPRequest) Reset()         { *m = BGPRequest{} }
func (m *BGPRequest) String() string { return proto.CompactTextString(m) }
func (*BGPRequest) ProtoMessage()    {}
func (*BGPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{5}
}
func (m *BGPRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPRequest.Merge(m, src)
}
func (m *BGPRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPRequest proto.InternalMessageInfo

func (m *BGPRequest) GetRequest() *BGPSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP create and update response
type BGPResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPResponse) Reset()         { *m = BGPResponse{} }
func (m *BGPResponse) String() string { return proto.CompactTextString(m) }
func (*BGPResponse) ProtoMessage()    {}
func (*BGPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{6}
}
func (m *BGPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPResponse.Merge(m, src)
}
func (m *BGPResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPResponse proto.InternalMessageInfo

func (m *BGPResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP KeyHandle used in Get/Delete
type BGPKeyHandle struct {
	Id                   []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPKeyHandle) Reset()         { *m = BGPKeyHandle{} }
func (m *BGPKeyHandle) String() string { return proto.CompactTextString(m) }
func (*BGPKeyHandle) ProtoMessage()    {}
func (*BGPKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{7}
}
func (m *BGPKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPKeyHandle.Merge(m, src)
}
func (m *BGPKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *BGPKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_BGPKeyHandle proto.InternalMessageInfo

func (m *BGPKeyHandle) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// BGP delete request
type BGPDeleteRequest struct {
	Request              *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BGPDeleteRequest) Reset()         { *m = BGPDeleteRequest{} }
func (m *BGPDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*BGPDeleteRequest) ProtoMessage()    {}
func (*BGPDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{8}
}
func (m *BGPDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPDeleteRequest.Merge(m, src)
}
func (m *BGPDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPDeleteRequest proto.InternalMessageInfo

func (m *BGPDeleteRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP delete response
type BGPDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPDeleteResponse) Reset()         { *m = BGPDeleteResponse{} }
func (m *BGPDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*BGPDeleteResponse) ProtoMessage()    {}
func (*BGPDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{9}
}
func (m *BGPDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPDeleteResponse.Merge(m, src)
}
func (m *BGPDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPDeleteResponse proto.InternalMessageInfo

func (m *BGPDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP get request
type BGPGetRequest struct {
	Request              *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BGPGetRequest) Reset()         { *m = BGPGetRequest{} }
func (m *BGPGetRequest) String() string { return proto.CompactTextString(m) }
func (*BGPGetRequest) ProtoMessage()    {}
func (*BGPGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{10}
}
func (m *BGPGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPGetRequest.Merge(m, src)
}
func (m *BGPGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPGetRequest proto.InternalMessageInfo

func (m *BGPGetRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP get response
type BGPGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *BGP      `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPGetResponse) Reset()         { *m = BGPGetResponse{} }
func (m *BGPGetResponse) String() string { return proto.CompactTextString(m) }
func (*BGPGetResponse) ProtoMessage()    {}
func (*BGPGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{11}
}
func (m *BGPGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPGetResponse.Merge(m, src)
}
func (m *BGPGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPGetResponse proto.InternalMessageInfo

func (m *BGPGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPGetResponse) GetResponse() *BGP {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer configurations
type BGPPeerSpec struct {
	// unique key/identifier of peer
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// peer enable/disable admin state. if peer is not enabled then local router
	// must not initiate connections to the neighbor and must not respond to
	// TCP connections attempts from neighbor
	State AdminState `protobuf:"varint,2,opt,name=State,proto3,enum=types.AdminState" json:"State,omitempty"`
	// BGP local IP address. control plane chooses the local IP address of the
	// session if an all 0 IP address is provided
	LocalAddr *IPAddress `protobuf:"bytes,3,opt,name=LocalAddr,proto3" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,4,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// remote 4-byte AS number
	RemoteASN uint32 `protobuf:"varint,5,opt,name=RemoteASN,proto3" json:"RemoteASN,omitempty"`
	// send regular community attributes to neighbor
	SendComm bool `protobuf:"varint,6,opt,name=SendComm,proto3" json:"SendComm,omitempty"`
	// send extended community attributes to neighbor
	SendExtComm bool `protobuf:"varint,7,opt,name=SendExtComm,proto3" json:"SendExtComm,omitempty"`
	// peer is a route reflector client
	RRClient BGPPeerRRClient `protobuf:"varint,8,opt,name=RRClient,proto3,enum=pds.BGPPeerRRClient" json:"RRClient,omitempty"`
	// BGP session connect-retry timer in seconds
	ConnectRetry uint32 `protobuf:"varint,9,opt,name=ConnectRetry,proto3" json:"ConnectRetry,omitempty"`
	// BGP session configured holdtime timer in seconds
	HoldTime uint32 `protobuf:"varint,10,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session configured keepalive timer in seconds
	KeepAlive uint32 `protobuf:"varint,11,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// MD5 authentication
	Password []byte `protobuf:"bytes,12,opt,name=Password,proto3" json:"Password,omitempty"`
	// TTL, set 1 to enable fast-external-fallover for directly connected eBGP sessions
	Ttl uint32 `protobuf:"varint,13,opt,name=Ttl,proto3" json:"Ttl,omitempty" meta:range:1-255, meta:default=64`
	// IdleHoldTime in seconds
	IdleHoldTime uint32 `protobuf:"varint,14,opt,name=IdleHoldTime,proto3" json:"IdleHoldTime,omitempty" meta:range:1-32767, meta:default=15`
	// The number of instances of the local AS identifier that may be contained in the route's
	// AS-Path without rejecting the route. Changing the value of this object while the peer
	// is active triggers BGP to refresh its routes from the peer
	AllowLocalAS         uint32   `protobuf:"varint,15,opt,name=AllowLocalAS,proto3" json:"AllowLocalAS,omitempty" meta:range:0-255, meta:default=0`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPPeerSpec) Reset()         { *m = BGPPeerSpec{} }
func (m *BGPPeerSpec) String() string { return proto.CompactTextString(m) }
func (*BGPPeerSpec) ProtoMessage()    {}
func (*BGPPeerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{12}
}
func (m *BGPPeerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerSpec.Merge(m, src)
}
func (m *BGPPeerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerSpec proto.InternalMessageInfo

func (m *BGPPeerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerSpec) GetState() AdminState {
	if m != nil {
		return m.State
	}
	return AdminState_ADMIN_STATE_NONE
}

func (m *BGPPeerSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetRemoteASN() uint32 {
	if m != nil {
		return m.RemoteASN
	}
	return 0
}

func (m *BGPPeerSpec) GetSendComm() bool {
	if m != nil {
		return m.SendComm
	}
	return false
}

func (m *BGPPeerSpec) GetSendExtComm() bool {
	if m != nil {
		return m.SendExtComm
	}
	return false
}

func (m *BGPPeerSpec) GetRRClient() BGPPeerRRClient {
	if m != nil {
		return m.RRClient
	}
	return BGPPeerRRClient_BGP_PEER_RR_NONE
}

func (m *BGPPeerSpec) GetConnectRetry() uint32 {
	if m != nil {
		return m.ConnectRetry
	}
	return 0
}

func (m *BGPPeerSpec) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerSpec) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerSpec) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *BGPPeerSpec) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *BGPPeerSpec) GetIdleHoldTime() uint32 {
	if m != nil {
		return m.IdleHoldTime
	}
	return 0
}

func (m *BGPPeerSpec) GetAllowLocalAS() uint32 {
	if m != nil {
		return m.AllowLocalAS
	}
	return 0
}

// BGP peer status
type BGPPeerStatus struct {
	// BGP session status
	Status BGPPeerState `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPPeerState" json:"Status,omitempty"`
	// BGP session previous status
	PrevStatus BGPPeerState `protobuf:"varint,2,opt,name=PrevStatus,proto3,enum=pds.BGPPeerState" json:"PrevStatus,omitempty"`
	// last error received
	LastErrorRcvd []byte `protobuf:"bytes,3,opt,name=LastErrorRcvd,proto3" json:"LastErrorRcvd,omitempty"`
	// Last error sent
	LastErrorSent []byte `protobuf:"bytes,4,opt,name=LastErrorSent,proto3" json:"LastErrorSent,omitempty"`
	// selected local address of the peer
	LocalAddr *IPAddress `protobuf:"bytes,5,opt,name=LocalAddr,proto3" json:"LocalAddr,omitempty"`
	// BGP session holdtime in seconds established with peer
	HoldTime uint32 `protobuf:"varint,6,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session keepalive in seconds established with peer
	KeepAlive uint32 `protobuf:"varint,7,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// BGP The capabilities announced to the peer on the most recent open message sent to the peer.
	CapsSent uint32 `protobuf:"varint,8,opt,name=CapsSent,proto3" json:"CapsSent,omitempty"`
	// BGP The capabilities received on the most recent open message received from the peer.
	CapsRcvd uint32 `protobuf:"varint,9,opt,name=CapsRcvd,proto3" json:"CapsRcvd,omitempty"`
	// BGP The capabilities negotiated for the session with the peer
	CapsNeg uint32 `protobuf:"varint,10,opt,name=CapsNeg,proto3" json:"CapsNeg,omitempty"`
	// BGP The address family of the local address used by the transport connection for the peering session.
	SelLocalAddrType BGPAddrType `protobuf:"varint,11,opt,name=SelLocalAddrType,proto3,enum=pds.BGPAddrType" json:"SelLocalAddrType,omitempty"`
	// Number of BGP Notifications received for this connection.
	InNotifications uint32 `protobuf:"varint,12,opt,name=InNotifications,proto3" json:"InNotifications,omitempty"`
	// Number of BGP Notifications sent for this connection.
	OutNotifications uint32 `protobuf:"varint,13,opt,name=OutNotifications,proto3" json:"OutNotifications,omitempty"`
	// Number of BGP Updates received for this connection.
	InUpdates uint32 `protobuf:"varint,14,opt,name=InUpdates,proto3" json:"InUpdates,omitempty"`
	// Number of BGP Updates received for this connection.
	OutUpdates uint32 `protobuf:"varint,15,opt,name=OutUpdates,proto3" json:"OutUpdates,omitempty"`
	// Number of BGP Keepalives received for this connection.
	InKeepalives uint32 `protobuf:"varint,16,opt,name=InKeepalives,proto3" json:"InKeepalives,omitempty"`
	// Number of BGP Opens sent for this connection.
	OutKeepalives uint32 `protobuf:"varint,17,opt,name=OutKeepalives,proto3" json:"OutKeepalives,omitempty"`
	// Number of BGP Route Refreshes received for this connection.
	InRefreshes uint32 `protobuf:"varint,18,opt,name=InRefreshes,proto3" json:"InRefreshes,omitempty"`
	// Number of BGP Route Refreshes sent for this connection.
	OutRefreshes uint32 `protobuf:"varint,19,opt,name=OutRefreshes,proto3" json:"OutRefreshes,omitempty"`
	// Total number of BGP messages received for this connection.
	InTotalMessages uint32 `protobuf:"varint,20,opt,name=InTotalMessages,proto3" json:"InTotalMessages,omitempty"`
	// Total number of BGP messages sent for this connection.
	OutTotalMessages uint32 `protobuf:"varint,21,opt,name=OutTotalMessages,proto3" json:"OutTotalMessages,omitempty"`
	// Number of times BGP FSM transitioned to established state.
	FsmEstTransitions uint32 `protobuf:"varint,22,opt,name=FsmEstTransitions,proto3" json:"FsmEstTransitions,omitempty"`
	// Number of retries after a flap.
	ConnectRetryCount uint32 `protobuf:"varint,23,opt,name=ConnectRetryCount,proto3" json:"ConnectRetryCount,omitempty"`
	// Peer Group ID.
	Peergr uint32 `protobuf:"varint,24,opt,name=Peergr,proto3" json:"Peergr,omitempty"`
	//Number of sec to stale the routes before deleting them.
	StalePathTime uint32 `protobuf:"varint,25,opt,name=StalePathTime,proto3" json:"StalePathTime,omitempty"`
	//Number of ORF entries of all types received from the peer.
	OrfEntryCount   uint32 `protobuf:"varint,26,opt,name=OrfEntryCount,proto3" json:"OrfEntryCount,omitempty"`
	RcvdMsgElpsTime uint32 `protobuf:"varint,27,opt,name=RcvdMsgElpsTime,proto3" json:"RcvdMsgElpsTime,omitempty"`
	// Number of Route Refreshes sent to the peer.
	RouteRefrSent uint32 `protobuf:"varint,28,opt,name=RouteRefrSent,proto3" json:"RouteRefrSent,omitempty"`
	// Number of Route Refreshes received from the peer.
	RouteRefrRcvd uint32 `protobuf:"varint,29,opt,name=RouteRefrRcvd,proto3" json:"RouteRefrRcvd,omitempty"`
	// Number of prefixes received from the peer.
	InPrfxes uint32 `protobuf:"varint,30,opt,name=InPrfxes,proto3" json:"InPrfxes,omitempty"`
	// Number of prefixes advertised to the peer including withdrawn prefixes.
	OutPrfxes uint32 `protobuf:"varint,31,opt,name=OutPrfxes,proto3" json:"OutPrfxes,omitempty"`
	// Number of prefixes advertised to the peer.
	OutPrfxesAdvertised uint32 `protobuf:"varint,32,opt,name=OutPrfxesAdvertised,proto3" json:"OutPrfxesAdvertised,omitempty"`
	// Connection retry time interval.
	ConnectRetryInt uint32 `protobuf:"varint,33,opt,name=ConnectRetryInt,proto3" json:"ConnectRetryInt,omitempty"`
	// Time in sec since last update was sent to the peer.
	OutUpdateElpsTime uint32 `protobuf:"varint,34,opt,name=OutUpdateElpsTime,proto3" json:"OutUpdateElpsTime,omitempty"`
	// Number of prefixes failed export policy.
	OutPrfxesDenied uint32 `protobuf:"varint,35,opt,name=OutPrfxesDenied,proto3" json:"OutPrfxesDenied,omitempty"`
	// Number of prefixes for which implicit withdraw has been sent.
	OutPrfxesImpWdr uint32 `protobuf:"varint,36,opt,name=OutPrfxesImpWdr,proto3" json:"OutPrfxesImpWdr,omitempty"`
	// Number of prefixes for which explicit withdraw has been sent.
	OutPrfxesExpWdr uint32 `protobuf:"varint,37,opt,name=OutPrfxesExpWdr,proto3" json:"OutPrfxesExpWdr,omitempty"`
	// Number of prefixes for which implicit withdraw has been rcvd.
	InPrfxesImpWdr uint32 `protobuf:"varint,38,opt,name=InPrfxesImpWdr,proto3" json:"InPrfxesImpWdr,omitempty"`
	// Number of prefixes for which explicit withdraw has been rcvd.
	InPrfxesExpWdr uint32 `protobuf:"varint,39,opt,name=InPrfxesExpWdr,proto3" json:"InPrfxesExpWdr,omitempty"`
	// Hold time received in open message.
	ReceivedHoldTime uint32 `protobuf:"varint,40,opt,name=ReceivedHoldTime,proto3" json:"ReceivedHoldTime,omitempty"`
	// For how long is this peer in established state in sec.
	FsmEstablishedTime uint32 `protobuf:"varint,41,opt,name=FsmEstablishedTime,proto3" json:"FsmEstablishedTime,omitempty"`
	// Elapsed time in sec since the last BGP message is received.
	InUpdatesElpsTime uint32 `protobuf:"varint,42,opt,name=InUpdatesElpsTime,proto3" json:"InUpdatesElpsTime,omitempty"`
	// Number of BGP Opens received for this connection.
	InOpens uint32 `protobuf:"varint,43,opt,name=InOpens,proto3" json:"InOpens,omitempty"`
	// Number of BGP Opens sent for this connection.
	OutOpens uint32 `protobuf:"varint,44,opt,name=OutOpens,proto3" json:"OutOpens,omitempty"`
	// Peer Index
	PeerIndex uint32 `protobuf:"varint,45,opt,name=PeerIndex,proto3" json:"PeerIndex,omitempty"`
	// Current TTL value in use
	Ttl uint32 `protobuf:"varint,46,opt,name=Ttl,proto3" json:"Ttl,omitempty"`
	// Operational status of this peer
	OperState            BGPOperStatus `protobuf:"varint,47,opt,name=OperState,proto3,enum=pds.BGPOperStatus" json:"OperState,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BGPPeerStatus) Reset()         { *m = BGPPeerStatus{} }
func (m *BGPPeerStatus) String() string { return proto.CompactTextString(m) }
func (*BGPPeerStatus) ProtoMessage()    {}
func (*BGPPeerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{13}
}
func (m *BGPPeerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerStatus.Merge(m, src)
}
func (m *BGPPeerStatus) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerStatus proto.InternalMessageInfo

func (m *BGPPeerStatus) GetStatus() BGPPeerState {
	if m != nil {
		return m.Status
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetPrevStatus() BGPPeerState {
	if m != nil {
		return m.PrevStatus
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetLastErrorRcvd() []byte {
	if m != nil {
		return m.LastErrorRcvd
	}
	return nil
}

func (m *BGPPeerStatus) GetLastErrorSent() []byte {
	if m != nil {
		return m.LastErrorSent
	}
	return nil
}

func (m *BGPPeerStatus) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerStatus) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerStatus) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsSent() uint32 {
	if m != nil {
		return m.CapsSent
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsRcvd() uint32 {
	if m != nil {
		return m.CapsRcvd
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsNeg() uint32 {
	if m != nil {
		return m.CapsNeg
	}
	return 0
}

func (m *BGPPeerStatus) GetSelLocalAddrType() BGPAddrType {
	if m != nil {
		return m.SelLocalAddrType
	}
	return BGPAddrType_BGP_ADDR_TYPE_OTHER
}

func (m *BGPPeerStatus) GetInNotifications() uint32 {
	if m != nil {
		return m.InNotifications
	}
	return 0
}

func (m *BGPPeerStatus) GetOutNotifications() uint32 {
	if m != nil {
		return m.OutNotifications
	}
	return 0
}

func (m *BGPPeerStatus) GetInUpdates() uint32 {
	if m != nil {
		return m.InUpdates
	}
	return 0
}

func (m *BGPPeerStatus) GetOutUpdates() uint32 {
	if m != nil {
		return m.OutUpdates
	}
	return 0
}

func (m *BGPPeerStatus) GetInKeepalives() uint32 {
	if m != nil {
		return m.InKeepalives
	}
	return 0
}

func (m *BGPPeerStatus) GetOutKeepalives() uint32 {
	if m != nil {
		return m.OutKeepalives
	}
	return 0
}

func (m *BGPPeerStatus) GetInRefreshes() uint32 {
	if m != nil {
		return m.InRefreshes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutRefreshes() uint32 {
	if m != nil {
		return m.OutRefreshes
	}
	return 0
}

func (m *BGPPeerStatus) GetInTotalMessages() uint32 {
	if m != nil {
		return m.InTotalMessages
	}
	return 0
}

func (m *BGPPeerStatus) GetOutTotalMessages() uint32 {
	if m != nil {
		return m.OutTotalMessages
	}
	return 0
}

func (m *BGPPeerStatus) GetFsmEstTransitions() uint32 {
	if m != nil {
		return m.FsmEstTransitions
	}
	return 0
}

func (m *BGPPeerStatus) GetConnectRetryCount() uint32 {
	if m != nil {
		return m.ConnectRetryCount
	}
	return 0
}

func (m *BGPPeerStatus) GetPeergr() uint32 {
	if m != nil {
		return m.Peergr
	}
	return 0
}

func (m *BGPPeerStatus) GetStalePathTime() uint32 {
	if m != nil {
		return m.StalePathTime
	}
	return 0
}

func (m *BGPPeerStatus) GetOrfEntryCount() uint32 {
	if m != nil {
		return m.OrfEntryCount
	}
	return 0
}

func (m *BGPPeerStatus) GetRcvdMsgElpsTime() uint32 {
	if m != nil {
		return m.RcvdMsgElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetRouteRefrSent() uint32 {
	if m != nil {
		return m.RouteRefrSent
	}
	return 0
}

func (m *BGPPeerStatus) GetRouteRefrRcvd() uint32 {
	if m != nil {
		return m.RouteRefrRcvd
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxes() uint32 {
	if m != nil {
		return m.InPrfxes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxes() uint32 {
	if m != nil {
		return m.OutPrfxes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesAdvertised() uint32 {
	if m != nil {
		return m.OutPrfxesAdvertised
	}
	return 0
}

func (m *BGPPeerStatus) GetConnectRetryInt() uint32 {
	if m != nil {
		return m.ConnectRetryInt
	}
	return 0
}

func (m *BGPPeerStatus) GetOutUpdateElpsTime() uint32 {
	if m != nil {
		return m.OutUpdateElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesDenied() uint32 {
	if m != nil {
		return m.OutPrfxesDenied
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesImpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesImpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesExpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesExpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxesImpWdr() uint32 {
	if m != nil {
		return m.InPrfxesImpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxesExpWdr() uint32 {
	if m != nil {
		return m.InPrfxesExpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetReceivedHoldTime() uint32 {
	if m != nil {
		return m.ReceivedHoldTime
	}
	return 0
}

func (m *BGPPeerStatus) GetFsmEstablishedTime() uint32 {
	if m != nil {
		return m.FsmEstablishedTime
	}
	return 0
}

func (m *BGPPeerStatus) GetInUpdatesElpsTime() uint32 {
	if m != nil {
		return m.InUpdatesElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetInOpens() uint32 {
	if m != nil {
		return m.InOpens
	}
	return 0
}

func (m *BGPPeerStatus) GetOutOpens() uint32 {
	if m != nil {
		return m.OutOpens
	}
	return 0
}

func (m *BGPPeerStatus) GetPeerIndex() uint32 {
	if m != nil {
		return m.PeerIndex
	}
	return 0
}

func (m *BGPPeerStatus) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *BGPPeerStatus) GetOperState() BGPOperStatus {
	if m != nil {
		return m.OperState
	}
	return BGPOperStatus_BGP_OPER_STATUS_NONE
}

// BGP peer object
type BGPPeer struct {
	Spec                 *BGPPeerSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *BGPPeerStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BGPPeer) Reset()         { *m = BGPPeer{} }
func (m *BGPPeer) String() string { return proto.CompactTextString(m) }
func (*BGPPeer) ProtoMessage()    {}
func (*BGPPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{14}
}
func (m *BGPPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeer.Merge(m, src)
}
func (m *BGPPeer) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeer.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeer proto.InternalMessageInfo

func (m *BGPPeer) GetSpec() *BGPPeerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeer) GetStatus() *BGPPeerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer create and update response
type BGPPeerResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPPeerResponse) Reset()         { *m = BGPPeerResponse{} }
func (m *BGPPeerResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerResponse) ProtoMessage()    {}
func (*BGPPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{15}
}
func (m *BGPPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerResponse.Merge(m, src)
}
func (m *BGPPeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerResponse proto.InternalMessageInfo

func (m *BGPPeerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer create and update request
type BGPPeerRequest struct {
	Request              []*BGPPeerSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BGPPeerRequest) Reset()         { *m = BGPPeerRequest{} }
func (m *BGPPeerRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerRequest) ProtoMessage()    {}
func (*BGPPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{16}
}
func (m *BGPPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerRequest.Merge(m, src)
}
func (m *BGPPeerRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerRequest proto.InternalMessageInfo

func (m *BGPPeerRequest) GetRequest() []*BGPPeerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer get response
type BGPPeerGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*BGPPeer `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BGPPeerGetResponse) Reset()         { *m = BGPPeerGetResponse{} }
func (m *BGPPeerGetResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerGetResponse) ProtoMessage()    {}
func (*BGPPeerGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{17}
}
func (m *BGPPeerGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerGetResponse.Merge(m, src)
}
func (m *BGPPeerGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerGetResponse proto.InternalMessageInfo

func (m *BGPPeerGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerGetResponse) GetResponse() []*BGPPeer {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer key parameters
type BGPPeerKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr,proto3" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr             *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BGPPeerKey) Reset()         { *m = BGPPeerKey{} }
func (m *BGPPeerKey) String() string { return proto.CompactTextString(m) }
func (*BGPPeerKey) ProtoMessage()    {}
func (*BGPPeerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{18}
}
func (m *BGPPeerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerKey.Merge(m, src)
}
func (m *BGPPeerKey) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerKey.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerKey proto.InternalMessageInfo

func (m *BGPPeerKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

// BGP peer get and delete key handle
type BGPPeerKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerKeyHandle_Id
	//	*BGPPeerKeyHandle_Key
	IdOrKey              isBGPPeerKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *BGPPeerKeyHandle) Reset()         { *m = BGPPeerKeyHandle{} }
func (m *BGPPeerKeyHandle) String() string { return proto.CompactTextString(m) }
func (*BGPPeerKeyHandle) ProtoMessage()    {}
func (*BGPPeerKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{19}
}
func (m *BGPPeerKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerKeyHandle.Merge(m, src)
}
func (m *BGPPeerKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerKeyHandle proto.InternalMessageInfo

type isBGPPeerKeyHandle_IdOrKey interface {
	isBGPPeerKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerKeyHandle_Key struct {
	Key *BGPPeerKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*BGPPeerKeyHandle_Id) isBGPPeerKeyHandle_IdOrKey()  {}
func (*BGPPeerKeyHandle_Key) isBGPPeerKeyHandle_IdOrKey() {}

func (m *BGPPeerKeyHandle) GetIdOrKey() isBGPPeerKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetKey() *BGPPeerKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BGPPeerKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BGPPeerKeyHandle_Id)(nil),
		(*BGPPeerKeyHandle_Key)(nil),
	}
}

// BGP peer delete request
type BGPPeerDeleteRequest struct {
	Request              []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BGPPeerDeleteRequest) Reset()         { *m = BGPPeerDeleteRequest{} }
func (m *BGPPeerDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerDeleteRequest) ProtoMessage()    {}
func (*BGPPeerDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{20}
}
func (m *BGPPeerDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerDeleteRequest.Merge(m, src)
}
func (m *BGPPeerDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerDeleteRequest proto.InternalMessageInfo

func (m *BGPPeerDeleteRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPPeerDeleteResponse) Reset()         { *m = BGPPeerDeleteResponse{} }
func (m *BGPPeerDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerDeleteResponse) ProtoMessage()    {}
func (*BGPPeerDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{21}
}
func (m *BGPPeerDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerDeleteResponse.Merge(m, src)
}
func (m *BGPPeerDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerDeleteResponse proto.InternalMessageInfo

func (m *BGPPeerDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer get request
type BGPPeerGetRequest struct {
	Request              []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BGPPeerGetRequest) Reset()         { *m = BGPPeerGetRequest{} }
func (m *BGPPeerGetRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerGetRequest) ProtoMessage()    {}
func (*BGPPeerGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{22}
}
func (m *BGPPeerGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerGetRequest.Merge(m, src)
}
func (m *BGPPeerGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerGetRequest proto.InternalMessageInfo

func (m *BGPPeerGetRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF configurations
type BGPPeerAfSpec struct {
	// unique key/identifier of peer AF config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,2,opt,name=LocalAddr,proto3" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,3,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,4,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty" meta:mandatory,immutable`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,5,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty" meta:mandatory,immutable`
	// enforce this router to set self as next-hop for advertised routes
	NexthopSelf bool `protobuf:"varint,6,opt,name=NexthopSelf,proto3" json:"NexthopSelf,omitempty"`
	// originate a default route to this peer
	DefaultOrig bool `protobuf:"varint,7,opt,name=DefaultOrig,proto3" json:"DefaultOrig,omitempty"`
	// The local port configured for the peering session
	LocalPort uint32 `protobuf:"varint,8,opt,name=LocalPort,proto3" json:"LocalPort,omitempty"`
	// The remote port configured for the peering session
	RemotePort uint32 `protobuf:"varint,9,opt,name=RemotePort,proto3" json:"RemotePort,omitempty"`
	// For a peer identified by a link-local IPv6 addresses, this is the scope ID
	// of bgpPeerLocalAddr and bgpPeerRemoteAddr. For a peer identified only by
	// interface (bgpPeerLocalAddr and bgpPeerRemoteAddr are both zero), this is
	// the interface index of the local point-to-point interface through which the
	// peer is reachable
	LocalAddrScopeId     uint32   `protobuf:"varint,10,opt,name=LocalAddrScopeId,proto3" json:"LocalAddrScopeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPPeerAfSpec) Reset()         { *m = BGPPeerAfSpec{} }
func (m *BGPPeerAfSpec) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfSpec) ProtoMessage()    {}
func (*BGPPeerAfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{23}
}
func (m *BGPPeerAfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfSpec.Merge(m, src)
}
func (m *BGPPeerAfSpec) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfSpec proto.InternalMessageInfo

func (m *BGPPeerAfSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerAfSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfSpec) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPPeerAfSpec) GetNexthopSelf() bool {
	if m != nil {
		return m.NexthopSelf
	}
	return false
}

func (m *BGPPeerAfSpec) GetDefaultOrig() bool {
	if m != nil {
		return m.DefaultOrig
	}
	return false
}

func (m *BGPPeerAfSpec) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *BGPPeerAfSpec) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

func (m *BGPPeerAfSpec) GetLocalAddrScopeId() uint32 {
	if m != nil {
		return m.LocalAddrScopeId
	}
	return 0
}

// BGP peer AF status
type BGPPeerAfStatus struct {
	// BGP The index of the update group that the peer is a member of for
	// this AFI/SAFI
	UpdateGroup uint32 `protobuf:"varint,1,opt,name=UpdateGroup,proto3" json:"UpdateGroup,omitempty"`
	// For a peer identified by a link-local IPv6 addresses, this is the scope ID
	// of bgpPeerLocalAddr and bgpPeerRemoteAddr. For a peer
	LocalAddrScopeId uint32 `protobuf:"varint,2,opt,name=LocalAddrScopeId,proto3" json:"LocalAddrScopeId,omitempty"`
	// send a Route Refresh request to the peer for this AFI/SAFI.
	RtRefresh bool `protobuf:"varint,3,opt,name=RtRefresh,proto3" json:"RtRefresh,omitempty"`
	//The BGP additional path capability negotiated with this peer for
	//this AFI/SAFI.
	AddPathCapNeg BgpAddPathCapNegCap `protobuf:"varint,4,opt,name=AddPathCapNeg,proto3,enum=pds.BgpAddPathCapNegCap" json:"AddPathCapNeg,omitempty"`
	// This value indicates whether the given peer is a reflector client of this
	// router for this AFI/SAFI, or not
	ReflectorClient      BGPPeerRRClient `protobuf:"varint,5,opt,name=ReflectorClient,proto3,enum=pds.BGPPeerRRClient" json:"ReflectorClient,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BGPPeerAfStatus) Reset()         { *m = BGPPeerAfStatus{} }
func (m *BGPPeerAfStatus) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfStatus) ProtoMessage()    {}
func (*BGPPeerAfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{24}
}
func (m *BGPPeerAfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfStatus.Merge(m, src)
}
func (m *BGPPeerAfStatus) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfStatus proto.InternalMessageInfo

func (m *BGPPeerAfStatus) GetUpdateGroup() uint32 {
	if m != nil {
		return m.UpdateGroup
	}
	return 0
}

func (m *BGPPeerAfStatus) GetLocalAddrScopeId() uint32 {
	if m != nil {
		return m.LocalAddrScopeId
	}
	return 0
}

func (m *BGPPeerAfStatus) GetRtRefresh() bool {
	if m != nil {
		return m.RtRefresh
	}
	return false
}

func (m *BGPPeerAfStatus) GetAddPathCapNeg() BgpAddPathCapNegCap {
	if m != nil {
		return m.AddPathCapNeg
	}
	return BgpAddPathCapNegCap_BGP_ADD_PATH_SR_DISABLE
}

func (m *BGPPeerAfStatus) GetReflectorClient() BGPPeerRRClient {
	if m != nil {
		return m.ReflectorClient
	}
	return BGPPeerRRClient_BGP_PEER_RR_NONE
}

// BGP peer AF object
type BGPPeerAf struct {
	Spec                 *BGPPeerAfSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *BGPPeerAfStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BGPPeerAf) Reset()         { *m = BGPPeerAf{} }
func (m *BGPPeerAf) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAf) ProtoMessage()    {}
func (*BGPPeerAf) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{25}
}
func (m *BGPPeerAf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAf.Merge(m, src)
}
func (m *BGPPeerAf) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAf) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAf.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAf proto.InternalMessageInfo

func (m *BGPPeerAf) GetSpec() *BGPPeerAfSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeerAf) GetStatus() *BGPPeerAfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer AF create and update response
type BGPPeerAfResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPPeerAfResponse) Reset()         { *m = BGPPeerAfResponse{} }
func (m *BGPPeerAfResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfResponse) ProtoMessage()    {}
func (*BGPPeerAfResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{26}
}
func (m *BGPPeerAfResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfResponse.Merge(m, src)
}
func (m *BGPPeerAfResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfResponse proto.InternalMessageInfo

func (m *BGPPeerAfResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer AF create and update request
type BGPPeerAfRequest struct {
	Request              []*BGPPeerAfSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BGPPeerAfRequest) Reset()         { *m = BGPPeerAfRequest{} }
func (m *BGPPeerAfRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfRequest) ProtoMessage()    {}
func (*BGPPeerAfRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{27}
}
func (m *BGPPeerAfRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfRequest.Merge(m, src)
}
func (m *BGPPeerAfRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfRequest proto.InternalMessageInfo

func (m *BGPPeerAfRequest) GetRequest() []*BGPPeerAfSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer key parameters
type BGPPeerAfKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr,proto3" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi                 BGPSafi  `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPPeerAfKey) Reset()         { *m = BGPPeerAfKey{} }
func (m *BGPPeerAfKey) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfKey) ProtoMessage()    {}
func (*BGPPeerAfKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{28}
}
func (m *BGPPeerAfKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfKey.Merge(m, src)
}
func (m *BGPPeerAfKey) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfKey.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfKey proto.InternalMessageInfo

func (m *BGPPeerAfKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

// BGP peer delete spec
type BGPPeerAfKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerAfKeyHandle_Id
	//	*BGPPeerAfKeyHandle_Key
	IdOrKey              isBGPPeerAfKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *BGPPeerAfKeyHandle) Reset()         { *m = BGPPeerAfKeyHandle{} }
func (m *BGPPeerAfKeyHandle) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfKeyHandle) ProtoMessage()    {}
func (*BGPPeerAfKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{29}
}
func (m *BGPPeerAfKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfKeyHandle.Merge(m, src)
}
func (m *BGPPeerAfKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfKeyHandle proto.InternalMessageInfo

type isBGPPeerAfKeyHandle_IdOrKey interface {
	isBGPPeerAfKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerAfKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerAfKeyHandle_Key struct {
	Key *BGPPeerAfKey `protobuf:"bytes,2,opt,name=Key,proto3,oneof"`
}

func (*BGPPeerAfKeyHandle_Id) isBGPPeerAfKeyHandle_IdOrKey()  {}
func (*BGPPeerAfKeyHandle_Key) isBGPPeerAfKeyHandle_IdOrKey() {}

func (m *BGPPeerAfKeyHandle) GetIdOrKey() isBGPPeerAfKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetKey() *BGPPeerAfKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BGPPeerAfKeyHandle) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BGPPeerAfKeyHandle_Id)(nil),
		(*BGPPeerAfKeyHandle_Key)(nil),
	}
}

// BGP peer af delete request
type BGPPeerAfDeleteRequest struct {
	Request              []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *BGPPeerAfDeleteRequest) Reset()         { *m = BGPPeerAfDeleteRequest{} }
func (m *BGPPeerAfDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteRequest) ProtoMessage()    {}
func (*BGPPeerAfDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{30}
}
func (m *BGPPeerAfDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfDeleteRequest.Merge(m, src)
}
func (m *BGPPeerAfDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfDeleteRequest proto.InternalMessageInfo

func (m *BGPPeerAfDeleteRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerAfDeleteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPPeerAfDeleteResponse) Reset()         { *m = BGPPeerAfDeleteResponse{} }
func (m *BGPPeerAfDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteResponse) ProtoMessage()    {}
func (*BGPPeerAfDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{31}
}
func (m *BGPPeerAfDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfDeleteResponse.Merge(m, src)
}
func (m *BGPPeerAfDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfDeleteResponse proto.InternalMessageInfo

func (m *BGPPeerAfDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer af get request
type BGPPeerAfGetRequest struct {
	Request              []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *BGPPeerAfGetRequest) Reset()         { *m = BGPPeerAfGetRequest{} }
func (m *BGPPeerAfGetRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfGetRequest) ProtoMessage()    {}
func (*BGPPeerAfGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{32}
}
func (m *BGPPeerAfGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfGetRequest.Merge(m, src)
}
func (m *BGPPeerAfGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfGetRequest proto.InternalMessageInfo

func (m *BGPPeerAfGetRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF get response
type BGPPeerAfGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*BGPPeerAf `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BGPPeerAfGetResponse) Reset()         { *m = BGPPeerAfGetResponse{} }
func (m *BGPPeerAfGetResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPeerAfGetResponse) ProtoMessage()    {}
func (*BGPPeerAfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{33}
}
func (m *BGPPeerAfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerAfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPeerAfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPeerAfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerAfGetResponse.Merge(m, src)
}
func (m *BGPPeerAfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerAfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerAfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerAfGetResponse proto.InternalMessageInfo

func (m *BGPPeerAfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerAfGetResponse) GetResponse() []*BGPPeerAf {
	if m != nil {
		return m.Response
	}
	return nil
}

type BGPClearRouteRequest struct {
	// clear route options
	Option BGPClearRouteOptions `protobuf:"varint,1,opt,name=Option,proto3,enum=pds.BGPClearRouteOptions" json:"Option,omitempty"`
	// Types that are valid to be assigned to PeerOrPeeraf:
	//	*BGPClearRouteRequest_Peer
	//	*BGPClearRouteRequest_PeerAf
	PeerOrPeeraf         isBGPClearRouteRequest_PeerOrPeeraf `protobuf_oneof:"peer_or_peeraf"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *BGPClearRouteRequest) Reset()         { *m = BGPClearRouteRequest{} }
func (m *BGPClearRouteRequest) String() string { return proto.CompactTextString(m) }
func (*BGPClearRouteRequest) ProtoMessage()    {}
func (*BGPClearRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{34}
}
func (m *BGPClearRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPClearRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPClearRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPClearRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPClearRouteRequest.Merge(m, src)
}
func (m *BGPClearRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPClearRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPClearRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPClearRouteRequest proto.InternalMessageInfo

type isBGPClearRouteRequest_PeerOrPeeraf interface {
	isBGPClearRouteRequest_PeerOrPeeraf()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPClearRouteRequest_Peer struct {
	Peer *BGPPeerKeyHandle `protobuf:"bytes,2,opt,name=Peer,proto3,oneof"`
}
type BGPClearRouteRequest_PeerAf struct {
	PeerAf *BGPPeerAfKeyHandle `protobuf:"bytes,3,opt,name=PeerAf,proto3,oneof"`
}

func (*BGPClearRouteRequest_Peer) isBGPClearRouteRequest_PeerOrPeeraf()   {}
func (*BGPClearRouteRequest_PeerAf) isBGPClearRouteRequest_PeerOrPeeraf() {}

func (m *BGPClearRouteRequest) GetPeerOrPeeraf() isBGPClearRouteRequest_PeerOrPeeraf {
	if m != nil {
		return m.PeerOrPeeraf
	}
	return nil
}

func (m *BGPClearRouteRequest) GetOption() BGPClearRouteOptions {
	if m != nil {
		return m.Option
	}
	return BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE
}

func (m *BGPClearRouteRequest) GetPeer() *BGPPeerKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_Peer); ok {
		return x.Peer
	}
	return nil
}

func (m *BGPClearRouteRequest) GetPeerAf() *BGPPeerAfKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_PeerAf); ok {
		return x.PeerAf
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BGPClearRouteRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BGPClearRouteRequest_Peer)(nil),
		(*BGPClearRouteRequest_PeerAf)(nil),
	}
}

// BGP clear route response
type BGPClearRouteResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BGPClearRouteResponse) Reset()         { *m = BGPClearRouteResponse{} }
func (m *BGPClearRouteResponse) String() string { return proto.CompactTextString(m) }
func (*BGPClearRouteResponse) ProtoMessage()    {}
func (*BGPClearRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{35}
}
func (m *BGPClearRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPClearRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPClearRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPClearRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPClearRouteResponse.Merge(m, src)
}
func (m *BGPClearRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPClearRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPClearRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPClearRouteResponse proto.InternalMessageInfo

func (m *BGPClearRouteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP NLRI prefix table
type BGPNLRIPrefixStatus struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID uint32 `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
	// chosen as BGP best route or not
	BestRoute bool `protobuf:"varint,8,opt,name=BestRoute,proto3" json:"BestRoute,omitempty"`
	// AS path string
	ASPathStr []byte `protobuf:"bytes,9,opt,name=ASPathStr,proto3" json:"ASPathStr,omitempty"`
	// originator ID
	PathOrigId []byte `protobuf:"bytes,10,opt,name=PathOrigId,proto3" json:"PathOrigId,omitempty"`
	// next-hop address
	NextHopAddr []byte `protobuf:"bytes,11,opt,name=NextHopAddr,proto3" json:"NextHopAddr,omitempty"`
	// Size of each ASN in the AS path string
	ASSize BGPASSize `protobuf:"varint,12,opt,name=ASSize,proto3,enum=pds.BGPASSize" json:"ASSize,omitempty"`
	// Is this route part of an ECMP set
	EcmpRoute bool `protobuf:"varint,13,opt,name=EcmpRoute,proto3" json:"EcmpRoute,omitempty"`
	// Peer IP
	PeerAddr *IPAddress `protobuf:"bytes,14,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty"`
	// The number of times this route has flapped since statistics were last cleared.
	FlapStatsFlapcnt uint32 `protobuf:"varint,15,opt,name=FlapStatsFlapcnt,proto3" json:"FlapStatsFlapcnt,omitempty"`
	// Whether or not this route is suppressed.
	FlapStatsSupprsd bool `protobuf:"varint,16,opt,name=FlapStatsSupprsd,proto3" json:"FlapStatsSupprsd,omitempty"`
	// An indication of whether or not this route is installed in the forwarding table
	IsActive BGPNLRIIsActive `protobuf:"varint,17,opt,name=IsActive,proto3,enum=pds.BGPNLRIIsActive" json:"IsActive,omitempty"`
	// Whether or not this route was last sent by the peer before BGP detected that the peer was restarting.
	Stale bool `protobuf:"varint,18,opt,name=Stale,proto3" json:"Stale,omitempty"`
	// The value of sysUpTime when this route flapped
	FlapStartTime uint32 `protobuf:"varint,19,opt,name=FlapStartTime,proto3" json:"FlapStartTime,omitempty"`
	// If bgpNlriPrefixBest is 'true', then this field is set to 'routeIsBest'.  Otherwise, it reports the stage in the decision process when the route was determined to be non-best.
	ReasonNotBest BGPRsnNotBest `protobuf:"varint,20,opt,name=ReasonNotBest,proto3,enum=pds.BGPRsnNotBest" json:"ReasonNotBest,omitempty"`
	// The extended community membership associated with the route after import policy has been applied.
	ExtComm              [][]byte `protobuf:"bytes,21,rep,name=ExtComm,proto3" json:"ExtComm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPNLRIPrefixStatus) Reset()         { *m = BGPNLRIPrefixStatus{} }
func (m *BGPNLRIPrefixStatus) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixStatus) ProtoMessage()    {}
func (*BGPNLRIPrefixStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{36}
}
func (m *BGPNLRIPrefixStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixStatus.Merge(m, src)
}
func (m *BGPNLRIPrefixStatus) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixStatus proto.InternalMessageInfo

func (m *BGPNLRIPrefixStatus) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixStatus) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetBestRoute() bool {
	if m != nil {
		return m.BestRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetASPathStr() []byte {
	if m != nil {
		return m.ASPathStr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPathOrigId() []byte {
	if m != nil {
		return m.PathOrigId
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetNextHopAddr() []byte {
	if m != nil {
		return m.NextHopAddr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetASSize() BGPASSize {
	if m != nil {
		return m.ASSize
	}
	return BGPASSize_BGP_AS_SIZE_NONE
}

func (m *BGPNLRIPrefixStatus) GetEcmpRoute() bool {
	if m != nil {
		return m.EcmpRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetFlapStatsFlapcnt() uint32 {
	if m != nil {
		return m.FlapStatsFlapcnt
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetFlapStatsSupprsd() bool {
	if m != nil {
		return m.FlapStatsSupprsd
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetIsActive() BGPNLRIIsActive {
	if m != nil {
		return m.IsActive
	}
	return BGPNLRIIsActive_BGP_NLRI_ISA_NONE
}

func (m *BGPNLRIPrefixStatus) GetStale() bool {
	if m != nil {
		return m.Stale
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetFlapStartTime() uint32 {
	if m != nil {
		return m.FlapStartTime
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetReasonNotBest() BGPRsnNotBest {
	if m != nil {
		return m.ReasonNotBest
	}
	return BGPRsnNotBest_BGP_REASON_NOT_CONSIDERED
}

func (m *BGPNLRIPrefixStatus) GetExtComm() [][]byte {
	if m != nil {
		return m.ExtComm
	}
	return nil
}

// BGP NLRI prefix key object
type BGPNLRIPrefixKey struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID               uint32   `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPNLRIPrefixKey) Reset()         { *m = BGPNLRIPrefixKey{} }
func (m *BGPNLRIPrefixKey) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKey) ProtoMessage()    {}
func (*BGPNLRIPrefixKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{37}
}
func (m *BGPNLRIPrefixKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixKey.Merge(m, src)
}
func (m *BGPNLRIPrefixKey) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixKey.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixKey proto.InternalMessageInfo

func (m *BGPNLRIPrefixKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixKey) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixKey) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixKey) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

// BGP NLRI prefix filter object
type BGPNLRIPrefixFilter struct {
	// filter based on extended communities
	ExtComm []byte `protobuf:"bytes,1,opt,name=ExtComm,proto3" json:"ExtComm,omitempty"`
	// filter based on l2vni/l3vni
	Vnid uint32 `protobuf:"varint,2,opt,name=Vnid,proto3" json:"Vnid,omitempty"`
	// filter based on route type
	RouteType uint32 `protobuf:"varint,3,opt,name=RouteType,proto3" json:"RouteType,omitempty"`
	// filter based on next-hop address
	NextHop *IPAddress `protobuf:"bytes,4,opt,name=NextHop,proto3" json:"NextHop,omitempty"`
	// filter based on ip address
	IPAddress *IPAddress `protobuf:"bytes,5,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	// filter to include only best routes
	Best                 bool     `protobuf:"varint,6,opt,name=Best,proto3" json:"Best,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPNLRIPrefixFilter) Reset()         { *m = BGPNLRIPrefixFilter{} }
func (m *BGPNLRIPrefixFilter) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixFilter) ProtoMessage()    {}
func (*BGPNLRIPrefixFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{38}
}
func (m *BGPNLRIPrefixFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixFilter.Merge(m, src)
}
func (m *BGPNLRIPrefixFilter) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixFilter proto.InternalMessageInfo

func (m *BGPNLRIPrefixFilter) GetExtComm() []byte {
	if m != nil {
		return m.ExtComm
	}
	return nil
}

func (m *BGPNLRIPrefixFilter) GetVnid() uint32 {
	if m != nil {
		return m.Vnid
	}
	return 0
}

func (m *BGPNLRIPrefixFilter) GetRouteType() uint32 {
	if m != nil {
		return m.RouteType
	}
	return 0
}

func (m *BGPNLRIPrefixFilter) GetNextHop() *IPAddress {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func (m *BGPNLRIPrefixFilter) GetIPAddress() *IPAddress {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *BGPNLRIPrefixFilter) GetBest() bool {
	if m != nil {
		return m.Best
	}
	return false
}

// BGP NLRI prefix object
type BGPNLRIPrefix struct {
	Status               *BGPNLRIPrefixStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *BGPNLRIPrefix) Reset()         { *m = BGPNLRIPrefix{} }
func (m *BGPNLRIPrefix) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefix) ProtoMessage()    {}
func (*BGPNLRIPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{39}
}
func (m *BGPNLRIPrefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefix.Merge(m, src)
}
func (m *BGPNLRIPrefix) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefix proto.InternalMessageInfo

func (m *BGPNLRIPrefix) GetStatus() *BGPNLRIPrefixStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP NLRI prefix get response
type BGPNLRIPrefixGetResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*BGPNLRIPrefix `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BGPNLRIPrefixGetResponse) Reset()         { *m = BGPNLRIPrefixGetResponse{} }
func (m *BGPNLRIPrefixGetResponse) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetResponse) ProtoMessage()    {}
func (*BGPNLRIPrefixGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{40}
}
func (m *BGPNLRIPrefixGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixGetResponse.Merge(m, src)
}
func (m *BGPNLRIPrefixGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixGetResponse proto.InternalMessageInfo

func (m *BGPNLRIPrefixGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPNLRIPrefixGetResponse) GetResponse() []*BGPNLRIPrefix {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP NLRI key handle
type BGPNLRIPrefixKeyHandle struct {
	Key                  *BGPNLRIPrefixKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BGPNLRIPrefixKeyHandle) Reset()         { *m = BGPNLRIPrefixKeyHandle{} }
func (m *BGPNLRIPrefixKeyHandle) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKeyHandle) ProtoMessage()    {}
func (*BGPNLRIPrefixKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{41}
}
func (m *BGPNLRIPrefixKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixKeyHandle.Merge(m, src)
}
func (m *BGPNLRIPrefixKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixKeyHandle proto.InternalMessageInfo

func (m *BGPNLRIPrefixKeyHandle) GetKey() *BGPNLRIPrefixKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGPNLRIPrefix GET Requests
type BGPNLRIPrefixGetRequests struct {
	Request              []*BGPNLRIPrefixKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *BGPNLRIPrefixGetRequests) Reset()         { *m = BGPNLRIPrefixGetRequests{} }
func (m *BGPNLRIPrefixGetRequests) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetRequests) ProtoMessage()    {}
func (*BGPNLRIPrefixGetRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{42}
}
func (m *BGPNLRIPrefixGetRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixGetRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixGetRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixGetRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixGetRequests.Merge(m, src)
}
func (m *BGPNLRIPrefixGetRequests) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixGetRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixGetRequests.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixGetRequests proto.InternalMessageInfo

func (m *BGPNLRIPrefixGetRequests) GetRequest() []*BGPNLRIPrefixKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP NLRI prefix get request
type BGPNLRIPrefixGetRequest struct {
	// Types that are valid to be assigned to RequestsOrFilter:
	//	*BGPNLRIPrefixGetRequest_Requests
	//	*BGPNLRIPrefixGetRequest_Filter
	RequestsOrFilter     isBGPNLRIPrefixGetRequest_RequestsOrFilter `protobuf_oneof:"requests_or_filter"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *BGPNLRIPrefixGetRequest) Reset()         { *m = BGPNLRIPrefixGetRequest{} }
func (m *BGPNLRIPrefixGetRequest) String() string { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetRequest) ProtoMessage()    {}
func (*BGPNLRIPrefixGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{43}
}
func (m *BGPNLRIPrefixGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPNLRIPrefixGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPNLRIPrefixGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPNLRIPrefixGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPNLRIPrefixGetRequest.Merge(m, src)
}
func (m *BGPNLRIPrefixGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPNLRIPrefixGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPNLRIPrefixGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPNLRIPrefixGetRequest proto.InternalMessageInfo

type isBGPNLRIPrefixGetRequest_RequestsOrFilter interface {
	isBGPNLRIPrefixGetRequest_RequestsOrFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPNLRIPrefixGetRequest_Requests struct {
	Requests *BGPNLRIPrefixGetRequests `protobuf:"bytes,1,opt,name=Requests,proto3,oneof"`
}
type BGPNLRIPrefixGetRequest_Filter struct {
	Filter *BGPNLRIPrefixFilter `protobuf:"bytes,2,opt,name=Filter,proto3,oneof"`
}

func (*BGPNLRIPrefixGetRequest_Requests) isBGPNLRIPrefixGetRequest_RequestsOrFilter() {}
func (*BGPNLRIPrefixGetRequest_Filter) isBGPNLRIPrefixGetRequest_RequestsOrFilter()   {}

func (m *BGPNLRIPrefixGetRequest) GetRequestsOrFilter() isBGPNLRIPrefixGetRequest_RequestsOrFilter {
	if m != nil {
		return m.RequestsOrFilter
	}
	return nil
}

func (m *BGPNLRIPrefixGetRequest) GetRequests() *BGPNLRIPrefixGetRequests {
	if x, ok := m.GetRequestsOrFilter().(*BGPNLRIPrefixGetRequest_Requests); ok {
		return x.Requests
	}
	return nil
}

func (m *BGPNLRIPrefixGetRequest) GetFilter() *BGPNLRIPrefixFilter {
	if x, ok := m.GetRequestsOrFilter().(*BGPNLRIPrefixGetRequest_Filter); ok {
		return x.Filter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BGPNLRIPrefixGetRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BGPNLRIPrefixGetRequest_Requests)(nil),
		(*BGPNLRIPrefixGetRequest_Filter)(nil),
	}
}

// BGP PrfxCntrs table
type BGPPrfxCntrsStatus struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The peer index
	PeerIndex uint32 `protobuf:"varint,2,opt,name=PeerIndex,proto3" json:"PeerIndex,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// The number of prefixes received from a peer and are stored in the Adj-RIB-In for that peer.
	InPrfxes uint32 `protobuf:"varint,5,opt,name=InPrfxes,proto3" json:"InPrfxes,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are eligible to become active in the Loc-Rib
	InPrfxesAccepted uint32 `protobuf:"varint,6,opt,name=InPrfxesAccepted,proto3" json:"InPrfxesAccepted,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are NOT eligible to become active in the Loc-Rib
	InPrfxesRejected uint32 `protobuf:"varint,7,opt,name=InPrfxesRejected,proto3" json:"InPrfxesRejected,omitempty"`
	// The number of prefixes for a peer that are installed in that peer's Adj-RIB-Out.
	OutPrfxes uint32 `protobuf:"varint,8,opt,name=OutPrfxes,proto3" json:"OutPrfxes,omitempty"`
	// The number of advertised prefixes currently associated with the peer
	OutPrfxesAdvertised uint32 `protobuf:"varint,9,opt,name=OutPrfxesAdvertised,proto3" json:"OutPrfxesAdvertised,omitempty"`
	// User data for this BGP prefix counters entry
	UserData string `protobuf:"bytes,10,opt,name=UserData,proto3" json:"UserData,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and for which RIB Manager is tracking a route flap damping penalty.
	InPrfxesFlapped uint32 `protobuf:"varint,11,opt,name=InPrfxesFlapped,proto3" json:"InPrfxesFlapped,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and that are suppressed as a result of route flapping.
	InPrfxesFlapSuppressed uint32 `protobuf:"varint,12,opt,name=InPrfxesFlapSuppressed,proto3" json:"InPrfxesFlapSuppressed,omitempty"`
	// The number of prefixes for a peer that are not currently in the Adj-RIB-In, but which have an associated route flap damping penalty
	InPrfxesFlapHistory uint32 `protobuf:"varint,13,opt,name=InPrfxesFlapHistory,proto3" json:"InPrfxesFlapHistory,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are marked as 'active' in the Loc-Rib.
	InPrfxesActive uint32 `protobuf:"varint,14,opt,name=InPrfxesActive,proto3" json:"InPrfxesActive,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because of local filter policy
	InPrfxesDeniedByPol uint32 `protobuf:"varint,15,opt,name=InPrfxesDeniedByPol,proto3" json:"InPrfxesDeniedByPol,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and included in the Loc-RIB
	NumLocRibRoutes uint32 `protobuf:"varint,16,opt,name=NumLocRibRoutes,proto3" json:"NumLocRibRoutes,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and included in the Loc-RIB as 'best' routes
	NumLocRibBestRoutes uint32 `protobuf:"varint,17,opt,name=NumLocRibBestRoutes,proto3" json:"NumLocRibBestRoutes,omitempty"`
	// The number of times a received Martian prefix has been denied and therefore not installed in the Adj-RIB-In
	InPrfxesDeniedMartian uint32 `protobuf:"varint,18,opt,name=InPrfxesDeniedMartian,proto3" json:"InPrfxesDeniedMartian,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, due to loops as determined by the AS Path
	InPrfxesDeniedAsLoop uint32 `protobuf:"varint,19,opt,name=InPrfxesDeniedAsLoop,proto3" json:"InPrfxesDeniedAsLoop,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because the next hop is invalid
	InPrfxesDeniedNextHop uint32 `protobuf:"varint,20,opt,name=InPrfxesDeniedNextHop,proto3" json:"InPrfxesDeniedNextHop,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because the AS Path length is too long
	InPrfxesDeniedAsLength uint32 `protobuf:"varint,21,opt,name=InPrfxesDeniedAsLength,proto3" json:"InPrfxesDeniedAsLength,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, due to well-known community checks
	InPrfxesDeniedCommunity uint32 `protobuf:"varint,22,opt,name=InPrfxesDeniedCommunity,proto3" json:"InPrfxesDeniedCommunity,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because it is locally originated
	InPrfxesDeniedLocalOrig uint32 `protobuf:"varint,23,opt,name=InPrfxesDeniedLocalOrig,proto3" json:"InPrfxesDeniedLocalOrig,omitempty"`
	// The total number of prefixes learned from all sessions with this peer
	InTotalPrfxes uint32 `protobuf:"varint,24,opt,name=InTotalPrfxes,proto3" json:"InTotalPrfxes,omitempty"`
	// The total number of prefixes sent on all sessions with this peer
	OutTotalPrfxes uint32 `protobuf:"varint,25,opt,name=OutTotalPrfxes,proto3" json:"OutTotalPrfxes,omitempty"`
	// The BGP peer's FSM state
	PeerState BGPPeerState `protobuf:"varint,26,opt,name=PeerState,proto3,enum=pds.BGPPeerState" json:"PeerState,omitempty"`
	// This is the number of prefixes in the Loc-RIB that have have failed export policy checks and so have not been installed in the Adj-RIB-Out
	OutPrfxesDenied uint32 `protobuf:"varint,27,opt,name=OutPrfxesDenied,proto3" json:"OutPrfxesDenied,omitempty"`
	// The total number of routes for which an implicit withdraw has been sent to this peer
	OutPrfxesImpWdr uint32 `protobuf:"varint,28,opt,name=OutPrfxesImpWdr,proto3" json:"OutPrfxesImpWdr,omitempty"`
	// The total number of routes for which an explicit withdraw has been sent to this peer
	OutPrfxesExpWdr uint32 `protobuf:"varint,29,opt,name=OutPrfxesExpWdr,proto3" json:"OutPrfxesExpWdr,omitempty"`
	// The total number of routes that have been implicitly withdrawn by this peer
	InPrfxesImpWdr uint32 `protobuf:"varint,30,opt,name=InPrfxesImpWdr,proto3" json:"InPrfxesImpWdr,omitempty"`
	// The total number of routes that have been explicitly withdrawn by this peer
	InPrfxesExpWdr uint32 `protobuf:"varint,31,opt,name=InPrfxesExpWdr,proto3" json:"InPrfxesExpWdr,omitempty"`
	// The number of stored prefixes from the peer that have failed import policy checks and so have not been installed in the Adj-RIB-In
	CurPrfxesDeniedByPol uint32   `protobuf:"varint,32,opt,name=CurPrfxesDeniedByPol,proto3" json:"CurPrfxesDeniedByPol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPPrfxCntrsStatus) Reset()         { *m = BGPPrfxCntrsStatus{} }
func (m *BGPPrfxCntrsStatus) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsStatus) ProtoMessage()    {}
func (*BGPPrfxCntrsStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{44}
}
func (m *BGPPrfxCntrsStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrsStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrsStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrsStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrsStatus.Merge(m, src)
}
func (m *BGPPrfxCntrsStatus) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrsStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrsStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrsStatus proto.InternalMessageInfo

func (m *BGPPrfxCntrsStatus) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetPeerIndex() uint32 {
	if m != nil {
		return m.PeerIndex
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPrfxCntrsStatus) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPPrfxCntrsStatus) GetInPrfxes() uint32 {
	if m != nil {
		return m.InPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesAccepted() uint32 {
	if m != nil {
		return m.InPrfxesAccepted
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesRejected() uint32 {
	if m != nil {
		return m.InPrfxesRejected
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxes() uint32 {
	if m != nil {
		return m.OutPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesAdvertised() uint32 {
	if m != nil {
		return m.OutPrfxesAdvertised
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetUserData() string {
	if m != nil {
		return m.UserData
	}
	return ""
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapped() uint32 {
	if m != nil {
		return m.InPrfxesFlapped
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapSuppressed() uint32 {
	if m != nil {
		return m.InPrfxesFlapSuppressed
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapHistory() uint32 {
	if m != nil {
		return m.InPrfxesFlapHistory
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesActive() uint32 {
	if m != nil {
		return m.InPrfxesActive
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedByPol() uint32 {
	if m != nil {
		return m.InPrfxesDeniedByPol
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetNumLocRibRoutes() uint32 {
	if m != nil {
		return m.NumLocRibRoutes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetNumLocRibBestRoutes() uint32 {
	if m != nil {
		return m.NumLocRibBestRoutes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedMartian() uint32 {
	if m != nil {
		return m.InPrfxesDeniedMartian
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedAsLoop() uint32 {
	if m != nil {
		return m.InPrfxesDeniedAsLoop
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedNextHop() uint32 {
	if m != nil {
		return m.InPrfxesDeniedNextHop
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedAsLength() uint32 {
	if m != nil {
		return m.InPrfxesDeniedAsLength
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedCommunity() uint32 {
	if m != nil {
		return m.InPrfxesDeniedCommunity
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedLocalOrig() uint32 {
	if m != nil {
		return m.InPrfxesDeniedLocalOrig
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInTotalPrfxes() uint32 {
	if m != nil {
		return m.InTotalPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutTotalPrfxes() uint32 {
	if m != nil {
		return m.OutTotalPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetPeerState() BGPPeerState {
	if m != nil {
		return m.PeerState
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesDenied() uint32 {
	if m != nil {
		return m.OutPrfxesDenied
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesImpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesImpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesExpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesExpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesImpWdr() uint32 {
	if m != nil {
		return m.InPrfxesImpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesExpWdr() uint32 {
	if m != nil {
		return m.InPrfxesExpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetCurPrfxesDeniedByPol() uint32 {
	if m != nil {
		return m.CurPrfxesDeniedByPol
	}
	return 0
}

// BGP PrfxCntrs key object
type BGPPrfxCntrsKey struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The peer index
	PeerIndex uint32 `protobuf:"varint,2,opt,name=PeerIndex,proto3" json:"PeerIndex,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi                 BGPSafi  `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPPrfxCntrsKey) Reset()         { *m = BGPPrfxCntrsKey{} }
func (m *BGPPrfxCntrsKey) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsKey) ProtoMessage()    {}
func (*BGPPrfxCntrsKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{45}
}
func (m *BGPPrfxCntrsKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrsKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrsKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrsKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrsKey.Merge(m, src)
}
func (m *BGPPrfxCntrsKey) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrsKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrsKey.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrsKey proto.InternalMessageInfo

func (m *BGPPrfxCntrsKey) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPPrfxCntrsKey) GetPeerIndex() uint32 {
	if m != nil {
		return m.PeerIndex
	}
	return 0
}

func (m *BGPPrfxCntrsKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPrfxCntrsKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

//BGP PrfxCntrs object
type BGPPrfxCntrs struct {
	Status               *BGPPrfxCntrsStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BGPPrfxCntrs) Reset()         { *m = BGPPrfxCntrs{} }
func (m *BGPPrfxCntrs) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrs) ProtoMessage()    {}
func (*BGPPrfxCntrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{46}
}
func (m *BGPPrfxCntrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrs.Merge(m, src)
}
func (m *BGPPrfxCntrs) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrs) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrs.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrs proto.InternalMessageInfo

func (m *BGPPrfxCntrs) GetStatus() *BGPPrfxCntrsStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP PrfxCntrs get response
type BGPPrfxCntrsGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*BGPPrfxCntrs `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BGPPrfxCntrsGetResponse) Reset()         { *m = BGPPrfxCntrsGetResponse{} }
func (m *BGPPrfxCntrsGetResponse) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsGetResponse) ProtoMessage()    {}
func (*BGPPrfxCntrsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{47}
}
func (m *BGPPrfxCntrsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrsGetResponse.Merge(m, src)
}
func (m *BGPPrfxCntrsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrsGetResponse proto.InternalMessageInfo

func (m *BGPPrfxCntrsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPrfxCntrsGetResponse) GetResponse() []*BGPPrfxCntrs {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP PrfxCntrs key handle
type BGPPrfxCntrsKeyHandle struct {
	Key                  *BGPPrfxCntrsKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BGPPrfxCntrsKeyHandle) Reset()         { *m = BGPPrfxCntrsKeyHandle{} }
func (m *BGPPrfxCntrsKeyHandle) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsKeyHandle) ProtoMessage()    {}
func (*BGPPrfxCntrsKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{48}
}
func (m *BGPPrfxCntrsKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrsKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrsKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrsKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrsKeyHandle.Merge(m, src)
}
func (m *BGPPrfxCntrsKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrsKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrsKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrsKeyHandle proto.InternalMessageInfo

func (m *BGPPrfxCntrsKeyHandle) GetKey() *BGPPrfxCntrsKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGP PrfxCntrs get request
type BGPPrfxCntrsGetRequest struct {
	Request              []*BGPPrfxCntrsKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *BGPPrfxCntrsGetRequest) Reset()         { *m = BGPPrfxCntrsGetRequest{} }
func (m *BGPPrfxCntrsGetRequest) String() string { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsGetRequest) ProtoMessage()    {}
func (*BGPPrfxCntrsGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e12fe45eec524a6, []int{49}
}
func (m *BGPPrfxCntrsGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPrfxCntrsGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPPrfxCntrsGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPPrfxCntrsGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPrfxCntrsGetRequest.Merge(m, src)
}
func (m *BGPPrfxCntrsGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *BGPPrfxCntrsGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPrfxCntrsGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPrfxCntrsGetRequest proto.InternalMessageInfo

func (m *BGPPrfxCntrsGetRequest) GetRequest() []*BGPPrfxCntrsKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.BGPAfi", BGPAfi_name, BGPAfi_value)
	proto.RegisterEnum("pds.BGPSafi", BGPSafi_name, BGPSafi_value)
	proto.RegisterEnum("pds.BGPPeerRRClient", BGPPeerRRClient_name, BGPPeerRRClient_value)
	proto.RegisterEnum("pds.BGPPeerState", BGPPeerState_name, BGPPeerState_value)
	proto.RegisterEnum("pds.BGPASSize", BGPASSize_name, BGPASSize_value)
	proto.RegisterEnum("pds.BGPAddrType", BGPAddrType_name, BGPAddrType_value)
	proto.RegisterEnum("pds.BGPOperStatus", BGPOperStatus_name, BGPOperStatus_value)
	proto.RegisterEnum("pds.BgpAddPathCapNegCap", BgpAddPathCapNegCap_name, BgpAddPathCapNegCap_value)
	proto.RegisterEnum("pds.BGPClearRouteOptions", BGPClearRouteOptions_name, BGPClearRouteOptions_value)
	proto.RegisterEnum("pds.NLRISrc", NLRISrc_name, NLRISrc_value)
	proto.RegisterEnum("pds.BGPNLRIIsActive", BGPNLRIIsActive_name, BGPNLRIIsActive_value)
	proto.RegisterEnum("pds.BGPRsnNotBest", BGPRsnNotBest_name, BGPRsnNotBest_value)
	proto.RegisterType((*BGPSpec)(nil), "pds.BGPSpec")
	proto.RegisterType((*BGPStatus)(nil), "pds.BGPStatus")
	proto.RegisterType((*BGPAfStats)(nil), "pds.BGPAfStats")
	proto.RegisterType((*BGPStats)(nil), "pds.BGPStats")
	proto.RegisterType((*BGP)(nil), "pds.BGP")
	proto.RegisterType((*BGPRequest)(nil), "pds.BGPRequest")
	proto.RegisterType((*BGPResponse)(nil), "pds.BGPResponse")
	proto.RegisterType((*BGPKeyHandle)(nil), "pds.BGPKeyHandle")
	proto.RegisterType((*BGPDeleteRequest)(nil), "pds.BGPDeleteRequest")
	proto.RegisterType((*BGPDeleteResponse)(nil), "pds.BGPDeleteResponse")
	proto.RegisterType((*BGPGetRequest)(nil), "pds.BGPGetRequest")
	proto.RegisterType((*BGPGetResponse)(nil), "pds.BGPGetResponse")
	proto.RegisterType((*BGPPeerSpec)(nil), "pds.BGPPeerSpec")
	proto.RegisterType((*BGPPeerStatus)(nil), "pds.BGPPeerStatus")
	proto.RegisterType((*BGPPeer)(nil), "pds.BGPPeer")
	proto.RegisterType((*BGPPeerResponse)(nil), "pds.BGPPeerResponse")
	proto.RegisterType((*BGPPeerRequest)(nil), "pds.BGPPeerRequest")
	proto.RegisterType((*BGPPeerGetResponse)(nil), "pds.BGPPeerGetResponse")
	proto.RegisterType((*BGPPeerKey)(nil), "pds.BGPPeerKey")
	proto.RegisterType((*BGPPeerKeyHandle)(nil), "pds.BGPPeerKeyHandle")
	proto.RegisterType((*BGPPeerDeleteRequest)(nil), "pds.BGPPeerDeleteRequest")
	proto.RegisterType((*BGPPeerDeleteResponse)(nil), "pds.BGPPeerDeleteResponse")
	proto.RegisterType((*BGPPeerGetRequest)(nil), "pds.BGPPeerGetRequest")
	proto.RegisterType((*BGPPeerAfSpec)(nil), "pds.BGPPeerAfSpec")
	proto.RegisterType((*BGPPeerAfStatus)(nil), "pds.BGPPeerAfStatus")
	proto.RegisterType((*BGPPeerAf)(nil), "pds.BGPPeerAf")
	proto.RegisterType((*BGPPeerAfResponse)(nil), "pds.BGPPeerAfResponse")
	proto.RegisterType((*BGPPeerAfRequest)(nil), "pds.BGPPeerAfRequest")
	proto.RegisterType((*BGPPeerAfKey)(nil), "pds.BGPPeerAfKey")
	proto.RegisterType((*BGPPeerAfKeyHandle)(nil), "pds.BGPPeerAfKeyHandle")
	proto.RegisterType((*BGPPeerAfDeleteRequest)(nil), "pds.BGPPeerAfDeleteRequest")
	proto.RegisterType((*BGPPeerAfDeleteResponse)(nil), "pds.BGPPeerAfDeleteResponse")
	proto.RegisterType((*BGPPeerAfGetRequest)(nil), "pds.BGPPeerAfGetRequest")
	proto.RegisterType((*BGPPeerAfGetResponse)(nil), "pds.BGPPeerAfGetResponse")
	proto.RegisterType((*BGPClearRouteRequest)(nil), "pds.BGPClearRouteRequest")
	proto.RegisterType((*BGPClearRouteResponse)(nil), "pds.BGPClearRouteResponse")
	proto.RegisterType((*BGPNLRIPrefixStatus)(nil), "pds.BGPNLRIPrefixStatus")
	proto.RegisterType((*BGPNLRIPrefixKey)(nil), "pds.BGPNLRIPrefixKey")
	proto.RegisterType((*BGPNLRIPrefixFilter)(nil), "pds.BGPNLRIPrefixFilter")
	proto.RegisterType((*BGPNLRIPrefix)(nil), "pds.BGPNLRIPrefix")
	proto.RegisterType((*BGPNLRIPrefixGetResponse)(nil), "pds.BGPNLRIPrefixGetResponse")
	proto.RegisterType((*BGPNLRIPrefixKeyHandle)(nil), "pds.BGPNLRIPrefixKeyHandle")
	proto.RegisterType((*BGPNLRIPrefixGetRequests)(nil), "pds.BGPNLRIPrefixGetRequests")
	proto.RegisterType((*BGPNLRIPrefixGetRequest)(nil), "pds.BGPNLRIPrefixGetRequest")
	proto.RegisterType((*BGPPrfxCntrsStatus)(nil), "pds.BGPPrfxCntrsStatus")
	proto.RegisterType((*BGPPrfxCntrsKey)(nil), "pds.BGPPrfxCntrsKey")
	proto.RegisterType((*BGPPrfxCntrs)(nil), "pds.BGPPrfxCntrs")
	proto.RegisterType((*BGPPrfxCntrsGetResponse)(nil), "pds.BGPPrfxCntrsGetResponse")
	proto.RegisterType((*BGPPrfxCntrsKeyHandle)(nil), "pds.BGPPrfxCntrsKeyHandle")
	proto.RegisterType((*BGPPrfxCntrsGetRequest)(nil), "pds.BGPPrfxCntrsGetRequest")
}

func init() { proto.RegisterFile("bgp.proto", fileDescriptor_2e12fe45eec524a6) }

var fileDescriptor_2e12fe45eec524a6 = []byte{
	// 4228 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5b, 0x4d, 0x70, 0x1b, 0x47,
	0x76, 0x16, 0x08, 0xfe, 0x80, 0x4d, 0x12, 0x1c, 0xb6, 0x28, 0x09, 0xa2, 0x64, 0x91, 0x0b, 0xcb,
	0x32, 0x0d, 0xd3, 0x14, 0x45, 0x4b, 0xb4, 0xe2, 0xd5, 0xda, 0x3b, 0x00, 0x86, 0xc0, 0x84, 0xe0,
	0x00, 0xee, 0x01, 0x69, 0xed, 0x1e, 0x82, 0x82, 0x80, 0x06, 0x05, 0x2f, 0x88, 0x99, 0xcc, 0x0c,
	0xb4, 0xa2, 0x8f, 0xa9, 0x4a, 0x2e, 0xd9, 0x7b, 0xae, 0x39, 0xe5, 0xb6, 0xa7, 0x9c, 0x52, 0xa9,
	0x9c, 0x93, 0xca, 0x29, 0xa9, 0x4a, 0xe5, 0xa8, 0xa4, 0x5c, 0x95, 0x8b, 0x8f, 0xba, 0xa7, 0x2a,
	0xd5, 0xbf, 0xd3, 0xf3, 0x03, 0x49, 0xa6, 0x92, 0x4a, 0x55, 0x72, 0x91, 0xd0, 0xef, 0x7b, 0xfd,
	0xfa, 0xf5, 0xeb, 0xee, 0xf7, 0x5e, 0xbf, 0x1e, 0x82, 0xc5, 0x67, 0x67, 0xee, 0xae, 0xeb, 0x39,
	0x81, 0x03, 0xb3, 0x6e, 0xdf, 0xdf, 0x00, 0x67, 0xce, 0x99, 0xc3, 0x08, 0x1b, 0xab, 0xe7, 0x38,
	0xe8, 0xde, 0x27, 0xff, 0x70, 0xc2, 0x52, 0x70, 0xe1, 0x62, 0x9f, 0x35, 0x8a, 0xff, 0x91, 0x01,
	0x0b, 0xe5, 0x5a, 0xcb, 0x76, 0x71, 0x0f, 0xee, 0x80, 0x19, 0xb3, 0x5f, 0xc8, 0x6c, 0x65, 0xb6,
	0x97, 0xcb, 0xb7, 0x5f, 0xbf, 0xda, 0x2c, 0x90, 0x4e, 0x5f, 0x9e, 0x77, 0xc7, 0xfd, 0x6e, 0xe0,
	0x78, 0x17, 0x3b, 0xc3, 0xf3, 0xf3, 0x49, 0xd0, 0x7d, 0x36, 0xc2, 0x68, 0xc6, 0xec, 0xc3, 0x0d,
	0x90, 0x6b, 0x38, 0xbd, 0xee, 0x48, 0xb7, 0xad, 0xc2, 0xcc, 0x56, 0x66, 0x7b, 0x05, 0xc9, 0x36,
	0xc1, 0x90, 0x33, 0x09, 0xb0, 0x67, 0xf6, 0x0b, 0xd9, 0xad, 0xcc, 0xf6, 0x02, 0x92, 0x6d, 0x78,
	0x1b, 0x2c, 0x56, 0x46, 0x13, 0x9f, 0x81, 0xb3, 0x14, 0x0c, 0x09, 0xb0, 0x00, 0x16, 0xaa, 0x43,
	0x9f, 0x0c, 0x52, 0x98, 0xdb, 0xca, 0x6c, 0xe7, 0x90, 0x68, 0xc2, 0x27, 0xe0, 0xa6, 0x3d, 0x71,
	0x5d, 0x0f, 0xfb, 0x7e, 0x15, 0x0f, 0xba, 0x93, 0x51, 0x80, 0xb0, 0xef, 0x8c, 0x26, 0xc1, 0xd0,
	0x19, 0x17, 0xe6, 0x29, 0xef, 0x74, 0x86, 0xe2, 0xbf, 0x65, 0xc0, 0x22, 0x99, 0x67, 0xd0, 0x0d,
	0x26, 0x3e, 0x2c, 0x81, 0x79, 0xf6, 0x8b, 0xce, 0x36, 0xbf, 0x0f, 0x77, 0xdd, 0xbe, 0xbf, 0x5b,
	0xae, 0xb5, 0x9a, 0x2e, 0xf6, 0x18, 0x82, 0x38, 0x07, 0xdc, 0x05, 0xd0, 0x9a, 0x9c, 0xeb, 0xfd,
	0xef, 0xd0, 0xf0, 0x59, 0x73, 0x12, 0xd0, 0x79, 0xf8, 0x7c, 0xc6, 0x29, 0x08, 0x3c, 0x00, 0xd7,
	0x5b, 0xb8, 0xfb, 0x9b, 0x94, 0x3e, 0x59, 0xda, 0x67, 0x0a, 0x0a, 0x8b, 0x60, 0x19, 0xe1, 0xf3,
	0x2a, 0x1e, 0x75, 0x2f, 0xda, 0xc3, 0x73, 0x4c, 0x4d, 0xb3, 0x82, 0x22, 0x34, 0x62, 0xd7, 0x36,
	0x31, 0xc6, 0x29, 0xf6, 0xa8, 0x79, 0x56, 0x90, 0x6c, 0x17, 0xff, 0x7e, 0x16, 0x80, 0x72, 0xad,
	0xa5, 0x0f, 0x88, 0xde, 0x3e, 0xfc, 0x00, 0x64, 0xf5, 0xc1, 0x90, 0xcf, 0x6f, 0x49, 0xcc, 0x4f,
	0x1f, 0x0c, 0x11, 0xa1, 0xc3, 0x2d, 0x30, 0x6b, 0x77, 0x07, 0x43, 0x3a, 0x8f, 0xfc, 0xfe, 0xb2,
	0xc0, 0x09, 0x0d, 0x51, 0x84, 0xe8, 0x63, 0x96, 0x6b, 0xad, 0x96, 0x87, 0x07, 0xc3, 0x97, 0x52,
	0xfb, 0x08, 0x8d, 0xf0, 0x18, 0x2a, 0x0f, 0xd7, 0x59, 0xa5, 0x11, 0x9d, 0xcd, 0x71, 0xcb, 0x1b,
	0x10, 0x9c, 0xeb, 0x2c, 0xda, 0xb0, 0x04, 0x34, 0xf1, 0x5b, 0xef, 0xf5, 0xb0, 0x1b, 0xe0, 0x3e,
	0x5d, 0xca, 0x15, 0x94, 0xa0, 0xab, 0xbc, 0x08, 0x7f, 0x87, 0x7b, 0x84, 0x77, 0x21, 0xca, 0x2b,
	0xe8, 0x64, 0x8f, 0x35, 0x27, 0x01, 0x1f, 0x34, 0x47, 0x99, 0x42, 0x02, 0xdc, 0x03, 0x57, 0x65,
	0x43, 0xef, 0xbf, 0xc0, 0x5e, 0x30, 0xf4, 0x71, 0xbf, 0xb0, 0x48, 0xf9, 0xd2, 0x20, 0xd2, 0x43,
	0x8c, 0x51, 0xc5, 0xe3, 0x21, 0xee, 0x97, 0x2f, 0x5a, 0xce, 0xa8, 0x00, 0x58, 0x8f, 0x14, 0x08,
	0x6e, 0x83, 0x55, 0x6b, 0x72, 0xde, 0x70, 0x7a, 0x68, 0xf8, 0x8c, 0x2f, 0xff, 0x12, 0xe5, 0x8e,
	0x93, 0x89, 0x6c, 0x49, 0x2a, 0x63, 0x5f, 0x6c, 0x96, 0x65, 0x26, 0x3b, 0x05, 0x82, 0x3b, 0x60,
	0x4d, 0x92, 0x2d, 0xfc, 0x32, 0xa8, 0x3b, 0xae, 0x5f, 0x58, 0xa1, 0xfc, 0x49, 0x20, 0x22, 0xdf,
	0xa8, 0x1c, 0xb7, 0xb8, 0xfc, 0x7c, 0x4c, 0x7e, 0x08, 0x15, 0x1f, 0x81, 0x1c, 0x3f, 0x2a, 0x3e,
	0xfc, 0x04, 0x2c, 0xf0, 0x1d, 0x55, 0xc8, 0x6c, 0x65, 0xb7, 0x97, 0xf6, 0x57, 0xc3, 0xad, 0x44,
	0xc9, 0x48, 0xe0, 0xc5, 0xbf, 0xce, 0x80, 0x6c, 0xb9, 0xd6, 0x82, 0x0f, 0xc1, 0x2c, 0x71, 0x27,
	0x74, 0xeb, 0x2d, 0x29, 0x5b, 0xcb, 0xc5, 0xbd, 0x32, 0xfc, 0xf1, 0xd5, 0x66, 0xde, 0x77, 0x71,
	0x6f, 0xc7, 0x39, 0x1f, 0x06, 0xf8, 0xdc, 0x0d, 0x2e, 0x10, 0xe5, 0x86, 0x4f, 0xe4, 0x91, 0x9c,
	0xa1, 0xfd, 0xf2, 0xb2, 0x1f, 0xa5, 0x96, 0xd7, 0x7f, 0x7c, 0xb5, 0xa9, 0xf9, 0xf4, 0xb7, 0xd2,
	0x57, 0x1c, 0xd2, 0xc7, 0x60, 0x8e, 0x29, 0x99, 0xa5, 0x9d, 0x57, 0xd4, 0xce, 0x7e, 0xf9, 0xea,
	0x8f, 0xaf, 0x36, 0x57, 0x49, 0x5f, 0xb5, 0x2b, 0xeb, 0x50, 0x7c, 0x48, 0x4f, 0x0d, 0xc2, 0x7f,
	0x3c, 0xc1, 0x7e, 0x00, 0xef, 0x81, 0x05, 0xfe, 0x33, 0x4d, 0x7d, 0x24, 0xc0, 0xe2, 0x2f, 0xc0,
	0x12, 0xed, 0xe5, 0xbb, 0xce, 0xd8, 0xc7, 0x70, 0x17, 0x2c, 0xea, 0xee, 0x30, 0xe2, 0x52, 0xb4,
	0x5d, 0xe6, 0x66, 0x25, 0x1d, 0x85, 0x2c, 0xc5, 0x3b, 0x60, 0xb9, 0x5c, 0x6b, 0x1d, 0xe1, 0x8b,
	0x7a, 0x77, 0xdc, 0x1f, 0x61, 0x98, 0x0f, 0x3d, 0x2f, 0xf1, 0xad, 0xc5, 0xaf, 0x81, 0x56, 0xae,
	0xb5, 0xaa, 0x78, 0x84, 0x03, 0x2c, 0x54, 0xfb, 0x34, 0xae, 0xda, 0x9a, 0x50, 0x4d, 0xca, 0x09,
	0xf5, 0xab, 0x80, 0x35, 0x45, 0xc0, 0x25, 0xb5, 0x7c, 0x02, 0x56, 0xca, 0xb5, 0x56, 0x0d, 0x07,
	0x97, 0x52, 0x61, 0x00, 0xf2, 0xa2, 0xf7, 0xe5, 0xc6, 0x87, 0x77, 0x41, 0x4e, 0xf4, 0xe5, 0x9b,
	0x22, 0x27, 0xc6, 0x43, 0x12, 0x29, 0xfe, 0xeb, 0x1c, 0x5d, 0x8b, 0x16, 0xc6, 0xde, 0x25, 0xa2,
	0xd8, 0xc7, 0x6c, 0xe3, 0x60, 0xee, 0x08, 0xd7, 0x84, 0x3e, 0xfd, 0xf3, 0xe1, 0x98, 0x02, 0x6c,
	0x9f, 0x60, 0xd8, 0x00, 0x8b, 0x2c, 0xbc, 0xf5, 0xfb, 0x1e, 0xdf, 0x65, 0x42, 0x79, 0xb3, 0x45,
	0x88, 0xd8, 0xf7, 0xdf, 0x32, 0x5e, 0x28, 0x00, 0xfe, 0x21, 0xc8, 0x11, 0x85, 0xa9, 0xb0, 0xd9,
	0x4b, 0x09, 0x93, 0xfd, 0x89, 0xb3, 0x43, 0xf8, 0xdc, 0x09, 0x30, 0x89, 0xc4, 0xcc, 0xc3, 0x86,
	0x04, 0xe2, 0x7e, 0x6d, 0x3c, 0xee, 0x57, 0x9c, 0xf3, 0x73, 0x1e, 0x25, 0x65, 0x1b, 0x6e, 0x81,
	0x25, 0xf2, 0xdb, 0x78, 0x19, 0x50, 0x78, 0x81, 0xc2, 0x2a, 0x09, 0xee, 0x81, 0x1c, 0x42, 0x95,
	0xd1, 0x10, 0x8f, 0x03, 0xea, 0x47, 0xf3, 0xfb, 0xeb, 0x62, 0x09, 0xc8, 0xf8, 0x02, 0x43, 0x92,
	0x8b, 0x84, 0x84, 0x8a, 0x33, 0x1e, 0xe3, 0x5e, 0x80, 0x70, 0xe0, 0x5d, 0x70, 0xaf, 0x1a, 0xa1,
	0x11, 0x9d, 0xea, 0xce, 0xa8, 0x4f, 0xc3, 0x1c, 0xf3, 0xa1, 0xb2, 0x4d, 0x66, 0x73, 0x84, 0xb1,
	0xab, 0x8f, 0x86, 0x2f, 0x30, 0x77, 0x99, 0x21, 0x81, 0xf4, 0x6c, 0x75, 0x7d, 0xff, 0xb7, 0x8e,
	0xd7, 0xa7, 0x1e, 0x72, 0x19, 0xc9, 0x36, 0xfc, 0x02, 0x64, 0xdb, 0xc1, 0x88, 0x39, 0xc2, 0xf2,
	0x47, 0xaf, 0x5f, 0x6d, 0xfe, 0x8c, 0x1a, 0xcf, 0xeb, 0x8e, 0xcf, 0xf0, 0x97, 0x0f, 0x3e, 0xdb,
	0x7f, 0xf4, 0x68, 0x67, 0x8b, 0x52, 0xfa, 0x2c, 0x3b, 0xf8, 0xc5, 0xc1, 0x43, 0x44, 0x7a, 0xc0,
	0x23, 0xb0, 0x6c, 0xf6, 0x47, 0x58, 0xaa, 0x44, 0x5d, 0x63, 0xf9, 0xe3, 0xd7, 0xaf, 0x36, 0x3f,
	0x8c, 0x48, 0xf8, 0x7c, 0xff, 0x8b, 0x83, 0x2f, 0x62, 0x32, 0x1e, 0x3c, 0x42, 0x91, 0xce, 0xb0,
	0x0e, 0x96, 0xf5, 0xd1, 0xc8, 0xf9, 0x2d, 0xcf, 0x85, 0x0a, 0xab, 0x54, 0xd8, 0xdd, 0xd7, 0xaf,
	0x36, 0xb7, 0x14, 0x61, 0x7b, 0x29, 0xea, 0xec, 0xa1, 0x48, 0xcf, 0xe2, 0x5f, 0xe4, 0xe9, 0xf9,
	0xa3, 0x1b, 0x9b, 0x1d, 0x88, 0x4f, 0x62, 0x69, 0xcb, 0x9a, 0xba, 0x16, 0x6c, 0xb7, 0x0a, 0x87,
	0xf8, 0x00, 0x80, 0x96, 0x87, 0x5f, 0x28, 0x2e, 0x35, 0x95, 0x5d, 0x61, 0x82, 0x77, 0xc1, 0x4a,
	0xa3, 0xeb, 0x07, 0x86, 0xe7, 0x39, 0x1e, 0xea, 0xbd, 0x60, 0x99, 0xdb, 0x32, 0x8a, 0x12, 0x23,
	0x5c, 0x36, 0xd9, 0x16, 0xb3, 0x31, 0x2e, 0x42, 0x24, 0x47, 0x3d, 0x3c, 0x2d, 0x73, 0xe9, 0x1b,
	0x5c, 0x3d, 0x0f, 0xea, 0x8e, 0x98, 0x7f, 0xd3, 0x8e, 0x58, 0x48, 0xd9, 0x11, 0x95, 0xae, 0xeb,
	0xdb, 0x62, 0x87, 0xae, 0x20, 0xd9, 0x16, 0x18, 0x9d, 0xcc, 0x62, 0x88, 0xd1, 0x79, 0x14, 0xc0,
	0x02, 0xf9, 0x6d, 0xe1, 0x33, 0xbe, 0x05, 0x45, 0x13, 0x3e, 0x01, 0x9a, 0x8d, 0x47, 0x52, 0xb7,
	0xf6, 0x85, 0xcb, 0x36, 0x22, 0xf1, 0x56, 0x22, 0xf6, 0x71, 0x3a, 0x4a, 0x70, 0x92, 0xc0, 0x6f,
	0x8e, 0x2d, 0x27, 0x18, 0x0e, 0x86, 0xbd, 0x2e, 0x49, 0x3d, 0x45, 0x28, 0x8f, 0x93, 0x49, 0x42,
	0xd3, 0x9c, 0x04, 0x51, 0x56, 0x16, 0xc5, 0x13, 0x74, 0x62, 0x03, 0x73, 0x7c, 0xe2, 0xf6, 0xbb,
	0x61, 0xe8, 0x0e, 0x09, 0xf0, 0x0e, 0x00, 0xcd, 0x49, 0x20, 0x60, 0xba, 0xe3, 0x90, 0x42, 0xa1,
	0xa9, 0xdc, 0x98, 0x98, 0xac, 0x4b, 0x4c, 0xe6, 0x17, 0x34, 0x9e, 0xca, 0x29, 0x34, 0xb2, 0xae,
	0xcd, 0x49, 0xa0, 0x30, 0xad, 0x51, 0xa6, 0x28, 0x91, 0x78, 0x0c, 0x73, 0x8c, 0xf0, 0xc0, 0xc3,
	0xfe, 0x73, 0xec, 0x17, 0x20, 0xe5, 0x51, 0x49, 0x64, 0x2c, 0x92, 0xd3, 0x4a, 0x96, 0xab, 0x6c,
	0x2c, 0x95, 0xc6, 0x6c, 0xd4, 0x76, 0x82, 0xee, 0xe8, 0x18, 0xfb, 0x7e, 0xf7, 0x0c, 0xfb, 0x85,
	0x75, 0x61, 0xa3, 0x08, 0x99, 0xdb, 0x28, 0xca, 0x7a, 0x4d, 0xda, 0x28, 0xca, 0xbb, 0x03, 0xd6,
	0x0e, 0xfd, 0x73, 0xc3, 0x0f, 0xda, 0x5e, 0x77, 0xec, 0x0f, 0x99, 0x41, 0xaf, 0xb3, 0xb4, 0x28,
	0x01, 0x10, 0x6e, 0xd5, 0x27, 0x55, 0x9c, 0xc9, 0x38, 0x28, 0xdc, 0x60, 0xdc, 0x09, 0x00, 0x5e,
	0x07, 0xf3, 0xe4, 0xd0, 0x9c, 0x79, 0x85, 0x02, 0x65, 0xe1, 0x2d, 0x62, 0x35, 0x3b, 0xe8, 0x8e,
	0x70, 0xab, 0x1b, 0x3c, 0xa7, 0x9b, 0xf7, 0x26, 0xb3, 0x5a, 0x84, 0x48, 0x6d, 0xeb, 0x0d, 0x8c,
	0xb1, 0x1c, 0x67, 0x83, 0xdb, 0x56, 0x25, 0x12, 0xab, 0x90, 0x9d, 0x79, 0xec, 0x9f, 0x19, 0x23,
	0xd7, 0xa7, 0xd2, 0x6e, 0x31, 0xab, 0xc4, 0xc8, 0x44, 0x1e, 0x4d, 0xd5, 0x88, 0x45, 0xe9, 0xc6,
	0xbf, 0xcd, 0xe4, 0x45, 0x88, 0x11, 0x2e, 0x7a, 0x04, 0x3e, 0x88, 0x71, 0xd1, 0x73, 0xa0, 0xa6,
	0xe7, 0x77, 0x62, 0xe9, 0x79, 0x24, 0x8d, 0xde, 0x7c, 0xc7, 0x34, 0x7a, 0x6b, 0x7a, 0x1a, 0xbd,
	0x0d, 0x56, 0x55, 0xd3, 0x9a, 0xe3, 0xa0, 0xf0, 0x33, 0x36, 0xc3, 0x18, 0x99, 0xac, 0x8e, 0xdc,
	0xbf, 0xd2, 0x1a, 0x45, 0xb6, 0x3a, 0x09, 0x80, 0xc8, 0x95, 0xc3, 0xb1, 0x24, 0xbc, 0xf0, 0x21,
	0x93, 0x1b, 0x23, 0x47, 0x38, 0xcd, 0x73, 0xf7, 0xdb, 0xbe, 0x57, 0xb8, 0x1b, 0xe3, 0x64, 0xe4,
	0x08, 0xa7, 0xf1, 0x92, 0x72, 0x7e, 0x14, 0xe3, 0x64, 0x64, 0x78, 0x0f, 0xe4, 0x85, 0xc5, 0xb8,
	0xc8, 0x7b, 0x94, 0x31, 0x46, 0x55, 0xf9, 0xb8, 0xc0, 0x8f, 0xa3, 0x7c, 0x5c, 0x5e, 0x09, 0x68,
	0x08, 0xf7, 0xf0, 0xf0, 0x05, 0xee, 0x4b, 0x9f, 0xb8, 0xcd, 0xf6, 0x7c, 0x9c, 0x4e, 0x2e, 0xa7,
	0x6c, 0x6b, 0x77, 0x9f, 0x8d, 0x86, 0xfe, 0x73, 0xcc, 0xb8, 0x3f, 0x61, 0x97, 0xd3, 0x24, 0x42,
	0xec, 0x2a, 0xdd, 0x86, 0xb4, 0x6b, 0x89, 0xd9, 0x35, 0x01, 0x10, 0x1f, 0x69, 0x8e, 0x9b, 0x2e,
	0x1e, 0xfb, 0x85, 0x4f, 0x99, 0x8f, 0xe4, 0x4d, 0xb2, 0x6b, 0x9a, 0x93, 0x80, 0x41, 0x3b, 0x6c,
	0xd7, 0x88, 0x36, 0xd9, 0x35, 0xe4, 0x74, 0x98, 0xe3, 0x3e, 0x7e, 0x59, 0xf8, 0x8c, 0xed, 0x1a,
	0x49, 0x80, 0x1a, 0x8b, 0xd2, 0xbb, 0x94, 0x4e, 0xc3, 0xef, 0x1e, 0x58, 0x14, 0xd7, 0x6e, 0x5c,
	0xb8, 0x3f, 0xf5, 0x3e, 0x1e, 0x32, 0x15, 0xff, 0x94, 0x15, 0x2d, 0x88, 0x50, 0xf8, 0x38, 0x72,
	0xdb, 0xd0, 0x22, 0x21, 0xee, 0xcd, 0x37, 0x8e, 0x5f, 0xc6, 0x6e, 0x1c, 0x30, 0x1e, 0x1e, 0xdf,
	0x76, 0xeb, 0x28, 0xea, 0x60, 0x55, 0x24, 0x42, 0x97, 0xcf, 0xb1, 0xf3, 0x52, 0x04, 0x4b, 0xb2,
	0x4b, 0x6a, 0x92, 0x9d, 0x4d, 0x9b, 0x53, 0x98, 0x63, 0x8f, 0x01, 0xe4, 0xf4, 0xf7, 0xc9, 0xb3,
	0xb7, 0x23, 0x79, 0x76, 0x56, 0xbd, 0xf5, 0x50, 0xc5, 0xc2, 0x5c, 0xfb, 0x3b, 0x7a, 0x59, 0x22,
	0xc4, 0x23, 0x7c, 0x11, 0x0d, 0xf2, 0x99, 0xb7, 0x07, 0xf9, 0x1d, 0x25, 0xe9, 0x9d, 0x99, 0xc2,
	0x2e, 0x39, 0x8a, 0xa7, 0xf4, 0x0e, 0xc4, 0xc7, 0xe2, 0xf7, 0x24, 0x2d, 0xcc, 0xed, 0xeb, 0x57,
	0x68, 0xfe, 0xfe, 0x21, 0xc8, 0x1e, 0xe1, 0x0b, 0x2e, 0x6e, 0x55, 0x55, 0x9b, 0xf4, 0xba, 0x82,
	0x08, 0x5a, 0x5e, 0x02, 0x8b, 0xc3, 0x7e, 0xc7, 0xf1, 0x3a, 0xbf, 0xc1, 0x17, 0xc5, 0x1a, 0x58,
	0xe7, 0x1c, 0xd1, 0xfb, 0xd5, 0xfd, 0xb8, 0xdd, 0xaf, 0xc5, 0xa5, 0xc5, 0x2e, 0x38, 0x35, 0x70,
	0x2d, 0x26, 0xe8, 0x92, 0x7b, 0xa0, 0x4a, 0x2f, 0x6b, 0x72, 0x15, 0x2f, 0xa9, 0xce, 0x9f, 0xcc,
	0xca, 0x74, 0x51, 0x1f, 0x5c, 0xe2, 0x26, 0x14, 0xb9, 0xe0, 0xcc, 0xfc, 0x77, 0x5e, 0x70, 0xb2,
	0xef, 0x79, 0xc1, 0xf9, 0x39, 0x2b, 0x65, 0xcd, 0x26, 0x4a, 0x59, 0x6f, 0x91, 0x40, 0x0b, 0x5d,
	0x5f, 0xf1, 0x42, 0xd7, 0x5c, 0xb2, 0xd0, 0xf5, 0x96, 0xee, 0xac, 0x0c, 0xb6, 0x05, 0x96, 0x2c,
	0xfc, 0x32, 0x78, 0xee, 0xb8, 0x36, 0x1e, 0x0d, 0xf8, 0x15, 0x4a, 0x25, 0x11, 0x0e, 0x5e, 0x6f,
	0x6c, 0x7a, 0xc3, 0x33, 0x71, 0x8b, 0x52, 0x48, 0xc4, 0x23, 0x52, 0xcb, 0xb4, 0x1c, 0x4f, 0x24,
	0xa9, 0x21, 0x81, 0x64, 0x6f, 0xec, 0xba, 0x46, 0x61, 0x96, 0xa7, 0x2a, 0x14, 0x12, 0x0f, 0xa4,
	0x5d, 0xed, 0x9e, 0xe3, 0x62, 0xb3, 0xcf, 0x53, 0xd6, 0x04, 0xbd, 0xf8, 0x9f, 0x19, 0xe9, 0x92,
	0x58, 0x59, 0x66, 0x42, 0x73, 0x36, 0xe6, 0xd8, 0x6b, 0x9e, 0x33, 0x71, 0xe9, 0x7e, 0x58, 0x41,
	0x2a, 0x29, 0x75, 0x84, 0x99, 0xf4, 0x11, 0xe8, 0x6d, 0x53, 0xa4, 0x72, 0x74, 0x65, 0x73, 0x28,
	0x24, 0xc0, 0xaf, 0xc0, 0x8a, 0xde, 0xef, 0x93, 0xc4, 0xa7, 0xd2, 0x75, 0x49, 0x6e, 0xcd, 0x16,
	0xad, 0xc0, 0xcc, 0x7e, 0xe6, 0x46, 0xc0, 0x4a, 0xd7, 0x45, 0x51, 0x76, 0xf8, 0x15, 0x58, 0x45,
	0x78, 0x30, 0xc2, 0xbd, 0xc0, 0xf1, 0xf8, 0xb5, 0x73, 0xee, 0x0d, 0xd7, 0xce, 0x38, 0x73, 0xf1,
	0xcf, 0x59, 0x99, 0x97, 0xcd, 0x1f, 0x7e, 0x19, 0x89, 0x0d, 0x11, 0xff, 0xce, 0x8e, 0xc8, 0x1b,
	0xa2, 0x43, 0x39, 0x16, 0x1d, 0xd6, 0x63, 0xbd, 0xdf, 0x25, 0x3e, 0x54, 0xe4, 0xc1, 0xd6, 0x07,
	0x97, 0xf6, 0x0e, 0xbf, 0x94, 0x7e, 0x90, 0x08, 0x61, 0xce, 0x61, 0x27, 0xee, 0x1c, 0x52, 0xe6,
	0x16, 0x7a, 0x86, 0xdf, 0x67, 0x68, 0xb9, 0x89, 0x41, 0xff, 0xe3, 0x8e, 0x5b, 0x54, 0x9e, 0xb3,
	0x6f, 0xa9, 0x3c, 0xcf, 0x4e, 0xab, 0x3c, 0x17, 0x7f, 0x2d, 0xa3, 0x1a, 0x55, 0x77, 0xaa, 0xef,
	0xff, 0x48, 0xf5, 0xfd, 0x6b, 0x51, 0x0b, 0x4c, 0xf3, 0xfe, 0x47, 0xe0, 0xba, 0xe4, 0x89, 0xfa,
	0xff, 0x07, 0x71, 0x9b, 0xde, 0x48, 0x4a, 0x8c, 0xb9, 0x5c, 0x13, 0xdc, 0x48, 0x08, 0xbb, 0xe4,
	0x2a, 0xd7, 0xc1, 0x55, 0x29, 0x4a, 0x89, 0x02, 0x97, 0x50, 0xca, 0x93, 0xf1, 0x8d, 0x4b, 0xba,
	0x64, 0x56, 0x50, 0x4a, 0x64, 0x05, 0xf9, 0xe8, 0xd8, 0x4a, 0x5e, 0xf0, 0xb7, 0x19, 0x3a, 0x68,
	0x65, 0x84, 0xbb, 0x1e, 0xbf, 0x5e, 0x08, 0xfd, 0xe7, 0x9b, 0x2e, 0x7d, 0xa1, 0x61, 0x23, 0xde,
	0x14, 0x22, 0x42, 0x56, 0x86, 0xfb, 0x88, 0x33, 0xc2, 0x4f, 0xc1, 0x2c, 0x91, 0xcf, 0x97, 0x35,
	0x3d, 0xea, 0xd5, 0xaf, 0x20, 0xca, 0x44, 0xe4, 0x33, 0x65, 0x78, 0x90, 0x99, 0x66, 0x9e, 0xfa,
	0x15, 0xc4, 0x19, 0xcb, 0x1a, 0xc8, 0xbb, 0x18, 0x7b, 0x64, 0x43, 0x90, 0xff, 0xbb, 0x03, 0x1e,
	0xc8, 0x55, 0xe5, 0x2f, 0xb9, 0x88, 0xbf, 0x9b, 0xa7, 0xab, 0x68, 0x35, 0x90, 0xc9, 0x9e, 0x3f,
	0xb8, 0x29, 0xdf, 0xfb, 0x2d, 0x86, 0x5c, 0x3f, 0xa9, 0x40, 0x5e, 0x93, 0xe1, 0x2d, 0x9a, 0x6a,
	0xd3, 0x5f, 0x0d, 0x3c, 0xe6, 0x8f, 0x2f, 0x21, 0x01, 0xee, 0x82, 0x25, 0x3a, 0x1f, 0xdb, 0x99,
	0x78, 0x3d, 0x1c, 0x89, 0x80, 0x44, 0x45, 0xdb, 0xeb, 0x21, 0x95, 0x81, 0x5e, 0x3c, 0xc2, 0x26,
	0xcb, 0xdf, 0xf9, 0x6b, 0x4c, 0x9c, 0x4e, 0x35, 0xea, 0x06, 0xcf, 0xcd, 0x2a, 0xaf, 0xc8, 0xf0,
	0x16, 0xd1, 0x48, 0xbe, 0x54, 0xd0, 0x50, 0x97, 0x43, 0x21, 0x81, 0xa0, 0xba, 0x4d, 0x38, 0xed,
	0xc0, 0xa3, 0x91, 0x6e, 0x19, 0x85, 0x04, 0x12, 0x08, 0xc9, 0x4f, 0x12, 0x32, 0x79, 0x88, 0x5b,
	0x46, 0x0a, 0x45, 0x84, 0xe2, 0xba, 0xe3, 0x52, 0x4f, 0xb4, 0x44, 0x19, 0x54, 0x12, 0xbc, 0x07,
	0xe6, 0x75, 0xdb, 0x1e, 0x7e, 0x8f, 0x69, 0xcd, 0x25, 0x1f, 0xee, 0x58, 0x46, 0x45, 0x1c, 0x25,
	0x7a, 0x18, 0xbd, 0x73, 0x97, 0x69, 0xb9, 0xc2, 0xb4, 0x94, 0x84, 0x88, 0xbb, 0xcb, 0xbf, 0xd5,
	0xdd, 0x95, 0x80, 0x76, 0x38, 0xea, 0xba, 0xf4, 0x35, 0x81, 0xfc, 0xe8, 0x8d, 0x03, 0x5e, 0x82,
	0x49, 0xd0, 0x23, 0xbc, 0xf4, 0xad, 0xd2, 0xef, 0xd3, 0x62, 0x4c, 0x0e, 0x25, 0xe8, 0x70, 0x0f,
	0xe4, 0x4c, 0x5f, 0xef, 0x05, 0xc3, 0x17, 0x98, 0xd6, 0x62, 0x94, 0x18, 0x48, 0x56, 0x4f, 0x60,
	0x48, 0x72, 0xc1, 0x75, 0x5a, 0xcb, 0x1e, 0x61, 0x5a, 0x96, 0xc9, 0x21, 0xd6, 0x80, 0x77, 0xc1,
	0x0a, 0x97, 0xed, 0x05, 0xf4, 0xba, 0xc7, 0x2a, 0x32, 0x51, 0x22, 0x7c, 0x0c, 0x56, 0x10, 0xee,
	0xfa, 0xce, 0xd8, 0x72, 0x02, 0xb2, 0x5e, 0xb4, 0x20, 0xa3, 0x5c, 0xc4, 0x90, 0x2f, 0x10, 0x14,
	0x65, 0x24, 0x97, 0x44, 0x51, 0x40, 0xbe, 0xb6, 0x95, 0xdd, 0x5e, 0x46, 0xa2, 0x49, 0x92, 0x11,
	0x2d, 0x72, 0x1c, 0x48, 0xec, 0xf9, 0xff, 0x73, 0x16, 0x8a, 0xff, 0x9c, 0x89, 0xb9, 0x83, 0xc3,
	0xe1, 0x28, 0xc0, 0x9e, 0x6a, 0x31, 0xf6, 0xe4, 0x23, 0x9a, 0x10, 0x82, 0xd9, 0xd3, 0xf1, 0x50,
	0x24, 0x5f, 0xf4, 0x37, 0x4d, 0xb8, 0xc8, 0x88, 0xb4, 0x0e, 0x99, 0xe5, 0xe5, 0x7d, 0x41, 0x20,
	0xb7, 0x45, 0x7e, 0x00, 0xa6, 0xbd, 0x23, 0x20, 0xc1, 0x40, 0xdc, 0x99, 0xa4, 0x4e, 0x2f, 0xca,
	0xca, 0x9f, 0x44, 0x1b, 0xba, 0x15, 0x58, 0xce, 0x4b, 0x7f, 0x17, 0x75, 0x7a, 0xc9, 0x08, 0xa7,
	0x04, 0xf7, 0x22, 0x35, 0xe9, 0x25, 0x91, 0xea, 0x25, 0xbd, 0xa0, 0xcc, 0x8a, 0xbe, 0x07, 0x85,
	0x08, 0xfc, 0x3e, 0x41, 0x6a, 0x37, 0x11, 0xa4, 0x60, 0x72, 0x7c, 0x25, 0x50, 0xe9, 0x34, 0xfc,
	0x47, 0x76, 0x24, 0x4f, 0x2f, 0x3e, 0x66, 0xc9, 0x44, 0x26, 0x1a, 0x75, 0x22, 0x9c, 0x34, 0x9d,
	0x28, 0x7e, 0x93, 0xa6, 0x3e, 0x8d, 0x76, 0x3e, 0x7c, 0x14, 0x0f, 0xd7, 0xb7, 0x52, 0x05, 0xc5,
	0x43, 0xf6, 0x5f, 0x66, 0x68, 0x22, 0x91, 0x26, 0x13, 0xfe, 0x9c, 0xcc, 0x90, 0x89, 0xe7, 0xca,
	0x7d, 0x90, 0x94, 0xa9, 0xe8, 0x50, 0xbf, 0x82, 0x64, 0x07, 0xb8, 0x0f, 0xe6, 0xd9, 0x9e, 0xe3,
	0xd1, 0x34, 0x65, 0x71, 0x18, 0x4e, 0xe2, 0x23, 0xfb, 0x55, 0x5e, 0x07, 0xd0, 0xe3, 0xfd, 0x49,
	0x8c, 0x1c, 0x50, 0x6a, 0xf1, 0xcf, 0x96, 0x58, 0x52, 0xe6, 0x0d, 0x5e, 0x56, 0xc6, 0x81, 0xe7,
	0x73, 0xfb, 0x6f, 0x80, 0x9c, 0x31, 0x0e, 0xd8, 0xf1, 0x60, 0x17, 0x0b, 0xd9, 0x8e, 0xd6, 0x81,
	0x66, 0xe2, 0x75, 0xa0, 0xf7, 0xcd, 0x12, 0xff, 0x4f, 0x7c, 0x57, 0xb0, 0x01, 0x72, 0x27, 0x3e,
	0xf6, 0xaa, 0xdd, 0xa0, 0x4b, 0xe3, 0xdd, 0x22, 0x92, 0x6d, 0x56, 0x24, 0x67, 0x3d, 0x88, 0xab,
	0x76, 0x71, 0x5f, 0x7c, 0x41, 0x10, 0x23, 0xc3, 0x03, 0x70, 0x5d, 0x25, 0x89, 0x8f, 0x60, 0x70,
	0x9f, 0xbf, 0x3c, 0x4c, 0x41, 0xd5, 0xaf, 0x1a, 0x08, 0x52, 0x1f, 0xfa, 0xe4, 0x06, 0xcc, 0xdf,
	0x20, 0xd2, 0x20, 0xb5, 0x84, 0xc9, 0x23, 0x53, 0x3e, 0x5a, 0xc2, 0xe4, 0x91, 0x68, 0xca, 0xf7,
	0x12, 0xab, 0x3f, 0xe9, 0x7b, 0x09, 0xed, 0x27, 0x7d, 0x2f, 0xb1, 0x36, 0xfd, 0x7b, 0x89, 0x87,
	0xe0, 0x5a, 0x74, 0xc8, 0xe3, 0xae, 0x17, 0x0c, 0xbb, 0x63, 0xfe, 0x7c, 0x91, 0x0e, 0xc2, 0x7d,
	0xb0, 0x1e, 0x05, 0x74, 0xbf, 0xe1, 0x38, 0x2e, 0x0f, 0x9f, 0xa9, 0x58, 0x72, 0x24, 0xe1, 0x9b,
	0xd7, 0xd3, 0x46, 0x12, 0x7e, 0x59, 0x59, 0x3f, 0x29, 0x0d, 0x8f, 0xcf, 0x82, 0xe7, 0xfc, 0xa9,
	0x63, 0x0a, 0x0a, 0x1f, 0x83, 0x1b, 0x51, 0x84, 0xc4, 0x90, 0xc9, 0x78, 0x18, 0x5c, 0xf0, 0x67,
	0x8f, 0x69, 0x70, 0xb2, 0x27, 0xbd, 0xeb, 0xd1, 0xf2, 0xc5, 0x8d, 0xb4, 0x9e, 0x12, 0x26, 0xd9,
	0x04, 0x7f, 0xa3, 0xe1, 0xa7, 0x80, 0xbd, 0x87, 0x44, 0x89, 0x64, 0x9f, 0x88, 0xe7, 0x19, 0xce,
	0xc6, 0xde, 0x45, 0x62, 0x54, 0x78, 0x9f, 0xb9, 0x08, 0x56, 0xfa, 0xdd, 0x98, 0xf6, 0x48, 0x19,
	0xf2, 0xa4, 0x55, 0xfa, 0x6f, 0xbd, 0x73, 0xa5, 0xff, 0xf6, 0x3b, 0x57, 0xfa, 0x3f, 0x78, 0xd7,
	0x4a, 0xff, 0x9d, 0x77, 0xac, 0xf4, 0x6f, 0xa6, 0x56, 0xfa, 0xf7, 0xc1, 0x7a, 0x65, 0xe2, 0x25,
	0xcf, 0x09, 0x7b, 0x42, 0x49, 0xc5, 0x8a, 0xbf, 0xe3, 0x15, 0x1e, 0xe1, 0x88, 0x49, 0x4e, 0xf5,
	0xbf, 0xe7, 0x85, 0x8b, 0x5f, 0xb3, 0xd2, 0x82, 0xd0, 0x06, 0xde, 0x8f, 0xa5, 0x03, 0xe1, 0x85,
	0x2c, 0x1a, 0x39, 0x64, 0x36, 0xf0, 0x92, 0xdd, 0xa1, 0x05, 0xfa, 0x3e, 0xc9, 0xc0, 0x67, 0x89,
	0x64, 0x60, 0x2d, 0x31, 0xba, 0x92, 0x0b, 0x7c, 0xcd, 0xea, 0xb7, 0x8a, 0x21, 0x79, 0x2a, 0x70,
	0x4f, 0x4d, 0x05, 0xd6, 0x13, 0x22, 0x64, 0x26, 0x60, 0xb1, 0x5a, 0x42, 0x44, 0x75, 0x16, 0xb4,
	0x1f, 0xc6, 0xf3, 0x80, 0x8d, 0x34, 0x29, 0xb1, 0x34, 0xa0, 0xf4, 0x0d, 0x98, 0x67, 0xc6, 0x87,
	0x1a, 0xb5, 0x6a, 0x47, 0x3f, 0x34, 0x3b, 0x56, 0xd3, 0x32, 0xb4, 0x2b, 0x2a, 0xc5, 0x6c, 0x9d,
	0x3e, 0xd4, 0x32, 0x31, 0xca, 0x81, 0x36, 0x03, 0xd7, 0x68, 0x6e, 0x46, 0x29, 0x8d, 0xfd, 0xd3,
	0x96, 0xa5, 0xdd, 0x2c, 0x19, 0xec, 0xeb, 0x4e, 0x12, 0x2f, 0x39, 0x6a, 0x2b, 0x42, 0xd7, 0x69,
	0x7e, 0xce, 0x48, 0x27, 0x96, 0x59, 0xd1, 0xed, 0xb6, 0x96, 0x89, 0x30, 0x1a, 0x44, 0xcc, 0x61,
	0xe9, 0x8f, 0xc2, 0x87, 0x0e, 0xf1, 0x9d, 0x07, 0xef, 0xdb, 0x32, 0x0c, 0xd4, 0x41, 0x48, 0x48,
	0xbc, 0x4e, 0xb3, 0x04, 0x49, 0xad, 0x34, 0x4c, 0xc3, 0x22, 0x32, 0x3f, 0x00, 0x37, 0x55, 0xfa,
	0xb1, 0x61, 0xd7, 0x8d, 0xaa, 0x80, 0x67, 0x4a, 0xff, 0x12, 0x56, 0xa8, 0xd8, 0x39, 0xbf, 0x41,
	0x33, 0x67, 0xc6, 0x6f, 0xb7, 0xf5, 0xb6, 0x21, 0x06, 0x48, 0x02, 0x66, 0xb5, 0x61, 0x68, 0x19,
	0xb8, 0x41, 0x17, 0x43, 0x05, 0x2a, 0x4d, 0xcb, 0x32, 0x2a, 0x6d, 0x6d, 0x06, 0xde, 0xa4, 0x2b,
	0xad, 0x62, 0x7a, 0xa5, 0x6d, 0x9e, 0x1a, 0x5a, 0x16, 0xde, 0xa2, 0xdb, 0x4f, 0x85, 0x9a, 0x2d,
	0xc3, 0xb2, 0x89, 0x5a, 0xb3, 0xf0, 0x0e, 0xd8, 0x48, 0x01, 0x2b, 0x4d, 0xeb, 0xd0, 0x44, 0xc7,
	0xda, 0x5c, 0x0a, 0x6e, 0xd8, 0x6d, 0xbd, 0xdc, 0x30, 0xc9, 0xec, 0xb4, 0xf9, 0xd2, 0x53, 0x5a,
	0x8c, 0xe4, 0x77, 0x4e, 0x6e, 0x30, 0xdd, 0xee, 0xd8, 0xe6, 0xaf, 0xe5, 0x7c, 0xb8, 0x6a, 0x82,
	0xda, 0xfe, 0xb6, 0xd9, 0x69, 0x56, 0xda, 0x46, 0x3b, 0x9c, 0x91, 0x80, 0x0e, 0x9b, 0x27, 0x88,
	0x63, 0x33, 0xa5, 0x7f, 0x9c, 0xa5, 0x1f, 0x3d, 0xc9, 0xaf, 0x0e, 0xb8, 0x59, 0xf4, 0x6a, 0x15,
	0x75, 0xda, 0xbf, 0x6a, 0x19, 0x9d, 0x66, 0xbb, 0x6e, 0xa0, 0x70, 0x41, 0x42, 0x80, 0xef, 0x9e,
	0x34, 0x3a, 0xd9, 0x43, 0x09, 0xba, 0x65, 0xeb, 0x2d, 0x2d, 0x9b, 0xa4, 0xd7, 0xab, 0x8d, 0x8a,
	0x36, 0x2b, 0xf5, 0x97, 0xf4, 0x72, 0xd9, 0x7a, 0xf0, 0x78, 0x7f, 0x5f, 0x9b, 0x4b, 0x42, 0xa6,
	0x61, 0x18, 0x8f, 0xf7, 0xf6, 0xb5, 0xf9, 0xa4, 0x34, 0xe3, 0xc1, 0xc1, 0xe7, 0xda, 0x42, 0x2a,
	0xfd, 0xa1, 0x96, 0x83, 0xd7, 0x68, 0x21, 0x55, 0xa1, 0x1f, 0x1e, 0xfc, 0x81, 0xb6, 0x98, 0x64,
	0x7f, 0xfa, 0x60, 0xff, 0x81, 0x06, 0x92, 0xec, 0x66, 0xeb, 0xa9, 0xb6, 0x24, 0xd6, 0x3a, 0x24,
	0xeb, 0xad, 0x56, 0xc3, 0x68, 0xeb, 0x8d, 0x23, 0x6d, 0x59, 0x5a, 0x5b, 0x82, 0x55, 0xa3, 0x62,
	0x19, 0x6d, 0xf3, 0x54, 0x5b, 0x49, 0x76, 0x2c, 0xeb, 0xd6, 0xaf, 0x74, 0xeb, 0xd4, 0xb4, 0xb4,
	0x7c, 0x12, 0x24, 0x3a, 0x33, 0xb3, 0xad, 0x26, 0xa5, 0x12, 0xf3, 0x77, 0xda, 0x96, 0xae, 0x69,
	0xa9, 0xd8, 0x01, 0xc5, 0xd6, 0x92, 0x18, 0x91, 0x47, 0x31, 0x98, 0xc4, 0x4e, 0x5b, 0x16, 0x5b,
	0xd6, 0xab, 0x53, 0xb1, 0x03, 0x6d, 0x3d, 0xb9, 0x47, 0x84, 0x93, 0xf8, 0x9b, 0x0c, 0x3d, 0xf1,
	0xe1, 0x5b, 0x2b, 0x2c, 0xd0, 0x72, 0x1e, 0xd9, 0xed, 0x6c, 0x63, 0x9f, 0xd8, 0xb1, 0x03, 0xae,
	0x22, 0x27, 0x2d, 0x2d, 0x93, 0xd6, 0xa3, 0xda, 0xfc, 0xd6, 0xd2, 0x66, 0xe0, 0x6d, 0x7a, 0x5f,
	0x8a, 0x20, 0xb5, 0xa6, 0x69, 0xd5, 0x48, 0xbf, 0xac, 0x38, 0x42, 0x49, 0x94, 0xf6, 0x9e, 0x4d,
	0xc3, 0xf5, 0x4a, 0xbb, 0x73, 0xa8, 0x9b, 0x0d, 0xa3, 0xaa, 0xcd, 0x95, 0xfe, 0x8e, 0xdc, 0xb1,
	0x93, 0xef, 0x0a, 0xca, 0xaa, 0x74, 0x5a, 0x7a, 0xbb, 0xde, 0xb1, 0x51, 0xa7, 0x6a, 0xda, 0x7a,
	0xb9, 0x41, 0x26, 0x91, 0x02, 0x22, 0xa3, 0x62, 0x10, 0x8f, 0x20, 0x67, 0xa2, 0x82, 0xb6, 0x61,
	0x55, 0xb5, 0x99, 0x34, 0xa4, 0xdc, 0x6c, 0xd7, 0x43, 0x2f, 0xa2, 0x22, 0xa6, 0x55, 0x37, 0x90,
	0x49, 0xbc, 0x48, 0x0a, 0x78, 0x62, 0x1d, 0x59, 0x64, 0x7e, 0x73, 0xa5, 0xdf, 0xc7, 0x2b, 0xa7,
	0xbc, 0x1c, 0x2a, 0x06, 0xab, 0x34, 0x0c, 0x1d, 0x75, 0x50, 0xf3, 0x24, 0x74, 0x81, 0x29, 0x48,
	0x5d, 0x47, 0x55, 0x2d, 0x23, 0x8c, 0xa5, 0x22, 0xc8, 0x38, 0x44, 0x86, 0x5d, 0xef, 0x98, 0x64,
	0x29, 0x36, 0xc1, 0xad, 0x69, 0x78, 0xf3, 0xa4, 0xad, 0x65, 0xe1, 0x16, 0xb8, 0x3d, 0x8d, 0x81,
	0xce, 0x74, 0xb6, 0x54, 0x05, 0x0b, 0xbc, 0x5e, 0x02, 0x57, 0xc0, 0x22, 0xf9, 0x29, 0xd4, 0x12,
	0x4d, 0xe2, 0x0d, 0xb5, 0x0c, 0x5c, 0x06, 0x39, 0xda, 0xd4, 0x0f, 0x8f, 0xb5, 0x19, 0x09, 0xda,
	0x46, 0xe3, 0x50, 0xcb, 0x96, 0xbe, 0xa7, 0xf1, 0x44, 0x2d, 0x63, 0x89, 0x33, 0x4b, 0xb9, 0x4c,
	0x5b, 0x17, 0x52, 0xf9, 0xee, 0x51, 0xc8, 0xed, 0x4e, 0x1b, 0xe9, 0x95, 0x23, 0x83, 0x4c, 0x98,
	0xbb, 0x18, 0x89, 0x9a, 0x16, 0x77, 0xec, 0x33, 0x62, 0xb7, 0x4b, 0x48, 0x78, 0xfc, 0xd2, 0x5f,
	0xb1, 0x77, 0xd2, 0xb0, 0xa0, 0x25, 0x82, 0x13, 0x32, 0x74, 0xbb, 0x69, 0xd1, 0x11, 0x2a, 0x4d,
	0xcb, 0x36, 0xab, 0x06, 0x32, 0xaa, 0xa1, 0x0a, 0x1c, 0x66, 0x56, 0x31, 0xed, 0x4e, 0xd9, 0xa0,
	0xd1, 0x92, 0xeb, 0xcd, 0xd1, 0x6f, 0x0d, 0xb3, 0x56, 0x57, 0x42, 0x0e, 0x27, 0x37, 0x9a, 0x15,
	0xbd, 0xd1, 0x69, 0x21, 0xe3, 0x50, 0xcb, 0x8a, 0x55, 0x10, 0x50, 0xa5, 0xd1, 0x69, 0x22, 0xb3,
	0xd6, 0x69, 0xa1, 0x43, 0x44, 0x06, 0x9c, 0x15, 0x87, 0x98, 0x33, 0xe8, 0x36, 0xdb, 0x36, 0x0d,
	0xc3, 0xd2, 0xe6, 0x62, 0xc3, 0x91, 0x8e, 0xa6, 0xa5, 0xcd, 0x43, 0x48, 0x3f, 0x23, 0x10, 0xe4,
	0x63, 0xa3, 0xaa, 0x2d, 0xc4, 0xa6, 0xc5, 0x54, 0xa0, 0x23, 0xb5, 0x4d, 0x43, 0xcb, 0xc5, 0xd4,
	0x30, 0xc8, 0xef, 0xd3, 0x8e, 0x29, 0xe2, 0x99, 0xb6, 0x18, 0xeb, 0xaf, 0x57, 0x8f, 0x4d, 0x8b,
	0x9c, 0xa1, 0xb6, 0x6e, 0x55, 0x0c, 0x0d, 0xc4, 0xfa, 0x53, 0x15, 0xdb, 0xcd, 0x8e, 0x65, 0x3c,
	0x6d, 0x77, 0x2a, 0x76, 0x5b, 0x5b, 0x8a, 0xd9, 0x8d, 0x4c, 0xbe, 0x63, 0x3c, 0x35, 0xed, 0xb6,
	0x69, 0xd5, 0xb4, 0xe5, 0x98, 0x81, 0xcc, 0xaa, 0x61, 0xb5, 0xcd, 0x43, 0xd3, 0x40, 0xda, 0x4a,
	0x6c, 0xfe, 0x95, 0xc6, 0x89, 0xdd, 0x36, 0x10, 0x9d, 0x7f, 0x3e, 0xa6, 0x14, 0x8d, 0xbc, 0xd2,
	0xa1, 0x69, 0xab, 0xe2, 0x6c, 0xc4, 0x61, 0x4d, 0x4b, 0x43, 0x5a, 0x4d, 0xd4, 0xd6, 0xd6, 0x84,
	0x4b, 0x53, 0x27, 0x62, 0x56, 0x35, 0xb8, 0xff, 0x7a, 0x81, 0xe6, 0x63, 0xf6, 0x8b, 0x1e, 0xdc,
	0xa3, 0x81, 0xbc, 0xe2, 0x61, 0x92, 0x9b, 0xc8, 0xaf, 0x0c, 0x78, 0xde, 0xb6, 0xa1, 0x85, 0x04,
	0x9e, 0x5a, 0x5e, 0xe1, 0x3d, 0xd8, 0x23, 0xeb, 0xbb, 0xf5, 0x78, 0x42, 0x7b, 0xb0, 0x67, 0x24,
	0x28, 0x0b, 0x50, 0x91, 0x37, 0xaa, 0x8d, 0xeb, 0x71, 0xb2, 0xec, 0xfd, 0x39, 0xd5, 0xb5, 0x86,
	0x03, 0x28, 0x0b, 0x60, 0x61, 0x3e, 0xba, 0x71, 0x35, 0x42, 0x53, 0x86, 0x14, 0x5f, 0x0c, 0xf0,
	0xa9, 0x5d, 0x8d, 0xbc, 0xb2, 0xf2, 0xce, 0xd1, 0xa7, 0xd7, 0xb4, 0xde, 0x7c, 0x9a, 0x3f, 0xa9,
	0x77, 0x5d, 0xf6, 0xe6, 0x53, 0xbe, 0xa9, 0x32, 0x46, 0xa7, 0xbd, 0x91, 0x06, 0x49, 0x49, 0x5f,
	0xcb, 0x8f, 0x52, 0xc8, 0xf4, 0xaf, 0xab, 0xbc, 0x8a, 0x09, 0x6e, 0x24, 0xe8, 0x52, 0x40, 0x59,
	0x79, 0x33, 0xe7, 0x86, 0xb8, 0x16, 0x7b, 0xea, 0x8a, 0xdb, 0x3f, 0xfa, 0xa6, 0x1b, 0x93, 0xc1,
	0xcd, 0xf1, 0x93, 0x65, 0x58, 0x8a, 0x0c, 0x6e, 0x94, 0x5b, 0x51, 0xe6, 0xa8, 0x59, 0x6e, 0xa7,
	0x83, 0x52, 0x9e, 0xa1, 0x3c, 0xfb, 0x12, 0xd3, 0x14, 0xa2, 0xfc, 0x8a, 0x71, 0x6e, 0xa6, 0x20,
	0xb1, 0x95, 0x0a, 0x23, 0x14, 0x4c, 0x79, 0xc4, 0x4b, 0xac, 0x54, 0xf2, 0x35, 0xad, 0x78, 0x05,
	0x7e, 0x13, 0x7b, 0x0f, 0x20, 0x4a, 0xdd, 0x7e, 0x53, 0x35, 0x73, 0x63, 0x5a, 0xad, 0x33, 0x6e,
	0x33, 0xe5, 0x0e, 0xa6, 0xd8, 0x2c, 0x79, 0x33, 0x53, 0x6c, 0x96, 0x72, 0xe3, 0x2c, 0x5e, 0x29,
	0x2f, 0xff, 0xc3, 0x0f, 0x77, 0x32, 0xff, 0xf4, 0xc3, 0x9d, 0xcc, 0xbf, 0xff, 0x70, 0x27, 0xf3,
	0x6c, 0x9e, 0xfe, 0x91, 0xdc, 0xe7, 0xff, 0x15, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xd4, 0xd9, 0xdc,
	0x60, 0x37, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BGPSvcClient is the client API for BGPSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BGPSvcClient interface {
	BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error)
	BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error)
	BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error)
	BGPPrfxCntrsGet(ctx context.Context, in *BGPPrfxCntrsGetRequest, opts ...grpc.CallOption) (*BGPPrfxCntrsGetResponse, error)
}

type bGPSvcClient struct {
	cc *grpc.ClientConn
}

func NewBGPSvcClient(cc *grpc.ClientConn) BGPSvcClient {
	return &bGPSvcClient{cc}
}

func (c *bGPSvcClient) BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error) {
	out := new(BGPDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error) {
	out := new(BGPGetResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error) {
	out := new(BGPPeerDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error) {
	out := new(BGPPeerGetResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error) {
	out := new(BGPPeerAfDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error) {
	out := new(BGPPeerAfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error) {
	out := new(BGPClearRouteResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPClearRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error) {
	out := new(BGPNLRIPrefixGetResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPNLRIPrefixGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPrfxCntrsGet(ctx context.Context, in *BGPPrfxCntrsGetRequest, opts ...grpc.CallOption) (*BGPPrfxCntrsGetResponse, error) {
	out := new(BGPPrfxCntrsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.BGPSvc/BGPPrfxCntrsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BGPSvcServer is the server API for BGPSvc service.
type BGPSvcServer interface {
	BGPCreate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPUpdate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPDelete(context.Context, *BGPDeleteRequest) (*BGPDeleteResponse, error)
	BGPGet(context.Context, *BGPGetRequest) (*BGPGetResponse, error)
	BGPPeerCreate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerUpdate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerDelete(context.Context, *BGPPeerDeleteRequest) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(context.Context, *BGPPeerGetRequest) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(context.Context, *BGPPeerAfDeleteRequest) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(context.Context, *BGPPeerAfGetRequest) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(context.Context, *BGPClearRouteRequest) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(context.Context, *BGPNLRIPrefixGetRequest) (*BGPNLRIPrefixGetResponse, error)
	BGPPrfxCntrsGet(context.Context, *BGPPrfxCntrsGetRequest) (*BGPPrfxCntrsGetResponse, error)
}

// UnimplementedBGPSvcServer can be embedded to have forward compatible implementations.
type UnimplementedBGPSvcServer struct {
}

func (*UnimplementedBGPSvcServer) BGPCreate(ctx context.Context, req *BGPRequest) (*BGPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPCreate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPUpdate(ctx context.Context, req *BGPRequest) (*BGPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPUpdate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPDelete(ctx context.Context, req *BGPDeleteRequest) (*BGPDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPDelete not implemented")
}
func (*UnimplementedBGPSvcServer) BGPGet(ctx context.Context, req *BGPGetRequest) (*BGPGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPGet not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerCreate(ctx context.Context, req *BGPPeerRequest) (*BGPPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerCreate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerUpdate(ctx context.Context, req *BGPPeerRequest) (*BGPPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerUpdate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerDelete(ctx context.Context, req *BGPPeerDeleteRequest) (*BGPPeerDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerDelete not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerGet(ctx context.Context, req *BGPPeerGetRequest) (*BGPPeerGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerGet not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerAfCreate(ctx context.Context, req *BGPPeerAfRequest) (*BGPPeerAfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerAfCreate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerAfUpdate(ctx context.Context, req *BGPPeerAfRequest) (*BGPPeerAfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerAfUpdate not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerAfDelete(ctx context.Context, req *BGPPeerAfDeleteRequest) (*BGPPeerAfDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerAfDelete not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPeerAfGet(ctx context.Context, req *BGPPeerAfGetRequest) (*BGPPeerAfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPeerAfGet not implemented")
}
func (*UnimplementedBGPSvcServer) BGPClearRoute(ctx context.Context, req *BGPClearRouteRequest) (*BGPClearRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPClearRoute not implemented")
}
func (*UnimplementedBGPSvcServer) BGPNLRIPrefixGet(ctx context.Context, req *BGPNLRIPrefixGetRequest) (*BGPNLRIPrefixGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPNLRIPrefixGet not implemented")
}
func (*UnimplementedBGPSvcServer) BGPPrfxCntrsGet(ctx context.Context, req *BGPPrfxCntrsGetRequest) (*BGPPrfxCntrsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BGPPrfxCntrsGet not implemented")
}

func RegisterBGPSvcServer(s *grpc.Server, srv BGPSvcServer) {
	s.RegisterService(&_BGPSvc_serviceDesc, srv)
}

func _BGPSvc_BGPCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPCreate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPUpdate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPDelete(ctx, req.(*BGPDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPGet(ctx, req.(*BGPGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, req.(*BGPPeerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, req.(*BGPPeerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, req.(*BGPPeerAfDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, req.(*BGPPeerAfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPClearRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPClearRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPClearRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, req.(*BGPClearRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPNLRIPrefixGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPNLRIPrefixGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPNLRIPrefixGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, req.(*BGPNLRIPrefixGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPrfxCntrsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPrfxCntrsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPrfxCntrsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPrfxCntrsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPrfxCntrsGet(ctx, req.(*BGPPrfxCntrsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BGPSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.BGPSvc",
	HandlerType: (*BGPSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BGPCreate",
			Handler:    _BGPSvc_BGPCreate_Handler,
		},
		{
			MethodName: "BGPUpdate",
			Handler:    _BGPSvc_BGPUpdate_Handler,
		},
		{
			MethodName: "BGPDelete",
			Handler:    _BGPSvc_BGPDelete_Handler,
		},
		{
			MethodName: "BGPGet",
			Handler:    _BGPSvc_BGPGet_Handler,
		},
		{
			MethodName: "BGPPeerCreate",
			Handler:    _BGPSvc_BGPPeerCreate_Handler,
		},
		{
			MethodName: "BGPPeerUpdate",
			Handler:    _BGPSvc_BGPPeerUpdate_Handler,
		},
		{
			MethodName: "BGPPeerDelete",
			Handler:    _BGPSvc_BGPPeerDelete_Handler,
		},
		{
			MethodName: "BGPPeerGet",
			Handler:    _BGPSvc_BGPPeerGet_Handler,
		},
		{
			MethodName: "BGPPeerAfCreate",
			Handler:    _BGPSvc_BGPPeerAfCreate_Handler,
		},
		{
			MethodName: "BGPPeerAfUpdate",
			Handler:    _BGPSvc_BGPPeerAfUpdate_Handler,
		},
		{
			MethodName: "BGPPeerAfDelete",
			Handler:    _BGPSvc_BGPPeerAfDelete_Handler,
		},
		{
			MethodName: "BGPPeerAfGet",
			Handler:    _BGPSvc_BGPPeerAfGet_Handler,
		},
		{
			MethodName: "BGPClearRoute",
			Handler:    _BGPSvc_BGPClearRoute_Handler,
		},
		{
			MethodName: "BGPNLRIPrefixGet",
			Handler:    _BGPSvc_BGPNLRIPrefixGet_Handler,
		},
		{
			MethodName: "BGPPrfxCntrsGet",
			Handler:    _BGPSvc_BGPPrfxCntrsGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bgp.proto",
}

func (m *BGPSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SuppressDefaultResolution {
		i--
		if m.SuppressDefaultResolution {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ClusterId != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClusterId))
		i--
		dAtA[i] = 0x25
	}
	if m.RouterId != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RouterId))
		i--
		dAtA[i] = 0x1d
	}
	if m.LocalASN != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalASN))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableVer != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.TableVer))
		i--
		dAtA[i] = 0x28
	}
	if m.RemDelayTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RemDelayTime))
		i--
		dAtA[i] = 0x20
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PeakNumAdjRibOutRoutes))
		i--
		dAtA[i] = 0x18
	}
	if m.NumAdjRibOutRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumAdjRibOutRoutes))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPAfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPAfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPAfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumLocRibECMPRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibECMPRoutes))
		i--
		dAtA[i] = 0x70
	}
	if m.NumLocRibNextHops != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibNextHops))
		i--
		dAtA[i] = 0x68
	}
	if m.NumLocRibBestRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibBestRoutes))
		i--
		dAtA[i] = 0x60
	}
	if m.NumLocRibRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibRoutes))
		i--
		dAtA[i] = 0x58
	}
	if m.InPrfxesDeniedByPol != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedByPol))
		i--
		dAtA[i] = 0x50
	}
	if m.OutPrfxesAdvertised != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesAdvertised))
		i--
		dAtA[i] = 0x48
	}
	if m.OutPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxes))
		i--
		dAtA[i] = 0x40
	}
	if m.InPrfxesRejected != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesRejected))
		i--
		dAtA[i] = 0x38
	}
	if m.InPrfxesAccepted != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesAccepted))
		i--
		dAtA[i] = 0x30
	}
	if m.InPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxes))
		i--
		dAtA[i] = 0x28
	}
	if m.EBGPPrefixes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.EBGPPrefixes))
		i--
		dAtA[i] = 0x20
	}
	if m.IBGPPrefixes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.IBGPPrefixes))
		i--
		dAtA[i] = 0x18
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x10
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AfStats) > 0 {
		for iNdEx := len(m.AfStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AfStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowLocalAS != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.AllowLocalAS))
		i--
		dAtA[i] = 0x78
	}
	if m.IdleHoldTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.IdleHoldTime))
		i--
		dAtA[i] = 0x70
	}
	if m.Ttl != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x62
	}
	if m.KeepAlive != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x58
	}
	if m.HoldTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
		i--
		dAtA[i] = 0x50
	}
	if m.ConnectRetry != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetry))
		i--
		dAtA[i] = 0x48
	}
	if m.RRClient != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RRClient))
		i--
		dAtA[i] = 0x40
	}
	if m.SendExtComm {
		i--
		if m.SendExtComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SendComm {
		i--
		if m.SendComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.RemoteASN != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RemoteASN))
		i--
		dAtA[i] = 0x28
	}
	if m.PeerAddr != nil {
		{
			size, err := m.PeerAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LocalAddr != nil {
		{
			size, err := m.LocalAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperState != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OperState))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.Ttl != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.PeerIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerIndex))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.OutOpens != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutOpens))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.InOpens != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InOpens))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.InUpdatesElpsTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InUpdatesElpsTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.FsmEstablishedTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.FsmEstablishedTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ReceivedHoldTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ReceivedHoldTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.InPrfxesExpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesExpWdr))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.InPrfxesImpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesImpWdr))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.OutPrfxesExpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesExpWdr))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.OutPrfxesImpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesImpWdr))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.OutPrfxesDenied != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesDenied))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.OutUpdateElpsTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutUpdateElpsTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.ConnectRetryInt != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetryInt))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.OutPrfxesAdvertised != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesAdvertised))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.OutPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.InPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RouteRefrRcvd != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteRefrRcvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.RouteRefrSent != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteRefrSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.RcvdMsgElpsTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RcvdMsgElpsTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.OrfEntryCount != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OrfEntryCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.StalePathTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.StalePathTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Peergr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Peergr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ConnectRetryCount != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetryCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.FsmEstTransitions != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.FsmEstTransitions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OutTotalMessages != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutTotalMessages))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.InTotalMessages != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InTotalMessages))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.OutRefreshes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutRefreshes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.InRefreshes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InRefreshes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.OutKeepalives != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutKeepalives))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.InKeepalives != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InKeepalives))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.OutUpdates != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutUpdates))
		i--
		dAtA[i] = 0x78
	}
	if m.InUpdates != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InUpdates))
		i--
		dAtA[i] = 0x70
	}
	if m.OutNotifications != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutNotifications))
		i--
		dAtA[i] = 0x68
	}
	if m.InNotifications != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InNotifications))
		i--
		dAtA[i] = 0x60
	}
	if m.SelLocalAddrType != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.SelLocalAddrType))
		i--
		dAtA[i] = 0x58
	}
	if m.CapsNeg != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsNeg))
		i--
		dAtA[i] = 0x50
	}
	if m.CapsRcvd != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsRcvd))
		i--
		dAtA[i] = 0x48
	}
	if m.CapsSent != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsSent))
		i--
		dAtA[i] = 0x40
	}
	if m.KeepAlive != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x38
	}
	if m.HoldTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
		i--
		dAtA[i] = 0x30
	}
	if m.LocalAddr != nil {
		{
			size, err := m.LocalAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastErrorSent) > 0 {
		i -= len(m.LastErrorSent)
		copy(dAtA[i:], m.LastErrorSent)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorSent)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LastErrorRcvd) > 0 {
		i -= len(m.LastErrorRcvd)
		copy(dAtA[i:], m.LastErrorRcvd)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorRcvd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PrevStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PrevStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PeerAddr != nil {
		{
			size, err := m.PeerAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LocalAddr != nil {
		{
			size, err := m.LocalAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPPeerKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *BGPPeerKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPPeerKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BGPPeerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LocalAddrScopeId != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddrScopeId))
		i--
		dAtA[i] = 0x50
	}
	if m.RemotePort != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RemotePort))
		i--
		dAtA[i] = 0x48
	}
	if m.LocalPort != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalPort))
		i--
		dAtA[i] = 0x40
	}
	if m.DefaultOrig {
		i--
		if m.DefaultOrig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NexthopSelf {
		i--
		if m.NexthopSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x28
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerAddr != nil {
		{
			size, err := m.PeerAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LocalAddr != nil {
		{
			size, err := m.LocalAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReflectorClient != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ReflectorClient))
		i--
		dAtA[i] = 0x28
	}
	if m.AddPathCapNeg != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.AddPathCapNeg))
		i--
		dAtA[i] = 0x20
	}
	if m.RtRefresh {
		i--
		if m.RtRefresh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.LocalAddrScopeId != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddrScopeId))
		i--
		dAtA[i] = 0x10
	}
	if m.UpdateGroup != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.UpdateGroup))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x20
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerAddr != nil {
		{
			size, err := m.PeerAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LocalAddr != nil {
		{
			size, err := m.LocalAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IdOrKey != nil {
		{
			size := m.IdOrKey.Size()
			i -= size
			if _, err := m.IdOrKey.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPPeerAfKeyHandle_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *BGPPeerAfKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPPeerAfKeyHandle_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BGPPeerAfDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerAfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerAfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPClearRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPClearRouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PeerOrPeeraf != nil {
		{
			size := m.PeerOrPeeraf.Size()
			i -= size
			if _, err := m.PeerOrPeeraf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Option != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPClearRouteRequest_Peer) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPClearRouteRequest_Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BGPClearRouteRequest_PeerAf) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPClearRouteRequest_PeerAf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PeerAf != nil {
		{
			size, err := m.PeerAf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BGPClearRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPClearRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExtComm) > 0 {
		for iNdEx := len(m.ExtComm) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtComm[iNdEx])
			copy(dAtA[i:], m.ExtComm[iNdEx])
			i = encodeVarintBgp(dAtA, i, uint64(len(m.ExtComm[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.ReasonNotBest != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ReasonNotBest))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.FlapStartTime != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.FlapStartTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Stale {
		i--
		if m.Stale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.IsActive != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.IsActive))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.FlapStatsSupprsd {
		i--
		if m.FlapStatsSupprsd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FlapStatsFlapcnt != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.FlapStatsFlapcnt))
		i--
		dAtA[i] = 0x78
	}
	if m.PeerAddr != nil {
		{
			size, err := m.PeerAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.EcmpRoute {
		i--
		if m.EcmpRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ASSize != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ASSize))
		i--
		dAtA[i] = 0x60
	}
	if len(m.NextHopAddr) > 0 {
		i -= len(m.NextHopAddr)
		copy(dAtA[i:], m.NextHopAddr)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.NextHopAddr)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PathOrigId) > 0 {
		i -= len(m.PathOrigId)
		copy(dAtA[i:], m.PathOrigId)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.PathOrigId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ASPathStr) > 0 {
		i -= len(m.ASPathStr)
		copy(dAtA[i:], m.ASPathStr)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.ASPathStr)))
		i--
		dAtA[i] = 0x4a
	}
	if m.BestRoute {
		i--
		if m.BestRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PathID != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
		i--
		dAtA[i] = 0x38
	}
	if m.RouteSourceIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.RouteSource != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
		i--
		dAtA[i] = 0x28
	}
	if m.PrefixLen != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x10
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PathID != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
		i--
		dAtA[i] = 0x38
	}
	if m.RouteSourceIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.RouteSource != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
		i--
		dAtA[i] = 0x28
	}
	if m.PrefixLen != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x10
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Best {
		i--
		if m.Best {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IPAddress != nil {
		{
			size, err := m.IPAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NextHop != nil {
		{
			size, err := m.NextHop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RouteType != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteType))
		i--
		dAtA[i] = 0x18
	}
	if m.Vnid != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Vnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExtComm) > 0 {
		i -= len(m.ExtComm)
		copy(dAtA[i:], m.ExtComm)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.ExtComm)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixGetRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixGetRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPNLRIPrefixGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestsOrFilter != nil {
		{
			size := m.RequestsOrFilter.Size()
			i -= size
			if _, err := m.RequestsOrFilter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BGPNLRIPrefixGetRequest_Requests) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPNLRIPrefixGetRequest_Requests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Requests != nil {
		{
			size, err := m.Requests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *BGPNLRIPrefixGetRequest_Filter) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *BGPNLRIPrefixGetRequest_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BGPPrfxCntrsStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrsStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurPrfxesDeniedByPol != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.CurPrfxesDeniedByPol))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.InPrfxesExpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesExpWdr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.InPrfxesImpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesImpWdr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.OutPrfxesExpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesExpWdr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.OutPrfxesImpWdr != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesImpWdr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.OutPrfxesDenied != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesDenied))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.PeerState != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.OutTotalPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutTotalPrfxes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.InTotalPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InTotalPrfxes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.InPrfxesDeniedLocalOrig != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedLocalOrig))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.InPrfxesDeniedCommunity != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedCommunity))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.InPrfxesDeniedAsLength != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedAsLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.InPrfxesDeniedNextHop != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedNextHop))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.InPrfxesDeniedAsLoop != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedAsLoop))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.InPrfxesDeniedMartian != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedMartian))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.NumLocRibBestRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibBestRoutes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NumLocRibRoutes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibRoutes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.InPrfxesDeniedByPol != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedByPol))
		i--
		dAtA[i] = 0x78
	}
	if m.InPrfxesActive != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesActive))
		i--
		dAtA[i] = 0x70
	}
	if m.InPrfxesFlapHistory != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapHistory))
		i--
		dAtA[i] = 0x68
	}
	if m.InPrfxesFlapSuppressed != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapSuppressed))
		i--
		dAtA[i] = 0x60
	}
	if m.InPrfxesFlapped != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapped))
		i--
		dAtA[i] = 0x58
	}
	if len(m.UserData) > 0 {
		i -= len(m.UserData)
		copy(dAtA[i:], m.UserData)
		i = encodeVarintBgp(dAtA, i, uint64(len(m.UserData)))
		i--
		dAtA[i] = 0x52
	}
	if m.OutPrfxesAdvertised != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesAdvertised))
		i--
		dAtA[i] = 0x48
	}
	if m.OutPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxes))
		i--
		dAtA[i] = 0x40
	}
	if m.InPrfxesRejected != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesRejected))
		i--
		dAtA[i] = 0x38
	}
	if m.InPrfxesAccepted != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesAccepted))
		i--
		dAtA[i] = 0x30
	}
	if m.InPrfxes != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxes))
		i--
		dAtA[i] = 0x28
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x20
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPrfxCntrsKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrsKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Safi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
		i--
		dAtA[i] = 0x20
	}
	if m.Afi != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntIndex != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPrfxCntrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPrfxCntrsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BGPPrfxCntrsKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrsKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBgp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPrfxCntrsGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPrfxCntrsGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBgp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBgp(dAtA []byte, offset int, v uint64) int {
	offset -= sovBgp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BGPSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalASN != 0 {
		n += 1 + sovBgp(uint64(m.LocalASN))
	}
	if m.RouterId != 0 {
		n += 5
	}
	if m.ClusterId != 0 {
		n += 5
	}
	if m.Disable {
		n += 2
	}
	if m.SuppressDefaultResolution {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.NumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumAdjRibOutRoutes))
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.PeakNumAdjRibOutRoutes))
	}
	if m.RemDelayTime != 0 {
		n += 1 + sovBgp(uint64(m.RemDelayTime))
	}
	if m.TableVer != 0 {
		n += 1 + sovBgp(uint64(m.TableVer))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPAfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.IBGPPrefixes != 0 {
		n += 1 + sovBgp(uint64(m.IBGPPrefixes))
	}
	if m.EBGPPrefixes != 0 {
		n += 1 + sovBgp(uint64(m.EBGPPrefixes))
	}
	if m.InPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxes))
	}
	if m.InPrfxesAccepted != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesAccepted))
	}
	if m.InPrfxesRejected != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesRejected))
	}
	if m.OutPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxesAdvertised))
	}
	if m.InPrfxesDeniedByPol != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesDeniedByPol))
	}
	if m.NumLocRibRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumLocRibRoutes))
	}
	if m.NumLocRibBestRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumLocRibBestRoutes))
	}
	if m.NumLocRibNextHops != 0 {
		n += 1 + sovBgp(uint64(m.NumLocRibNextHops))
	}
	if m.NumLocRibECMPRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumLocRibECMPRoutes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AfStats) > 0 {
		for _, e := range m.AfStats {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBgp(uint64(m.State))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.RemoteASN != 0 {
		n += 1 + sovBgp(uint64(m.RemoteASN))
	}
	if m.SendComm {
		n += 2
	}
	if m.SendExtComm {
		n += 2
	}
	if m.RRClient != 0 {
		n += 1 + sovBgp(uint64(m.RRClient))
	}
	if m.ConnectRetry != 0 {
		n += 1 + sovBgp(uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovBgp(uint64(m.Ttl))
	}
	if m.IdleHoldTime != 0 {
		n += 1 + sovBgp(uint64(m.IdleHoldTime))
	}
	if m.AllowLocalAS != 0 {
		n += 1 + sovBgp(uint64(m.AllowLocalAS))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.PrevStatus != 0 {
		n += 1 + sovBgp(uint64(m.PrevStatus))
	}
	l = len(m.LastErrorRcvd)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.LastErrorSent)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	if m.CapsSent != 0 {
		n += 1 + sovBgp(uint64(m.CapsSent))
	}
	if m.CapsRcvd != 0 {
		n += 1 + sovBgp(uint64(m.CapsRcvd))
	}
	if m.CapsNeg != 0 {
		n += 1 + sovBgp(uint64(m.CapsNeg))
	}
	if m.SelLocalAddrType != 0 {
		n += 1 + sovBgp(uint64(m.SelLocalAddrType))
	}
	if m.InNotifications != 0 {
		n += 1 + sovBgp(uint64(m.InNotifications))
	}
	if m.OutNotifications != 0 {
		n += 1 + sovBgp(uint64(m.OutNotifications))
	}
	if m.InUpdates != 0 {
		n += 1 + sovBgp(uint64(m.InUpdates))
	}
	if m.OutUpdates != 0 {
		n += 1 + sovBgp(uint64(m.OutUpdates))
	}
	if m.InKeepalives != 0 {
		n += 2 + sovBgp(uint64(m.InKeepalives))
	}
	if m.OutKeepalives != 0 {
		n += 2 + sovBgp(uint64(m.OutKeepalives))
	}
	if m.InRefreshes != 0 {
		n += 2 + sovBgp(uint64(m.InRefreshes))
	}
	if m.OutRefreshes != 0 {
		n += 2 + sovBgp(uint64(m.OutRefreshes))
	}
	if m.InTotalMessages != 0 {
		n += 2 + sovBgp(uint64(m.InTotalMessages))
	}
	if m.OutTotalMessages != 0 {
		n += 2 + sovBgp(uint64(m.OutTotalMessages))
	}
	if m.FsmEstTransitions != 0 {
		n += 2 + sovBgp(uint64(m.FsmEstTransitions))
	}
	if m.ConnectRetryCount != 0 {
		n += 2 + sovBgp(uint64(m.ConnectRetryCount))
	}
	if m.Peergr != 0 {
		n += 2 + sovBgp(uint64(m.Peergr))
	}
	if m.StalePathTime != 0 {
		n += 2 + sovBgp(uint64(m.StalePathTime))
	}
	if m.OrfEntryCount != 0 {
		n += 2 + sovBgp(uint64(m.OrfEntryCount))
	}
	if m.RcvdMsgElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.RcvdMsgElpsTime))
	}
	if m.RouteRefrSent != 0 {
		n += 2 + sovBgp(uint64(m.RouteRefrSent))
	}
	if m.RouteRefrRcvd != 0 {
		n += 2 + sovBgp(uint64(m.RouteRefrRcvd))
	}
	if m.InPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxes))
	}
	if m.OutPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesAdvertised))
	}
	if m.ConnectRetryInt != 0 {
		n += 2 + sovBgp(uint64(m.ConnectRetryInt))
	}
	if m.OutUpdateElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.OutUpdateElpsTime))
	}
	if m.OutPrfxesDenied != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesExpWdr))
	}
	if m.ReceivedHoldTime != 0 {
		n += 2 + sovBgp(uint64(m.ReceivedHoldTime))
	}
	if m.FsmEstablishedTime != 0 {
		n += 2 + sovBgp(uint64(m.FsmEstablishedTime))
	}
	if m.InUpdatesElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.InUpdatesElpsTime))
	}
	if m.InOpens != 0 {
		n += 2 + sovBgp(uint64(m.InOpens))
	}
	if m.OutOpens != 0 {
		n += 2 + sovBgp(uint64(m.OutOpens))
	}
	if m.PeerIndex != 0 {
		n += 2 + sovBgp(uint64(m.PeerIndex))
	}
	if m.Ttl != 0 {
		n += 2 + sovBgp(uint64(m.Ttl))
	}
	if m.OperState != 0 {
		n += 2 + sovBgp(uint64(m.OperState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.NexthopSelf {
		n += 2
	}
	if m.DefaultOrig {
		n += 2
	}
	if m.LocalPort != 0 {
		n += 1 + sovBgp(uint64(m.LocalPort))
	}
	if m.RemotePort != 0 {
		n += 1 + sovBgp(uint64(m.RemotePort))
	}
	if m.LocalAddrScopeId != 0 {
		n += 1 + sovBgp(uint64(m.LocalAddrScopeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroup != 0 {
		n += 1 + sovBgp(uint64(m.UpdateGroup))
	}
	if m.LocalAddrScopeId != 0 {
		n += 1 + sovBgp(uint64(m.LocalAddrScopeId))
	}
	if m.RtRefresh {
		n += 2
	}
	if m.AddPathCapNeg != 0 {
		n += 1 + sovBgp(uint64(m.AddPathCapNeg))
	}
	if m.ReflectorClient != 0 {
		n += 1 + sovBgp(uint64(m.ReflectorClient))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfKeyHandle_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfKeyHandle_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPeerAfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPClearRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Option != 0 {
		n += 1 + sovBgp(uint64(m.Option))
	}
	if m.PeerOrPeeraf != nil {
		n += m.PeerOrPeeraf.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPClearRouteRequest_Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteRequest_PeerAf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerAf != nil {
		l = m.PeerAf.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	if m.BestRoute {
		n += 2
	}
	l = len(m.ASPathStr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.PathOrigId)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.NextHopAddr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.ASSize != 0 {
		n += 1 + sovBgp(uint64(m.ASSize))
	}
	if m.EcmpRoute {
		n += 2
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.FlapStatsFlapcnt != 0 {
		n += 1 + sovBgp(uint64(m.FlapStatsFlapcnt))
	}
	if m.FlapStatsSupprsd {
		n += 3
	}
	if m.IsActive != 0 {
		n += 2 + sovBgp(uint64(m.IsActive))
	}
	if m.Stale {
		n += 3
	}
	if m.FlapStartTime != 0 {
		n += 2 + sovBgp(uint64(m.FlapStartTime))
	}
	if m.ReasonNotBest != 0 {
		n += 2 + sovBgp(uint64(m.ReasonNotBest))
	}
	if len(m.ExtComm) > 0 {
		for _, b := range m.ExtComm {
			l = len(b)
			n += 2 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExtComm)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Vnid != 0 {
		n += 1 + sovBgp(uint64(m.Vnid))
	}
	if m.RouteType != 0 {
		n += 1 + sovBgp(uint64(m.RouteType))
	}
	if m.NextHop != nil {
		l = m.NextHop.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.IPAddress != nil {
		l = m.IPAddress.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Best {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixGetRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestsOrFilter != nil {
		n += m.RequestsOrFilter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPNLRIPrefixGetRequest_Requests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requests != nil {
		l = m.Requests.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPNLRIPrefixGetRequest_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPrfxCntrsStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		n += 1 + sovBgp(uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.InPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxes))
	}
	if m.InPrfxesAccepted != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesAccepted))
	}
	if m.InPrfxesRejected != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesRejected))
	}
	if m.OutPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxesAdvertised))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.InPrfxesFlapped != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapped))
	}
	if m.InPrfxesFlapSuppressed != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapSuppressed))
	}
	if m.InPrfxesFlapHistory != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapHistory))
	}
	if m.InPrfxesActive != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesActive))
	}
	if m.InPrfxesDeniedByPol != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesDeniedByPol))
	}
	if m.NumLocRibRoutes != 0 {
		n += 2 + sovBgp(uint64(m.NumLocRibRoutes))
	}
	if m.NumLocRibBestRoutes != 0 {
		n += 2 + sovBgp(uint64(m.NumLocRibBestRoutes))
	}
	if m.InPrfxesDeniedMartian != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedMartian))
	}
	if m.InPrfxesDeniedAsLoop != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedAsLoop))
	}
	if m.InPrfxesDeniedNextHop != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedNextHop))
	}
	if m.InPrfxesDeniedAsLength != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedAsLength))
	}
	if m.InPrfxesDeniedCommunity != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedCommunity))
	}
	if m.InPrfxesDeniedLocalOrig != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedLocalOrig))
	}
	if m.InTotalPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.InTotalPrfxes))
	}
	if m.OutTotalPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.OutTotalPrfxes))
	}
	if m.PeerState != 0 {
		n += 2 + sovBgp(uint64(m.PeerState))
	}
	if m.OutPrfxesDenied != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesExpWdr))
	}
	if m.CurPrfxesDeniedByPol != 0 {
		n += 2 + sovBgp(uint64(m.CurPrfxesDeniedByPol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPrfxCntrsKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		n += 1 + sovBgp(uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPrfxCntrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPrfxCntrsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPrfxCntrsKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPPrfxCntrsGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBgp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBgp(x uint64) (n int) {
	return sovBgp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BGPSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalASN", wireType)
			}
			m.LocalASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalASN |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			m.RouterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressDefaultResolution", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuppressDefaultResolution = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BGPOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAdjRibOutRoutes", wireType)
			}
			m.NumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAdjRibOutRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakNumAdjRibOutRoutes", wireType)
			}
			m.PeakNumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakNumAdjRibOutRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemDelayTime", wireType)
			}
			m.RemDelayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemDelayTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableVer", wireType)
			}
			m.TableVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableVer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPAfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPAfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPAfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBGPPrefixes", wireType)
			}
			m.IBGPPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IBGPPrefixes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EBGPPrefixes", wireType)
			}
			m.EBGPPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EBGPPrefixes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxes", wireType)
			}
			m.InPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesAccepted", wireType)
			}
			m.InPrfxesAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesAccepted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesRejected", wireType)
			}
			m.InPrfxesRejected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesRejected |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxes", wireType)
			}
			m.OutPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesAdvertised", wireType)
			}
			m.OutPrfxesAdvertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesAdvertised |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedByPol", wireType)
			}
			m.InPrfxesDeniedByPol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedByPol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibRoutes", wireType)
			}
			m.NumLocRibRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibBestRoutes", wireType)
			}
			m.NumLocRibBestRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibBestRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibNextHops", wireType)
			}
			m.NumLocRibNextHops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibNextHops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibECMPRoutes", wireType)
			}
			m.NumLocRibECMPRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibECMPRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfStats = append(m.AfStats, &BGPAfStats{})
			if err := m.AfStats[len(m.AfStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &BGPStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &BGP{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AdminState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteASN", wireType)
			}
			m.RemoteASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteASN |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendComm = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendExtComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendExtComm = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRClient", wireType)
			}
			m.RRClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RRClient |= BGPPeerRRClient(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetry", wireType)
			}
			m.ConnectRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleHoldTime", wireType)
			}
			m.IdleHoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleHoldTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowLocalAS", wireType)
			}
			m.AllowLocalAS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowLocalAS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BGPPeerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevStatus", wireType)
			}
			m.PrevStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevStatus |= BGPPeerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorRcvd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorRcvd = append(m.LastErrorRcvd[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorRcvd == nil {
				m.LastErrorRcvd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorSent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorSent = append(m.LastErrorSent[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorSent == nil {
				m.LastErrorSent = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsSent", wireType)
			}
			m.CapsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsRcvd", wireType)
			}
			m.CapsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsRcvd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsNeg", wireType)
			}
			m.CapsNeg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsNeg |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelLocalAddrType", wireType)
			}
			m.SelLocalAddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelLocalAddrType |= BGPAddrType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InNotifications", wireType)
			}
			m.InNotifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InNotifications |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNotifications", wireType)
			}
			m.OutNotifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutNotifications |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUpdates", wireType)
			}
			m.InUpdates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUpdates |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUpdates", wireType)
			}
			m.OutUpdates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUpdates |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InKeepalives", wireType)
			}
			m.InKeepalives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InKeepalives |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutKeepalives", wireType)
			}
			m.OutKeepalives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutKeepalives |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRefreshes", wireType)
			}
			m.InRefreshes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InRefreshes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRefreshes", wireType)
			}
			m.OutRefreshes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutRefreshes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTotalMessages", wireType)
			}
			m.InTotalMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InTotalMessages |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTotalMessages", wireType)
			}
			m.OutTotalMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutTotalMessages |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsmEstTransitions", wireType)
			}
			m.FsmEstTransitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsmEstTransitions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetryCount", wireType)
			}
			m.ConnectRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetryCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peergr", wireType)
			}
			m.Peergr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Peergr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePathTime", wireType)
			}
			m.StalePathTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePathTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrfEntryCount", wireType)
			}
			m.OrfEntryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrfEntryCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvdMsgElpsTime", wireType)
			}
			m.RcvdMsgElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvdMsgElpsTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRefrSent", wireType)
			}
			m.RouteRefrSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteRefrSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRefrRcvd", wireType)
			}
			m.RouteRefrRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteRefrRcvd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxes", wireType)
			}
			m.InPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxes", wireType)
			}
			m.OutPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesAdvertised", wireType)
			}
			m.OutPrfxesAdvertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesAdvertised |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetryInt", wireType)
			}
			m.ConnectRetryInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetryInt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUpdateElpsTime", wireType)
			}
			m.OutUpdateElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUpdateElpsTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesDenied", wireType)
			}
			m.OutPrfxesDenied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesDenied |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesImpWdr", wireType)
			}
			m.OutPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesImpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesExpWdr", wireType)
			}
			m.OutPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesExpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesImpWdr", wireType)
			}
			m.InPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesImpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesExpWdr", wireType)
			}
			m.InPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesExpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedHoldTime", wireType)
			}
			m.ReceivedHoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedHoldTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsmEstablishedTime", wireType)
			}
			m.FsmEstablishedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsmEstablishedTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUpdatesElpsTime", wireType)
			}
			m.InUpdatesElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUpdatesElpsTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOpens", wireType)
			}
			m.InOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InOpens |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutOpens", wireType)
			}
			m.OutOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutOpens |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIndex", wireType)
			}
			m.PeerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperState", wireType)
			}
			m.OperState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperState |= BGPOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeer{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NexthopSelf = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOrig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultOrig = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			m.RemotePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddrScopeId", wireType)
			}
			m.LocalAddrScopeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAddrScopeId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroup", wireType)
			}
			m.UpdateGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateGroup |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddrScopeId", wireType)
			}
			m.LocalAddrScopeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAddrScopeId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtRefresh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RtRefresh = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPathCapNeg", wireType)
			}
			m.AddPathCapNeg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddPathCapNeg |= BgpAddPathCapNegCap(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReflectorClient", wireType)
			}
			m.ReflectorClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReflectorClient |= BGPPeerRRClient(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerAfSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerAfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerAfKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerAfKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeerAf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= BGPClearRouteOptions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_Peer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_PeerAf{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= NLRISrc(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BestRoute = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASPathStr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ASPathStr = append(m.ASPathStr[:0], dAtA[iNdEx:postIndex]...)
			if m.ASPathStr == nil {
				m.ASPathStr = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOrigId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOrigId = append(m.PathOrigId[:0], dAtA[iNdEx:postIndex]...)
			if m.PathOrigId == nil {
				m.PathOrigId = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopAddr = append(m.NextHopAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.NextHopAddr == nil {
				m.NextHopAddr = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASSize", wireType)
			}
			m.ASSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ASSize |= BGPASSize(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EcmpRoute = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStatsFlapcnt", wireType)
			}
			m.FlapStatsFlapcnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlapStatsFlapcnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStatsSupprsd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlapStatsSupprsd = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			m.IsActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActive |= BGPNLRIIsActive(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stale = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStartTime", wireType)
			}
			m.FlapStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlapStartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonNotBest", wireType)
			}
			m.ReasonNotBest = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReasonNotBest |= BGPRsnNotBest(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtComm", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtComm = append(m.ExtComm, make([]byte, postIndex-iNdEx))
			copy(m.ExtComm[len(m.ExtComm)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= NLRISrc(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtComm", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtComm = append(m.ExtComm[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtComm == nil {
				m.ExtComm = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnid", wireType)
			}
			m.Vnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteType", wireType)
			}
			m.RouteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextHop == nil {
				m.NextHop = &IPAddress{}
			}
			if err := m.NextHop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddress == nil {
				m.IPAddress = &IPAddress{}
			}
			if err := m.IPAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Best = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPNLRIPrefixStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPNLRIPrefix{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPNLRIPrefixKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPNLRIPrefixKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPNLRIPrefixGetRequests{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestsOrFilter = &BGPNLRIPrefixGetRequest_Requests{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPNLRIPrefixFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestsOrFilter = &BGPNLRIPrefixGetRequest_Filter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIndex", wireType)
			}
			m.PeerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxes", wireType)
			}
			m.InPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesAccepted", wireType)
			}
			m.InPrfxesAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesAccepted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesRejected", wireType)
			}
			m.InPrfxesRejected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesRejected |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxes", wireType)
			}
			m.OutPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesAdvertised", wireType)
			}
			m.OutPrfxesAdvertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesAdvertised |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapped", wireType)
			}
			m.InPrfxesFlapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapped |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapSuppressed", wireType)
			}
			m.InPrfxesFlapSuppressed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapSuppressed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapHistory", wireType)
			}
			m.InPrfxesFlapHistory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapHistory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesActive", wireType)
			}
			m.InPrfxesActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesActive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedByPol", wireType)
			}
			m.InPrfxesDeniedByPol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedByPol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibRoutes", wireType)
			}
			m.NumLocRibRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibBestRoutes", wireType)
			}
			m.NumLocRibBestRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibBestRoutes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedMartian", wireType)
			}
			m.InPrfxesDeniedMartian = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedMartian |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedAsLoop", wireType)
			}
			m.InPrfxesDeniedAsLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedAsLoop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedNextHop", wireType)
			}
			m.InPrfxesDeniedNextHop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedNextHop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedAsLength", wireType)
			}
			m.InPrfxesDeniedAsLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedAsLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedCommunity", wireType)
			}
			m.InPrfxesDeniedCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedCommunity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedLocalOrig", wireType)
			}
			m.InPrfxesDeniedLocalOrig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedLocalOrig |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTotalPrfxes", wireType)
			}
			m.InTotalPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InTotalPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTotalPrfxes", wireType)
			}
			m.OutTotalPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutTotalPrfxes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerState", wireType)
			}
			m.PeerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerState |= BGPPeerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesDenied", wireType)
			}
			m.OutPrfxesDenied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesDenied |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesImpWdr", wireType)
			}
			m.OutPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesImpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesExpWdr", wireType)
			}
			m.OutPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesExpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesImpWdr", wireType)
			}
			m.InPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesImpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesExpWdr", wireType)
			}
			m.InPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesExpWdr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurPrfxesDeniedByPol", wireType)
			}
			m.CurPrfxesDeniedByPol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurPrfxesDeniedByPol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIndex", wireType)
			}
			m.PeerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= BGPAfi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= BGPSafi(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPrfxCntrsStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPrfxCntrs{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPPrfxCntrsKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBgp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPrfxCntrsKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBgp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBgp
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBgp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBgp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBgp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBgp
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBgp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBgp   = fmt.Errorf("proto: integer overflow")
)
