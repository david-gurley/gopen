// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tgw.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VPC attachment to Transit Gateway
type TGwVPCAttachment struct {
	// VPC to be attached to the Transit Gateway
	VPCId uint32 `protobuf:"varint,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	// Subnet to be attached the Transit Gateway
	SubnetId uint32 `protobuf:"varint,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	// IPv4 route table to be used for this attachment, 0 for default route table
	IPv4RouteTableId uint32 `protobuf:"varint,3,opt,name=IPv4RouteTableId,proto3" json:"IPv4RouteTableId,omitempty"`
	// IPv6 route table to be used for this attachment, 0 for default route table
	IPv6RouteTableId uint32 `protobuf:"varint,4,opt,name=IPv6RouteTableId,proto3" json:"IPv6RouteTableId,omitempty"`
	// if RoutePropagationEn is true, attached VPC will have its
	// routes added to route table of the attachment or default route table of
	// the Transit Gateway this attachment is part of
	RoutePropagationEn   bool     `protobuf:"varint,5,opt,name=RoutePropagationEn,proto3" json:"RoutePropagationEn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TGwVPCAttachment) Reset()         { *m = TGwVPCAttachment{} }
func (m *TGwVPCAttachment) String() string { return proto.CompactTextString(m) }
func (*TGwVPCAttachment) ProtoMessage()    {}
func (*TGwVPCAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{0}
}
func (m *TGwVPCAttachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwVPCAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwVPCAttachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwVPCAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwVPCAttachment.Merge(m, src)
}
func (m *TGwVPCAttachment) XXX_Size() int {
	return m.Size()
}
func (m *TGwVPCAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwVPCAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_TGwVPCAttachment proto.InternalMessageInfo

func (m *TGwVPCAttachment) GetVPCId() uint32 {
	if m != nil {
		return m.VPCId
	}
	return 0
}

func (m *TGwVPCAttachment) GetSubnetId() uint32 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *TGwVPCAttachment) GetIPv4RouteTableId() uint32 {
	if m != nil {
		return m.IPv4RouteTableId
	}
	return 0
}

func (m *TGwVPCAttachment) GetIPv6RouteTableId() uint32 {
	if m != nil {
		return m.IPv6RouteTableId
	}
	return 0
}

func (m *TGwVPCAttachment) GetRoutePropagationEn() bool {
	if m != nil {
		return m.RoutePropagationEn
	}
	return false
}

// VPN attachment to Transit Gateway
type TGwVPNAttachment struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TGwVPNAttachment) Reset()         { *m = TGwVPNAttachment{} }
func (m *TGwVPNAttachment) String() string { return proto.CompactTextString(m) }
func (*TGwVPNAttachment) ProtoMessage()    {}
func (*TGwVPNAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{1}
}
func (m *TGwVPNAttachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwVPNAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwVPNAttachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwVPNAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwVPNAttachment.Merge(m, src)
}
func (m *TGwVPNAttachment) XXX_Size() int {
	return m.Size()
}
func (m *TGwVPNAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwVPNAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_TGwVPNAttachment proto.InternalMessageInfo

// TGwSpec captures Trasnit Gawteway configuration
type TGwSpec struct {
	// unique key/identifier of Tranit Gateway
	Id uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// IPv4 route tables of the Transit Gateway
	IPv4RouteTableId []uint32 `protobuf:"varint,2,rep,packed,name=IPv4RouteTableId,proto3" json:"IPv4RouteTableId,omitempty"`
	// IPv6 route tables of the Transit Gateway
	IPv6RouteTableId []uint32 `protobuf:"varint,3,rep,packed,name=IPv6RouteTableId,proto3" json:"IPv6RouteTableId,omitempty"`
	// default IPv4 route table id to be used for this TGw or 0, if none
	IPv4DefaultRouteTableId uint32 `protobuf:"varint,4,opt,name=IPv4DefaultRouteTableId,proto3" json:"IPv4DefaultRouteTableId,omitempty"`
	// default IPv6 route table id to be used for this TGw or 0, if none
	IPv6DefaultRouteTableId uint32 `protobuf:"varint,5,opt,name=IPv6DefaultRouteTableId,proto3" json:"IPv6DefaultRouteTableId,omitempty"`
	// VPC attachments
	VPCAttachments []*TGwVPCAttachment `protobuf:"bytes,6,rep,name=VPCAttachments,proto3" json:"VPCAttachments,omitempty"`
	// VPN attachments
	VPNAttachments       []*TGwVPNAttachment `protobuf:"bytes,7,rep,name=VPNAttachments,proto3" json:"VPNAttachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TGwSpec) Reset()         { *m = TGwSpec{} }
func (m *TGwSpec) String() string { return proto.CompactTextString(m) }
func (*TGwSpec) ProtoMessage()    {}
func (*TGwSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{2}
}
func (m *TGwSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwSpec.Merge(m, src)
}
func (m *TGwSpec) XXX_Size() int {
	return m.Size()
}
func (m *TGwSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TGwSpec proto.InternalMessageInfo

func (m *TGwSpec) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TGwSpec) GetIPv4RouteTableId() []uint32 {
	if m != nil {
		return m.IPv4RouteTableId
	}
	return nil
}

func (m *TGwSpec) GetIPv6RouteTableId() []uint32 {
	if m != nil {
		return m.IPv6RouteTableId
	}
	return nil
}

func (m *TGwSpec) GetIPv4DefaultRouteTableId() uint32 {
	if m != nil {
		return m.IPv4DefaultRouteTableId
	}
	return 0
}

func (m *TGwSpec) GetIPv6DefaultRouteTableId() uint32 {
	if m != nil {
		return m.IPv6DefaultRouteTableId
	}
	return 0
}

func (m *TGwSpec) GetVPCAttachments() []*TGwVPCAttachment {
	if m != nil {
		return m.VPCAttachments
	}
	return nil
}

func (m *TGwSpec) GetVPNAttachments() []*TGwVPNAttachment {
	if m != nil {
		return m.VPNAttachments
	}
	return nil
}

// operational status of a Transit Gateway, if any
type TGwStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TGwStatus) Reset()         { *m = TGwStatus{} }
func (m *TGwStatus) String() string { return proto.CompactTextString(m) }
func (*TGwStatus) ProtoMessage()    {}
func (*TGwStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{3}
}
func (m *TGwStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwStatus.Merge(m, src)
}
func (m *TGwStatus) XXX_Size() int {
	return m.Size()
}
func (m *TGwStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TGwStatus proto.InternalMessageInfo

// stats of a Transit Gateway, if any
type TGwStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TGwStats) Reset()         { *m = TGwStats{} }
func (m *TGwStats) String() string { return proto.CompactTextString(m) }
func (*TGwStats) ProtoMessage()    {}
func (*TGwStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{4}
}
func (m *TGwStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwStats.Merge(m, src)
}
func (m *TGwStats) XXX_Size() int {
	return m.Size()
}
func (m *TGwStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwStats.DiscardUnknown(m)
}

var xxx_messageInfo_TGwStats proto.InternalMessageInfo

// Transit Gateway object
type TGw struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *TGwSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *TGwStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *TGwStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TGw) Reset()         { *m = TGw{} }
func (m *TGw) String() string { return proto.CompactTextString(m) }
func (*TGw) ProtoMessage()    {}
func (*TGw) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{5}
}
func (m *TGw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGw.Merge(m, src)
}
func (m *TGw) XXX_Size() int {
	return m.Size()
}
func (m *TGw) XXX_DiscardUnknown() {
	xxx_messageInfo_TGw.DiscardUnknown(m)
}

var xxx_messageInfo_TGw proto.InternalMessageInfo

func (m *TGw) GetSpec() *TGwSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TGw) GetStatus() *TGwStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TGw) GetStats() *TGwStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Transit Gateway create and update request
type TGwRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched requests
	Request              []*TGwSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TGwRequest) Reset()         { *m = TGwRequest{} }
func (m *TGwRequest) String() string { return proto.CompactTextString(m) }
func (*TGwRequest) ProtoMessage()    {}
func (*TGwRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{6}
}
func (m *TGwRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwRequest.Merge(m, src)
}
func (m *TGwRequest) XXX_Size() int {
	return m.Size()
}
func (m *TGwRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TGwRequest proto.InternalMessageInfo

func (m *TGwRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *TGwRequest) GetRequest() []*TGwSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Transit Gateway create and update response
type TGwResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TGwStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TGwResponse) Reset()         { *m = TGwResponse{} }
func (m *TGwResponse) String() string { return proto.CompactTextString(m) }
func (*TGwResponse) ProtoMessage()    {}
func (*TGwResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{7}
}
func (m *TGwResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwResponse.Merge(m, src)
}
func (m *TGwResponse) XXX_Size() int {
	return m.Size()
}
func (m *TGwResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TGwResponse proto.InternalMessageInfo

func (m *TGwResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TGwResponse) GetResponse() []*TGwStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// Transit Gateway get request
type TGwGetRequest struct {
	Id                   []uint32 `protobuf:"varint,1,rep,packed,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TGwGetRequest) Reset()         { *m = TGwGetRequest{} }
func (m *TGwGetRequest) String() string { return proto.CompactTextString(m) }
func (*TGwGetRequest) ProtoMessage()    {}
func (*TGwGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{8}
}
func (m *TGwGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwGetRequest.Merge(m, src)
}
func (m *TGwGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *TGwGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TGwGetRequest proto.InternalMessageInfo

func (m *TGwGetRequest) GetId() []uint32 {
	if m != nil {
		return m.Id
	}
	return nil
}

// Transit Gateway get response
type TGwGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TGw    `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TGwGetResponse) Reset()         { *m = TGwGetResponse{} }
func (m *TGwGetResponse) String() string { return proto.CompactTextString(m) }
func (*TGwGetResponse) ProtoMessage()    {}
func (*TGwGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{9}
}
func (m *TGwGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwGetResponse.Merge(m, src)
}
func (m *TGwGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TGwGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TGwGetResponse proto.InternalMessageInfo

func (m *TGwGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TGwGetResponse) GetResponse() []*TGw {
	if m != nil {
		return m.Response
	}
	return nil
}

// Transit Gateway delete request
type TGwDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   []uint32   `protobuf:"varint,2,rep,packed,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TGwDeleteRequest) Reset()         { *m = TGwDeleteRequest{} }
func (m *TGwDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*TGwDeleteRequest) ProtoMessage()    {}
func (*TGwDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{10}
}
func (m *TGwDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwDeleteRequest.Merge(m, src)
}
func (m *TGwDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *TGwDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TGwDeleteRequest proto.InternalMessageInfo

func (m *TGwDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *TGwDeleteRequest) GetId() []uint32 {
	if m != nil {
		return m.Id
	}
	return nil
}

// Transit Gateway delete response
type TGwDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TGwDeleteResponse) Reset()         { *m = TGwDeleteResponse{} }
func (m *TGwDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*TGwDeleteResponse) ProtoMessage()    {}
func (*TGwDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5666a3a26dd25d5c, []int{11}
}
func (m *TGwDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGwDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TGwDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TGwDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGwDeleteResponse.Merge(m, src)
}
func (m *TGwDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *TGwDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TGwDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TGwDeleteResponse proto.InternalMessageInfo

func (m *TGwDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*TGwVPCAttachment)(nil), "pds.TGwVPCAttachment")
	proto.RegisterType((*TGwVPNAttachment)(nil), "pds.TGwVPNAttachment")
	proto.RegisterType((*TGwSpec)(nil), "pds.TGwSpec")
	proto.RegisterType((*TGwStatus)(nil), "pds.TGwStatus")
	proto.RegisterType((*TGwStats)(nil), "pds.TGwStats")
	proto.RegisterType((*TGw)(nil), "pds.TGw")
	proto.RegisterType((*TGwRequest)(nil), "pds.TGwRequest")
	proto.RegisterType((*TGwResponse)(nil), "pds.TGwResponse")
	proto.RegisterType((*TGwGetRequest)(nil), "pds.TGwGetRequest")
	proto.RegisterType((*TGwGetResponse)(nil), "pds.TGwGetResponse")
	proto.RegisterType((*TGwDeleteRequest)(nil), "pds.TGwDeleteRequest")
	proto.RegisterType((*TGwDeleteResponse)(nil), "pds.TGwDeleteResponse")
}

func init() { proto.RegisterFile("tgw.proto", fileDescriptor_5666a3a26dd25d5c) }

var fileDescriptor_5666a3a26dd25d5c = []byte{
	// 707 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0x4f, 0x4f, 0xdb, 0x4c,
	0x10, 0xc6, 0x5f, 0xdb, 0xe4, 0x0f, 0x13, 0x48, 0xf2, 0x2e, 0xbc, 0xbc, 0x51, 0x0e, 0x24, 0xb2,
	0xaa, 0x0a, 0x21, 0xe4, 0x56, 0x01, 0x21, 0xd4, 0x52, 0x55, 0x38, 0x54, 0x56, 0x0e, 0xa5, 0xd1,
	0xe2, 0x72, 0x77, 0xe2, 0x25, 0xa4, 0x4a, 0x6c, 0x37, 0xde, 0x90, 0xe6, 0x63, 0xf5, 0x5b, 0xf4,
	0xd0, 0x03, 0x9f, 0x20, 0xad, 0x38, 0x72, 0xec, 0xa5, 0xd7, 0x6a, 0xd7, 0xeb, 0x8d, 0x1d, 0x82,
	0x8a, 0xb8, 0x20, 0xf6, 0x99, 0xf9, 0x31, 0xf3, 0xcc, 0xec, 0x1a, 0x58, 0xa5, 0xbd, 0x89, 0x11,
	0x8c, 0x7c, 0xea, 0x23, 0x2d, 0x70, 0xc3, 0x2a, 0xf4, 0xfc, 0x9e, 0x1f, 0x09, 0xd5, 0xd2, 0x90,
	0x50, 0xe7, 0x05, 0xfb, 0x21, 0x84, 0x02, 0x9d, 0x06, 0x24, 0x8c, 0x0e, 0xfa, 0x77, 0x05, 0xca,
	0xb6, 0x35, 0xb9, 0x68, 0x37, 0x4f, 0x28, 0x75, 0xba, 0x57, 0x43, 0xe2, 0x51, 0xb4, 0x09, 0x99,
	0x8b, 0x76, 0xb3, 0xe5, 0x56, 0x94, 0xba, 0xb2, 0xb3, 0x8e, 0xa3, 0x03, 0xaa, 0x42, 0xfe, 0x7c,
	0xdc, 0xf1, 0x08, 0x6d, 0xb9, 0x15, 0x95, 0x07, 0xe4, 0x19, 0xed, 0x42, 0xb9, 0xd5, 0xbe, 0x3e,
	0xc0, 0xfe, 0x98, 0x12, 0xdb, 0xe9, 0x0c, 0x48, 0xcb, 0xad, 0x68, 0x3c, 0xe7, 0x9e, 0x2e, 0x72,
	0x0f, 0x53, 0xb9, 0x2b, 0x32, 0x37, 0xa5, 0x23, 0x03, 0x10, 0x3f, 0xb7, 0x47, 0x7e, 0xe0, 0xf4,
	0x1c, 0xda, 0xf7, 0xbd, 0x77, 0x5e, 0x25, 0x53, 0x57, 0x76, 0xf2, 0x78, 0x49, 0x44, 0x47, 0xc2,
	0xcd, 0xd9, 0xdc, 0x8d, 0xfe, 0x5b, 0x85, 0x9c, 0x6d, 0x4d, 0xce, 0x03, 0xd2, 0x45, 0x3a, 0xa8,
	0xb1, 0x2d, 0x13, 0xfd, 0x9a, 0xd5, 0x8a, 0x6c, 0x2e, 0xaf, 0x86, 0x8e, 0xe7, 0x3a, 0xd4, 0x1f,
	0x4d, 0xb1, 0xfa, 0x80, 0x17, 0xb5, 0xae, 0x3d, 0xda, 0x8b, 0x26, 0x73, 0xd3, 0x5e, 0x8e, 0xe0,
	0x7f, 0xc6, 0x9f, 0x92, 0x4b, 0x67, 0x3c, 0xa0, 0x4b, 0xec, 0x3f, 0x14, 0x16, 0xe4, 0xe1, 0x32,
	0x32, 0x23, 0xc9, 0x65, 0x61, 0xf4, 0x06, 0x8a, 0xa9, 0xd5, 0x86, 0x95, 0x6c, 0x5d, 0xdb, 0x29,
	0x34, 0xfe, 0x33, 0x02, 0x37, 0x34, 0x16, 0x17, 0x8f, 0x17, 0x92, 0x23, 0xfc, 0x2c, 0x89, 0xe7,
	0x16, 0xf1, 0xb3, 0x34, 0x9e, 0x4c, 0xd6, 0x0b, 0xb0, 0xca, 0x06, 0x4f, 0x1d, 0x3a, 0x0e, 0x75,
	0x80, 0xbc, 0x38, 0x84, 0xfa, 0x57, 0x15, 0x34, 0xdb, 0x9a, 0xa0, 0xd7, 0x90, 0xb7, 0xa7, 0x01,
	0x79, 0x4f, 0xa8, 0xc3, 0x97, 0x52, 0x68, 0x14, 0x0d, 0x7e, 0x53, 0x63, 0xd5, 0x2c, 0xdd, 0xcc,
	0x6a, 0xca, 0xdd, 0xac, 0x96, 0xdb, 0xeb, 0x7b, 0x83, 0xbe, 0x47, 0xb0, 0x04, 0xd0, 0x5b, 0xc8,
	0x7d, 0xe8, 0x7c, 0xe2, 0xac, 0xca, 0xd9, 0xf5, 0x88, 0x15, 0xa2, 0xb9, 0x25, 0x50, 0xbe, 0xe3,
	0x3d, 0x7f, 0xd8, 0xa7, 0x64, 0x18, 0xd0, 0x29, 0x8e, 0x29, 0x74, 0x00, 0x2b, 0xec, 0x52, 0xf0,
	0x8b, 0x5a, 0x68, 0xac, 0xc5, 0x9e, 0x98, 0x66, 0x22, 0x06, 0x86, 0x01, 0xe9, 0x26, 0x40, 0x9e,
	0x8d, 0x8e, 0x21, 0x1b, 0x39, 0xe2, 0x5b, 0x63, 0x1d, 0xc7, 0x1c, 0x57, 0xcd, 0xcd, 0xbb, 0x59,
	0xad, 0x1c, 0xf2, 0xdf, 0x13, 0xac, 0x60, 0xd0, 0x11, 0x64, 0xf8, 0x08, 0xf8, 0xe2, 0x58, 0xcb,
	0x09, 0x38, 0x34, 0x37, 0xee, 0x66, 0xb5, 0x12, 0x63, 0x93, 0x68, 0x04, 0xe8, 0x2e, 0x80, 0x6d,
	0x4d, 0x30, 0xf9, 0x3c, 0x26, 0x21, 0x45, 0x06, 0xac, 0x9a, 0x0e, 0xed, 0x5e, 0x35, 0xe9, 0x17,
	0x2a, 0x46, 0x57, 0x36, 0xa2, 0x87, 0x2d, 0x75, 0x3c, 0x4f, 0x41, 0xcf, 0x21, 0x27, 0x50, 0x7e,
	0x97, 0x17, 0xec, 0xe2, 0x38, 0xa8, 0xf7, 0xa1, 0xc0, 0xab, 0x84, 0x81, 0xef, 0x85, 0x84, 0x95,
	0x39, 0x09, 0xfa, 0xc2, 0x2f, 0x2b, 0x53, 0x94, 0x65, 0xa4, 0x8e, 0xe7, 0x29, 0x68, 0x17, 0xf2,
	0x31, 0x2b, 0xea, 0x2c, 0x8c, 0x07, 0xcb, 0xb8, 0x5e, 0x83, 0x75, 0xdb, 0x9a, 0x58, 0x84, 0xc6,
	0x9e, 0x8a, 0xe2, 0x71, 0xb2, 0xe7, 0xa3, 0xb6, 0x5c, 0xfd, 0x12, 0x8a, 0x71, 0xc2, 0x13, 0xdb,
	0x79, 0x76, 0xaf, 0x9d, 0x7c, 0xdc, 0x4e, 0xa2, 0x11, 0xcc, 0x3f, 0x1a, 0xa7, 0x64, 0x40, 0x28,
	0x79, 0xea, 0x7c, 0xa3, 0xde, 0x55, 0xd9, 0x7b, 0x13, 0xfe, 0x4d, 0xfc, 0xcd, 0xe5, 0xed, 0x6b,
	0x7f, 0x69, 0xbf, 0xf1, 0x43, 0x81, 0x2c, 0x9b, 0xdc, 0x75, 0x17, 0xbd, 0xe4, 0x4f, 0xa9, 0x39,
	0x22, 0x0e, 0x25, 0xa8, 0x24, 0x4d, 0x44, 0xdd, 0x56, 0xcb, 0x73, 0x41, 0x78, 0xfa, 0x47, 0x10,
	0x1f, 0x03, 0xf7, 0xd1, 0xc4, 0x3e, 0xaf, 0x66, 0x11, 0x8a, 0x50, 0x1c, 0x9d, 0x6f, 0xa7, 0xba,
	0x91, 0xd2, 0x24, 0x74, 0xcc, 0xcb, 0x44, 0x46, 0x91, 0xfc, 0x2e, 0xa4, 0x86, 0x59, 0xdd, 0x5a,
	0x94, 0x63, 0xda, 0x5c, 0xfb, 0x76, 0xbb, 0xad, 0xdc, 0xdc, 0x6e, 0x2b, 0x3f, 0x6f, 0xb7, 0x95,
	0x4e, 0x96, 0xff, 0x4f, 0xda, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x21, 0x08, 0xe2, 0x1e, 0xcf,
	0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TGwSvcClient is the client API for TGwSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TGwSvcClient interface {
	TGwCreate(ctx context.Context, in *TGwRequest, opts ...grpc.CallOption) (*TGwResponse, error)
	TGwUpdate(ctx context.Context, in *TGwRequest, opts ...grpc.CallOption) (*TGwResponse, error)
	TGwGet(ctx context.Context, in *TGwGetRequest, opts ...grpc.CallOption) (*TGwGetResponse, error)
	TGwDelete(ctx context.Context, in *TGwDeleteRequest, opts ...grpc.CallOption) (*TGwDeleteResponse, error)
}

type tGwSvcClient struct {
	cc *grpc.ClientConn
}

func NewTGwSvcClient(cc *grpc.ClientConn) TGwSvcClient {
	return &tGwSvcClient{cc}
}

func (c *tGwSvcClient) TGwCreate(ctx context.Context, in *TGwRequest, opts ...grpc.CallOption) (*TGwResponse, error) {
	out := new(TGwResponse)
	err := c.cc.Invoke(ctx, "/pds.TGwSvc/TGwCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tGwSvcClient) TGwUpdate(ctx context.Context, in *TGwRequest, opts ...grpc.CallOption) (*TGwResponse, error) {
	out := new(TGwResponse)
	err := c.cc.Invoke(ctx, "/pds.TGwSvc/TGwUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tGwSvcClient) TGwGet(ctx context.Context, in *TGwGetRequest, opts ...grpc.CallOption) (*TGwGetResponse, error) {
	out := new(TGwGetResponse)
	err := c.cc.Invoke(ctx, "/pds.TGwSvc/TGwGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tGwSvcClient) TGwDelete(ctx context.Context, in *TGwDeleteRequest, opts ...grpc.CallOption) (*TGwDeleteResponse, error) {
	out := new(TGwDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.TGwSvc/TGwDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TGwSvcServer is the server API for TGwSvc service.
type TGwSvcServer interface {
	TGwCreate(context.Context, *TGwRequest) (*TGwResponse, error)
	TGwUpdate(context.Context, *TGwRequest) (*TGwResponse, error)
	TGwGet(context.Context, *TGwGetRequest) (*TGwGetResponse, error)
	TGwDelete(context.Context, *TGwDeleteRequest) (*TGwDeleteResponse, error)
}

// UnimplementedTGwSvcServer can be embedded to have forward compatible implementations.
type UnimplementedTGwSvcServer struct {
}

func (*UnimplementedTGwSvcServer) TGwCreate(ctx context.Context, req *TGwRequest) (*TGwResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TGwCreate not implemented")
}
func (*UnimplementedTGwSvcServer) TGwUpdate(ctx context.Context, req *TGwRequest) (*TGwResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TGwUpdate not implemented")
}
func (*UnimplementedTGwSvcServer) TGwGet(ctx context.Context, req *TGwGetRequest) (*TGwGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TGwGet not implemented")
}
func (*UnimplementedTGwSvcServer) TGwDelete(ctx context.Context, req *TGwDeleteRequest) (*TGwDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TGwDelete not implemented")
}

func RegisterTGwSvcServer(s *grpc.Server, srv TGwSvcServer) {
	s.RegisterService(&_TGwSvc_serviceDesc, srv)
}

func _TGwSvc_TGwCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TGwRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TGwSvcServer).TGwCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TGwSvc/TGwCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TGwSvcServer).TGwCreate(ctx, req.(*TGwRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TGwSvc_TGwUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TGwRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TGwSvcServer).TGwUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TGwSvc/TGwUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TGwSvcServer).TGwUpdate(ctx, req.(*TGwRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TGwSvc_TGwGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TGwGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TGwSvcServer).TGwGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TGwSvc/TGwGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TGwSvcServer).TGwGet(ctx, req.(*TGwGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TGwSvc_TGwDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TGwDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TGwSvcServer).TGwDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.TGwSvc/TGwDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TGwSvcServer).TGwDelete(ctx, req.(*TGwDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TGwSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.TGwSvc",
	HandlerType: (*TGwSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TGwCreate",
			Handler:    _TGwSvc_TGwCreate_Handler,
		},
		{
			MethodName: "TGwUpdate",
			Handler:    _TGwSvc_TGwUpdate_Handler,
		},
		{
			MethodName: "TGwGet",
			Handler:    _TGwSvc_TGwGet_Handler,
		},
		{
			MethodName: "TGwDelete",
			Handler:    _TGwSvc_TGwDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tgw.proto",
}

func (m *TGwVPCAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwVPCAttachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwVPCAttachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoutePropagationEn {
		i--
		if m.RoutePropagationEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IPv6RouteTableId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.IPv6RouteTableId))
		i--
		dAtA[i] = 0x20
	}
	if m.IPv4RouteTableId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.IPv4RouteTableId))
		i--
		dAtA[i] = 0x18
	}
	if m.SubnetId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x10
	}
	if m.VPCId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.VPCId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TGwVPNAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwVPNAttachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwVPNAttachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TGwSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VPNAttachments) > 0 {
		for iNdEx := len(m.VPNAttachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VPNAttachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTgw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.VPCAttachments) > 0 {
		for iNdEx := len(m.VPCAttachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VPCAttachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTgw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.IPv6DefaultRouteTableId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.IPv6DefaultRouteTableId))
		i--
		dAtA[i] = 0x28
	}
	if m.IPv4DefaultRouteTableId != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.IPv4DefaultRouteTableId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IPv6RouteTableId) > 0 {
		dAtA2 := make([]byte, len(m.IPv6RouteTableId)*10)
		var j1 int
		for _, num := range m.IPv6RouteTableId {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTgw(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IPv4RouteTableId) > 0 {
		dAtA4 := make([]byte, len(m.IPv4RouteTableId)*10)
		var j3 int
		for _, num := range m.IPv4RouteTableId {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTgw(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TGwStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TGwStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TGw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TGwRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTgw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TGwResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTgw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TGwGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA12 := make([]byte, len(m.Id)*10)
		var j11 int
		for _, num := range m.Id {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTgw(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TGwGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTgw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTgw(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TGwDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA14 := make([]byte, len(m.Id)*10)
		var j13 int
		for _, num := range m.Id {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintTgw(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTgw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TGwDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGwDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGwDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA17 := make([]byte, len(m.ApiStatus)*10)
		var j16 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintTgw(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTgw(dAtA []byte, offset int, v uint64) int {
	offset -= sovTgw(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TGwVPCAttachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VPCId != 0 {
		n += 1 + sovTgw(uint64(m.VPCId))
	}
	if m.SubnetId != 0 {
		n += 1 + sovTgw(uint64(m.SubnetId))
	}
	if m.IPv4RouteTableId != 0 {
		n += 1 + sovTgw(uint64(m.IPv4RouteTableId))
	}
	if m.IPv6RouteTableId != 0 {
		n += 1 + sovTgw(uint64(m.IPv6RouteTableId))
	}
	if m.RoutePropagationEn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwVPNAttachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTgw(uint64(m.Id))
	}
	if len(m.IPv4RouteTableId) > 0 {
		l = 0
		for _, e := range m.IPv4RouteTableId {
			l += sovTgw(uint64(e))
		}
		n += 1 + sovTgw(uint64(l)) + l
	}
	if len(m.IPv6RouteTableId) > 0 {
		l = 0
		for _, e := range m.IPv6RouteTableId {
			l += sovTgw(uint64(e))
		}
		n += 1 + sovTgw(uint64(l)) + l
	}
	if m.IPv4DefaultRouteTableId != 0 {
		n += 1 + sovTgw(uint64(m.IPv4DefaultRouteTableId))
	}
	if m.IPv6DefaultRouteTableId != 0 {
		n += 1 + sovTgw(uint64(m.IPv6DefaultRouteTableId))
	}
	if len(m.VPCAttachments) > 0 {
		for _, e := range m.VPCAttachments {
			l = e.Size()
			n += 1 + l + sovTgw(uint64(l))
		}
	}
	if len(m.VPNAttachments) > 0 {
		for _, e := range m.VPNAttachments {
			l = e.Size()
			n += 1 + l + sovTgw(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTgw(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTgw(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTgw(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovTgw(uint64(e))
		}
		n += 1 + sovTgw(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTgw(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTgw(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovTgw(uint64(l))
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovTgw(uint64(e))
		}
		n += 1 + sovTgw(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TGwDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovTgw(uint64(e))
		}
		n += 1 + sovTgw(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTgw(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTgw(x uint64) (n int) {
	return sovTgw(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TGwVPCAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwVPCAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwVPCAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			m.VPCId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VPCId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4RouteTableId", wireType)
			}
			m.IPv4RouteTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv4RouteTableId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6RouteTableId", wireType)
			}
			m.IPv6RouteTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv6RouteTableId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutePropagationEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoutePropagationEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwVPNAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwVPNAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwVPNAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IPv4RouteTableId = append(m.IPv4RouteTableId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTgw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTgw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IPv4RouteTableId) == 0 {
					m.IPv4RouteTableId = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTgw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IPv4RouteTableId = append(m.IPv4RouteTableId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4RouteTableId", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IPv6RouteTableId = append(m.IPv6RouteTableId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTgw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTgw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IPv6RouteTableId) == 0 {
					m.IPv6RouteTableId = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTgw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IPv6RouteTableId = append(m.IPv6RouteTableId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6RouteTableId", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4DefaultRouteTableId", wireType)
			}
			m.IPv4DefaultRouteTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv4DefaultRouteTableId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6DefaultRouteTableId", wireType)
			}
			m.IPv6DefaultRouteTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPv6DefaultRouteTableId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCAttachments = append(m.VPCAttachments, &TGwVPCAttachment{})
			if err := m.VPCAttachments[len(m.VPCAttachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPNAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPNAttachments = append(m.VPNAttachments, &TGwVPNAttachment{})
			if err := m.VPNAttachments[len(m.VPNAttachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TGwSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TGwStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TGwStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TGwSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TGwStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTgw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTgw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTgw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TGw{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTgw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTgw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTgw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTgw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGwDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGwDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGwDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTgw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTgw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTgw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTgw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTgw(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTgw
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTgw
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTgw
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTgw
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTgw(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTgw
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTgw = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTgw   = fmt.Errorf("proto: integer overflow")
)
