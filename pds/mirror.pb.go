// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mirror.proto

package pds

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// types of ERSPAN sessions differ in the encap
type ERSpanType int32

const (
	ERSpanType_ERSPAN_TYPE_NONE ERSpanType = 0
	// Type 1 ERSPAN
	ERSpanType_ERSPAN_TYPE_1 ERSpanType = 1
	// Type 2 ERSPAN
	ERSpanType_ERSPAN_TYPE_2 ERSpanType = 2
	// Type 3 ERSPAN
	ERSpanType_ERSPAN_TYPE_3 ERSpanType = 3
)

var ERSpanType_name = map[int32]string{
	0: "ERSPAN_TYPE_NONE",
	1: "ERSPAN_TYPE_1",
	2: "ERSPAN_TYPE_2",
	3: "ERSPAN_TYPE_3",
}

var ERSpanType_value = map[string]int32{
	"ERSPAN_TYPE_NONE": 0,
	"ERSPAN_TYPE_1":    1,
	"ERSPAN_TYPE_2":    2,
	"ERSPAN_TYPE_3":    3,
}

func (x ERSpanType) String() string {
	return proto.EnumName(ERSpanType_name, int32(x))
}

func (ERSpanType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{0}
}

// LSpanSpec is the configuration specification for LSPAN
type LSpanSpec struct {
	// host PF/VF or ARM PF/VF uuid
	Interface []byte `protobuf:"bytes,1,opt,name=Interface,proto3" json:"Interface,omitempty" meta:mandatory`
	// packets per second
	// NOTE:
	// 1. if pps is not set or configured as 0, then pps is set to 1000
	// 2. if pps is non-zero, then maximum acceptable pps is 8000
	PacketsPerSecond     uint64   `protobuf:"varint,2,opt,name=PacketsPerSecond,proto3" json:"PacketsPerSecond,omitempty" meta:range:0-8000,meta:default=1000`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LSpanSpec) Reset()         { *m = LSpanSpec{} }
func (m *LSpanSpec) String() string { return proto.CompactTextString(m) }
func (*LSpanSpec) ProtoMessage()    {}
func (*LSpanSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{0}
}
func (m *LSpanSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSpanSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSpanSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSpanSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSpanSpec.Merge(m, src)
}
func (m *LSpanSpec) XXX_Size() int {
	return m.Size()
}
func (m *LSpanSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LSpanSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LSpanSpec proto.InternalMessageInfo

func (m *LSpanSpec) GetInterface() []byte {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *LSpanSpec) GetPacketsPerSecond() uint64 {
	if m != nil {
		return m.PacketsPerSecond
	}
	return 0
}

// RspanSpec is the configuration specification for RSPAN
type RSpanSpec struct {
	// interface to send RSPAN pkts on
	// NOTE: uplink interfaces and host interfaces (aka. lif) are supported
	//       currently
	Interface []byte `protobuf:"bytes,1,opt,name=Interface,proto3" json:"Interface,omitempty" meta:mandatory`
	// RSPAN encap, only VLAN encapsulation supported here
	Encap                *Encap   `protobuf:"bytes,2,opt,name=Encap,proto3" json:"Encap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RSpanSpec) Reset()         { *m = RSpanSpec{} }
func (m *RSpanSpec) String() string { return proto.CompactTextString(m) }
func (*RSpanSpec) ProtoMessage()    {}
func (*RSpanSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{1}
}
func (m *RSpanSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSpanSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSpanSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RSpanSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSpanSpec.Merge(m, src)
}
func (m *RSpanSpec) XXX_Size() int {
	return m.Size()
}
func (m *RSpanSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RSpanSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RSpanSpec proto.InternalMessageInfo

func (m *RSpanSpec) GetInterface() []byte {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *RSpanSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

// ERSpanSpec is the configuration specification for ERSPAN
// NOTE: source IP used in the ERSPAN packet is either
//       1. subnet VR IP in case DstIP is in a VPC of type VPC_TYPE_TENANT
//       2. local TEP (MyTEP) IP in case DstIP is in VPC  of type
//          VPC_TYPE_UNDERLAY
type ERSpanSpec struct {
	// type of the ERSPAN session
	// NOTE: only TYPE 3 is supported currently
	Type ERSpanType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.ERSpanType" json:"Type,omitempty"`
	// VPC id
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory`
	// Types that are valid to be assigned to Erspandst:
	//	*ERSpanSpec_DstIP
	//	*ERSpanSpec_TunnelId
	Erspandst isERSpanSpec_Erspandst `protobuf_oneof:"erspandst"`
	// DSCP value to use in the packet
	Dscp uint32 `protobuf:"varint,5,opt,name=Dscp,proto3" json:"Dscp,omitempty"`
	// Span ID to use in the packet
	SpanId uint32 `protobuf:"varint,6,opt,name=SpanId,proto3" json:"SpanId,omitempty" meta:range:0,1023`
	// when VlanStripEn is set to true, dot1q tag of original packet is stripped
	// before mirroring
	// NOTE: VlanStringEn is applicable only for ERSPAN_TYPE_2 mirror session
	VlanStripEn          bool     `protobuf:"varint,7,opt,name=VlanStripEn,proto3" json:"VlanStripEn,omitempty" meta:constraints={ERSpanSpec.Type==ERSPAN_TYPE_2`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ERSpanSpec) Reset()         { *m = ERSpanSpec{} }
func (m *ERSpanSpec) String() string { return proto.CompactTextString(m) }
func (*ERSpanSpec) ProtoMessage()    {}
func (*ERSpanSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{2}
}
func (m *ERSpanSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERSpanSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERSpanSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERSpanSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERSpanSpec.Merge(m, src)
}
func (m *ERSpanSpec) XXX_Size() int {
	return m.Size()
}
func (m *ERSpanSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ERSpanSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ERSpanSpec proto.InternalMessageInfo

type isERSpanSpec_Erspandst interface {
	isERSpanSpec_Erspandst()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ERSpanSpec_DstIP struct {
	DstIP *IPAddress `protobuf:"bytes,3,opt,name=DstIP,proto3,oneof"`
}
type ERSpanSpec_TunnelId struct {
	TunnelId []byte `protobuf:"bytes,4,opt,name=TunnelId,proto3,oneof"`
}

func (*ERSpanSpec_DstIP) isERSpanSpec_Erspandst()    {}
func (*ERSpanSpec_TunnelId) isERSpanSpec_Erspandst() {}

func (m *ERSpanSpec) GetErspandst() isERSpanSpec_Erspandst {
	if m != nil {
		return m.Erspandst
	}
	return nil
}

func (m *ERSpanSpec) GetType() ERSpanType {
	if m != nil {
		return m.Type
	}
	return ERSpanType_ERSPAN_TYPE_NONE
}

func (m *ERSpanSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *ERSpanSpec) GetDstIP() *IPAddress {
	if x, ok := m.GetErspandst().(*ERSpanSpec_DstIP); ok {
		return x.DstIP
	}
	return nil
}

func (m *ERSpanSpec) GetTunnelId() []byte {
	if x, ok := m.GetErspandst().(*ERSpanSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (m *ERSpanSpec) GetDscp() uint32 {
	if m != nil {
		return m.Dscp
	}
	return 0
}

func (m *ERSpanSpec) GetSpanId() uint32 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

func (m *ERSpanSpec) GetVlanStripEn() bool {
	if m != nil {
		return m.VlanStripEn
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ERSpanSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ERSpanSpec_DstIP)(nil),
		(*ERSpanSpec_TunnelId)(nil),
	}
}

// MirrorSessionSpec captures configuration of mirror session
type MirrorSessionSpec struct {
	// unique identifier of mirror session
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// maximum  bytes of packet to mirror
	// NOTE:
	// 1. if SnapLen is not set (i.e., configured as 0), maximum of 128 bytes are
	//     mirrored by default
	// 2. if SnapLen is non-zero, minimum length acceptable is 64 and maximum
	//     acceptable length is 2048
	// 3. SnapLen specificed includes protocol headers of the tenant packet (i.e.,
	//    eth header, IP header, any L4 headers etc.)
	SnapLen uint32 `protobuf:"varint,2,opt,name=SnapLen,proto3" json:"SnapLen,omitempty" meta:range:0,64-2048`
	// Types that are valid to be assigned to Mirrordst:
	//	*MirrorSessionSpec_LspanSpec
	//	*MirrorSessionSpec_RspanSpec
	//	*MirrorSessionSpec_ErspanSpec
	Mirrordst            isMirrorSessionSpec_Mirrordst `protobuf_oneof:"mirrordst"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *MirrorSessionSpec) Reset()         { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()    {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{3}
}
func (m *MirrorSessionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionSpec.Merge(m, src)
}
func (m *MirrorSessionSpec) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionSpec proto.InternalMessageInfo

type isMirrorSessionSpec_Mirrordst interface {
	isMirrorSessionSpec_Mirrordst()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MirrorSessionSpec_LspanSpec struct {
	LspanSpec *LSpanSpec `protobuf:"bytes,3,opt,name=LspanSpec,proto3,oneof"`
}
type MirrorSessionSpec_RspanSpec struct {
	RspanSpec *RSpanSpec `protobuf:"bytes,4,opt,name=RspanSpec,proto3,oneof"`
}
type MirrorSessionSpec_ErspanSpec struct {
	ErspanSpec *ERSpanSpec `protobuf:"bytes,5,opt,name=ErspanSpec,proto3,oneof"`
}

func (*MirrorSessionSpec_LspanSpec) isMirrorSessionSpec_Mirrordst()  {}
func (*MirrorSessionSpec_RspanSpec) isMirrorSessionSpec_Mirrordst()  {}
func (*MirrorSessionSpec_ErspanSpec) isMirrorSessionSpec_Mirrordst() {}

func (m *MirrorSessionSpec) GetMirrordst() isMirrorSessionSpec_Mirrordst {
	if m != nil {
		return m.Mirrordst
	}
	return nil
}

func (m *MirrorSessionSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorSessionSpec) GetSnapLen() uint32 {
	if m != nil {
		return m.SnapLen
	}
	return 0
}

func (m *MirrorSessionSpec) GetLspanSpec() *LSpanSpec {
	if x, ok := m.GetMirrordst().(*MirrorSessionSpec_LspanSpec); ok {
		return x.LspanSpec
	}
	return nil
}

func (m *MirrorSessionSpec) GetRspanSpec() *RSpanSpec {
	if x, ok := m.GetMirrordst().(*MirrorSessionSpec_RspanSpec); ok {
		return x.RspanSpec
	}
	return nil
}

func (m *MirrorSessionSpec) GetErspanSpec() *ERSpanSpec {
	if x, ok := m.GetMirrordst().(*MirrorSessionSpec_ErspanSpec); ok {
		return x.ErspanSpec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MirrorSessionSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MirrorSessionSpec_LspanSpec)(nil),
		(*MirrorSessionSpec_RspanSpec)(nil),
		(*MirrorSessionSpec_ErspanSpec)(nil),
	}
}

// operational status of mirror session, if any
type MirrorSessionStatus struct {
	// hardware id allocated for the mirror session
	HwId uint32 `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	// hardware id allocated for CoPP enforcement, if any
	CoppHwId             uint32   `protobuf:"varint,2,opt,name=CoppHwId,proto3" json:"CoppHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorSessionStatus) Reset()         { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()    {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{4}
}
func (m *MirrorSessionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionStatus.Merge(m, src)
}
func (m *MirrorSessionStatus) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionStatus proto.InternalMessageInfo

func (m *MirrorSessionStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *MirrorSessionStatus) GetCoppHwId() uint32 {
	if m != nil {
		return m.CoppHwId
	}
	return 0
}

// stats of mirror session, if any
type MirrorSessionStats struct {
	// number of packets mirrored by this mirror session
	PacketCount uint64 `protobuf:"varint,1,opt,name=PacketCount,proto3" json:"PacketCount,omitempty"`
	// number of bytes mirrored by this mirror session
	ByteCount uint64 `protobuf:"varint,2,opt,name=ByteCount,proto3" json:"ByteCount,omitempty"`
	// number of packets dropped by this mirror session's copp policer
	DroppedPacketCount   uint64   `protobuf:"varint,3,opt,name=DroppedPacketCount,proto3" json:"DroppedPacketCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorSessionStats) Reset()         { *m = MirrorSessionStats{} }
func (m *MirrorSessionStats) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionStats) ProtoMessage()    {}
func (*MirrorSessionStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{5}
}
func (m *MirrorSessionStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionStats.Merge(m, src)
}
func (m *MirrorSessionStats) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionStats.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionStats proto.InternalMessageInfo

func (m *MirrorSessionStats) GetPacketCount() uint64 {
	if m != nil {
		return m.PacketCount
	}
	return 0
}

func (m *MirrorSessionStats) GetByteCount() uint64 {
	if m != nil {
		return m.ByteCount
	}
	return 0
}

func (m *MirrorSessionStats) GetDroppedPacketCount() uint64 {
	if m != nil {
		return m.DroppedPacketCount
	}
	return 0
}

// mirror session object
type MirrorSession struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *MirrorSessionSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *MirrorSessionStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *MirrorSessionStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MirrorSession) Reset()         { *m = MirrorSession{} }
func (m *MirrorSession) String() string { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()    {}
func (*MirrorSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{6}
}
func (m *MirrorSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSession.Merge(m, src)
}
func (m *MirrorSession) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSession) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSession.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSession proto.InternalMessageInfo

func (m *MirrorSession) GetSpec() *MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorSession) GetStatus() *MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *MirrorSession) GetStats() *MirrorSessionStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// mirror session create and update request
type MirrorSessionRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt           `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*MirrorSessionSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MirrorSessionRequest) Reset()         { *m = MirrorSessionRequest{} }
func (m *MirrorSessionRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionRequest) ProtoMessage()    {}
func (*MirrorSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{7}
}
func (m *MirrorSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionRequest.Merge(m, src)
}
func (m *MirrorSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionRequest proto.InternalMessageInfo

func (m *MirrorSessionRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorSessionRequest) GetRequest() []*MirrorSessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// mirror session create and update response
type MirrorSessionResponse struct {
	ApiStatus            ApiStatus              `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*MirrorSessionStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MirrorSessionResponse) Reset()         { *m = MirrorSessionResponse{} }
func (m *MirrorSessionResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionResponse) ProtoMessage()    {}
func (*MirrorSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{8}
}
func (m *MirrorSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionResponse.Merge(m, src)
}
func (m *MirrorSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionResponse proto.InternalMessageInfo

func (m *MirrorSessionResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionResponse) GetResponse() []*MirrorSessionStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror session get request
type MirrorSessionGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorSessionGetRequest) Reset()         { *m = MirrorSessionGetRequest{} }
func (m *MirrorSessionGetRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetRequest) ProtoMessage()    {}
func (*MirrorSessionGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{9}
}
func (m *MirrorSessionGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionGetRequest.Merge(m, src)
}
func (m *MirrorSessionGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionGetRequest proto.InternalMessageInfo

func (m *MirrorSessionGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror session get response
type MirrorSessionGetResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*MirrorSession `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MirrorSessionGetResponse) Reset()         { *m = MirrorSessionGetResponse{} }
func (m *MirrorSessionGetResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetResponse) ProtoMessage()    {}
func (*MirrorSessionGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{10}
}
func (m *MirrorSessionGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionGetResponse.Merge(m, src)
}
func (m *MirrorSessionGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionGetResponse proto.InternalMessageInfo

func (m *MirrorSessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionGetResponse) GetResponse() []*MirrorSession {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror session delete request
type MirrorSessionDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MirrorSessionDeleteRequest) Reset()         { *m = MirrorSessionDeleteRequest{} }
func (m *MirrorSessionDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteRequest) ProtoMessage()    {}
func (*MirrorSessionDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{11}
}
func (m *MirrorSessionDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionDeleteRequest.Merge(m, src)
}
func (m *MirrorSessionDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionDeleteRequest proto.InternalMessageInfo

func (m *MirrorSessionDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorSessionDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror session delete response
type MirrorSessionDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MirrorSessionDeleteResponse) Reset()         { *m = MirrorSessionDeleteResponse{} }
func (m *MirrorSessionDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteResponse) ProtoMessage()    {}
func (*MirrorSessionDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{12}
}
func (m *MirrorSessionDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorSessionDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorSessionDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorSessionDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorSessionDeleteResponse.Merge(m, src)
}
func (m *MirrorSessionDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorSessionDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorSessionDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorSessionDeleteResponse proto.InternalMessageInfo

func (m *MirrorSessionDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// IP protocol match condition
type IPProtocolMatch struct {
	// IP Protocol number
	Protocol             uint32   `protobuf:"varint,1,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPProtocolMatch) Reset()         { *m = IPProtocolMatch{} }
func (m *IPProtocolMatch) String() string { return proto.CompactTextString(m) }
func (*IPProtocolMatch) ProtoMessage()    {}
func (*IPProtocolMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{13}
}
func (m *IPProtocolMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPProtocolMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPProtocolMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPProtocolMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPProtocolMatch.Merge(m, src)
}
func (m *IPProtocolMatch) XXX_Size() int {
	return m.Size()
}
func (m *IPProtocolMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_IPProtocolMatch.DiscardUnknown(m)
}

var xxx_messageInfo_IPProtocolMatch proto.InternalMessageInfo

func (m *IPProtocolMatch) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

// TCP/UDP mactch condition(s)
type TCPUDPRuleMatch struct {
	// source port match condition
	SrcPort *TCPUDPRuleMatch_L4PortMatch `protobuf:"bytes,1,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	// destination port match condition
	DstPort *TCPUDPRuleMatch_L4PortMatch `protobuf:"bytes,2,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	// TCP SYN flag
	// NOTE: this is valid only if IP protocol is set to TCP
	TCPSyn bool `protobuf:"varint,3,opt,name=TCPSyn,proto3" json:"TCPSyn,omitempty"`
	// TCP FIN flag
	// NOTE: this is valid only if IP protocol is set to TCP
	TCPFin bool `protobuf:"varint,4,opt,name=TCPFin,proto3" json:"TCPFin,omitempty"`
	// TCP RST flag
	// NOTE: this is valid only if IP protocol is set to TCP
	TCPRst bool `protobuf:"varint,5,opt,name=TCPRst,proto3" json:"TCPRst,omitempty"`
	// TCP URG flag
	// NOTE: this is valid only if IP protocol is set to TCP
	TCPUrg bool `protobuf:"varint,6,opt,name=TCPUrg,proto3" json:"TCPUrg,omitempty"`
	// TCP PSH flag
	// NOTE: this is valid only if IP protocol is set to TCP
	TCPPsh               bool     `protobuf:"varint,7,opt,name=TCPPsh,proto3" json:"TCPPsh,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCPUDPRuleMatch) Reset()         { *m = TCPUDPRuleMatch{} }
func (m *TCPUDPRuleMatch) String() string { return proto.CompactTextString(m) }
func (*TCPUDPRuleMatch) ProtoMessage()    {}
func (*TCPUDPRuleMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{14}
}
func (m *TCPUDPRuleMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPUDPRuleMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPUDPRuleMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPUDPRuleMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPUDPRuleMatch.Merge(m, src)
}
func (m *TCPUDPRuleMatch) XXX_Size() int {
	return m.Size()
}
func (m *TCPUDPRuleMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPUDPRuleMatch.DiscardUnknown(m)
}

var xxx_messageInfo_TCPUDPRuleMatch proto.InternalMessageInfo

func (m *TCPUDPRuleMatch) GetSrcPort() *TCPUDPRuleMatch_L4PortMatch {
	if m != nil {
		return m.SrcPort
	}
	return nil
}

func (m *TCPUDPRuleMatch) GetDstPort() *TCPUDPRuleMatch_L4PortMatch {
	if m != nil {
		return m.DstPort
	}
	return nil
}

func (m *TCPUDPRuleMatch) GetTCPSyn() bool {
	if m != nil {
		return m.TCPSyn
	}
	return false
}

func (m *TCPUDPRuleMatch) GetTCPFin() bool {
	if m != nil {
		return m.TCPFin
	}
	return false
}

func (m *TCPUDPRuleMatch) GetTCPRst() bool {
	if m != nil {
		return m.TCPRst
	}
	return false
}

func (m *TCPUDPRuleMatch) GetTCPUrg() bool {
	if m != nil {
		return m.TCPUrg
	}
	return false
}

func (m *TCPUDPRuleMatch) GetTCPPsh() bool {
	if m != nil {
		return m.TCPPsh
	}
	return false
}

// TCP/UDP port match condition
type TCPUDPRuleMatch_L4PortMatch struct {
	// L4 port number
	Port                 uint32   `protobuf:"varint,1,opt,name=Port,proto3" json:"Port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCPUDPRuleMatch_L4PortMatch) Reset()         { *m = TCPUDPRuleMatch_L4PortMatch{} }
func (m *TCPUDPRuleMatch_L4PortMatch) String() string { return proto.CompactTextString(m) }
func (*TCPUDPRuleMatch_L4PortMatch) ProtoMessage()    {}
func (*TCPUDPRuleMatch_L4PortMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{14, 0}
}
func (m *TCPUDPRuleMatch_L4PortMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPUDPRuleMatch_L4PortMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPUDPRuleMatch_L4PortMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPUDPRuleMatch_L4PortMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPUDPRuleMatch_L4PortMatch.Merge(m, src)
}
func (m *TCPUDPRuleMatch_L4PortMatch) XXX_Size() int {
	return m.Size()
}
func (m *TCPUDPRuleMatch_L4PortMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPUDPRuleMatch_L4PortMatch.DiscardUnknown(m)
}

var xxx_messageInfo_TCPUDPRuleMatch_L4PortMatch proto.InternalMessageInfo

func (m *TCPUDPRuleMatch_L4PortMatch) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// ICMP match condition(s)
type ICMPRuleMatch struct {
	// ICMP type
	Type *ICMPRuleMatch_ICMPTypeMatch `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// ICMP code
	Code                 *ICMPRuleMatch_ICMPCodeMatch `protobuf:"bytes,2,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ICMPRuleMatch) Reset()         { *m = ICMPRuleMatch{} }
func (m *ICMPRuleMatch) String() string { return proto.CompactTextString(m) }
func (*ICMPRuleMatch) ProtoMessage()    {}
func (*ICMPRuleMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{15}
}
func (m *ICMPRuleMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPRuleMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPRuleMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPRuleMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPRuleMatch.Merge(m, src)
}
func (m *ICMPRuleMatch) XXX_Size() int {
	return m.Size()
}
func (m *ICMPRuleMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPRuleMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPRuleMatch proto.InternalMessageInfo

func (m *ICMPRuleMatch) GetType() *ICMPRuleMatch_ICMPTypeMatch {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ICMPRuleMatch) GetCode() *ICMPRuleMatch_ICMPCodeMatch {
	if m != nil {
		return m.Code
	}
	return nil
}

// ICMP type match condition
type ICMPRuleMatch_ICMPTypeMatch struct {
	// ICMP type value
	Type                 uint32   `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPRuleMatch_ICMPTypeMatch) Reset()         { *m = ICMPRuleMatch_ICMPTypeMatch{} }
func (m *ICMPRuleMatch_ICMPTypeMatch) String() string { return proto.CompactTextString(m) }
func (*ICMPRuleMatch_ICMPTypeMatch) ProtoMessage()    {}
func (*ICMPRuleMatch_ICMPTypeMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{15, 0}
}
func (m *ICMPRuleMatch_ICMPTypeMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPRuleMatch_ICMPTypeMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPRuleMatch_ICMPTypeMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPRuleMatch_ICMPTypeMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPRuleMatch_ICMPTypeMatch.Merge(m, src)
}
func (m *ICMPRuleMatch_ICMPTypeMatch) XXX_Size() int {
	return m.Size()
}
func (m *ICMPRuleMatch_ICMPTypeMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPRuleMatch_ICMPTypeMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPRuleMatch_ICMPTypeMatch proto.InternalMessageInfo

func (m *ICMPRuleMatch_ICMPTypeMatch) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// ICMP code match condition
type ICMPRuleMatch_ICMPCodeMatch struct {
	// ICMP code value
	Code                 uint32   `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPRuleMatch_ICMPCodeMatch) Reset()         { *m = ICMPRuleMatch_ICMPCodeMatch{} }
func (m *ICMPRuleMatch_ICMPCodeMatch) String() string { return proto.CompactTextString(m) }
func (*ICMPRuleMatch_ICMPCodeMatch) ProtoMessage()    {}
func (*ICMPRuleMatch_ICMPCodeMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{15, 1}
}
func (m *ICMPRuleMatch_ICMPCodeMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPRuleMatch_ICMPCodeMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPRuleMatch_ICMPCodeMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPRuleMatch_ICMPCodeMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPRuleMatch_ICMPCodeMatch.Merge(m, src)
}
func (m *ICMPRuleMatch_ICMPCodeMatch) XXX_Size() int {
	return m.Size()
}
func (m *ICMPRuleMatch_ICMPCodeMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPRuleMatch_ICMPCodeMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPRuleMatch_ICMPCodeMatch proto.InternalMessageInfo

func (m *ICMPRuleMatch_ICMPCodeMatch) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// mirror rule attributes
// NOTE: match criteria can have wildcards
type MirrorRuleAttrs struct {
	// optional VPC id to narrow down the matched IPs as IPs can overlap
	// across VPCs
	Vpc []byte `protobuf:"bytes,1,opt,name=Vpc,proto3" json:"Vpc,omitempty"`
	// optional vnic id as match condition
	Vnic []byte `protobuf:"bytes,2,opt,name=Vnic,proto3" json:"Vnic,omitempty"`
	// source prefix
	SrcPrefix *IPPrefix `protobuf:"bytes,3,opt,name=SrcPrefix,proto3" json:"SrcPrefix,omitempty"`
	// destination prefix
	DstPrefix *IPPrefix `protobuf:"bytes,4,opt,name=DstPrefix,proto3" json:"DstPrefix,omitempty"`
	// IP protocol
	IPProto *IPProtocolMatch `protobuf:"bytes,5,opt,name=IPProto,proto3" json:"IPProto,omitempty"`
	// L4 match conditions
	//
	// Types that are valid to be assigned to L4Info:
	//	*MirrorRuleAttrs_TCPUDPMatch
	//	*MirrorRuleAttrs_ICMPMatch
	L4Info isMirrorRuleAttrs_L4Info `protobuf_oneof:"l4info"`
	// DSCP in other header to match against
	DSCP uint32 `protobuf:"varint,8,opt,name=DSCP,proto3" json:"DSCP,omitempty"`
	// mirror session uuid containing details of SPAN collector
	MirrorSession        [][]byte `protobuf:"bytes,9,rep,name=MirrorSession,proto3" json:"MirrorSession,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorRuleAttrs) Reset()         { *m = MirrorRuleAttrs{} }
func (m *MirrorRuleAttrs) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleAttrs) ProtoMessage()    {}
func (*MirrorRuleAttrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{16}
}
func (m *MirrorRuleAttrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleAttrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleAttrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleAttrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleAttrs.Merge(m, src)
}
func (m *MirrorRuleAttrs) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleAttrs) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleAttrs.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleAttrs proto.InternalMessageInfo

type isMirrorRuleAttrs_L4Info interface {
	isMirrorRuleAttrs_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MirrorRuleAttrs_TCPUDPMatch struct {
	TCPUDPMatch *TCPUDPRuleMatch `protobuf:"bytes,6,opt,name=TCPUDPMatch,proto3,oneof"`
}
type MirrorRuleAttrs_ICMPMatch struct {
	ICMPMatch *ICMPRuleMatch `protobuf:"bytes,7,opt,name=ICMPMatch,proto3,oneof"`
}

func (*MirrorRuleAttrs_TCPUDPMatch) isMirrorRuleAttrs_L4Info() {}
func (*MirrorRuleAttrs_ICMPMatch) isMirrorRuleAttrs_L4Info()   {}

func (m *MirrorRuleAttrs) GetL4Info() isMirrorRuleAttrs_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *MirrorRuleAttrs) GetVpc() []byte {
	if m != nil {
		return m.Vpc
	}
	return nil
}

func (m *MirrorRuleAttrs) GetVnic() []byte {
	if m != nil {
		return m.Vnic
	}
	return nil
}

func (m *MirrorRuleAttrs) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *MirrorRuleAttrs) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *MirrorRuleAttrs) GetIPProto() *IPProtocolMatch {
	if m != nil {
		return m.IPProto
	}
	return nil
}

func (m *MirrorRuleAttrs) GetTCPUDPMatch() *TCPUDPRuleMatch {
	if x, ok := m.GetL4Info().(*MirrorRuleAttrs_TCPUDPMatch); ok {
		return x.TCPUDPMatch
	}
	return nil
}

func (m *MirrorRuleAttrs) GetICMPMatch() *ICMPRuleMatch {
	if x, ok := m.GetL4Info().(*MirrorRuleAttrs_ICMPMatch); ok {
		return x.ICMPMatch
	}
	return nil
}

func (m *MirrorRuleAttrs) GetDSCP() uint32 {
	if m != nil {
		return m.DSCP
	}
	return 0
}

func (m *MirrorRuleAttrs) GetMirrorSession() [][]byte {
	if m != nil {
		return m.MirrorSession
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MirrorRuleAttrs) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MirrorRuleAttrs_TCPUDPMatch)(nil),
		(*MirrorRuleAttrs_ICMPMatch)(nil),
	}
}

// MirrorRuleInfo is a single rule in the mirror policy
type MirrorRuleInfo struct {
	// optional rule id needed if incremental route ADD/DEL/UPD functionality
	// is needed
	Id                   []byte           `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Attrs                *MirrorRuleAttrs `protobuf:"bytes,2,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MirrorRuleInfo) Reset()         { *m = MirrorRuleInfo{} }
func (m *MirrorRuleInfo) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleInfo) ProtoMessage()    {}
func (*MirrorRuleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{17}
}
func (m *MirrorRuleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleInfo.Merge(m, src)
}
func (m *MirrorRuleInfo) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleInfo proto.InternalMessageInfo

func (m *MirrorRuleInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorRuleInfo) GetAttrs() *MirrorRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// mirror policy configuration
type MirrorPolicySpec struct {
	// unique identifier of mirror policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// list of mirror rules
	Rules                []*MirrorRuleInfo `protobuf:"bytes,2,rep,name=Rules,proto3" json:"Rules,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MirrorPolicySpec) Reset()         { *m = MirrorPolicySpec{} }
func (m *MirrorPolicySpec) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicySpec) ProtoMessage()    {}
func (*MirrorPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{18}
}
func (m *MirrorPolicySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicySpec.Merge(m, src)
}
func (m *MirrorPolicySpec) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicySpec.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicySpec proto.InternalMessageInfo

func (m *MirrorPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorPolicySpec) GetRules() []*MirrorRuleInfo {
	if m != nil {
		return m.Rules
	}
	return nil
}

// operational status of mirror policy, if any
type MirrorPolicyStatus struct {
	// current partition of TCAM in use
	ActivePartition      uint32   `protobuf:"varint,1,opt,name=ActivePartition,proto3" json:"ActivePartition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorPolicyStatus) Reset()         { *m = MirrorPolicyStatus{} }
func (m *MirrorPolicyStatus) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyStatus) ProtoMessage()    {}
func (*MirrorPolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{19}
}
func (m *MirrorPolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyStatus.Merge(m, src)
}
func (m *MirrorPolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyStatus proto.InternalMessageInfo

func (m *MirrorPolicyStatus) GetActivePartition() uint32 {
	if m != nil {
		return m.ActivePartition
	}
	return 0
}

// stats of mirror policy, if any
type MirrorPolicyStats struct {
	// per mirror rule statistics
	RuleStats            []*MirrorRuleStats `protobuf:"bytes,1,rep,name=RuleStats,proto3" json:"RuleStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MirrorPolicyStats) Reset()         { *m = MirrorPolicyStats{} }
func (m *MirrorPolicyStats) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyStats) ProtoMessage()    {}
func (*MirrorPolicyStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{20}
}
func (m *MirrorPolicyStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyStats.Merge(m, src)
}
func (m *MirrorPolicyStats) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyStats.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyStats proto.InternalMessageInfo

func (m *MirrorPolicyStats) GetRuleStats() []*MirrorRuleStats {
	if m != nil {
		return m.RuleStats
	}
	return nil
}

// mirror policy object
type MirrorPolicy struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *MirrorPolicySpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *MirrorPolicyStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *MirrorPolicyStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *MirrorPolicy) Reset()         { *m = MirrorPolicy{} }
func (m *MirrorPolicy) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicy) ProtoMessage()    {}
func (*MirrorPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{21}
}
func (m *MirrorPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicy.Merge(m, src)
}
func (m *MirrorPolicy) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicy proto.InternalMessageInfo

func (m *MirrorPolicy) GetSpec() *MirrorPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorPolicy) GetStatus() *MirrorPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *MirrorPolicy) GetStats() *MirrorPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// mirror policy create and update request
type MirrorPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt          `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*MirrorPolicySpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *MirrorPolicyRequest) Reset()         { *m = MirrorPolicyRequest{} }
func (m *MirrorPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyRequest) ProtoMessage()    {}
func (*MirrorPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{22}
}
func (m *MirrorPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyRequest.Merge(m, src)
}
func (m *MirrorPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyRequest proto.InternalMessageInfo

func (m *MirrorPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorPolicyRequest) GetRequest() []*MirrorPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// mirror policy create and update response
type MirrorPolicyResponse struct {
	ApiStatus            ApiStatus             `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*MirrorPolicyStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MirrorPolicyResponse) Reset()         { *m = MirrorPolicyResponse{} }
func (m *MirrorPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyResponse) ProtoMessage()    {}
func (*MirrorPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{23}
}
func (m *MirrorPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyResponse.Merge(m, src)
}
func (m *MirrorPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyResponse proto.InternalMessageInfo

func (m *MirrorPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorPolicyResponse) GetResponse() []*MirrorPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror policy get request
type MirrorPolicyGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorPolicyGetRequest) Reset()         { *m = MirrorPolicyGetRequest{} }
func (m *MirrorPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyGetRequest) ProtoMessage()    {}
func (*MirrorPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{24}
}
func (m *MirrorPolicyGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyGetRequest.Merge(m, src)
}
func (m *MirrorPolicyGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyGetRequest proto.InternalMessageInfo

func (m *MirrorPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror policy get response
type MirrorPolicyGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*MirrorPolicy `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MirrorPolicyGetResponse) Reset()         { *m = MirrorPolicyGetResponse{} }
func (m *MirrorPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyGetResponse) ProtoMessage()    {}
func (*MirrorPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{25}
}
func (m *MirrorPolicyGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyGetResponse.Merge(m, src)
}
func (m *MirrorPolicyGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyGetResponse proto.InternalMessageInfo

func (m *MirrorPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorPolicyGetResponse) GetResponse() []*MirrorPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror policy delete request
type MirrorPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MirrorPolicyDeleteRequest) Reset()         { *m = MirrorPolicyDeleteRequest{} }
func (m *MirrorPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyDeleteRequest) ProtoMessage()    {}
func (*MirrorPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{26}
}
func (m *MirrorPolicyDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyDeleteRequest.Merge(m, src)
}
func (m *MirrorPolicyDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyDeleteRequest proto.InternalMessageInfo

func (m *MirrorPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror policy delete response
type MirrorPolicyDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MirrorPolicyDeleteResponse) Reset()         { *m = MirrorPolicyDeleteResponse{} }
func (m *MirrorPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyDeleteResponse) ProtoMessage()    {}
func (*MirrorPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{27}
}
func (m *MirrorPolicyDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyDeleteResponse.Merge(m, src)
}
func (m *MirrorPolicyDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyDeleteResponse proto.InternalMessageInfo

func (m *MirrorPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// unique id to identify a mirror policy rule
type MirrorPolicyRuleId struct {
	// unique identifier of mirror rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// mirror policy this rule belongs to
	MirrorPolicyId       []byte   `protobuf:"bytes,2,opt,name=MirrorPolicyId,proto3" json:"MirrorPolicyId,omitempty" meta:mandatory,immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorPolicyRuleId) Reset()         { *m = MirrorPolicyRuleId{} }
func (m *MirrorPolicyRuleId) String() string { return proto.CompactTextString(m) }
func (*MirrorPolicyRuleId) ProtoMessage()    {}
func (*MirrorPolicyRuleId) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{28}
}
func (m *MirrorPolicyRuleId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyRuleId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorPolicyRuleId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorPolicyRuleId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyRuleId.Merge(m, src)
}
func (m *MirrorPolicyRuleId) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyRuleId) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyRuleId.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyRuleId proto.InternalMessageInfo

func (m *MirrorPolicyRuleId) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorPolicyRuleId) GetMirrorPolicyId() []byte {
	if m != nil {
		return m.MirrorPolicyId
	}
	return nil
}

// mirror rule configuration
type MirrorRuleSpec struct {
	// unique identifier of mirror rule
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// mirror policy this rule belongs to
	MirrorPolicyId []byte `protobuf:"bytes,2,opt,name=MirrorPolicyId,proto3" json:"MirrorPolicyId,omitempty" meta:mandatory,immutable`
	// rule information
	Attrs                *MirrorRuleAttrs `protobuf:"bytes,3,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MirrorRuleSpec) Reset()         { *m = MirrorRuleSpec{} }
func (m *MirrorRuleSpec) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleSpec) ProtoMessage()    {}
func (*MirrorRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{29}
}
func (m *MirrorRuleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleSpec.Merge(m, src)
}
func (m *MirrorRuleSpec) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleSpec proto.InternalMessageInfo

func (m *MirrorRuleSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorRuleSpec) GetMirrorPolicyId() []byte {
	if m != nil {
		return m.MirrorPolicyId
	}
	return nil
}

func (m *MirrorRuleSpec) GetAttrs() *MirrorRuleAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// operational status of the mirror rule, if any
type MirrorRuleStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorRuleStatus) Reset()         { *m = MirrorRuleStatus{} }
func (m *MirrorRuleStatus) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleStatus) ProtoMessage()    {}
func (*MirrorRuleStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{30}
}
func (m *MirrorRuleStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleStatus.Merge(m, src)
}
func (m *MirrorRuleStatus) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleStatus proto.InternalMessageInfo

// stats of the mirror rule, if any
type MirrorRuleStats struct {
	// number of times the rule is hit
	NumRuleHit           uint64   `protobuf:"varint,1,opt,name=NumRuleHit,proto3" json:"NumRuleHit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MirrorRuleStats) Reset()         { *m = MirrorRuleStats{} }
func (m *MirrorRuleStats) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleStats) ProtoMessage()    {}
func (*MirrorRuleStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{31}
}
func (m *MirrorRuleStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleStats.Merge(m, src)
}
func (m *MirrorRuleStats) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleStats.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleStats proto.InternalMessageInfo

func (m *MirrorRuleStats) GetNumRuleHit() uint64 {
	if m != nil {
		return m.NumRuleHit
	}
	return 0
}

// mirror rule object
type MirrorRule struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *MirrorRuleSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *MirrorRuleStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *MirrorRuleStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MirrorRule) Reset()         { *m = MirrorRule{} }
func (m *MirrorRule) String() string { return proto.CompactTextString(m) }
func (*MirrorRule) ProtoMessage()    {}
func (*MirrorRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{32}
}
func (m *MirrorRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRule.Merge(m, src)
}
func (m *MirrorRule) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRule) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRule.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRule proto.InternalMessageInfo

func (m *MirrorRule) GetSpec() *MirrorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorRule) GetStatus() *MirrorRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *MirrorRule) GetStats() *MirrorRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// mirror policy rule create and update request
type MirrorRuleRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// mirror policy rule configuration
	Request              *MirrorRuleSpec `protobuf:"bytes,2,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MirrorRuleRequest) Reset()         { *m = MirrorRuleRequest{} }
func (m *MirrorRuleRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleRequest) ProtoMessage()    {}
func (*MirrorRuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{33}
}
func (m *MirrorRuleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleRequest.Merge(m, src)
}
func (m *MirrorRuleRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleRequest proto.InternalMessageInfo

func (m *MirrorRuleRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorRuleRequest) GetRequest() *MirrorRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// mirror policy rule create and update response
type MirrorRuleResponse struct {
	// success or failure status
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// operational status
	Response             *MirrorRuleStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MirrorRuleResponse) Reset()         { *m = MirrorRuleResponse{} }
func (m *MirrorRuleResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleResponse) ProtoMessage()    {}
func (*MirrorRuleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{34}
}
func (m *MirrorRuleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleResponse.Merge(m, src)
}
func (m *MirrorRuleResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleResponse proto.InternalMessageInfo

func (m *MirrorRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorRuleResponse) GetResponse() *MirrorRuleStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror policy rule get request
type MirrorRuleGetRequest struct {
	// list of id/key of the mirror policy rules of interest
	Id                   []*MirrorPolicyRuleId `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MirrorRuleGetRequest) Reset()         { *m = MirrorRuleGetRequest{} }
func (m *MirrorRuleGetRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleGetRequest) ProtoMessage()    {}
func (*MirrorRuleGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{35}
}
func (m *MirrorRuleGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleGetRequest.Merge(m, src)
}
func (m *MirrorRuleGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleGetRequest proto.InternalMessageInfo

func (m *MirrorRuleGetRequest) GetId() []*MirrorPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror policy rule get response
type MirrorRuleGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// mirror policy rule information
	Response             []*MirrorRule `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MirrorRuleGetResponse) Reset()         { *m = MirrorRuleGetResponse{} }
func (m *MirrorRuleGetResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleGetResponse) ProtoMessage()    {}
func (*MirrorRuleGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{36}
}
func (m *MirrorRuleGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleGetResponse.Merge(m, src)
}
func (m *MirrorRuleGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleGetResponse proto.InternalMessageInfo

func (m *MirrorRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorRuleGetResponse) GetResponse() []*MirrorRule {
	if m != nil {
		return m.Response
	}
	return nil
}

// mirror policy rule delete request
type MirrorRuleDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// id/key list of the mirror policy rule(s) to be deleted
	Id                   []*MirrorPolicyRuleId `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MirrorRuleDeleteRequest) Reset()         { *m = MirrorRuleDeleteRequest{} }
func (m *MirrorRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleDeleteRequest) ProtoMessage()    {}
func (*MirrorRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{37}
}
func (m *MirrorRuleDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleDeleteRequest.Merge(m, src)
}
func (m *MirrorRuleDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleDeleteRequest proto.InternalMessageInfo

func (m *MirrorRuleDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *MirrorRuleDeleteRequest) GetId() []*MirrorPolicyRuleId {
	if m != nil {
		return m.Id
	}
	return nil
}

// mirror policy rule delete response
type MirrorRuleDeleteResponse struct {
	// API status code
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MirrorRuleDeleteResponse) Reset()         { *m = MirrorRuleDeleteResponse{} }
func (m *MirrorRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorRuleDeleteResponse) ProtoMessage()    {}
func (*MirrorRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d929026f6c123c0c, []int{38}
}
func (m *MirrorRuleDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorRuleDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MirrorRuleDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MirrorRuleDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorRuleDeleteResponse.Merge(m, src)
}
func (m *MirrorRuleDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MirrorRuleDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorRuleDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorRuleDeleteResponse proto.InternalMessageInfo

func (m *MirrorRuleDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.ERSpanType", ERSpanType_name, ERSpanType_value)
	proto.RegisterType((*LSpanSpec)(nil), "pds.LSpanSpec")
	proto.RegisterType((*RSpanSpec)(nil), "pds.RSpanSpec")
	proto.RegisterType((*ERSpanSpec)(nil), "pds.ERSpanSpec")
	proto.RegisterType((*MirrorSessionSpec)(nil), "pds.MirrorSessionSpec")
	proto.RegisterType((*MirrorSessionStatus)(nil), "pds.MirrorSessionStatus")
	proto.RegisterType((*MirrorSessionStats)(nil), "pds.MirrorSessionStats")
	proto.RegisterType((*MirrorSession)(nil), "pds.MirrorSession")
	proto.RegisterType((*MirrorSessionRequest)(nil), "pds.MirrorSessionRequest")
	proto.RegisterType((*MirrorSessionResponse)(nil), "pds.MirrorSessionResponse")
	proto.RegisterType((*MirrorSessionGetRequest)(nil), "pds.MirrorSessionGetRequest")
	proto.RegisterType((*MirrorSessionGetResponse)(nil), "pds.MirrorSessionGetResponse")
	proto.RegisterType((*MirrorSessionDeleteRequest)(nil), "pds.MirrorSessionDeleteRequest")
	proto.RegisterType((*MirrorSessionDeleteResponse)(nil), "pds.MirrorSessionDeleteResponse")
	proto.RegisterType((*IPProtocolMatch)(nil), "pds.IPProtocolMatch")
	proto.RegisterType((*TCPUDPRuleMatch)(nil), "pds.TCPUDPRuleMatch")
	proto.RegisterType((*TCPUDPRuleMatch_L4PortMatch)(nil), "pds.TCPUDPRuleMatch.L4PortMatch")
	proto.RegisterType((*ICMPRuleMatch)(nil), "pds.ICMPRuleMatch")
	proto.RegisterType((*ICMPRuleMatch_ICMPTypeMatch)(nil), "pds.ICMPRuleMatch.ICMPTypeMatch")
	proto.RegisterType((*ICMPRuleMatch_ICMPCodeMatch)(nil), "pds.ICMPRuleMatch.ICMPCodeMatch")
	proto.RegisterType((*MirrorRuleAttrs)(nil), "pds.MirrorRuleAttrs")
	proto.RegisterType((*MirrorRuleInfo)(nil), "pds.MirrorRuleInfo")
	proto.RegisterType((*MirrorPolicySpec)(nil), "pds.MirrorPolicySpec")
	proto.RegisterType((*MirrorPolicyStatus)(nil), "pds.MirrorPolicyStatus")
	proto.RegisterType((*MirrorPolicyStats)(nil), "pds.MirrorPolicyStats")
	proto.RegisterType((*MirrorPolicy)(nil), "pds.MirrorPolicy")
	proto.RegisterType((*MirrorPolicyRequest)(nil), "pds.MirrorPolicyRequest")
	proto.RegisterType((*MirrorPolicyResponse)(nil), "pds.MirrorPolicyResponse")
	proto.RegisterType((*MirrorPolicyGetRequest)(nil), "pds.MirrorPolicyGetRequest")
	proto.RegisterType((*MirrorPolicyGetResponse)(nil), "pds.MirrorPolicyGetResponse")
	proto.RegisterType((*MirrorPolicyDeleteRequest)(nil), "pds.MirrorPolicyDeleteRequest")
	proto.RegisterType((*MirrorPolicyDeleteResponse)(nil), "pds.MirrorPolicyDeleteResponse")
	proto.RegisterType((*MirrorPolicyRuleId)(nil), "pds.MirrorPolicyRuleId")
	proto.RegisterType((*MirrorRuleSpec)(nil), "pds.MirrorRuleSpec")
	proto.RegisterType((*MirrorRuleStatus)(nil), "pds.MirrorRuleStatus")
	proto.RegisterType((*MirrorRuleStats)(nil), "pds.MirrorRuleStats")
	proto.RegisterType((*MirrorRule)(nil), "pds.MirrorRule")
	proto.RegisterType((*MirrorRuleRequest)(nil), "pds.MirrorRuleRequest")
	proto.RegisterType((*MirrorRuleResponse)(nil), "pds.MirrorRuleResponse")
	proto.RegisterType((*MirrorRuleGetRequest)(nil), "pds.MirrorRuleGetRequest")
	proto.RegisterType((*MirrorRuleGetResponse)(nil), "pds.MirrorRuleGetResponse")
	proto.RegisterType((*MirrorRuleDeleteRequest)(nil), "pds.MirrorRuleDeleteRequest")
	proto.RegisterType((*MirrorRuleDeleteResponse)(nil), "pds.MirrorRuleDeleteResponse")
}

func init() { proto.RegisterFile("mirror.proto", fileDescriptor_d929026f6c123c0c) }

var fileDescriptor_d929026f6c123c0c = []byte{
	// 1946 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0x17, 0x29, 0x4a, 0x14, 0x9f, 0x44, 0x91, 0x1e, 0xcb, 0x32, 0xcd, 0xe8, 0x2b, 0xea, 0xbb,
	0x2e, 0x10, 0xb5, 0x95, 0x18, 0x8a, 0x26, 0x0a, 0xc3, 0x86, 0x1c, 0x88, 0x14, 0x1d, 0xb1, 0x95,
	0x94, 0xed, 0x50, 0x56, 0xd1, 0xa6, 0x40, 0xb0, 0x26, 0x47, 0xce, 0xb6, 0xd4, 0xee, 0x76, 0x77,
	0xe9, 0x58, 0x0d, 0xda, 0x5e, 0x7a, 0xe8, 0xb9, 0x40, 0xff, 0x83, 0xfe, 0x29, 0x2d, 0x50, 0xa0,
	0x28, 0x90, 0x4b, 0x0f, 0xbd, 0x10, 0x85, 0x8f, 0x3e, 0xea, 0xd2, 0x5b, 0x51, 0xcc, 0xaf, 0xdd,
	0xd9, 0x1f, 0x94, 0x13, 0x3a, 0x40, 0x2e, 0xc2, 0xee, 0x9b, 0xcf, 0x7b, 0xf3, 0x7e, 0xcd, 0x67,
	0xde, 0x52, 0xb0, 0x72, 0x69, 0xba, 0xae, 0xed, 0xd6, 0x1d, 0xd7, 0xf6, 0x6d, 0x34, 0xef, 0x0c,
	0xbd, 0x6a, 0xe9, 0x92, 0xf8, 0xc6, 0x07, 0xf4, 0x0f, 0x97, 0x56, 0x97, 0xfd, 0x2b, 0x87, 0x78,
	0xfc, 0x45, 0xfb, 0x63, 0x06, 0x0a, 0xc7, 0x7d, 0xc7, 0xb0, 0xfa, 0x0e, 0x19, 0xa0, 0x06, 0x14,
	0x7a, 0x96, 0x4f, 0xdc, 0x0b, 0x63, 0x40, 0x2a, 0x99, 0xad, 0xcc, 0xf6, 0x4a, 0x1b, 0x5d, 0x4f,
	0x6a, 0xab, 0x54, 0xfb, 0xd1, 0xa5, 0x61, 0x0d, 0x0d, 0xdf, 0x76, 0xaf, 0x70, 0x08, 0x42, 0x7d,
	0x28, 0xeb, 0xc6, 0xe0, 0x97, 0xc4, 0xf7, 0x74, 0xe2, 0xf6, 0xc9, 0xc0, 0xb6, 0x86, 0x95, 0xec,
	0x56, 0x66, 0x3b, 0xd7, 0x7e, 0xff, 0x7a, 0x52, 0xbb, 0xcf, 0x14, 0x5d, 0xc3, 0x7a, 0x41, 0x1e,
	0x35, 0x76, 0x1f, 0x36, 0x1a, 0x8d, 0x1d, 0x26, 0x19, 0x92, 0x0b, 0x63, 0x3c, 0xf2, 0xf7, 0xf7,
	0x1a, 0x8d, 0x06, 0x4e, 0x18, 0xd0, 0x0c, 0x28, 0xe0, 0x77, 0xf0, 0x49, 0x83, 0x85, 0xae, 0x35,
	0x30, 0x1c, 0xe6, 0xc8, 0x72, 0x73, 0xa5, 0xce, 0x03, 0x66, 0x32, 0xcc, 0x97, 0xb4, 0xbf, 0x67,
	0x01, 0xba, 0xe1, 0x26, 0xf7, 0x21, 0x77, 0x76, 0xe5, 0x70, 0xfb, 0xab, 0xcd, 0x52, 0xdd, 0x19,
	0x7a, 0x75, 0xbe, 0x4c, 0xc5, 0x98, 0x2d, 0xa2, 0x6d, 0x58, 0x38, 0xd7, 0x3b, 0x3d, 0x1e, 0x60,
	0xba, 0x17, 0x1c, 0x40, 0x91, 0x87, 0x9e, 0xdf, 0xd3, 0x2b, 0xf3, 0xcc, 0x83, 0xb2, 0xf0, 0xa0,
	0xa7, 0x1f, 0x0c, 0x87, 0x2e, 0xf1, 0xbc, 0xa3, 0x39, 0xcc, 0x01, 0x68, 0x03, 0x96, 0xce, 0xc6,
	0x96, 0x45, 0x46, 0xbd, 0x61, 0x25, 0x47, 0xcd, 0x1e, 0xcd, 0xe1, 0x40, 0x82, 0x10, 0xe4, 0x0e,
	0xbd, 0x81, 0x53, 0x59, 0xd8, 0xca, 0x6c, 0x17, 0x31, 0x7b, 0x46, 0xbb, 0xb0, 0x48, 0xfd, 0xea,
	0x0d, 0x2b, 0x8b, 0x54, 0xda, 0xbe, 0x73, 0x3d, 0xa9, 0xdd, 0x52, 0xf3, 0xbc, 0xb3, 0xd7, 0x68,
	0x3e, 0xc0, 0x02, 0x84, 0xce, 0x61, 0xf9, 0x7c, 0x64, 0x58, 0x7d, 0xdf, 0x35, 0x9d, 0xae, 0x55,
	0xc9, 0x6f, 0x65, 0xb6, 0x97, 0xda, 0xad, 0xeb, 0x49, 0xad, 0xc1, 0x74, 0x06, 0xb6, 0xe5, 0xf9,
	0xae, 0x61, 0x5a, 0xbe, 0xb7, 0xff, 0x45, 0x98, 0x90, 0x3a, 0x0d, 0x78, 0x7f, 0xbf, 0x8b, 0xfb,
	0xfa, 0xc1, 0xe9, 0xa7, 0x67, 0x3f, 0xd5, 0xbb, 0x9f, 0x36, 0xb1, 0x6a, 0xa8, 0xbd, 0x0c, 0x05,
	0xe2, 0x7a, 0x8e, 0x61, 0x0d, 0x3d, 0x5f, 0xfb, 0x53, 0x16, 0x6e, 0x9d, 0xb0, 0xce, 0xeb, 0x13,
	0xcf, 0x33, 0x6d, 0x9e, 0xd4, 0x1d, 0xc8, 0xf6, 0x86, 0xa2, 0x64, 0x1b, 0xd7, 0x93, 0x5a, 0x25,
	0x9a, 0xac, 0x1d, 0xf3, 0xf2, 0x72, 0xec, 0x1b, 0xcf, 0x47, 0x04, 0x67, 0x7b, 0x43, 0xd4, 0x84,
	0x7c, 0xdf, 0x32, 0x9c, 0x63, 0x62, 0xb1, 0xfc, 0x16, 0xdb, 0x95, 0xeb, 0x49, 0x6d, 0x2d, 0x12,
	0xd8, 0x0f, 0x5a, 0xbb, 0xcd, 0x46, 0xeb, 0x21, 0x96, 0x40, 0x54, 0x87, 0xc2, 0xb1, 0x27, 0x5c,
	0x16, 0xb9, 0x5e, 0x65, 0xb5, 0x0b, 0x5a, 0xfa, 0x68, 0x0e, 0x87, 0x10, 0x8a, 0xc7, 0x01, 0x3e,
	0xa7, 0xe0, 0xb1, 0x8a, 0x0f, 0x20, 0x68, 0x0f, 0xa0, 0xeb, 0x06, 0x0a, 0x0b, 0x4c, 0x41, 0x6d,
	0x0e, 0xa1, 0xa1, 0x80, 0x68, 0x5e, 0xf8, 0x19, 0xa4, 0x79, 0xe9, 0xc2, 0xed, 0x68, 0x5a, 0x7c,
	0xc3, 0x1f, 0x7b, 0xb4, 0xac, 0x47, 0x9f, 0x8b, 0xd4, 0x14, 0x31, 0x7b, 0x46, 0x55, 0x58, 0xea,
	0xd8, 0x8e, 0xc3, 0xe4, 0x2c, 0x7e, 0x1c, 0xbc, 0x6b, 0xbf, 0xcf, 0x00, 0x4a, 0xd8, 0xf1, 0xd0,
	0x16, 0x2c, 0xf3, 0xa3, 0xd3, 0xb1, 0xc7, 0x96, 0xcf, 0xac, 0xe5, 0xb0, 0x2a, 0x42, 0x1b, 0x50,
	0x68, 0x5f, 0xf9, 0x84, 0xaf, 0xb3, 0x63, 0x89, 0x43, 0x01, 0xaa, 0x03, 0x3a, 0x74, 0x6d, 0xc7,
	0x21, 0x43, 0xd5, 0xcc, 0x3c, 0x83, 0xa5, 0xac, 0x68, 0xff, 0xca, 0x42, 0x31, 0xe2, 0x06, 0x7a,
	0x0c, 0x4b, 0xb4, 0x51, 0x4e, 0x88, 0x6f, 0xb0, 0xed, 0x69, 0x3a, 0x19, 0xd3, 0x48, 0x69, 0xbb,
	0xf4, 0xe5, 0xa4, 0x96, 0x79, 0x33, 0xa9, 0xe5, 0x77, 0x4c, 0x6b, 0x64, 0x5a, 0x04, 0x07, 0x0a,
	0xe8, 0x43, 0xc8, 0x7f, 0xfc, 0xfc, 0x17, 0x4c, 0x97, 0x1f, 0xd4, 0x22, 0xd7, 0x15, 0xc2, 0xf6,
	0xba, 0x50, 0x65, 0x67, 0x6c, 0xc7, 0xbe, 0x34, 0x7d, 0x72, 0xe9, 0xf8, 0x57, 0x58, 0x6a, 0xa1,
	0x27, 0x90, 0x53, 0x0a, 0xbf, 0xce, 0xea, 0x92, 0xe8, 0xc2, 0x36, 0xa2, 0x26, 0x3c, 0x87, 0x0c,
	0x14, 0x13, 0x4c, 0x0f, 0x3d, 0x85, 0x45, 0x5e, 0x10, 0xd1, 0x0a, 0x95, 0x14, 0x0b, 0x6c, 0xbd,
	0xbd, 0xf6, 0x66, 0x52, 0x2b, 0x7b, 0xec, 0x59, 0xb1, 0x22, 0xb4, 0x51, 0x1b, 0x16, 0x58, 0x41,
	0x44, 0x83, 0xdc, 0x4d, 0x37, 0xe3, 0xb5, 0x6f, 0xbf, 0x99, 0xd4, 0x4a, 0xd4, 0x8a, 0x6a, 0x84,
	0xab, 0x6a, 0xaf, 0x60, 0x2d, 0xa2, 0x81, 0xc9, 0xaf, 0xc6, 0xc4, 0xa3, 0x35, 0x2a, 0xb4, 0x0d,
	0x7f, 0xf0, 0x59, 0xc7, 0x7f, 0xe5, 0x8b, 0x14, 0x4b, 0x36, 0x09, 0xe4, 0x38, 0x84, 0xa0, 0x06,
	0xe4, 0x85, 0x6a, 0x25, 0xbb, 0x35, 0x3f, 0x3d, 0x2d, 0x58, 0xc2, 0xb4, 0xdf, 0xc0, 0x9d, 0xd8,
	0xce, 0x9e, 0x63, 0x5b, 0x1e, 0xa1, 0x5b, 0x1f, 0x38, 0xa6, 0xc8, 0x10, 0x27, 0x46, 0xb9, 0x75,
	0x20, 0xc7, 0x21, 0x04, 0xb5, 0x60, 0x49, 0xea, 0x8a, 0xbd, 0xa7, 0x26, 0x14, 0x07, 0x48, 0xed,
	0xbb, 0x70, 0x37, 0x02, 0xf8, 0x88, 0xf8, 0x32, 0xf6, 0x55, 0xc1, 0x1f, 0xf3, 0xdb, 0x2b, 0x94,
	0x21, 0xb4, 0x5f, 0x43, 0x25, 0x09, 0x9d, 0xd1, 0xd9, 0x7a, 0xc2, 0x59, 0x94, 0x74, 0x56, 0x71,
	0xf3, 0xe7, 0x50, 0x8d, 0x2c, 0x1d, 0x92, 0x11, 0xf1, 0xc9, 0xac, 0x55, 0xe2, 0x91, 0x65, 0x83,
	0xc8, 0x4e, 0xe0, 0xbd, 0x54, 0xeb, 0xe9, 0xc1, 0xcd, 0xbf, 0x25, 0x38, 0x6d, 0x17, 0x4a, 0x3d,
	0x5d, 0xa7, 0xf7, 0xfb, 0xc0, 0x1e, 0x9d, 0xd0, 0x5d, 0x29, 0xbd, 0x48, 0x81, 0xa0, 0x9d, 0xe0,
	0x5d, 0xfb, 0x73, 0x16, 0x4a, 0x67, 0x1d, 0xfd, 0xd9, 0xa1, 0x8e, 0xc7, 0x23, 0xc2, 0xf1, 0x8f,
	0x20, 0xdf, 0x77, 0x07, 0xba, 0xed, 0xca, 0x78, 0xb6, 0x58, 0x7a, 0x62, 0xb0, 0xfa, 0x71, 0x8b,
	0x42, 0xd8, 0x33, 0x96, 0x0a, 0x54, 0xf7, 0xd0, 0xf3, 0x99, 0x6e, 0xf6, 0xab, 0xea, 0x0a, 0x05,
	0xb4, 0x0e, 0x8b, 0x67, 0x1d, 0xbd, 0x7f, 0x65, 0xb1, 0x53, 0xbd, 0x84, 0xc5, 0x9b, 0x90, 0x3f,
	0x35, 0x2d, 0x76, 0x56, 0xb9, 0xfc, 0xa9, 0x29, 0xe5, 0xd8, 0xf3, 0xd9, 0xe1, 0xe3, 0x72, 0xec,
	0x49, 0x3b, 0xcf, 0xdc, 0x17, 0xec, 0x96, 0xe4, 0xf2, 0x67, 0xee, 0x0b, 0x21, 0xd7, 0xbd, 0xcf,
	0xf8, 0x4d, 0x88, 0xc5, 0x5b, 0xf5, 0xff, 0x61, 0x59, 0xf1, 0x87, 0x32, 0x74, 0x10, 0x7b, 0x11,
	0xb3, 0x67, 0xed, 0xaf, 0x19, 0x28, 0xf6, 0x3a, 0x27, 0x4a, 0x92, 0x5a, 0xca, 0xd4, 0x20, 0xa3,
	0x8c, 0x20, 0xd8, 0x1b, 0x23, 0x3c, 0x16, 0x25, 0x1f, 0x23, 0x5a, 0x90, 0xeb, 0xd8, 0x43, 0x12,
	0xc9, 0x4d, 0x52, 0x8b, 0x42, 0x84, 0x16, 0x7d, 0xac, 0xde, 0xe7, 0x9b, 0x07, 0xc6, 0xa8, 0x8b,
	0xc1, 0xe6, 0x45, 0x6e, 0x5a, 0x82, 0x02, 0x5d, 0x0a, 0x62, 0x7b, 0x09, 0x10, 0x7d, 0xd6, 0xfe,
	0x93, 0x85, 0x12, 0xef, 0x36, 0xba, 0xe3, 0x81, 0xef, 0xbb, 0x1e, 0x2a, 0xc3, 0xfc, 0xb9, 0x33,
	0xe0, 0x77, 0x35, 0xa6, 0x8f, 0x54, 0xf3, 0xdc, 0x32, 0x07, 0x7c, 0xd6, 0xc1, 0xec, 0x19, 0xed,
	0x42, 0x81, 0xd6, 0xd8, 0x25, 0x17, 0xe6, 0x2b, 0xc1, 0xba, 0xa5, 0x60, 0xb4, 0xe1, 0x62, 0x1c,
	0x22, 0x28, 0x9c, 0x96, 0x95, 0xc3, 0x73, 0x53, 0xe0, 0x01, 0x02, 0xd5, 0x21, 0x2f, 0xba, 0x56,
	0x10, 0xe9, 0x1a, 0x4f, 0x4d, 0xb4, 0x93, 0xb1, 0x04, 0xa1, 0x87, 0xb0, 0xcc, 0x5b, 0x8a, 0xc9,
	0x59, 0x9d, 0xa5, 0x4e, 0xac, 0xd5, 0x8e, 0xe6, 0xb0, 0x0a, 0x45, 0x4d, 0x28, 0xd0, 0x34, 0x71,
	0xbd, 0x3c, 0xd3, 0x43, 0xc9, 0x32, 0xd0, 0x51, 0x20, 0x80, 0xb1, 0x51, 0xac, 0xdf, 0xd1, 0x2b,
	0x4b, 0x62, 0x14, 0xeb, 0x77, 0x74, 0xf4, 0x9d, 0xd8, 0x7d, 0x58, 0x29, 0xb0, 0x13, 0x1d, 0x15,
	0xb6, 0x97, 0x60, 0x71, 0xd4, 0x32, 0xad, 0x0b, 0x5b, 0xfb, 0x2d, 0xac, 0x86, 0x89, 0xef, 0x59,
	0x17, 0xf6, 0xd7, 0x1c, 0x91, 0x9e, 0xc0, 0x02, 0x2b, 0x97, 0x68, 0x9d, 0x35, 0x85, 0xb1, 0x82,
	0x52, 0xa6, 0x8f, 0xa5, 0x6c, 0x49, 0xfb, 0x1d, 0x94, 0x39, 0x5a, 0xb7, 0x47, 0xe6, 0xe0, 0x6a,
	0x86, 0x21, 0x6d, 0x1f, 0x16, 0xe8, 0x4e, 0x9e, 0xe0, 0xcc, 0xdb, 0x31, 0x0f, 0x68, 0x4c, 0xe9,
	0x0e, 0x30, 0x2d, 0xed, 0x89, 0x9c, 0x63, 0x84, 0x03, 0x9c, 0x8b, 0xb7, 0xa1, 0x74, 0x30, 0xf0,
	0xcd, 0x97, 0x44, 0x37, 0x5c, 0xdf, 0xf4, 0x69, 0x22, 0x79, 0xbf, 0xc6, 0xc5, 0xda, 0x47, 0x72,
	0xcc, 0x0c, 0xf5, 0x3d, 0x5a, 0x4d, 0x6a, 0x9d, 0x5f, 0xc1, 0x19, 0xe6, 0x57, 0x3c, 0x33, 0x6c,
	0x0d, 0x87, 0x30, 0xed, 0x9f, 0x59, 0x58, 0x51, 0x2d, 0x7d, 0xcb, 0x93, 0xcc, 0x7e, 0x64, 0x92,
	0xb9, 0xa3, 0x78, 0x1f, 0x56, 0xea, 0x86, 0x41, 0xa6, 0x1b, 0x1b, 0x64, 0xee, 0x26, 0x0d, 0x7c,
	0x95, 0x39, 0xe6, 0x20, 0x3a, 0xc7, 0xac, 0xa7, 0x5a, 0xb9, 0x79, 0x8c, 0x79, 0x29, 0x07, 0x5e,
	0xae, 0x30, 0xeb, 0xfd, 0xf8, 0x41, 0x7c, 0x8a, 0x49, 0x4f, 0x49, 0x38, 0xc4, 0x7c, 0x21, 0xc7,
	0x27, 0xb9, 0xef, 0x8c, 0x63, 0xc1, 0x83, 0xc4, 0x58, 0x30, 0x2d, 0x97, 0xca, 0x6c, 0xb0, 0x0d,
	0xeb, 0xea, 0xfa, 0x0d, 0x13, 0xcc, 0x2b, 0x39, 0xec, 0x28, 0xc8, 0x19, 0x3d, 0xdd, 0x4d, 0x78,
	0x7a, 0x2b, 0xe1, 0xa9, 0xe2, 0xe3, 0x27, 0x70, 0x4f, 0x5d, 0xf9, 0x66, 0xc7, 0x97, 0x63, 0x39,
	0x1c, 0x45, 0x8d, 0xcf, 0x38, 0xbd, 0xfc, 0x21, 0x13, 0x65, 0x09, 0x46, 0x2c, 0xc3, 0xaf, 0x49,
	0x54, 0x87, 0x92, 0x6a, 0xb9, 0x8d, 0xe0, 0xa3, 0xfd, 0x66, 0xcd, 0x98, 0x8e, 0xf6, 0x97, 0x8c,
	0xca, 0xd8, 0x33, 0xf0, 0xe5, 0x37, 0xe2, 0x46, 0xc8, 0xfb, 0xf3, 0xb3, 0xf1, 0x3e, 0x92, 0xbc,
	0x2f, 0x09, 0x70, 0xec, 0x69, 0x7b, 0xea, 0x10, 0xc0, 0x89, 0x74, 0x13, 0xe0, 0x74, 0x7c, 0x49,
	0xdf, 0x8f, 0x4c, 0xf9, 0x39, 0xa9, 0x48, 0xb4, 0x7f, 0x64, 0x01, 0x42, 0x9d, 0x6f, 0x99, 0x32,
	0x1f, 0x47, 0x28, 0x33, 0x7e, 0x11, 0xbd, 0x85, 0x30, 0x3b, 0x31, 0xc2, 0xbc, 0x93, 0x72, 0x5f,
	0xbc, 0x95, 0x2e, 0x3f, 0x8c, 0xd2, 0x65, 0xea, 0x9d, 0x73, 0x23, 0x59, 0xba, 0xf2, 0x36, 0xa3,
	0xf0, 0x59, 0xcf, 0xe2, 0xae, 0x4a, 0x95, 0xd3, 0x52, 0x11, 0x12, 0xe5, 0xe7, 0xf2, 0x6c, 0xf1,
	0x3d, 0x67, 0x24, 0x9f, 0xbd, 0x08, 0xf9, 0x4c, 0xcf, 0xa0, 0x42, 0x40, 0x7d, 0xc9, 0xd0, 0x74,
	0x55, 0xa1, 0xc8, 0xc7, 0x01, 0x45, 0xa6, 0x71, 0x2d, 0x3f, 0xfb, 0xa9, 0xbd, 0x4d, 0x89, 0xc7,
	0x97, 0xdf, 0xae, 0x81, 0xd1, 0x19, 0x03, 0xfa, 0x7e, 0x82, 0x4d, 0x4b, 0xb1, 0x80, 0x94, 0x50,
	0x5c, 0xc9, 0xe2, 0x54, 0xfe, 0x6e, 0x4c, 0xfa, 0x7e, 0xc0, 0xa4, 0xd3, 0xa3, 0x67, 0x91, 0xfe,
	0x50, 0x7e, 0xfb, 0xaa, 0x7b, 0xce, 0x46, 0xb0, 0xdf, 0xfb, 0x44, 0xfe, 0xf4, 0xc9, 0x3e, 0x47,
	0xd6, 0xa0, 0xac, 0xfe, 0xcc, 0x77, 0xfa, 0xf1, 0x69, 0xb7, 0x3c, 0x87, 0x6e, 0x41, 0x51, 0x95,
	0xee, 0x95, 0x33, 0x71, 0x51, 0xb3, 0x9c, 0x8d, 0x8b, 0x1e, 0x94, 0xe7, 0x9b, 0xff, 0xcd, 0x43,
	0x41, 0xcc, 0xbf, 0x2f, 0x07, 0xe8, 0x34, 0xf6, 0x03, 0x58, 0xc7, 0x25, 0x86, 0x4f, 0xd0, 0xbd,
	0x94, 0x6f, 0x6d, 0x9e, 0xc1, 0x6a, 0x35, 0x6d, 0x49, 0x24, 0x7e, 0x2e, 0x61, 0xef, 0x99, 0x33,
	0x7c, 0x27, 0x7b, 0x3f, 0x96, 0xcc, 0x18, 0xfe, 0xa4, 0x80, 0x36, 0x92, 0x1a, 0x61, 0xbf, 0x56,
	0xff, 0x6f, 0xca, 0x6a, 0x60, 0xf2, 0x67, 0x31, 0x17, 0x79, 0xb1, 0x50, 0x2d, 0xa9, 0x17, 0x69,
	0x9d, 0xea, 0xd6, 0x74, 0x40, 0x60, 0xbb, 0x15, 0xfb, 0xb1, 0x84, 0xcf, 0xb5, 0xc4, 0x23, 0x3e,
	0x2a, 0xc8, 0x2f, 0xab, 0x61, 0x35, 0xf8, 0xc1, 0x9b, 0x92, 0x8d, 0x36, 0x87, 0x7e, 0x14, 0xbd,
	0x4f, 0x45, 0x0d, 0x2a, 0xc9, 0x76, 0x13, 0x9e, 0xdc, 0x4b, 0x59, 0x09, 0x5c, 0x88, 0x19, 0x13,
	0x05, 0x98, 0xd1, 0xd8, 0xa9, 0xbc, 0x84, 0x82, 0x79, 0x08, 0xbd, 0x97, 0xc0, 0x2b, 0xc9, 0xdf,
	0x48, 0x5f, 0x0c, 0xec, 0xfd, 0x24, 0xea, 0x9c, 0x48, 0xfd, 0x66, 0x42, 0x2b, 0x9a, 0xf9, 0xda,
	0xd4, 0xf5, 0xc0, 0x70, 0x57, 0xbd, 0x41, 0x45, 0x02, 0xd7, 0xe3, 0x0c, 0x21, 0xcc, 0xdd, 0x4d,
	0xc8, 0xd3, 0xcd, 0x88, 0xd4, 0xcd, 0x60, 0xe6, 0x48, 0x7e, 0x77, 0x0a, 0xda, 0x8b, 0xf4, 0x7f,
	0x94, 0x5f, 0x23, 0xfd, 0x1f, 0x63, 0x49, 0xb5, 0xff, 0x43, 0x5a, 0x89, 0xf4, 0x7f, 0x82, 0xe1,
	0x22, 0xfd, 0x9f, 0xe4, 0x22, 0x6d, 0xae, 0xbd, 0xf2, 0xb7, 0xd7, 0x9b, 0x99, 0x2f, 0x5f, 0x6f,
	0x66, 0xfe, 0xfd, 0x7a, 0x33, 0xf3, 0x7c, 0x91, 0xfd, 0x9b, 0xe9, 0xc1, 0xff, 0x02, 0x00, 0x00,
	0xff, 0xff, 0xfe, 0x33, 0xd5, 0x27, 0x99, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MirrorSvcClient is the client API for MirrorSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MirrorSvcClient interface {
	MirrorSessionCreate(ctx context.Context, in *MirrorSessionRequest, opts ...grpc.CallOption) (*MirrorSessionResponse, error)
	MirrorSessionUpdate(ctx context.Context, in *MirrorSessionRequest, opts ...grpc.CallOption) (*MirrorSessionResponse, error)
	MirrorSessionGet(ctx context.Context, in *MirrorSessionGetRequest, opts ...grpc.CallOption) (*MirrorSessionGetResponse, error)
	MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteRequest, opts ...grpc.CallOption) (*MirrorSessionDeleteResponse, error)
	// given a uuid of a mirror session, clear its stats or else clear stats of all mirror sessions
	MirrorSessionStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	// mirror policy APIs
	MirrorPolicyCreate(ctx context.Context, in *MirrorPolicyRequest, opts ...grpc.CallOption) (*MirrorPolicyResponse, error)
	MirrorPolicyUpdate(ctx context.Context, in *MirrorPolicyRequest, opts ...grpc.CallOption) (*MirrorPolicyResponse, error)
	MirrorPolicyGet(ctx context.Context, in *MirrorPolicyGetRequest, opts ...grpc.CallOption) (*MirrorPolicyGetResponse, error)
	MirrorPolicyDelete(ctx context.Context, in *MirrorPolicyDeleteRequest, opts ...grpc.CallOption) (*MirrorPolicyDeleteResponse, error)
	// mirror policy rule APIs
	MirrorRuleCreate(ctx context.Context, in *MirrorRuleRequest, opts ...grpc.CallOption) (*MirrorRuleResponse, error)
	MirrorRuleUpdate(ctx context.Context, in *MirrorRuleRequest, opts ...grpc.CallOption) (*MirrorRuleResponse, error)
	MirrorRuleGet(ctx context.Context, in *MirrorRuleGetRequest, opts ...grpc.CallOption) (*MirrorRuleGetResponse, error)
	MirrorRuleDelete(ctx context.Context, in *MirrorRuleDeleteRequest, opts ...grpc.CallOption) (*MirrorRuleDeleteResponse, error)
}

type mirrorSvcClient struct {
	cc *grpc.ClientConn
}

func NewMirrorSvcClient(cc *grpc.ClientConn) MirrorSvcClient {
	return &mirrorSvcClient{cc}
}

func (c *mirrorSvcClient) MirrorSessionCreate(ctx context.Context, in *MirrorSessionRequest, opts ...grpc.CallOption) (*MirrorSessionResponse, error) {
	out := new(MirrorSessionResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorSessionCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorSessionUpdate(ctx context.Context, in *MirrorSessionRequest, opts ...grpc.CallOption) (*MirrorSessionResponse, error) {
	out := new(MirrorSessionResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorSessionUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorSessionGet(ctx context.Context, in *MirrorSessionGetRequest, opts ...grpc.CallOption) (*MirrorSessionGetResponse, error) {
	out := new(MirrorSessionGetResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorSessionGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteRequest, opts ...grpc.CallOption) (*MirrorSessionDeleteResponse, error) {
	out := new(MirrorSessionDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorSessionDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorSessionStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorSessionStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorPolicyCreate(ctx context.Context, in *MirrorPolicyRequest, opts ...grpc.CallOption) (*MirrorPolicyResponse, error) {
	out := new(MirrorPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorPolicyCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorPolicyUpdate(ctx context.Context, in *MirrorPolicyRequest, opts ...grpc.CallOption) (*MirrorPolicyResponse, error) {
	out := new(MirrorPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorPolicyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorPolicyGet(ctx context.Context, in *MirrorPolicyGetRequest, opts ...grpc.CallOption) (*MirrorPolicyGetResponse, error) {
	out := new(MirrorPolicyGetResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorPolicyGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorPolicyDelete(ctx context.Context, in *MirrorPolicyDeleteRequest, opts ...grpc.CallOption) (*MirrorPolicyDeleteResponse, error) {
	out := new(MirrorPolicyDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorPolicyDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorRuleCreate(ctx context.Context, in *MirrorRuleRequest, opts ...grpc.CallOption) (*MirrorRuleResponse, error) {
	out := new(MirrorRuleResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorRuleCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorRuleUpdate(ctx context.Context, in *MirrorRuleRequest, opts ...grpc.CallOption) (*MirrorRuleResponse, error) {
	out := new(MirrorRuleResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorRuleUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorRuleGet(ctx context.Context, in *MirrorRuleGetRequest, opts ...grpc.CallOption) (*MirrorRuleGetResponse, error) {
	out := new(MirrorRuleGetResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorRuleGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSvcClient) MirrorRuleDelete(ctx context.Context, in *MirrorRuleDeleteRequest, opts ...grpc.CallOption) (*MirrorRuleDeleteResponse, error) {
	out := new(MirrorRuleDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.MirrorSvc/MirrorRuleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MirrorSvcServer is the server API for MirrorSvc service.
type MirrorSvcServer interface {
	MirrorSessionCreate(context.Context, *MirrorSessionRequest) (*MirrorSessionResponse, error)
	MirrorSessionUpdate(context.Context, *MirrorSessionRequest) (*MirrorSessionResponse, error)
	MirrorSessionGet(context.Context, *MirrorSessionGetRequest) (*MirrorSessionGetResponse, error)
	MirrorSessionDelete(context.Context, *MirrorSessionDeleteRequest) (*MirrorSessionDeleteResponse, error)
	// given a uuid of a mirror session, clear its stats or else clear stats of all mirror sessions
	MirrorSessionStatsReset(context.Context, *Id) (*Empty, error)
	// mirror policy APIs
	MirrorPolicyCreate(context.Context, *MirrorPolicyRequest) (*MirrorPolicyResponse, error)
	MirrorPolicyUpdate(context.Context, *MirrorPolicyRequest) (*MirrorPolicyResponse, error)
	MirrorPolicyGet(context.Context, *MirrorPolicyGetRequest) (*MirrorPolicyGetResponse, error)
	MirrorPolicyDelete(context.Context, *MirrorPolicyDeleteRequest) (*MirrorPolicyDeleteResponse, error)
	// mirror policy rule APIs
	MirrorRuleCreate(context.Context, *MirrorRuleRequest) (*MirrorRuleResponse, error)
	MirrorRuleUpdate(context.Context, *MirrorRuleRequest) (*MirrorRuleResponse, error)
	MirrorRuleGet(context.Context, *MirrorRuleGetRequest) (*MirrorRuleGetResponse, error)
	MirrorRuleDelete(context.Context, *MirrorRuleDeleteRequest) (*MirrorRuleDeleteResponse, error)
}

// UnimplementedMirrorSvcServer can be embedded to have forward compatible implementations.
type UnimplementedMirrorSvcServer struct {
}

func (*UnimplementedMirrorSvcServer) MirrorSessionCreate(ctx context.Context, req *MirrorSessionRequest) (*MirrorSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorSessionCreate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorSessionUpdate(ctx context.Context, req *MirrorSessionRequest) (*MirrorSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorSessionUpdate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorSessionGet(ctx context.Context, req *MirrorSessionGetRequest) (*MirrorSessionGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorSessionGet not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorSessionDelete(ctx context.Context, req *MirrorSessionDeleteRequest) (*MirrorSessionDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorSessionDelete not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorSessionStatsReset(ctx context.Context, req *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorSessionStatsReset not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorPolicyCreate(ctx context.Context, req *MirrorPolicyRequest) (*MirrorPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorPolicyCreate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorPolicyUpdate(ctx context.Context, req *MirrorPolicyRequest) (*MirrorPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorPolicyUpdate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorPolicyGet(ctx context.Context, req *MirrorPolicyGetRequest) (*MirrorPolicyGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorPolicyGet not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorPolicyDelete(ctx context.Context, req *MirrorPolicyDeleteRequest) (*MirrorPolicyDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorPolicyDelete not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorRuleCreate(ctx context.Context, req *MirrorRuleRequest) (*MirrorRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorRuleCreate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorRuleUpdate(ctx context.Context, req *MirrorRuleRequest) (*MirrorRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorRuleUpdate not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorRuleGet(ctx context.Context, req *MirrorRuleGetRequest) (*MirrorRuleGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorRuleGet not implemented")
}
func (*UnimplementedMirrorSvcServer) MirrorRuleDelete(ctx context.Context, req *MirrorRuleDeleteRequest) (*MirrorRuleDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorRuleDelete not implemented")
}

func RegisterMirrorSvcServer(s *grpc.Server, srv MirrorSvcServer) {
	s.RegisterService(&_MirrorSvc_serviceDesc, srv)
}

func _MirrorSvc_MirrorSessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorSessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorSessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorSessionCreate(ctx, req.(*MirrorSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorSessionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorSessionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorSessionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorSessionUpdate(ctx, req.(*MirrorSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorSessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorSessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorSessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorSessionGet(ctx, req.(*MirrorSessionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorSessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorSessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorSessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorSessionDelete(ctx, req.(*MirrorSessionDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorSessionStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorSessionStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorSessionStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorSessionStatsReset(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorPolicyCreate(ctx, req.(*MirrorPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorPolicyUpdate(ctx, req.(*MirrorPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorPolicyGet(ctx, req.(*MirrorPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorPolicyDelete(ctx, req.(*MirrorPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorRuleCreate(ctx, req.(*MirrorRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorRuleUpdate(ctx, req.(*MirrorRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorRuleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorRuleGet(ctx, req.(*MirrorRuleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSvc_MirrorRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorRuleDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSvcServer).MirrorRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.MirrorSvc/MirrorRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSvcServer).MirrorRuleDelete(ctx, req.(*MirrorRuleDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MirrorSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.MirrorSvc",
	HandlerType: (*MirrorSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MirrorSessionCreate",
			Handler:    _MirrorSvc_MirrorSessionCreate_Handler,
		},
		{
			MethodName: "MirrorSessionUpdate",
			Handler:    _MirrorSvc_MirrorSessionUpdate_Handler,
		},
		{
			MethodName: "MirrorSessionGet",
			Handler:    _MirrorSvc_MirrorSessionGet_Handler,
		},
		{
			MethodName: "MirrorSessionDelete",
			Handler:    _MirrorSvc_MirrorSessionDelete_Handler,
		},
		{
			MethodName: "MirrorSessionStatsReset",
			Handler:    _MirrorSvc_MirrorSessionStatsReset_Handler,
		},
		{
			MethodName: "MirrorPolicyCreate",
			Handler:    _MirrorSvc_MirrorPolicyCreate_Handler,
		},
		{
			MethodName: "MirrorPolicyUpdate",
			Handler:    _MirrorSvc_MirrorPolicyUpdate_Handler,
		},
		{
			MethodName: "MirrorPolicyGet",
			Handler:    _MirrorSvc_MirrorPolicyGet_Handler,
		},
		{
			MethodName: "MirrorPolicyDelete",
			Handler:    _MirrorSvc_MirrorPolicyDelete_Handler,
		},
		{
			MethodName: "MirrorRuleCreate",
			Handler:    _MirrorSvc_MirrorRuleCreate_Handler,
		},
		{
			MethodName: "MirrorRuleUpdate",
			Handler:    _MirrorSvc_MirrorRuleUpdate_Handler,
		},
		{
			MethodName: "MirrorRuleGet",
			Handler:    _MirrorSvc_MirrorRuleGet_Handler,
		},
		{
			MethodName: "MirrorRuleDelete",
			Handler:    _MirrorSvc_MirrorRuleDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mirror.proto",
}

func (m *LSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSpanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PacketsPerSecond != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketsPerSecond))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Interface) > 0 {
		i -= len(m.Interface)
		copy(dAtA[i:], m.Interface)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Interface)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RSpanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Interface) > 0 {
		i -= len(m.Interface)
		copy(dAtA[i:], m.Interface)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Interface)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ERSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERSpanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VlanStripEn {
		i--
		if m.VlanStripEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SpanId != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.SpanId))
		i--
		dAtA[i] = 0x30
	}
	if m.Dscp != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Dscp))
		i--
		dAtA[i] = 0x28
	}
	if m.Erspandst != nil {
		{
			size := m.Erspandst.Size()
			i -= size
			if _, err := m.Erspandst.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ERSpanSpec_DstIP) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ERSpanSpec_DstIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIP != nil {
		{
			size, err := m.DstIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ERSpanSpec_TunnelId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ERSpanSpec_TunnelId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelId != nil {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mirrordst != nil {
		{
			size := m.Mirrordst.Size()
			i -= size
			if _, err := m.Mirrordst.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SnapLen != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.SnapLen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionSpec_LspanSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MirrorSessionSpec_LspanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LspanSpec != nil {
		{
			size, err := m.LspanSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MirrorSessionSpec_RspanSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MirrorSessionSpec_RspanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RspanSpec != nil {
		{
			size, err := m.RspanSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MirrorSessionSpec_ErspanSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MirrorSessionSpec_ErspanSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ErspanSpec != nil {
		{
			size, err := m.ErspanSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CoppHwId != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.CoppHwId))
		i--
		dAtA[i] = 0x10
	}
	if m.HwId != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DroppedPacketCount != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.DroppedPacketCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ByteCount != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ByteCount))
		i--
		dAtA[i] = 0x10
	}
	if m.PacketCount != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMirror(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMirror(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorSessionDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorSessionDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA14 := make([]byte, len(m.ApiStatus)*10)
		var j13 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintMirror(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPProtocolMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPProtocolMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPProtocolMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Protocol != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TCPUDPRuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPUDPRuleMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPUDPRuleMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TCPPsh {
		i--
		if m.TCPPsh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TCPUrg {
		i--
		if m.TCPUrg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TCPRst {
		i--
		if m.TCPRst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TCPFin {
		i--
		if m.TCPFin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.TCPSyn {
		i--
		if m.TCPSyn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DstPort != nil {
		{
			size, err := m.DstPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPort != nil {
		{
			size, err := m.SrcPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TCPUDPRuleMatch_L4PortMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPUDPRuleMatch_L4PortMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPUDPRuleMatch_L4PortMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPRuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPRuleMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPRuleMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != nil {
		{
			size, err := m.Code.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ICMPRuleMatch_ICMPTypeMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPRuleMatch_ICMPTypeMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPRuleMatch_ICMPTypeMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPRuleMatch_ICMPCodeMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPRuleMatch_ICMPCodeMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPRuleMatch_ICMPCodeMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MirrorSession) > 0 {
		for iNdEx := len(m.MirrorSession) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MirrorSession[iNdEx])
			copy(dAtA[i:], m.MirrorSession[iNdEx])
			i = encodeVarintMirror(dAtA, i, uint64(len(m.MirrorSession[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DSCP != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.DSCP))
		i--
		dAtA[i] = 0x40
	}
	if m.L4Info != nil {
		{
			size := m.L4Info.Size()
			i -= size
			if _, err := m.L4Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IPProto != nil {
		{
			size, err := m.IPProto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DstPrefix != nil {
		{
			size, err := m.DstPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SrcPrefix != nil {
		{
			size, err := m.SrcPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vnic) > 0 {
		i -= len(m.Vnic)
		copy(dAtA[i:], m.Vnic)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Vnic)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vpc) > 0 {
		i -= len(m.Vpc)
		copy(dAtA[i:], m.Vpc)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Vpc)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleAttrs_TCPUDPMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MirrorRuleAttrs_TCPUDPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TCPUDPMatch != nil {
		{
			size, err := m.TCPUDPMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MirrorRuleAttrs_ICMPMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MirrorRuleAttrs_ICMPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ICMPMatch != nil {
		{
			size, err := m.ICMPMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *MirrorRuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActivePartition != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ActivePartition))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuleStats) > 0 {
		for iNdEx := len(m.RuleStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuleStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMirror(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMirror(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA33 := make([]byte, len(m.ApiStatus)*10)
		var j32 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintMirror(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyRuleId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyRuleId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyRuleId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MirrorPolicyId) > 0 {
		i -= len(m.MirrorPolicyId)
		copy(dAtA[i:], m.MirrorPolicyId)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.MirrorPolicyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MirrorPolicyId) > 0 {
		i -= len(m.MirrorPolicyId)
		copy(dAtA[i:], m.MirrorPolicyId)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.MirrorPolicyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumRuleHit != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.NumRuleHit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintMirror(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMirror(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMirror(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MirrorRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorRuleDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA45 := make([]byte, len(m.ApiStatus)*10)
		var j44 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintMirror(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMirror(dAtA []byte, offset int, v uint64) int {
	offset -= sovMirror(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LSpanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Interface)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.PacketsPerSecond != 0 {
		n += 1 + sovMirror(uint64(m.PacketsPerSecond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RSpanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Interface)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ERSpanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMirror(uint64(m.Type))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Erspandst != nil {
		n += m.Erspandst.Size()
	}
	if m.Dscp != 0 {
		n += 1 + sovMirror(uint64(m.Dscp))
	}
	if m.SpanId != 0 {
		n += 1 + sovMirror(uint64(m.SpanId))
	}
	if m.VlanStripEn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ERSpanSpec_DstIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIP != nil {
		l = m.DstIP.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *ERSpanSpec_TunnelId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		l = len(m.TunnelId)
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.SnapLen != 0 {
		n += 1 + sovMirror(uint64(m.SnapLen))
	}
	if m.Mirrordst != nil {
		n += m.Mirrordst.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionSpec_LspanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LspanSpec != nil {
		l = m.LspanSpec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_RspanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RspanSpec != nil {
		l = m.RspanSpec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_ErspanSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErspanSpec != nil {
		l = m.ErspanSpec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorSessionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovMirror(uint64(m.HwId))
	}
	if m.CoppHwId != 0 {
		n += 1 + sovMirror(uint64(m.CoppHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketCount != 0 {
		n += 1 + sovMirror(uint64(m.PacketCount))
	}
	if m.ByteCount != 0 {
		n += 1 + sovMirror(uint64(m.ByteCount))
	}
	if m.DroppedPacketCount != 0 {
		n += 1 + sovMirror(uint64(m.DroppedPacketCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorSessionDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPProtocolMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovMirror(uint64(m.Protocol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCPUDPRuleMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPort != nil {
		l = m.SrcPort.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.DstPort != nil {
		l = m.DstPort.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.TCPSyn {
		n += 2
	}
	if m.TCPFin {
		n += 2
	}
	if m.TCPRst {
		n += 2
	}
	if m.TCPUrg {
		n += 2
	}
	if m.TCPPsh {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCPUDPRuleMatch_L4PortMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovMirror(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPRuleMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Code != nil {
		l = m.Code.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPRuleMatch_ICMPTypeMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMirror(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPRuleMatch_ICMPCodeMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMirror(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vpc)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = len(m.Vnic)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.IPProto != nil {
		l = m.IPProto.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	if m.DSCP != 0 {
		n += 1 + sovMirror(uint64(m.DSCP))
	}
	if len(m.MirrorSession) > 0 {
		for _, b := range m.MirrorSession {
			l = len(b)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleAttrs_TCPUDPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TCPUDPMatch != nil {
		l = m.TCPUDPMatch.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorRuleAttrs_ICMPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ICMPMatch != nil {
		l = m.ICMPMatch.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}
func (m *MirrorRuleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActivePartition != 0 {
		n += 1 + sovMirror(uint64(m.ActivePartition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RuleStats) > 0 {
		for _, e := range m.RuleStats {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorPolicyRuleId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = len(m.MirrorPolicyId)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = len(m.MirrorPolicyId)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumRuleHit != 0 {
		n += 1 + sovMirror(uint64(m.NumRuleHit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovMirror(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MirrorRuleDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMirror(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMirror(x uint64) (n int) {
	return sovMirror(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface[:0], dAtA[iNdEx:postIndex]...)
			if m.Interface == nil {
				m.Interface = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsPerSecond", wireType)
			}
			m.PacketsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsPerSecond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface[:0], dAtA[iNdEx:postIndex]...)
			if m.Interface == nil {
				m.Interface = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ERSpanType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Erspandst = &ERSpanSpec_DstIP{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Erspandst = &ERSpanSpec_TunnelId{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dscp", wireType)
			}
			m.Dscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dscp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			m.SpanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanStripEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanStripEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapLen", wireType)
			}
			m.SnapLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mirrordst = &MirrorSessionSpec_LspanSpec{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mirrordst = &MirrorSessionSpec_RspanSpec{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ERSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mirrordst = &MirrorSessionSpec_ErspanSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppHwId", wireType)
			}
			m.CoppHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoppHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketCount", wireType)
			}
			m.PacketCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCount", wireType)
			}
			m.ByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPacketCount", wireType)
			}
			m.DroppedPacketCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPacketCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MirrorSessionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MirrorSessionStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MirrorSessionStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSessionStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSession{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMirror
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPProtocolMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPProtocolMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPProtocolMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPUDPRuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPUDPRuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPUDPRuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPort == nil {
				m.SrcPort = &TCPUDPRuleMatch_L4PortMatch{}
			}
			if err := m.SrcPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPort == nil {
				m.DstPort = &TCPUDPRuleMatch_L4PortMatch{}
			}
			if err := m.DstPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPSyn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TCPSyn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPFin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TCPFin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPRst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TCPRst = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPUrg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TCPUrg = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPPsh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TCPPsh = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPUDPRuleMatch_L4PortMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4PortMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4PortMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPRuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPRuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPRuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &ICMPRuleMatch_ICMPTypeMatch{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Code == nil {
				m.Code = &ICMPRuleMatch_ICMPCodeMatch{}
			}
			if err := m.Code.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPRuleMatch_ICMPTypeMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPTypeMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPTypeMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPRuleMatch_ICMPCodeMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPCodeMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPCodeMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vpc = append(m.Vpc[:0], dAtA[iNdEx:postIndex]...)
			if m.Vpc == nil {
				m.Vpc = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vnic = append(m.Vnic[:0], dAtA[iNdEx:postIndex]...)
			if m.Vnic == nil {
				m.Vnic = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPrefix == nil {
				m.SrcPrefix = &IPPrefix{}
			}
			if err := m.SrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPrefix == nil {
				m.DstPrefix = &IPPrefix{}
			}
			if err := m.DstPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPProto == nil {
				m.IPProto = &IPProtocolMatch{}
			}
			if err := m.IPProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPUDPMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPUDPRuleMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &MirrorRuleAttrs_TCPUDPMatch{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPRuleMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &MirrorRuleAttrs_ICMPMatch{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCP", wireType)
			}
			m.DSCP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSCP |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSession", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSession = append(m.MirrorSession, make([]byte, postIndex-iNdEx))
			copy(m.MirrorSession[len(m.MirrorSession)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &MirrorRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &MirrorRuleInfo{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePartition", wireType)
			}
			m.ActivePartition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePartition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleStats = append(m.RuleStats, &MirrorRuleStats{})
			if err := m.RuleStats[len(m.RuleStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MirrorPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MirrorPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MirrorPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMirror
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyRuleId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyRuleId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyRuleId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorPolicyId = append(m.MirrorPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.MirrorPolicyId == nil {
				m.MirrorPolicyId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorPolicyId = append(m.MirrorPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.MirrorPolicyId == nil {
				m.MirrorPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &MirrorRuleAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRuleHit", wireType)
			}
			m.NumRuleHit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRuleHit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MirrorRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MirrorRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MirrorRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &MirrorRuleSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &MirrorRuleStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &MirrorPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorRule{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMirror
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &MirrorPolicyRuleId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMirror
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMirror(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMirror
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMirror
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMirror(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMirror
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMirror = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMirror   = fmt.Errorf("proto: integer overflow")
)
