// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RouteClass captures different types/classes of routes
type RouteClass int32

const (
	RouteClass_ROUTE_CLASS_NONE RouteClass = 0
	// route pointing to Internet
	RouteClass_ROUTE_CLASS_INTERNET RouteClass = 1
	// route used for internal/shared services
	RouteClass_ROUTE_CLASS_SERVICE RouteClass = 2
	// VPC internal routes
	RouteClass_ROUTE_CLASS_VPC RouteClass = 3
)

var RouteClass_name = map[int32]string{
	0: "ROUTE_CLASS_NONE",
	1: "ROUTE_CLASS_INTERNET",
	2: "ROUTE_CLASS_SERVICE",
	3: "ROUTE_CLASS_VPC",
}

var RouteClass_value = map[string]int32{
	"ROUTE_CLASS_NONE":     0,
	"ROUTE_CLASS_INTERNET": 1,
	"ROUTE_CLASS_SERVICE":  2,
	"ROUTE_CLASS_VPC":      3,
}

func (x RouteClass) String() string {
	return proto.EnumName(RouteClass_name, int32(x))
}

func (RouteClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{0}
}

type NATAction struct {
	// if SrcNatAction is set to NAT_ACTION_STATIC, floating IP of the
	// local IP mapping is used to NAT the source IP or else (NAT IP, NAT port)
	// are dynamically allocated in s/w datapath
	// NOTE: Floating IP (i.e., public IP in local mapping object is always
	//       preferred over NAPT port block
	SrcNatAction NatAction `protobuf:"varint,1,opt,name=SrcNatAction,proto3,enum=types.NatAction" json:"SrcNatAction,omitempty"`
	// DstNatIP is set, if 1:1 destination NAT needs to be done
	// NOTE: if DNAT is done, using the DNAT IP route lookup will be done
	//       in the same routing table to get forwarding information this time
	DstNatIP *IPAddress `protobuf:"bytes,2,opt,name=DstNatIP,proto3" json:"DstNatIP,omitempty"`
	// indicate whether a (NAT address, NAT port) pair already allocated for
	// a different session earlier can be reused for new sessions/flows
	// that require NAPT
	// NOTE: this attribute is valid only SrcNatAction is either
	//       NAT_ACTION_NAPT_PUBLIC or NAT_ACTION_NAPT_SVC and not applicable
	//       in any other cases
	PortReuse            bool     `protobuf:"varint,3,opt,name=PortReuse,proto3" json:"PortReuse,omitempty" meta:constraints=SrcNatAction==NAT_ACTION_NAPT_PUBLIC|SrcNatAction==NAT_ACTION_NAPT_SVC`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NATAction) Reset()         { *m = NATAction{} }
func (m *NATAction) String() string { return proto.CompactTextString(m) }
func (*NATAction) ProtoMessage()    {}
func (*NATAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{0}
}
func (m *NATAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NATAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NATAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NATAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NATAction.Merge(m, src)
}
func (m *NATAction) XXX_Size() int {
	return m.Size()
}
func (m *NATAction) XXX_DiscardUnknown() {
	xxx_messageInfo_NATAction.DiscardUnknown(m)
}

var xxx_messageInfo_NATAction proto.InternalMessageInfo

func (m *NATAction) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_ACTION_NONE
}

func (m *NATAction) GetDstNatIP() *IPAddress {
	if m != nil {
		return m.DstNatIP
	}
	return nil
}

func (m *NATAction) GetPortReuse() bool {
	if m != nil {
		return m.PortReuse
	}
	return false
}

// for VPC peering, a route in a route table points to VPCPeerNhInfo
// that contains peer VPC's uuid and the route table to launch a
// lookup in the route table. Note that along with the route lookup,
// mapping lookup is also launched in the peer VPC
type VPCPeerNhInfo struct {
	// peer VPC's id
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory`
	// route table to be used in that VPC
	RouteTableId         []byte   `protobuf:"bytes,2,opt,name=RouteTableId,proto3" json:"RouteTableId,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPCPeerNhInfo) Reset()         { *m = VPCPeerNhInfo{} }
func (m *VPCPeerNhInfo) String() string { return proto.CompactTextString(m) }
func (*VPCPeerNhInfo) ProtoMessage()    {}
func (*VPCPeerNhInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{1}
}
func (m *VPCPeerNhInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPCPeerNhInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPCPeerNhInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPCPeerNhInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPCPeerNhInfo.Merge(m, src)
}
func (m *VPCPeerNhInfo) XXX_Size() int {
	return m.Size()
}
func (m *VPCPeerNhInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VPCPeerNhInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VPCPeerNhInfo proto.InternalMessageInfo

func (m *VPCPeerNhInfo) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *VPCPeerNhInfo) GetRouteTableId() []byte {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

// if metering is enabled on a vnic, when traffic from a vnic hits a route
// with a MeterClass that is not METER_CLASS_NONE and all such traffic is
// accounted (bytes & packets) against the specified meter class on that
// vnic, it is up to the application to map the meter classes defined to
// specific use case (e.g., Internet routes can be assigned to
// METER_CLASS_1, service routes can be assiged METER_CLASS_2 and so on.)
// MeterClasses captures the Tx and Rx metering classes/buckets to use
// for traffic egressing (Tx) from the vnic and for traffic ingressing (Rx)
// into the vnic
// NOTE:
// Tx/Rx is orthogonal to whether vnic is client/server side of the
// connection (i.e. vnic could be session initiator or responder), as there
// can be Tx/Rx traffic irrespective of which side originated the session
// NOTE:
// 1. upto 4K meter classes per vnic are supported, so meter class value
//    must be between 1 to 4K - 1 (valid range depends on pipeline, some
//    pipelines support meter class in [1-15] range)
// 2. meter class value of 0 is reserved
type MeterClasses struct {
	// Tx meter class/bucket
	TxMeterClass uint32 `protobuf:"varint,1,opt,name=TxMeterClass,proto3" json:"TxMeterClass,omitempty" meta:range:1-4095`
	// Rx meter class/bucket
	RxMeterClass         uint32   `protobuf:"varint,2,opt,name=RxMeterClass,proto3" json:"RxMeterClass,omitempty" meta:range:1-4095`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MeterClasses) Reset()         { *m = MeterClasses{} }
func (m *MeterClasses) String() string { return proto.CompactTextString(m) }
func (*MeterClasses) ProtoMessage()    {}
func (*MeterClasses) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{2}
}
func (m *MeterClasses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeterClasses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeterClasses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeterClasses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeterClasses.Merge(m, src)
}
func (m *MeterClasses) XXX_Size() int {
	return m.Size()
}
func (m *MeterClasses) XXX_DiscardUnknown() {
	xxx_messageInfo_MeterClasses.DiscardUnknown(m)
}

var xxx_messageInfo_MeterClasses proto.InternalMessageInfo

func (m *MeterClasses) GetTxMeterClass() uint32 {
	if m != nil {
		return m.TxMeterClass
	}
	return 0
}

func (m *MeterClasses) GetRxMeterClass() uint32 {
	if m != nil {
		return m.RxMeterClass
	}
	return 0
}

// in some cases, traffic going to certian overlay prefixes is sent to
// intermediate overlay workloads (e.g. virtual appliances) that perform
// some services on the packet (firewall, NAT etc.) and the traffic is then
// forwarded to the final destination
//
// OverlayNextHopIPInfo captures list of overlay IP destinations for a given
// route
//
// NOTE:
// 1. more than one overlay nexthop IP is not supported in all the pipelines
// 2. maximum number of overlay nexthop IPs supported depends on pipeline
// 3. when more than one overlay nexthop IP is configured, one of them is
//    picked based on the flow hash
// 4. when more than one overlay nexthop IP is configured, only IPv4 is
//    supported
type OverlayNextHopIPInfo struct {
	// overlay nexthop IP list
	NhIP []*IPAddress `protobuf:"bytes,1,rep,name=NhIP,proto3" json:"NhIP,omitempty"`
	// overlay MAC (DMAC inner) to be used when corresponding
	// to the overlay nexthop IP picked
	NhMac                []uint64 `protobuf:"varint,2,rep,packed,name=NhMac,proto3" json:"NhMac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OverlayNextHopIPInfo) Reset()         { *m = OverlayNextHopIPInfo{} }
func (m *OverlayNextHopIPInfo) String() string { return proto.CompactTextString(m) }
func (*OverlayNextHopIPInfo) ProtoMessage()    {}
func (*OverlayNextHopIPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{3}
}
func (m *OverlayNextHopIPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OverlayNextHopIPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OverlayNextHopIPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OverlayNextHopIPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OverlayNextHopIPInfo.Merge(m, src)
}
func (m *OverlayNextHopIPInfo) XXX_Size() int {
	return m.Size()
}
func (m *OverlayNextHopIPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OverlayNextHopIPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OverlayNextHopIPInfo proto.InternalMessageInfo

func (m *OverlayNextHopIPInfo) GetNhIP() []*IPAddress {
	if m != nil {
		return m.NhIP
	}
	return nil
}

func (m *OverlayNextHopIPInfo) GetNhMac() []uint64 {
	if m != nil {
		return m.NhMac
	}
	return nil
}

// route attributes
//
// routes can be classified into various classes (e.g. service routes, static
// routes, Internet routes etc.) and within each class of routes, they can
// have priority instead of standard longest prefix semantics
// route class priority can be used to pick higher priority routes among all
// route matches and it can also be used to configure some routes (or class of
// routes) with priority higher than the IP mappings as well in case both
// route table and mapping table get a hit for a given packet
type RouteAttrs struct {
	// IP prefix
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"Prefix,omitempty" meta:mandatory`
	// class of the route
	Class RouteClass `protobuf:"varint,2,opt,name=Class,proto3,enum=pds.RouteClass" json:"Class,omitempty" meta:default=ROUTE_TYPE_VPC`
	// priority of the route class this route belongs to
	// NOTE: ClassPriority attribute is used only when PriorityEn is set to true
	//       on the corresponding routing table
	ClassPriority uint32 `protobuf:"varint,3,opt,name=ClassPriority,proto3" json:"ClassPriority,omitempty" meta:range:0-31`
	// priority of the route within the class
	// NOTE:
	// 1. lower the numerical value, higher the priority in the datapath
	// 2. a route table MUST have either all the routes with priority set or no
	//    priority set on all the routes
	// 3. if multiple routes have same priority, route with longest prefix length
	//    will take effect
	// 4. if no priority value is set (i.e. 0) then route priority is computed as
	//    128 - <prefix length>, so longer prefixes will have higher precedence
	//    over shorter ones giving regular LPM semantics
	// 5. Priority attribute on the route is used only when PriorityEn is set to
	//    true on the corresponding routing table
	Priority uint32 `protobuf:"varint,4,opt,name=Priority,proto3" json:"Priority,omitempty" meta:range:0-1023`
	// route either points to one of the following types of nexthops
	//
	// Types that are valid to be assigned to Nh:
	//	*RouteAttrs_OverlayNhIPInfo
	//	*RouteAttrs_NexthopId
	//	*RouteAttrs_NexthopGroupId
	//	*RouteAttrs_VPCNh
	//	*RouteAttrs_TunnelId
	//	*RouteAttrs_RouteTableId
	Nh isRouteAttrs_Nh `protobuf_oneof:"nh"`
	// if NATAction is set, source and/or destination NAT will be performed on
	// the packet and if destination NAT is performed, another route lookup
	// will be done in the same route table with the post-NAT destination IP
	// address being rewritten
	NatAction *NATAction `protobuf:"bytes,11,opt,name=NatAction,proto3" json:"NatAction,omitempty"`
	// Types that are valid to be assigned to MeterAction:
	//	*RouteAttrs_MeterClasses
	//	*RouteAttrs_EvalMeterPolicy
	MeterAction isRouteAttrs_MeterAction `protobuf_oneof:"meter_action"`
	// ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
	// header or in the Traffic Class field of IPv6 outer header, this value , if
	// non-zero, will be written as-is (i.e., not interpreted) during encap time
	// by the dataplane for the flows/sessions established due to this route hit
	// NOTE:
	// the ToS value configured on the route will override ToS configuration
	// in vpc, subnet and tunnel objects
	ToS uint32 `protobuf:"varint,14,opt,name=ToS,proto3" json:"ToS,omitempty"`
	// traffic hitting a route can be programmed to carry a different encap value
	// (from that of the corresponding subnet or vpc overlay encap) and this
	// custom encap can be used to identify and process differently on the remote
	// side
	// NOTE: currently only VxLAN encap can be driven like this
	Encap *Encap `protobuf:"bytes,15,opt,name=Encap,proto3" json:"Encap,omitempty" meta:constraints={Encap.Vnid != 0}`
	// when a custom overlay MAC is provided in the route configuration, the MAC
	// address is used as inner DMAC in the (VxLAN) encapped packet
	OverlayMac uint64 `protobuf:"varint,16,opt,name=OverlayMac,proto3" json:"OverlayMac,omitempty"`
	// SvcRewrite contains all the rewrite info for the shared services
	SvcRewrite *SvcRewriteInfo `protobuf:"bytes,17,opt,name=SvcRewrite,proto3" json:"SvcRewrite,omitempty"`
	// in case of route (Ra) pointing to another route table, it is possible that
	// the route lookup in 2nd route table can yield nat action
	// NAT_ACTION_NAPT_PUBLIC and DisablePublicNAPT is used to ignore such NAT
	// action
	// NOTE:
	// NAT action on route Ra itself should be NAT_ACTION_NONE in this case
	DisablePublicNAPT    bool     `protobuf:"varint,18,opt,name=DisablePublicNAPT,proto3" json:"DisablePublicNAPT,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteAttrs) Reset()         { *m = RouteAttrs{} }
func (m *RouteAttrs) String() string { return proto.CompactTextString(m) }
func (*RouteAttrs) ProtoMessage()    {}
func (*RouteAttrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{4}
}
func (m *RouteAttrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteAttrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteAttrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteAttrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteAttrs.Merge(m, src)
}
func (m *RouteAttrs) XXX_Size() int {
	return m.Size()
}
func (m *RouteAttrs) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteAttrs.DiscardUnknown(m)
}

var xxx_messageInfo_RouteAttrs proto.InternalMessageInfo

type isRouteAttrs_Nh interface {
	isRouteAttrs_Nh()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteAttrs_MeterAction interface {
	isRouteAttrs_MeterAction()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteAttrs_OverlayNhIPInfo struct {
	OverlayNhIPInfo *OverlayNextHopIPInfo `protobuf:"bytes,5,opt,name=OverlayNhIPInfo,proto3,oneof"`
}
type RouteAttrs_NexthopId struct {
	NexthopId []byte `protobuf:"bytes,6,opt,name=NexthopId,proto3,oneof"`
}
type RouteAttrs_NexthopGroupId struct {
	NexthopGroupId []byte `protobuf:"bytes,7,opt,name=NexthopGroupId,proto3,oneof"`
}
type RouteAttrs_VPCNh struct {
	VPCNh *VPCPeerNhInfo `protobuf:"bytes,8,opt,name=VPCNh,proto3,oneof"`
}
type RouteAttrs_TunnelId struct {
	TunnelId []byte `protobuf:"bytes,9,opt,name=TunnelId,proto3,oneof"`
}
type RouteAttrs_RouteTableId struct {
	RouteTableId []byte `protobuf:"bytes,10,opt,name=RouteTableId,proto3,oneof"`
}
type RouteAttrs_MeterClasses struct {
	MeterClasses *MeterClasses `protobuf:"bytes,12,opt,name=MeterClasses,proto3,oneof"`
}
type RouteAttrs_EvalMeterPolicy struct {
	EvalMeterPolicy bool `protobuf:"varint,13,opt,name=EvalMeterPolicy,proto3,oneof"`
}

func (*RouteAttrs_OverlayNhIPInfo) isRouteAttrs_Nh()          {}
func (*RouteAttrs_NexthopId) isRouteAttrs_Nh()                {}
func (*RouteAttrs_NexthopGroupId) isRouteAttrs_Nh()           {}
func (*RouteAttrs_VPCNh) isRouteAttrs_Nh()                    {}
func (*RouteAttrs_TunnelId) isRouteAttrs_Nh()                 {}
func (*RouteAttrs_RouteTableId) isRouteAttrs_Nh()             {}
func (*RouteAttrs_MeterClasses) isRouteAttrs_MeterAction()    {}
func (*RouteAttrs_EvalMeterPolicy) isRouteAttrs_MeterAction() {}

func (m *RouteAttrs) GetNh() isRouteAttrs_Nh {
	if m != nil {
		return m.Nh
	}
	return nil
}
func (m *RouteAttrs) GetMeterAction() isRouteAttrs_MeterAction {
	if m != nil {
		return m.MeterAction
	}
	return nil
}

func (m *RouteAttrs) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *RouteAttrs) GetClass() RouteClass {
	if m != nil {
		return m.Class
	}
	return RouteClass_ROUTE_CLASS_NONE
}

func (m *RouteAttrs) GetClassPriority() uint32 {
	if m != nil {
		return m.ClassPriority
	}
	return 0
}

func (m *RouteAttrs) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *RouteAttrs) GetOverlayNhIPInfo() *OverlayNextHopIPInfo {
	if x, ok := m.GetNh().(*RouteAttrs_OverlayNhIPInfo); ok {
		return x.OverlayNhIPInfo
	}
	return nil
}

func (m *RouteAttrs) GetNexthopId() []byte {
	if x, ok := m.GetNh().(*RouteAttrs_NexthopId); ok {
		return x.NexthopId
	}
	return nil
}

func (m *RouteAttrs) GetNexthopGroupId() []byte {
	if x, ok := m.GetNh().(*RouteAttrs_NexthopGroupId); ok {
		return x.NexthopGroupId
	}
	return nil
}

func (m *RouteAttrs) GetVPCNh() *VPCPeerNhInfo {
	if x, ok := m.GetNh().(*RouteAttrs_VPCNh); ok {
		return x.VPCNh
	}
	return nil
}

func (m *RouteAttrs) GetTunnelId() []byte {
	if x, ok := m.GetNh().(*RouteAttrs_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (m *RouteAttrs) GetRouteTableId() []byte {
	if x, ok := m.GetNh().(*RouteAttrs_RouteTableId); ok {
		return x.RouteTableId
	}
	return nil
}

func (m *RouteAttrs) GetNatAction() *NATAction {
	if m != nil {
		return m.NatAction
	}
	return nil
}

func (m *RouteAttrs) GetMeterClasses() *MeterClasses {
	if x, ok := m.GetMeterAction().(*RouteAttrs_MeterClasses); ok {
		return x.MeterClasses
	}
	return nil
}

func (m *RouteAttrs) GetEvalMeterPolicy() bool {
	if x, ok := m.GetMeterAction().(*RouteAttrs_EvalMeterPolicy); ok {
		return x.EvalMeterPolicy
	}
	return false
}

func (m *RouteAttrs) GetToS() uint32 {
	if m != nil {
		return m.ToS
	}
	return 0
}

func (m *RouteAttrs) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *RouteAttrs) GetOverlayMac() uint64 {
	if m != nil {
		return m.OverlayMac
	}
	return 0
}

func (m *RouteAttrs) GetSvcRewrite() *SvcRewriteInfo {
	if m != nil {
		return m.SvcRewrite
	}
	return nil
}

func (m *RouteAttrs) GetDisablePublicNAPT() bool {
	if m != nil {
		return m.DisablePublicNAPT
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteAttrs) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteAttrs_OverlayNhIPInfo)(nil),
		(*RouteAttrs_NexthopId)(nil),
		(*RouteAttrs_NexthopGroupId)(nil),
		(*RouteAttrs_VPCNh)(nil),
		(*RouteAttrs_TunnelId)(nil),
		(*RouteAttrs_RouteTableId)(nil),
		(*RouteAttrs_MeterClasses)(nil),
		(*RouteAttrs_EvalMeterPolicy)(nil),
	}
}

// route configuration information
type RouteInfo struct {
	// optional route id needed if incremental route ADD/DEL/UPD functionality
	// is needed
	Id                   []byte      `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	Attrs                *RouteAttrs `protobuf:"bytes,2,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RouteInfo) Reset()         { *m = RouteInfo{} }
func (m *RouteInfo) String() string { return proto.CompactTextString(m) }
func (*RouteInfo) ProtoMessage()    {}
func (*RouteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{5}
}
func (m *RouteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteInfo.Merge(m, src)
}
func (m *RouteInfo) XXX_Size() int {
	return m.Size()
}
func (m *RouteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RouteInfo proto.InternalMessageInfo

func (m *RouteInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RouteInfo) GetAttrs() *RouteAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// route table specification
// NOTE: any time a route table's route(s) changes, client is expected to send
//       full new route table (i.e., no incremental route add/del/upd is
//       supported)
type RouteTableSpec struct {
	// unique route table id (this id is not scoped under VPC or subnet)
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// IP address family
	Af IPAF `protobuf:"varint,2,opt,name=Af,proto3,enum=types.IPAF" json:"Af,omitempty" meta:mandatory,immutable`
	// enable or disable priority based routing for the route table
	PriorityEn bool `protobuf:"varint,3,opt,name=PriorityEn,proto3" json:"PriorityEn,omitempty" meta:immutable,default=false`
	// routes in this route table
	// NOTE: in a given route table, same prefix must not appear more than once.
	//       if there are multiple paths to same route prefix, application is
	//       expected to create a nexthop group and point the route to it instead
	//       of adding same route with multiple different nexthops
	Routes               []*RouteInfo `protobuf:"bytes,4,rep,name=Routes,proto3" json:"Routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RouteTableSpec) Reset()         { *m = RouteTableSpec{} }
func (m *RouteTableSpec) String() string { return proto.CompactTextString(m) }
func (*RouteTableSpec) ProtoMessage()    {}
func (*RouteTableSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{6}
}
func (m *RouteTableSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableSpec.Merge(m, src)
}
func (m *RouteTableSpec) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableSpec proto.InternalMessageInfo

func (m *RouteTableSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RouteTableSpec) GetAf() IPAF {
	if m != nil {
		return m.Af
	}
	return IPAF_IP_AF_NONE
}

func (m *RouteTableSpec) GetPriorityEn() bool {
	if m != nil {
		return m.PriorityEn
	}
	return false
}

func (m *RouteTableSpec) GetRoutes() []*RouteInfo {
	if m != nil {
		return m.Routes
	}
	return nil
}

// operational status of the route table, if any
type RouteTableStatus struct {
	PoolId               uint32   `protobuf:"varint,1,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
	HwId                 uint32   `protobuf:"varint,2,opt,name=HwId,proto3" json:"HwId,omitempty"`
	RouteTableBaseAddr   uint64   `protobuf:"varint,3,opt,name=RouteTableBaseAddr,proto3" json:"RouteTableBaseAddr,omitempty"`
	DNatBaseIdx          uint32   `protobuf:"varint,4,opt,name=DNatBaseIdx,proto3" json:"DNatBaseIdx,omitempty"`
	DNatIdxCount         uint32   `protobuf:"varint,5,opt,name=DNatIdxCount,proto3" json:"DNatIdxCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteTableStatus) Reset()         { *m = RouteTableStatus{} }
func (m *RouteTableStatus) String() string { return proto.CompactTextString(m) }
func (*RouteTableStatus) ProtoMessage()    {}
func (*RouteTableStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{7}
}
func (m *RouteTableStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableStatus.Merge(m, src)
}
func (m *RouteTableStatus) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableStatus proto.InternalMessageInfo

func (m *RouteTableStatus) GetPoolId() uint32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *RouteTableStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *RouteTableStatus) GetRouteTableBaseAddr() uint64 {
	if m != nil {
		return m.RouteTableBaseAddr
	}
	return 0
}

func (m *RouteTableStatus) GetDNatBaseIdx() uint32 {
	if m != nil {
		return m.DNatBaseIdx
	}
	return 0
}

func (m *RouteTableStatus) GetDNatIdxCount() uint32 {
	if m != nil {
		return m.DNatIdxCount
	}
	return 0
}

// stats of the route table, if any
type RouteTableStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteTableStats) Reset()         { *m = RouteTableStats{} }
func (m *RouteTableStats) String() string { return proto.CompactTextString(m) }
func (*RouteTableStats) ProtoMessage()    {}
func (*RouteTableStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{8}
}
func (m *RouteTableStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableStats.Merge(m, src)
}
func (m *RouteTableStats) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableStats) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableStats.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableStats proto.InternalMessageInfo

// route table object
type RouteTable struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *RouteTableSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *RouteTableStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *RouteTableStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RouteTable) Reset()         { *m = RouteTable{} }
func (m *RouteTable) String() string { return proto.CompactTextString(m) }
func (*RouteTable) ProtoMessage()    {}
func (*RouteTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{9}
}
func (m *RouteTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTable.Merge(m, src)
}
func (m *RouteTable) XXX_Size() int {
	return m.Size()
}
func (m *RouteTable) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTable.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTable proto.InternalMessageInfo

func (m *RouteTable) GetSpec() *RouteTableSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *RouteTable) GetStatus() *RouteTableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RouteTable) GetStats() *RouteTableStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// route table create and update request
type RouteTableRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt        `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*RouteTableSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RouteTableRequest) Reset()         { *m = RouteTableRequest{} }
func (m *RouteTableRequest) String() string { return proto.CompactTextString(m) }
func (*RouteTableRequest) ProtoMessage()    {}
func (*RouteTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{10}
}
func (m *RouteTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableRequest.Merge(m, src)
}
func (m *RouteTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableRequest proto.InternalMessageInfo

func (m *RouteTableRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *RouteTableRequest) GetRequest() []*RouteTableSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// route table create and update response
type RouteTableResponse struct {
	ApiStatus            ApiStatus           `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*RouteTableStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RouteTableResponse) Reset()         { *m = RouteTableResponse{} }
func (m *RouteTableResponse) String() string { return proto.CompactTextString(m) }
func (*RouteTableResponse) ProtoMessage()    {}
func (*RouteTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{11}
}
func (m *RouteTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableResponse.Merge(m, src)
}
func (m *RouteTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableResponse proto.InternalMessageInfo

func (m *RouteTableResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RouteTableResponse) GetResponse() []*RouteTableStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// route table get request
type RouteTableGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteTableGetRequest) Reset()         { *m = RouteTableGetRequest{} }
func (m *RouteTableGetRequest) String() string { return proto.CompactTextString(m) }
func (*RouteTableGetRequest) ProtoMessage()    {}
func (*RouteTableGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{12}
}
func (m *RouteTableGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableGetRequest.Merge(m, src)
}
func (m *RouteTableGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableGetRequest proto.InternalMessageInfo

func (m *RouteTableGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// route table get response
type RouteTableGetResponse struct {
	ApiStatus            ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*RouteTable `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RouteTableGetResponse) Reset()         { *m = RouteTableGetResponse{} }
func (m *RouteTableGetResponse) String() string { return proto.CompactTextString(m) }
func (*RouteTableGetResponse) ProtoMessage()    {}
func (*RouteTableGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{13}
}
func (m *RouteTableGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableGetResponse.Merge(m, src)
}
func (m *RouteTableGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableGetResponse proto.InternalMessageInfo

func (m *RouteTableGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RouteTableGetResponse) GetResponse() []*RouteTable {
	if m != nil {
		return m.Response
	}
	return nil
}

// route table delete request
type RouteTableDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Id                   [][]byte `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteTableDeleteRequest) Reset()         { *m = RouteTableDeleteRequest{} }
func (m *RouteTableDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*RouteTableDeleteRequest) ProtoMessage()    {}
func (*RouteTableDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{14}
}
func (m *RouteTableDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableDeleteRequest.Merge(m, src)
}
func (m *RouteTableDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableDeleteRequest proto.InternalMessageInfo

func (m *RouteTableDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *RouteTableDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// route table delete response
type RouteTableDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RouteTableDeleteResponse) Reset()         { *m = RouteTableDeleteResponse{} }
func (m *RouteTableDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*RouteTableDeleteResponse) ProtoMessage()    {}
func (*RouteTableDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{15}
}
func (m *RouteTableDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableDeleteResponse.Merge(m, src)
}
func (m *RouteTableDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableDeleteResponse proto.InternalMessageInfo

func (m *RouteTableDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// route identifier
type RouteId struct {
	// unique route id (this id is not scoped under VPC or subnet)
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// route table this route belongs to
	RouteTableId         []byte   `protobuf:"bytes,2,opt,name=RouteTableId,proto3" json:"RouteTableId,omitempty" meta:mandatory,immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteId) Reset()         { *m = RouteId{} }
func (m *RouteId) String() string { return proto.CompactTextString(m) }
func (*RouteId) ProtoMessage()    {}
func (*RouteId) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{16}
}
func (m *RouteId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteId.Merge(m, src)
}
func (m *RouteId) XXX_Size() int {
	return m.Size()
}
func (m *RouteId) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteId.DiscardUnknown(m)
}

var xxx_messageInfo_RouteId proto.InternalMessageInfo

func (m *RouteId) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RouteId) GetRouteTableId() []byte {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

// route specification
type RouteSpec struct {
	// globally unique route table id
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// route table this route belongs to
	RouteTableId []byte `protobuf:"bytes,2,opt,name=RouteTableId,proto3" json:"RouteTableId,omitempty" meta:mandatory,immutable`
	// route configuration
	Attrs                *RouteAttrs `protobuf:"bytes,3,opt,name=Attrs,proto3" json:"Attrs,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RouteSpec) Reset()         { *m = RouteSpec{} }
func (m *RouteSpec) String() string { return proto.CompactTextString(m) }
func (*RouteSpec) ProtoMessage()    {}
func (*RouteSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{17}
}
func (m *RouteSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteSpec.Merge(m, src)
}
func (m *RouteSpec) XXX_Size() int {
	return m.Size()
}
func (m *RouteSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RouteSpec proto.InternalMessageInfo

func (m *RouteSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RouteSpec) GetRouteTableId() []byte {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

func (m *RouteSpec) GetAttrs() *RouteAttrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// operational status of the route, if any
type RouteStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteStatus) Reset()         { *m = RouteStatus{} }
func (m *RouteStatus) String() string { return proto.CompactTextString(m) }
func (*RouteStatus) ProtoMessage()    {}
func (*RouteStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{18}
}
func (m *RouteStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteStatus.Merge(m, src)
}
func (m *RouteStatus) XXX_Size() int {
	return m.Size()
}
func (m *RouteStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RouteStatus proto.InternalMessageInfo

// stats of the route, if any
type RouteStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteStats) Reset()         { *m = RouteStats{} }
func (m *RouteStats) String() string { return proto.CompactTextString(m) }
func (*RouteStats) ProtoMessage()    {}
func (*RouteStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{19}
}
func (m *RouteStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteStats.Merge(m, src)
}
func (m *RouteStats) XXX_Size() int {
	return m.Size()
}
func (m *RouteStats) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteStats.DiscardUnknown(m)
}

var xxx_messageInfo_RouteStats proto.InternalMessageInfo

// route object
type Route struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *RouteSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *RouteStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *RouteStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{20}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetSpec() *RouteSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Route) GetStatus() *RouteStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Route) GetStats() *RouteStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// route create and update request
type RouteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// route configuration
	Request              *RouteSpec `protobuf:"bytes,2,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RouteRequest) Reset()         { *m = RouteRequest{} }
func (m *RouteRequest) String() string { return proto.CompactTextString(m) }
func (*RouteRequest) ProtoMessage()    {}
func (*RouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{21}
}
func (m *RouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRequest.Merge(m, src)
}
func (m *RouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRequest proto.InternalMessageInfo

func (m *RouteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *RouteRequest) GetRequest() *RouteSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// route create and update response
type RouteResponse struct {
	// success or failure status
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// operational status
	Response             *RouteStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RouteResponse) Reset()         { *m = RouteResponse{} }
func (m *RouteResponse) String() string { return proto.CompactTextString(m) }
func (*RouteResponse) ProtoMessage()    {}
func (*RouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{22}
}
func (m *RouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteResponse.Merge(m, src)
}
func (m *RouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteResponse proto.InternalMessageInfo

func (m *RouteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RouteResponse) GetResponse() *RouteStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// route get request
type RouteGetRequest struct {
	// list of keys of interest
	Id                   []*RouteId `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RouteGetRequest) Reset()         { *m = RouteGetRequest{} }
func (m *RouteGetRequest) String() string { return proto.CompactTextString(m) }
func (*RouteGetRequest) ProtoMessage()    {}
func (*RouteGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{23}
}
func (m *RouteGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteGetRequest.Merge(m, src)
}
func (m *RouteGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteGetRequest proto.InternalMessageInfo

func (m *RouteGetRequest) GetId() []*RouteId {
	if m != nil {
		return m.Id
	}
	return nil
}

// route get response
type RouteGetResponse struct {
	// API status code
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// route information
	Response             []*Route `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteGetResponse) Reset()         { *m = RouteGetResponse{} }
func (m *RouteGetResponse) String() string { return proto.CompactTextString(m) }
func (*RouteGetResponse) ProtoMessage()    {}
func (*RouteGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{24}
}
func (m *RouteGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteGetResponse.Merge(m, src)
}
func (m *RouteGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteGetResponse proto.InternalMessageInfo

func (m *RouteGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RouteGetResponse) GetResponse() []*Route {
	if m != nil {
		return m.Response
	}
	return nil
}

// route delete request
type RouteDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// list of routes to delete
	Id                   *RouteId `protobuf:"bytes,2,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteDeleteRequest) Reset()         { *m = RouteDeleteRequest{} }
func (m *RouteDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*RouteDeleteRequest) ProtoMessage()    {}
func (*RouteDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{25}
}
func (m *RouteDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDeleteRequest.Merge(m, src)
}
func (m *RouteDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDeleteRequest proto.InternalMessageInfo

func (m *RouteDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *RouteDeleteRequest) GetId() *RouteId {
	if m != nil {
		return m.Id
	}
	return nil
}

// route delete response
type RouteDeleteResponse struct {
	// API status code
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RouteDeleteResponse) Reset()         { *m = RouteDeleteResponse{} }
func (m *RouteDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*RouteDeleteResponse) ProtoMessage()    {}
func (*RouteDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0984d49a362b6b9f, []int{26}
}
func (m *RouteDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDeleteResponse.Merge(m, src)
}
func (m *RouteDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDeleteResponse proto.InternalMessageInfo

func (m *RouteDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterEnum("pds.RouteClass", RouteClass_name, RouteClass_value)
	proto.RegisterType((*NATAction)(nil), "pds.NATAction")
	proto.RegisterType((*VPCPeerNhInfo)(nil), "pds.VPCPeerNhInfo")
	proto.RegisterType((*MeterClasses)(nil), "pds.MeterClasses")
	proto.RegisterType((*OverlayNextHopIPInfo)(nil), "pds.OverlayNextHopIPInfo")
	proto.RegisterType((*RouteAttrs)(nil), "pds.RouteAttrs")
	proto.RegisterType((*RouteInfo)(nil), "pds.RouteInfo")
	proto.RegisterType((*RouteTableSpec)(nil), "pds.RouteTableSpec")
	proto.RegisterType((*RouteTableStatus)(nil), "pds.RouteTableStatus")
	proto.RegisterType((*RouteTableStats)(nil), "pds.RouteTableStats")
	proto.RegisterType((*RouteTable)(nil), "pds.RouteTable")
	proto.RegisterType((*RouteTableRequest)(nil), "pds.RouteTableRequest")
	proto.RegisterType((*RouteTableResponse)(nil), "pds.RouteTableResponse")
	proto.RegisterType((*RouteTableGetRequest)(nil), "pds.RouteTableGetRequest")
	proto.RegisterType((*RouteTableGetResponse)(nil), "pds.RouteTableGetResponse")
	proto.RegisterType((*RouteTableDeleteRequest)(nil), "pds.RouteTableDeleteRequest")
	proto.RegisterType((*RouteTableDeleteResponse)(nil), "pds.RouteTableDeleteResponse")
	proto.RegisterType((*RouteId)(nil), "pds.RouteId")
	proto.RegisterType((*RouteSpec)(nil), "pds.RouteSpec")
	proto.RegisterType((*RouteStatus)(nil), "pds.RouteStatus")
	proto.RegisterType((*RouteStats)(nil), "pds.RouteStats")
	proto.RegisterType((*Route)(nil), "pds.Route")
	proto.RegisterType((*RouteRequest)(nil), "pds.RouteRequest")
	proto.RegisterType((*RouteResponse)(nil), "pds.RouteResponse")
	proto.RegisterType((*RouteGetRequest)(nil), "pds.RouteGetRequest")
	proto.RegisterType((*RouteGetResponse)(nil), "pds.RouteGetResponse")
	proto.RegisterType((*RouteDeleteRequest)(nil), "pds.RouteDeleteRequest")
	proto.RegisterType((*RouteDeleteResponse)(nil), "pds.RouteDeleteResponse")
}

func init() { proto.RegisterFile("route.proto", fileDescriptor_0984d49a362b6b9f) }

var fileDescriptor_0984d49a362b6b9f = []byte{
	// 1676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0xf5, 0xe1, 0x8f, 0xa7, 0x4f, 0x8f, 0x9d, 0x84, 0xeb, 0xa6, 0x96, 0x4a, 0x2c, 0x02,
	0x21, 0x55, 0x5c, 0xc7, 0xd9, 0x4d, 0x91, 0x04, 0xee, 0xae, 0xa8, 0x68, 0xd7, 0x5c, 0x6c, 0x68,
	0x76, 0xa4, 0xb8, 0x58, 0xf4, 0x60, 0x30, 0xe2, 0x38, 0x62, 0x20, 0x91, 0x5a, 0x72, 0xe4, 0x58,
	0x68, 0x7b, 0xeb, 0xb1, 0x7f, 0x4e, 0x51, 0xa0, 0xff, 0x41, 0x2f, 0x05, 0xf6, 0x2f, 0x10, 0x8a,
	0xf4, 0x96, 0xa3, 0x6f, 0xbd, 0x15, 0x1c, 0x8e, 0xc8, 0xa1, 0xc4, 0xe6, 0x43, 0x39, 0xf4, 0x12,
	0x68, 0xde, 0x7b, 0xbf, 0xf7, 0x35, 0xef, 0xfd, 0x86, 0x0e, 0x14, 0x3c, 0x77, 0x42, 0xc9, 0xc1,
	0xd8, 0x73, 0xa9, 0x8b, 0xb2, 0x63, 0xcb, 0xdf, 0x83, 0x97, 0xee, 0x4b, 0x37, 0x14, 0xec, 0x55,
	0x46, 0x84, 0x9a, 0xbf, 0x0a, 0xfe, 0xe1, 0x82, 0x02, 0x9d, 0x8e, 0x89, 0x1f, 0x1e, 0x94, 0xb7,
	0x12, 0x6c, 0xe9, 0xad, 0x5e, 0xab, 0x4f, 0x6d, 0xd7, 0x41, 0x5f, 0x40, 0xb1, 0xeb, 0xf5, 0x75,
	0x93, 0x86, 0x67, 0x59, 0xaa, 0x4b, 0x8d, 0xf2, 0x51, 0xf5, 0x20, 0x44, 0x44, 0x72, 0x9c, 0xb0,
	0x42, 0x4d, 0xd8, 0x7c, 0xea, 0x53, 0xdd, 0xa4, 0x9a, 0x21, 0x67, 0xea, 0x52, 0xa3, 0x10, 0x21,
	0x34, 0xa3, 0x65, 0x59, 0x1e, 0xf1, 0x7d, 0x1c, 0x59, 0xa0, 0x29, 0x6c, 0x19, 0xae, 0x47, 0x31,
	0x99, 0xf8, 0x44, 0xce, 0xd6, 0xa5, 0xc6, 0xa6, 0xfa, 0xfb, 0xeb, 0x59, 0xed, 0x77, 0x41, 0x86,
	0x8f, 0xfb, 0xae, 0xe3, 0x53, 0xcf, 0xb4, 0x1d, 0xea, 0x1f, 0x8b, 0x31, 0x8e, 0x8f, 0xf5, 0x56,
	0xef, 0xbc, 0xd5, 0xee, 0x69, 0xa7, 0xfa, 0xb9, 0xde, 0x32, 0x7a, 0xe7, 0xc6, 0x73, 0xf5, 0x7b,
	0xad, 0xfd, 0xc7, 0x77, 0x1b, 0x75, 0xcf, 0xda, 0x38, 0x8e, 0xa6, 0xfc, 0x08, 0xa5, 0x33, 0xa3,
	0x6d, 0x10, 0xe2, 0xe9, 0x03, 0xcd, 0xb9, 0x70, 0x51, 0x03, 0xf2, 0x67, 0x46, 0x5b, 0xb3, 0x58,
	0xa1, 0x45, 0x15, 0x5d, 0xcf, 0x6a, 0x65, 0x96, 0xc7, 0xc8, 0x74, 0x2c, 0x93, 0xba, 0xde, 0x14,
	0x87, 0x06, 0xe8, 0x21, 0x14, 0x71, 0xd0, 0xe5, 0x9e, 0xf9, 0x62, 0x48, 0x34, 0x8b, 0xd5, 0x99,
	0x0e, 0x48, 0xd8, 0x29, 0x7f, 0x96, 0xa0, 0xf8, 0x8c, 0x50, 0xe2, 0xb5, 0x87, 0xa6, 0xef, 0x13,
	0x1f, 0x3d, 0x82, 0x62, 0xef, 0x2a, 0x96, 0xb0, 0xc8, 0x25, 0xf5, 0xc6, 0xf5, 0xac, 0xb6, 0xcd,
	0x1c, 0x79, 0xa6, 0xf3, 0x92, 0x3c, 0xbe, 0x7f, 0xef, 0x8b, 0xc3, 0x47, 0x5f, 0xe2, 0x84, 0x69,
	0x00, 0xc5, 0x22, 0x34, 0xf3, 0x4e, 0xa8, 0x68, 0xaa, 0x60, 0xd8, 0x3d, 0xbd, 0x24, 0xde, 0xd0,
	0x9c, 0xea, 0xe4, 0x8a, 0x9e, 0xb8, 0x63, 0xcd, 0x60, 0x0d, 0xf8, 0x1c, 0x72, 0xfa, 0x40, 0x33,
	0x64, 0xa9, 0x9e, 0x4d, 0xbd, 0x36, 0xa6, 0x45, 0xbb, 0x90, 0xd7, 0x07, 0xcf, 0xcc, 0xbe, 0x9c,
	0xa9, 0x67, 0x1b, 0x39, 0x1c, 0x1e, 0x94, 0xbf, 0x6c, 0x00, 0xb0, 0x5a, 0x5b, 0x94, 0x7a, 0x3e,
	0x7a, 0x02, 0xeb, 0x86, 0x47, 0x2e, 0xec, 0x2b, 0x56, 0x52, 0xe1, 0xa8, 0x12, 0x39, 0x0b, 0xc5,
	0xa9, 0xcd, 0xe2, 0x10, 0xf4, 0x0d, 0xe4, 0xe3, 0x9a, 0xca, 0x47, 0x95, 0x83, 0xb1, 0xe5, 0x1f,
	0x30, 0xe7, 0x4c, 0xac, 0xd6, 0xae, 0x67, 0xb5, 0x9f, 0x31, 0xac, 0x45, 0x2e, 0xcc, 0xc9, 0x90,
	0x1e, 0xe3, 0xd3, 0xe7, 0xbd, 0xce, 0x79, 0xef, 0x07, 0xa3, 0x73, 0x7e, 0x66, 0xb4, 0x71, 0x7e,
	0xde, 0xa2, 0x12, 0xfb, 0x61, 0x78, 0xb6, 0xeb, 0xd9, 0x74, 0xca, 0x06, 0xac, 0xa4, 0xee, 0x5c,
	0xcf, 0x6a, 0x15, 0xa1, 0x47, 0x87, 0xf7, 0x1e, 0xdc, 0xc7, 0x49, 0x4b, 0x74, 0x1f, 0x36, 0x23,
	0x54, 0x2e, 0xb5, 0xb3, 0x87, 0xf7, 0xee, 0x1f, 0x1e, 0x3d, 0xc0, 0x91, 0x19, 0xea, 0x40, 0x65,
	0xde, 0xd5, 0x41, 0xd8, 0x50, 0x39, 0xcf, 0x6a, 0xff, 0x8c, 0xe5, 0x9f, 0xd6, 0xf1, 0x93, 0x35,
	0xbc, 0x88, 0x41, 0xfb, 0xb0, 0x15, 0xd8, 0x0c, 0xdc, 0xb1, 0x66, 0xc9, 0xeb, 0xc1, 0x60, 0x9d,
	0xac, 0xe1, 0x58, 0x84, 0x1a, 0x50, 0xe6, 0x87, 0x6f, 0x3d, 0x77, 0x12, 0x18, 0x6d, 0x70, 0xa3,
	0x05, 0x39, 0xba, 0xcb, 0xe6, 0x59, 0x1f, 0xc8, 0x9b, 0x2c, 0x0d, 0xc4, 0xd2, 0x48, 0x8c, 0xfc,
	0xc9, 0x1a, 0x0e, 0x4d, 0xd0, 0x6d, 0xd8, 0xec, 0x4d, 0x1c, 0x87, 0x0c, 0x35, 0x4b, 0xde, 0xe2,
	0xfe, 0x22, 0x09, 0xfa, 0x7c, 0x61, 0xde, 0x81, 0x5b, 0x24, 0xa4, 0xa8, 0x09, 0x5b, 0x31, 0x59,
	0x14, 0x58, 0xcc, 0x32, 0x8b, 0x19, 0x51, 0x0a, 0x8e, 0x0d, 0xd0, 0xaf, 0x93, 0xab, 0x20, 0x17,
	0x19, 0x60, 0x9b, 0x01, 0x44, 0xc5, 0x89, 0x84, 0x93, 0x3b, 0x73, 0x17, 0x2a, 0x9d, 0x4b, 0x73,
	0xc8, 0x64, 0x86, 0x3b, 0xb4, 0xfb, 0x53, 0xb9, 0x14, 0x10, 0xc7, 0x89, 0x84, 0x17, 0x15, 0xa8,
	0x0a, 0xd9, 0x9e, 0xdb, 0x95, 0xcb, 0xc1, 0x0d, 0xe2, 0xe0, 0x27, 0xfa, 0x0e, 0xf2, 0x1d, 0xa7,
	0x6f, 0x8e, 0xe5, 0x0a, 0x8b, 0x57, 0xe4, 0x73, 0xc9, 0x64, 0xea, 0x9d, 0xeb, 0x59, 0x4d, 0x59,
	0xa2, 0x9e, 0x3f, 0x30, 0xe5, 0xc1, 0x99, 0x63, 0x5b, 0xf5, 0x5f, 0x1c, 0xd7, 0x0f, 0xff, 0x84,
	0x43, 0x17, 0x68, 0x1f, 0x80, 0xdf, 0x5e, 0xb0, 0x0e, 0xd5, 0xba, 0xd4, 0xc8, 0x61, 0x41, 0x82,
	0xbe, 0x04, 0xe8, 0x5e, 0xf6, 0x31, 0x79, 0xed, 0xd9, 0x94, 0xc8, 0xdb, 0x2c, 0xe0, 0x0d, 0x1e,
	0x30, 0x56, 0x04, 0x17, 0x81, 0x05, 0x43, 0xd4, 0x84, 0xed, 0xa7, 0xb6, 0x1f, 0x34, 0xd5, 0x98,
	0xbc, 0x18, 0xda, 0xfd, 0x80, 0xbc, 0x64, 0x14, 0x94, 0x88, 0x97, 0x15, 0x6a, 0x0e, 0x32, 0xce,
	0x40, 0x2d, 0x43, 0x71, 0x14, 0xd4, 0x7d, 0x6e, 0xb2, 0xee, 0x2a, 0x14, 0xb6, 0xd8, 0xdd, 0xb0,
	0x91, 0x6a, 0x42, 0x26, 0x62, 0xb5, 0xdb, 0xd7, 0xb3, 0x9a, 0x9c, 0xdc, 0xbb, 0xa6, 0x3d, 0x1a,
	0x4d, 0x68, 0xe0, 0x16, 0x67, 0x34, 0x0b, 0x3d, 0x82, 0x3c, 0xdb, 0x61, 0xce, 0xde, 0xc2, 0xf6,
	0x31, 0x71, 0x3a, 0x2f, 0x32, 0x95, 0xf2, 0x6f, 0x09, 0xca, 0xf1, 0x48, 0x74, 0xc7, 0xa4, 0xff,
	0xd1, 0xb1, 0x33, 0xad, 0x0b, 0xbe, 0xf6, 0x85, 0x98, 0x7f, 0xbe, 0x79, 0x1f, 0xb4, 0x75, 0x81,
	0xbe, 0x06, 0x98, 0xaf, 0x62, 0xc7, 0xe1, 0x4f, 0x49, 0xfd, 0x7a, 0x56, 0xbb, 0xcd, 0x50, 0x91,
	0x6d, 0x73, 0x4e, 0x19, 0x17, 0xe6, 0xd0, 0x27, 0x58, 0xc0, 0xa0, 0x3b, 0xb0, 0xce, 0x92, 0xf7,
	0xe5, 0x1c, 0x23, 0xc0, 0x72, 0x5c, 0x39, 0xbb, 0x23, 0xae, 0x55, 0xfe, 0x2a, 0x41, 0x55, 0xa8,
	0x92, 0x9a, 0x74, 0xe2, 0xa3, 0x9b, 0xb0, 0x6e, 0xb8, 0xee, 0x90, 0xd7, 0x5a, 0xc2, 0xfc, 0x84,
	0x10, 0xe4, 0x4e, 0x5e, 0xf3, 0x27, 0xa2, 0x84, 0xd9, 0x6f, 0x74, 0x00, 0x28, 0xc6, 0xab, 0xa6,
	0x4f, 0x02, 0x82, 0x65, 0x29, 0xe7, 0x70, 0x8a, 0x06, 0xd5, 0xa1, 0xf0, 0x54, 0x37, 0x69, 0x70,
	0xd6, 0xac, 0xab, 0x90, 0x8f, 0xb0, 0x28, 0x42, 0x0a, 0x14, 0x83, 0xa3, 0x66, 0x5d, 0xb5, 0xdd,
	0x89, 0x43, 0x19, 0xf1, 0x94, 0x70, 0x42, 0xa6, 0x6c, 0x43, 0x25, 0x99, 0xb5, 0xaf, 0xfc, 0x33,
	0xc3, 0x49, 0x9b, 0xc9, 0xd0, 0x13, 0xd8, 0xec, 0x4d, 0xc7, 0xe4, 0x19, 0xa1, 0x26, 0xa7, 0xed,
	0xf2, 0x01, 0xfb, 0x54, 0x98, 0x4b, 0xd5, 0xca, 0x4f, 0xb3, 0x9a, 0xf4, 0x76, 0x56, 0xdb, 0x68,
	0xda, 0xce, 0xd0, 0x76, 0x08, 0x8e, 0x00, 0xe8, 0x2b, 0xd8, 0x38, 0x7d, 0xf1, 0x8a, 0x61, 0xc3,
	0xc1, 0x29, 0x85, 0x58, 0x2e, 0x54, 0x6f, 0x72, 0x28, 0x1b, 0x9d, 0xa6, 0x3b, 0xb2, 0x29, 0x19,
	0x8d, 0xe9, 0x14, 0xcf, 0x51, 0xe8, 0x09, 0xe4, 0x82, 0x89, 0x61, 0x7d, 0x28, 0x1c, 0xed, 0xc4,
	0xcd, 0x8f, 0x86, 0x49, 0x45, 0x01, 0xde, 0x1f, 0x93, 0xbe, 0x80, 0x67, 0x20, 0xd4, 0x86, 0xf5,
	0xf0, 0x22, 0x58, 0x77, 0x82, 0x35, 0x5b, 0x80, 0x33, 0xa5, 0xba, 0xfb, 0x76, 0x56, 0xab, 0xfa,
	0xec, 0xb7, 0xe0, 0x82, 0x43, 0xd1, 0x57, 0x90, 0x67, 0x7d, 0xe1, 0xbc, 0xbd, 0x9b, 0xe2, 0xc3,
	0x57, 0x77, 0xde, 0xce, 0x6a, 0x95, 0xc0, 0x85, 0xe8, 0x21, 0xc4, 0x29, 0x1e, 0x6c, 0xc7, 0xe6,
	0x98, 0xfc, 0x38, 0x21, 0x3e, 0x45, 0x07, 0xb0, 0xa5, 0x9a, 0xb4, 0x3f, 0x68, 0xd3, 0x2b, 0xca,
	0xdb, 0x3a, 0x7f, 0x5a, 0x23, 0x39, 0x8e, 0x4d, 0xd0, 0x3d, 0xd8, 0xe0, 0x50, 0xf6, 0xc2, 0xa6,
	0xb7, 0x02, 0xcf, 0x6d, 0x94, 0xd7, 0xe2, 0x30, 0x61, 0xe2, 0x8f, 0x5d, 0xc7, 0x27, 0x41, 0xd0,
	0xd6, 0xd8, 0xe6, 0x2d, 0x49, 0x7e, 0xb8, 0x45, 0x72, 0x1c, 0x9b, 0x04, 0xef, 0xdd, 0x1c, 0xcb,
	0xa3, 0xa6, 0x77, 0x10, 0x47, 0x66, 0xca, 0x1d, 0xd8, 0x8d, 0xb5, 0xdf, 0x12, 0x3a, 0xaf, 0xb7,
	0xcc, 0x37, 0x3e, 0xdb, 0x28, 0x06, 0x3b, 0xad, 0x50, 0xb8, 0xb1, 0x60, 0xb7, 0x62, 0x8e, 0xbf,
	0x5c, 0xca, 0xb1, 0xb2, 0x90, 0xa3, 0x90, 0xdd, 0x0f, 0x70, 0x2b, 0x96, 0x3f, 0x25, 0x43, 0x42,
	0x57, 0xbe, 0x90, 0xb0, 0xa0, 0x4c, 0x54, 0xd0, 0x77, 0x20, 0x2f, 0xbb, 0x4e, 0xaf, 0x29, 0xfb,
	0x9e, 0x9a, 0x94, 0x29, 0x6c, 0x84, 0x04, 0x63, 0x7d, 0x24, 0x53, 0x7e, 0x9d, 0xfa, 0x09, 0xfa,
	0x6e, 0x5c, 0xf2, 0x63, 0xf4, 0x6f, 0x12, 0x7f, 0x23, 0x56, 0xe0, 0xe9, 0x4f, 0x8e, 0x1e, 0xbf,
	0x32, 0xd9, 0x8f, 0x7e, 0x65, 0x4a, 0x50, 0x08, 0xf3, 0x0e, 0x5b, 0x58, 0xe4, 0x1c, 0x16, 0xae,
	0xe0, 0xdf, 0x33, 0x90, 0x67, 0xc7, 0xff, 0x33, 0x9b, 0x3d, 0x4c, 0xb0, 0x99, 0xf0, 0x94, 0xbc,
	0x87, 0xc8, 0x7e, 0xb3, 0x40, 0x64, 0x55, 0x01, 0xf9, 0x21, 0x1c, 0xf6, 0x38, 0xc9, 0x61, 0x95,
	0x24, 0xfc, 0xdd, 0xf4, 0x35, 0xe0, 0xb7, 0xba, 0xea, 0xa2, 0x34, 0x44, 0xe6, 0x4a, 0x29, 0x3b,
	0x26, 0xad, 0x11, 0x94, 0x78, 0xa4, 0x15, 0xb9, 0xa0, 0x99, 0xe0, 0x82, 0xd4, 0x46, 0x09, 0x64,
	0xd0, 0xe6, 0x4f, 0x9f, 0xc0, 0x52, 0x87, 0x11, 0x4b, 0x05, 0x1f, 0x81, 0xf1, 0x43, 0x6f, 0xa5,
	0x4e, 0x5e, 0xb0, 0xf6, 0xaf, 0xf8, 0xab, 0xff, 0x29, 0x14, 0x76, 0x67, 0x89, 0xc2, 0x20, 0x8e,
	0x2d, 0x24, 0x7c, 0xc9, 0x49, 0xfd, 0xd3, 0x88, 0xeb, 0x90, 0x13, 0x97, 0xf4, 0xc1, 0x35, 0x76,
	0x60, 0x27, 0x11, 0x77, 0xb5, 0x32, 0xef, 0xbe, 0xe2, 0x2b, 0x19, 0xfe, 0x19, 0xb6, 0x0b, 0xd5,
	0xf0, 0xef, 0xb3, 0xf6, 0xf7, 0xad, 0x6e, 0xf7, 0x5c, 0x3f, 0xd5, 0x3b, 0xd5, 0x35, 0x24, 0xc3,
	0xae, 0x28, 0xd5, 0xf4, 0x5e, 0x07, 0xeb, 0x9d, 0x5e, 0x55, 0x42, 0xb7, 0x60, 0x47, 0xd4, 0x74,
	0x3b, 0xf8, 0x4c, 0x6b, 0x77, 0xaa, 0x19, 0xb4, 0x03, 0x15, 0x51, 0x71, 0x66, 0xb4, 0xab, 0xd9,
	0xa3, 0xff, 0xe4, 0x60, 0x33, 0xbc, 0xf5, 0xcb, 0x3e, 0xea, 0x88, 0x5f, 0x66, 0x6d, 0x8f, 0x98,
	0x94, 0xa0, 0x9b, 0x8b, 0x8f, 0x44, 0xd8, 0xcd, 0xbd, 0x5b, 0x4b, 0x72, 0xde, 0xfc, 0xb5, 0xa4,
	0x9b, 0xe7, 0x63, 0x6b, 0x45, 0x37, 0x27, 0x7c, 0xca, 0xe7, 0x2f, 0x1f, 0xfa, 0x6c, 0xc1, 0x36,
	0x9e, 0xc7, 0xbd, 0xbd, 0x34, 0x55, 0xe4, 0xa9, 0x0b, 0x37, 0x13, 0xaa, 0x2e, 0xf5, 0x88, 0x39,
	0xb2, 0x9d, 0x97, 0x2b, 0xbb, 0x3c, 0x94, 0xd0, 0x6f, 0xc5, 0x2a, 0xc3, 0x1b, 0x47, 0xb7, 0x17,
	0x30, 0x89, 0x01, 0xdc, 0xfb, 0xf9, 0xff, 0xd0, 0x46, 0x79, 0x3e, 0xe4, 0xd4, 0xcc, 0x5b, 0xbf,
	0x2d, 0x0c, 0x37, 0x77, 0x81, 0x44, 0xd1, 0x12, 0x8e, 0xf7, 0xfa, 0x83, 0x71, 0x8f, 0xf8, 0xdd,
	0x07, 0xcd, 0x15, 0x3e, 0xd7, 0x84, 0x26, 0xdc, 0x58, 0x90, 0x46, 0x50, 0x95, 0x87, 0xe4, 0x85,
	0x0b, 0xd7, 0x98, 0xac, 0x59, 0x5e, 0x56, 0xcc, 0x7d, 0xa8, 0xc5, 0x7f, 0xbc, 0xd9, 0x97, 0x7e,
	0x7a, 0xb3, 0x2f, 0xfd, 0xeb, 0xcd, 0xbe, 0xf4, 0x62, 0x9d, 0xfd, 0x27, 0xda, 0x83, 0xff, 0x06,
	0x00, 0x00, 0xff, 0xff, 0x7a, 0xa2, 0x02, 0x7f, 0x82, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RouteSvcClient is the client API for RouteSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouteSvcClient interface {
	// route table APIs
	RouteTableCreate(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error)
	RouteTableUpdate(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error)
	RouteTableGet(ctx context.Context, in *RouteTableGetRequest, opts ...grpc.CallOption) (*RouteTableGetResponse, error)
	RouteTableGetStreaming(ctx context.Context, in *RouteTableGetRequest, opts ...grpc.CallOption) (RouteSvc_RouteTableGetStreamingClient, error)
	RouteTableDelete(ctx context.Context, in *RouteTableDeleteRequest, opts ...grpc.CallOption) (*RouteTableDeleteResponse, error)
	// route APIs
	RouteCreate(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*RouteResponse, error)
	RouteUpdate(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*RouteResponse, error)
	RouteGet(ctx context.Context, in *RouteGetRequest, opts ...grpc.CallOption) (*RouteGetResponse, error)
	RouteDelete(ctx context.Context, in *RouteDeleteRequest, opts ...grpc.CallOption) (*RouteDeleteResponse, error)
}

type routeSvcClient struct {
	cc *grpc.ClientConn
}

func NewRouteSvcClient(cc *grpc.ClientConn) RouteSvcClient {
	return &routeSvcClient{cc}
}

func (c *routeSvcClient) RouteTableCreate(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error) {
	out := new(RouteTableResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteTableCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteTableUpdate(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error) {
	out := new(RouteTableResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteTableUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteTableGet(ctx context.Context, in *RouteTableGetRequest, opts ...grpc.CallOption) (*RouteTableGetResponse, error) {
	out := new(RouteTableGetResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteTableGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteTableGetStreaming(ctx context.Context, in *RouteTableGetRequest, opts ...grpc.CallOption) (RouteSvc_RouteTableGetStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouteSvc_serviceDesc.Streams[0], "/pds.RouteSvc/RouteTableGetStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeSvcRouteTableGetStreamingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouteSvc_RouteTableGetStreamingClient interface {
	Recv() (*RouteTableGetResponse, error)
	grpc.ClientStream
}

type routeSvcRouteTableGetStreamingClient struct {
	grpc.ClientStream
}

func (x *routeSvcRouteTableGetStreamingClient) Recv() (*RouteTableGetResponse, error) {
	m := new(RouteTableGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeSvcClient) RouteTableDelete(ctx context.Context, in *RouteTableDeleteRequest, opts ...grpc.CallOption) (*RouteTableDeleteResponse, error) {
	out := new(RouteTableDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteTableDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteCreate(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*RouteResponse, error) {
	out := new(RouteResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteUpdate(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*RouteResponse, error) {
	out := new(RouteResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteGet(ctx context.Context, in *RouteGetRequest, opts ...grpc.CallOption) (*RouteGetResponse, error) {
	out := new(RouteGetResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeSvcClient) RouteDelete(ctx context.Context, in *RouteDeleteRequest, opts ...grpc.CallOption) (*RouteDeleteResponse, error) {
	out := new(RouteDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.RouteSvc/RouteDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouteSvcServer is the server API for RouteSvc service.
type RouteSvcServer interface {
	// route table APIs
	RouteTableCreate(context.Context, *RouteTableRequest) (*RouteTableResponse, error)
	RouteTableUpdate(context.Context, *RouteTableRequest) (*RouteTableResponse, error)
	RouteTableGet(context.Context, *RouteTableGetRequest) (*RouteTableGetResponse, error)
	RouteTableGetStreaming(*RouteTableGetRequest, RouteSvc_RouteTableGetStreamingServer) error
	RouteTableDelete(context.Context, *RouteTableDeleteRequest) (*RouteTableDeleteResponse, error)
	// route APIs
	RouteCreate(context.Context, *RouteRequest) (*RouteResponse, error)
	RouteUpdate(context.Context, *RouteRequest) (*RouteResponse, error)
	RouteGet(context.Context, *RouteGetRequest) (*RouteGetResponse, error)
	RouteDelete(context.Context, *RouteDeleteRequest) (*RouteDeleteResponse, error)
}

// UnimplementedRouteSvcServer can be embedded to have forward compatible implementations.
type UnimplementedRouteSvcServer struct {
}

func (*UnimplementedRouteSvcServer) RouteTableCreate(ctx context.Context, req *RouteTableRequest) (*RouteTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteTableCreate not implemented")
}
func (*UnimplementedRouteSvcServer) RouteTableUpdate(ctx context.Context, req *RouteTableRequest) (*RouteTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteTableUpdate not implemented")
}
func (*UnimplementedRouteSvcServer) RouteTableGet(ctx context.Context, req *RouteTableGetRequest) (*RouteTableGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteTableGet not implemented")
}
func (*UnimplementedRouteSvcServer) RouteTableGetStreaming(req *RouteTableGetRequest, srv RouteSvc_RouteTableGetStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method RouteTableGetStreaming not implemented")
}
func (*UnimplementedRouteSvcServer) RouteTableDelete(ctx context.Context, req *RouteTableDeleteRequest) (*RouteTableDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteTableDelete not implemented")
}
func (*UnimplementedRouteSvcServer) RouteCreate(ctx context.Context, req *RouteRequest) (*RouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteCreate not implemented")
}
func (*UnimplementedRouteSvcServer) RouteUpdate(ctx context.Context, req *RouteRequest) (*RouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteUpdate not implemented")
}
func (*UnimplementedRouteSvcServer) RouteGet(ctx context.Context, req *RouteGetRequest) (*RouteGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteGet not implemented")
}
func (*UnimplementedRouteSvcServer) RouteDelete(ctx context.Context, req *RouteDeleteRequest) (*RouteDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteDelete not implemented")
}

func RegisterRouteSvcServer(s *grpc.Server, srv RouteSvcServer) {
	s.RegisterService(&_RouteSvc_serviceDesc, srv)
}

func _RouteSvc_RouteTableCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteTableCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteTableCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteTableCreate(ctx, req.(*RouteTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteTableUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteTableUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteTableUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteTableUpdate(ctx, req.(*RouteTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteTableGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteTableGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteTableGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteTableGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteTableGet(ctx, req.(*RouteTableGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteTableGetStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteTableGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteSvcServer).RouteTableGetStreaming(m, &routeSvcRouteTableGetStreamingServer{stream})
}

type RouteSvc_RouteTableGetStreamingServer interface {
	Send(*RouteTableGetResponse) error
	grpc.ServerStream
}

type routeSvcRouteTableGetStreamingServer struct {
	grpc.ServerStream
}

func (x *routeSvcRouteTableGetStreamingServer) Send(m *RouteTableGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RouteSvc_RouteTableDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteTableDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteTableDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteTableDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteTableDelete(ctx, req.(*RouteTableDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteCreate(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteUpdate(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteGet(ctx, req.(*RouteGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteSvc_RouteDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteSvcServer).RouteDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.RouteSvc/RouteDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteSvcServer).RouteDelete(ctx, req.(*RouteDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouteSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.RouteSvc",
	HandlerType: (*RouteSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteTableCreate",
			Handler:    _RouteSvc_RouteTableCreate_Handler,
		},
		{
			MethodName: "RouteTableUpdate",
			Handler:    _RouteSvc_RouteTableUpdate_Handler,
		},
		{
			MethodName: "RouteTableGet",
			Handler:    _RouteSvc_RouteTableGet_Handler,
		},
		{
			MethodName: "RouteTableDelete",
			Handler:    _RouteSvc_RouteTableDelete_Handler,
		},
		{
			MethodName: "RouteCreate",
			Handler:    _RouteSvc_RouteCreate_Handler,
		},
		{
			MethodName: "RouteUpdate",
			Handler:    _RouteSvc_RouteUpdate_Handler,
		},
		{
			MethodName: "RouteGet",
			Handler:    _RouteSvc_RouteGet_Handler,
		},
		{
			MethodName: "RouteDelete",
			Handler:    _RouteSvc_RouteDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RouteTableGetStreaming",
			Handler:       _RouteSvc_RouteTableGetStreaming_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "route.proto",
}

func (m *NATAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NATAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NATAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortReuse {
		i--
		if m.PortReuse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DstNatIP != nil {
		{
			size, err := m.DstNatIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcNatAction != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.SrcNatAction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VPCPeerNhInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPCPeerNhInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VPCPeerNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeterClasses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeterClasses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeterClasses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RxMeterClass != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.RxMeterClass))
		i--
		dAtA[i] = 0x10
	}
	if m.TxMeterClass != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.TxMeterClass))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OverlayNextHopIPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverlayNextHopIPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OverlayNextHopIPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NhMac) > 0 {
		dAtA3 := make([]byte, len(m.NhMac)*10)
		var j2 int
		for _, num := range m.NhMac {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintRoute(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NhIP) > 0 {
		for iNdEx := len(m.NhIP) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NhIP[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DisablePublicNAPT {
		i--
		if m.DisablePublicNAPT {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SvcRewrite != nil {
		{
			size, err := m.SvcRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OverlayMac != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.OverlayMac))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ToS != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ToS))
		i--
		dAtA[i] = 0x70
	}
	if m.MeterAction != nil {
		{
			size := m.MeterAction.Size()
			i -= size
			if _, err := m.MeterAction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NatAction != nil {
		{
			size, err := m.NatAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Nh != nil {
		{
			size := m.Nh.Size()
			i -= size
			if _, err := m.Nh.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if m.ClassPriority != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ClassPriority))
		i--
		dAtA[i] = 0x18
	}
	if m.Class != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.Class))
		i--
		dAtA[i] = 0x10
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteAttrs_OverlayNhIPInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_OverlayNhIPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OverlayNhIPInfo != nil {
		{
			size, err := m.OverlayNhIPInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_NexthopId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_NexthopId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NexthopId != nil {
		i -= len(m.NexthopId)
		copy(dAtA[i:], m.NexthopId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.NexthopId)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_NexthopGroupId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_NexthopGroupId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NexthopGroupId != nil {
		i -= len(m.NexthopGroupId)
		copy(dAtA[i:], m.NexthopGroupId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.NexthopGroupId)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_VPCNh) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_VPCNh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VPCNh != nil {
		{
			size, err := m.VPCNh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_TunnelId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_TunnelId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelId != nil {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_RouteTableId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_RouteTableId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteTableId != nil {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_MeterClasses) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_MeterClasses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MeterClasses != nil {
		{
			size, err := m.MeterClasses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *RouteAttrs_EvalMeterPolicy) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RouteAttrs_EvalMeterPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.EvalMeterPolicy {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	return len(dAtA) - i, nil
}
func (m *RouteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PriorityEn {
		i--
		if m.PriorityEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Af != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.Af))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DNatIdxCount != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.DNatIdxCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DNatBaseIdx != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.DNatBaseIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.RouteTableBaseAddr != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.RouteTableBaseAddr))
		i--
		dAtA[i] = 0x18
	}
	if m.HwId != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintRoute(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA20 := make([]byte, len(m.ApiStatus)*10)
		var j19 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintRoute(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size, err := m.Attrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RouteStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Id[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoute(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NATAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcNatAction != 0 {
		n += 1 + sovRoute(uint64(m.SrcNatAction))
	}
	if m.DstNatIP != nil {
		l = m.DstNatIP.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.PortReuse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPCPeerNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MeterClasses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxMeterClass != 0 {
		n += 1 + sovRoute(uint64(m.TxMeterClass))
	}
	if m.RxMeterClass != 0 {
		n += 1 + sovRoute(uint64(m.RxMeterClass))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OverlayNextHopIPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NhIP) > 0 {
		for _, e := range m.NhIP {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.NhMac) > 0 {
		l = 0
		for _, e := range m.NhMac {
			l += sovRoute(uint64(e))
		}
		n += 1 + sovRoute(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Class != 0 {
		n += 1 + sovRoute(uint64(m.Class))
	}
	if m.ClassPriority != 0 {
		n += 1 + sovRoute(uint64(m.ClassPriority))
	}
	if m.Priority != 0 {
		n += 1 + sovRoute(uint64(m.Priority))
	}
	if m.Nh != nil {
		n += m.Nh.Size()
	}
	if m.NatAction != nil {
		l = m.NatAction.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.MeterAction != nil {
		n += m.MeterAction.Size()
	}
	if m.ToS != 0 {
		n += 1 + sovRoute(uint64(m.ToS))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.OverlayMac != 0 {
		n += 2 + sovRoute(uint64(m.OverlayMac))
	}
	if m.SvcRewrite != nil {
		l = m.SvcRewrite.Size()
		n += 2 + l + sovRoute(uint64(l))
	}
	if m.DisablePublicNAPT {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteAttrs_OverlayNhIPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlayNhIPInfo != nil {
		l = m.OverlayNhIPInfo.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_NexthopId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NexthopId != nil {
		l = len(m.NexthopId)
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_NexthopGroupId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NexthopGroupId != nil {
		l = len(m.NexthopGroupId)
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_VPCNh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VPCNh != nil {
		l = m.VPCNh.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_TunnelId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		l = len(m.TunnelId)
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_RouteTableId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteTableId != nil {
		l = len(m.RouteTableId)
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_MeterClasses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MeterClasses != nil {
		l = m.MeterClasses.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}
func (m *RouteAttrs_EvalMeterPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Af != 0 {
		n += 1 + sovRoute(uint64(m.Af))
	}
	if m.PriorityEn {
		n += 2
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovRoute(uint64(m.PoolId))
	}
	if m.HwId != 0 {
		n += 1 + sovRoute(uint64(m.HwId))
	}
	if m.RouteTableBaseAddr != 0 {
		n += 1 + sovRoute(uint64(m.RouteTableBaseAddr))
	}
	if m.DNatBaseIdx != 0 {
		n += 1 + sovRoute(uint64(m.DNatBaseIdx))
	}
	if m.DNatIdxCount != 0 {
		n += 1 + sovRoute(uint64(m.DNatIdxCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRoute(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRoute(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteTableDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovRoute(uint64(e))
		}
		n += 1 + sovRoute(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Attrs != nil {
		l = m.Attrs.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRoute(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, e := range m.Id {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRoute(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRoute(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRoute(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NATAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NATAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NATAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= NatAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatIP == nil {
				m.DstNatIP = &IPAddress{}
			}
			if err := m.DstNatIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortReuse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortReuse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPCPeerNhInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPCPeerNhInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPCPeerNhInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.RouteTableId == nil {
				m.RouteTableId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeterClasses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeterClasses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeterClasses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMeterClass", wireType)
			}
			m.TxMeterClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxMeterClass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMeterClass", wireType)
			}
			m.RxMeterClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxMeterClass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverlayNextHopIPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverlayNextHopIPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverlayNextHopIPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NhIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NhIP = append(m.NhIP, &IPAddress{})
			if err := m.NhIP[len(m.NhIP)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NhMac = append(m.NhMac, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoute
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRoute
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NhMac) == 0 {
					m.NhMac = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NhMac = append(m.NhMac, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NhMac", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= RouteClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassPriority", wireType)
			}
			m.ClassPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayNhIPInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OverlayNextHopIPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nh = &RouteAttrs_OverlayNhIPInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &RouteAttrs_NexthopId{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopGroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &RouteAttrs_NexthopGroupId{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCNh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VPCPeerNhInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nh = &RouteAttrs_VPCNh{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &RouteAttrs_TunnelId{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Nh = &RouteAttrs_RouteTableId{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatAction == nil {
				m.NatAction = &NATAction{}
			}
			if err := m.NatAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MeterClasses{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeterAction = &RouteAttrs_MeterClasses{v}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvalMeterPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MeterAction = &RouteAttrs_EvalMeterPolicy{b}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToS", wireType)
			}
			m.ToS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayMac", wireType)
			}
			m.OverlayMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlayMac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvcRewrite == nil {
				m.SvcRewrite = &SvcRewriteInfo{}
			}
			if err := m.SvcRewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePublicNAPT", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePublicNAPT = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &RouteAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Af", wireType)
			}
			m.Af = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Af |= IPAF(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PriorityEn = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteInfo{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableBaseAddr", wireType)
			}
			m.RouteTableBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteTableBaseAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNatBaseIdx", wireType)
			}
			m.DNatBaseIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DNatBaseIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNatIdxCount", wireType)
			}
			m.DNatIdxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DNatIdxCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &RouteTableSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &RouteTableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &RouteTableStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RouteTableSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RouteTableStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RouteTable{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoute
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRoute
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.RouteTableId == nil {
				m.RouteTableId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId[:0], dAtA[iNdEx:postIndex]...)
			if m.RouteTableId == nil {
				m.RouteTableId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = &RouteAttrs{}
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &RouteSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &RouteStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &RouteStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &RouteSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &RouteStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, &RouteId{})
			if err := m.Id[len(m.Id)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Route{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &RouteId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRoute
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)
