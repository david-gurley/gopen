// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nh.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NexthopType int32

const (
	NexthopType_NEXTHOP_TYPE_NONE     NexthopType = 0
	NexthopType_NEXTHOP_TYPE_IP       NexthopType = 1
	NexthopType_NEXTHOP_TYPE_UNDERLAY NexthopType = 2
	NexthopType_NEXTHOP_TYPE_OVERLAY  NexthopType = 3
)

var NexthopType_name = map[int32]string{
	0: "NEXTHOP_TYPE_NONE",
	1: "NEXTHOP_TYPE_IP",
	2: "NEXTHOP_TYPE_UNDERLAY",
	3: "NEXTHOP_TYPE_OVERLAY",
}

var NexthopType_value = map[string]int32{
	"NEXTHOP_TYPE_NONE":     0,
	"NEXTHOP_TYPE_IP":       1,
	"NEXTHOP_TYPE_UNDERLAY": 2,
	"NEXTHOP_TYPE_OVERLAY":  3,
}

func (x NexthopType) String() string {
	return proto.EnumName(NexthopType_name, int32(x))
}

func (NexthopType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{0}
}

// type of the nexthop group
type NhGroupType int32

const (
	NhGroupType_NEXTHOP_GROUP_TYPE_NONE NhGroupType = 0
	// ECMP for overlay routes pointing to VTEPs
	NhGroupType_NEXTHOP_GROUP_TYPE_OVERLAY_ECMP NhGroupType = 1
	// ECMP for underlay VTEPs pointing to nexthops
	NhGroupType_NEXTHOP_GROUP_TYPE_UNDERLAY_ECMP NhGroupType = 2
)

var NhGroupType_name = map[int32]string{
	0: "NEXTHOP_GROUP_TYPE_NONE",
	1: "NEXTHOP_GROUP_TYPE_OVERLAY_ECMP",
	2: "NEXTHOP_GROUP_TYPE_UNDERLAY_ECMP",
}

var NhGroupType_value = map[string]int32{
	"NEXTHOP_GROUP_TYPE_NONE":          0,
	"NEXTHOP_GROUP_TYPE_OVERLAY_ECMP":  1,
	"NEXTHOP_GROUP_TYPE_UNDERLAY_ECMP": 2,
}

func (x NhGroupType) String() string {
	return proto.EnumName(NhGroupType_name, int32(x))
}

func (NhGroupType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{1}
}

// IP nexthop information
type IPNhSpec struct {
	// egress VRF id
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	// nexthop's IP address
	IP *IPAddress `protobuf:"bytes,2,opt,name=IP,proto3" json:"IP,omitempty"`
	// egress vlan
	Vlan uint32 `protobuf:"varint,3,opt,name=Vlan,proto3" json:"Vlan,omitempty"`
	// optional mac address
	Mac                  uint64   `protobuf:"varint,4,opt,name=Mac,proto3" json:"Mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPNhSpec) Reset()         { *m = IPNhSpec{} }
func (m *IPNhSpec) String() string { return proto.CompactTextString(m) }
func (*IPNhSpec) ProtoMessage()    {}
func (*IPNhSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{0}
}
func (m *IPNhSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPNhSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPNhSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPNhSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPNhSpec.Merge(m, src)
}
func (m *IPNhSpec) XXX_Size() int {
	return m.Size()
}
func (m *IPNhSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IPNhSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IPNhSpec proto.InternalMessageInfo

func (m *IPNhSpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *IPNhSpec) GetIP() *IPAddress {
	if m != nil {
		return m.IP
	}
	return nil
}

func (m *IPNhSpec) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *IPNhSpec) GetMac() uint64 {
	if m != nil {
		return m.Mac
	}
	return 0
}

// Underlay nexthop information
type UnderlayNhSpec struct {
	// L3 interface of this nexthop (outer SMAC, vlan tag and outgoing port
	// are picked from this L3 interface)
	L3Interface []byte `protobuf:"bytes,1,opt,name=L3Interface,proto3" json:"L3Interface,omitempty" meta:mandatory`
	// UnderlayNexthopMAC is the outer DMAC in case of VxLAN fabric
	UnderlayMAC          uint64   `protobuf:"varint,2,opt,name=UnderlayMAC,proto3" json:"UnderlayMAC,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnderlayNhSpec) Reset()         { *m = UnderlayNhSpec{} }
func (m *UnderlayNhSpec) String() string { return proto.CompactTextString(m) }
func (*UnderlayNhSpec) ProtoMessage()    {}
func (*UnderlayNhSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{1}
}
func (m *UnderlayNhSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnderlayNhSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnderlayNhSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnderlayNhSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnderlayNhSpec.Merge(m, src)
}
func (m *UnderlayNhSpec) XXX_Size() int {
	return m.Size()
}
func (m *UnderlayNhSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UnderlayNhSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UnderlayNhSpec proto.InternalMessageInfo

func (m *UnderlayNhSpec) GetL3Interface() []byte {
	if m != nil {
		return m.L3Interface
	}
	return nil
}

func (m *UnderlayNhSpec) GetUnderlayMAC() uint64 {
	if m != nil {
		return m.UnderlayMAC
	}
	return 0
}

// Overlay nexthop information
type OverlayNhSpec struct {
	TunnelId             []byte   `protobuf:"bytes,1,opt,name=TunnelId,proto3" json:"TunnelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OverlayNhSpec) Reset()         { *m = OverlayNhSpec{} }
func (m *OverlayNhSpec) String() string { return proto.CompactTextString(m) }
func (*OverlayNhSpec) ProtoMessage()    {}
func (*OverlayNhSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{2}
}
func (m *OverlayNhSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OverlayNhSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OverlayNhSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OverlayNhSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OverlayNhSpec.Merge(m, src)
}
func (m *OverlayNhSpec) XXX_Size() int {
	return m.Size()
}
func (m *OverlayNhSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OverlayNhSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OverlayNhSpec proto.InternalMessageInfo

func (m *OverlayNhSpec) GetTunnelId() []byte {
	if m != nil {
		return m.TunnelId
	}
	return nil
}

// nexthop specification
type NexthopSpec struct {
	// unique nexthop id
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// nexthop can be one of different types
	//
	// Types that are valid to be assigned to Nhinfo:
	//	*NexthopSpec_OverlayNhInfo
	//	*NexthopSpec_UnderlayNhInfo
	//	*NexthopSpec_IPNhInfo
	Nhinfo               isNexthopSpec_Nhinfo `protobuf_oneof:"nhinfo"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NexthopSpec) Reset()         { *m = NexthopSpec{} }
func (m *NexthopSpec) String() string { return proto.CompactTextString(m) }
func (*NexthopSpec) ProtoMessage()    {}
func (*NexthopSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{3}
}
func (m *NexthopSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopSpec.Merge(m, src)
}
func (m *NexthopSpec) XXX_Size() int {
	return m.Size()
}
func (m *NexthopSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopSpec proto.InternalMessageInfo

type isNexthopSpec_Nhinfo interface {
	isNexthopSpec_Nhinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexthopSpec_OverlayNhInfo struct {
	OverlayNhInfo *OverlayNhSpec `protobuf:"bytes,2,opt,name=OverlayNhInfo,proto3,oneof"`
}
type NexthopSpec_UnderlayNhInfo struct {
	UnderlayNhInfo *UnderlayNhSpec `protobuf:"bytes,3,opt,name=UnderlayNhInfo,proto3,oneof"`
}
type NexthopSpec_IPNhInfo struct {
	IPNhInfo *IPNhSpec `protobuf:"bytes,4,opt,name=IPNhInfo,proto3,oneof"`
}

func (*NexthopSpec_OverlayNhInfo) isNexthopSpec_Nhinfo()  {}
func (*NexthopSpec_UnderlayNhInfo) isNexthopSpec_Nhinfo() {}
func (*NexthopSpec_IPNhInfo) isNexthopSpec_Nhinfo()       {}

func (m *NexthopSpec) GetNhinfo() isNexthopSpec_Nhinfo {
	if m != nil {
		return m.Nhinfo
	}
	return nil
}

func (m *NexthopSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NexthopSpec) GetOverlayNhInfo() *OverlayNhSpec {
	if x, ok := m.GetNhinfo().(*NexthopSpec_OverlayNhInfo); ok {
		return x.OverlayNhInfo
	}
	return nil
}

func (m *NexthopSpec) GetUnderlayNhInfo() *UnderlayNhSpec {
	if x, ok := m.GetNhinfo().(*NexthopSpec_UnderlayNhInfo); ok {
		return x.UnderlayNhInfo
	}
	return nil
}

func (m *NexthopSpec) GetIPNhInfo() *IPNhSpec {
	if x, ok := m.GetNhinfo().(*NexthopSpec_IPNhInfo); ok {
		return x.IPNhInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexthopSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexthopSpec_OverlayNhInfo)(nil),
		(*NexthopSpec_UnderlayNhInfo)(nil),
		(*NexthopSpec_IPNhInfo)(nil),
	}
}

type UnderlayNhStatus struct {
	Port                 uint32   `protobuf:"varint,1,opt,name=Port,proto3" json:"Port,omitempty"`
	Vlan                 uint32   `protobuf:"varint,2,opt,name=Vlan,proto3" json:"Vlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnderlayNhStatus) Reset()         { *m = UnderlayNhStatus{} }
func (m *UnderlayNhStatus) String() string { return proto.CompactTextString(m) }
func (*UnderlayNhStatus) ProtoMessage()    {}
func (*UnderlayNhStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{4}
}
func (m *UnderlayNhStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnderlayNhStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnderlayNhStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnderlayNhStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnderlayNhStatus.Merge(m, src)
}
func (m *UnderlayNhStatus) XXX_Size() int {
	return m.Size()
}
func (m *UnderlayNhStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UnderlayNhStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UnderlayNhStatus proto.InternalMessageInfo

func (m *UnderlayNhStatus) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *UnderlayNhStatus) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

type OverlayNhStatus struct {
	TunnelIP             *IPAddress `protobuf:"bytes,1,opt,name=TunnelIP,proto3" json:"TunnelIP,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *OverlayNhStatus) Reset()         { *m = OverlayNhStatus{} }
func (m *OverlayNhStatus) String() string { return proto.CompactTextString(m) }
func (*OverlayNhStatus) ProtoMessage()    {}
func (*OverlayNhStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{5}
}
func (m *OverlayNhStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OverlayNhStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OverlayNhStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OverlayNhStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OverlayNhStatus.Merge(m, src)
}
func (m *OverlayNhStatus) XXX_Size() int {
	return m.Size()
}
func (m *OverlayNhStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OverlayNhStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OverlayNhStatus proto.InternalMessageInfo

func (m *OverlayNhStatus) GetTunnelIP() *IPAddress {
	if m != nil {
		return m.TunnelIP
	}
	return nil
}

// operational status of nexthop, if any
type NexthopStatus struct {
	// nexthop hw id
	HwId uint32 `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	// Types that are valid to be assigned to Nhinfo:
	//	*NexthopStatus_UnderlayNhInfo
	//	*NexthopStatus_OverlayNhInfo
	Nhinfo               isNexthopStatus_Nhinfo `protobuf_oneof:"nhinfo"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *NexthopStatus) Reset()         { *m = NexthopStatus{} }
func (m *NexthopStatus) String() string { return proto.CompactTextString(m) }
func (*NexthopStatus) ProtoMessage()    {}
func (*NexthopStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{6}
}
func (m *NexthopStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopStatus.Merge(m, src)
}
func (m *NexthopStatus) XXX_Size() int {
	return m.Size()
}
func (m *NexthopStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopStatus proto.InternalMessageInfo

type isNexthopStatus_Nhinfo interface {
	isNexthopStatus_Nhinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexthopStatus_UnderlayNhInfo struct {
	UnderlayNhInfo *UnderlayNhStatus `protobuf:"bytes,2,opt,name=UnderlayNhInfo,proto3,oneof"`
}
type NexthopStatus_OverlayNhInfo struct {
	OverlayNhInfo *OverlayNhStatus `protobuf:"bytes,3,opt,name=OverlayNhInfo,proto3,oneof"`
}

func (*NexthopStatus_UnderlayNhInfo) isNexthopStatus_Nhinfo() {}
func (*NexthopStatus_OverlayNhInfo) isNexthopStatus_Nhinfo()  {}

func (m *NexthopStatus) GetNhinfo() isNexthopStatus_Nhinfo {
	if m != nil {
		return m.Nhinfo
	}
	return nil
}

func (m *NexthopStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *NexthopStatus) GetUnderlayNhInfo() *UnderlayNhStatus {
	if x, ok := m.GetNhinfo().(*NexthopStatus_UnderlayNhInfo); ok {
		return x.UnderlayNhInfo
	}
	return nil
}

func (m *NexthopStatus) GetOverlayNhInfo() *OverlayNhStatus {
	if x, ok := m.GetNhinfo().(*NexthopStatus_OverlayNhInfo); ok {
		return x.OverlayNhInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexthopStatus) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexthopStatus_UnderlayNhInfo)(nil),
		(*NexthopStatus_OverlayNhInfo)(nil),
	}
}

// stats of a nexthop, if any
type NexthopStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NexthopStats) Reset()         { *m = NexthopStats{} }
func (m *NexthopStats) String() string { return proto.CompactTextString(m) }
func (*NexthopStats) ProtoMessage()    {}
func (*NexthopStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{7}
}
func (m *NexthopStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopStats.Merge(m, src)
}
func (m *NexthopStats) XXX_Size() int {
	return m.Size()
}
func (m *NexthopStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopStats.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopStats proto.InternalMessageInfo

// nexthop object
type Nexthop struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *NexthopSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *NexthopStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *NexthopStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Nexthop) Reset()         { *m = Nexthop{} }
func (m *Nexthop) String() string { return proto.CompactTextString(m) }
func (*Nexthop) ProtoMessage()    {}
func (*Nexthop) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{8}
}
func (m *Nexthop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Nexthop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Nexthop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Nexthop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nexthop.Merge(m, src)
}
func (m *Nexthop) XXX_Size() int {
	return m.Size()
}
func (m *Nexthop) XXX_DiscardUnknown() {
	xxx_messageInfo_Nexthop.DiscardUnknown(m)
}

var xxx_messageInfo_Nexthop proto.InternalMessageInfo

func (m *Nexthop) GetSpec() *NexthopSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Nexthop) GetStatus() *NexthopStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Nexthop) GetStats() *NexthopStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// nexthop create and update request
type NexthopRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched create or update requests
	Request              []*NexthopSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NexthopRequest) Reset()         { *m = NexthopRequest{} }
func (m *NexthopRequest) String() string { return proto.CompactTextString(m) }
func (*NexthopRequest) ProtoMessage()    {}
func (*NexthopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{9}
}
func (m *NexthopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopRequest.Merge(m, src)
}
func (m *NexthopRequest) XXX_Size() int {
	return m.Size()
}
func (m *NexthopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopRequest proto.InternalMessageInfo

func (m *NexthopRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NexthopRequest) GetRequest() []*NexthopSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// nexthop create and update response
type NexthopResponse struct {
	// API status code for create & update operations
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// response containing operational status of the objects created/updated
	Response             []*NexthopStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NexthopResponse) Reset()         { *m = NexthopResponse{} }
func (m *NexthopResponse) String() string { return proto.CompactTextString(m) }
func (*NexthopResponse) ProtoMessage()    {}
func (*NexthopResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{10}
}
func (m *NexthopResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopResponse.Merge(m, src)
}
func (m *NexthopResponse) XXX_Size() int {
	return m.Size()
}
func (m *NexthopResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopResponse proto.InternalMessageInfo

func (m *NexthopResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NexthopResponse) GetResponse() []*NexthopStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// nexthop get request
type NexthopGetRequest struct {
	// Types that are valid to be assigned to Gettype:
	//	*NexthopGetRequest_Type
	//	*NexthopGetRequest_Id
	Gettype              isNexthopGetRequest_Gettype `protobuf_oneof:"gettype"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *NexthopGetRequest) Reset()         { *m = NexthopGetRequest{} }
func (m *NexthopGetRequest) String() string { return proto.CompactTextString(m) }
func (*NexthopGetRequest) ProtoMessage()    {}
func (*NexthopGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{11}
}
func (m *NexthopGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopGetRequest.Merge(m, src)
}
func (m *NexthopGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *NexthopGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopGetRequest proto.InternalMessageInfo

type isNexthopGetRequest_Gettype interface {
	isNexthopGetRequest_Gettype()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NexthopGetRequest_Type struct {
	Type NexthopType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.NexthopType,oneof"`
}
type NexthopGetRequest_Id struct {
	Id []byte `protobuf:"bytes,2,opt,name=Id,proto3,oneof"`
}

func (*NexthopGetRequest_Type) isNexthopGetRequest_Gettype() {}
func (*NexthopGetRequest_Id) isNexthopGetRequest_Gettype()   {}

func (m *NexthopGetRequest) GetGettype() isNexthopGetRequest_Gettype {
	if m != nil {
		return m.Gettype
	}
	return nil
}

func (m *NexthopGetRequest) GetType() NexthopType {
	if x, ok := m.GetGettype().(*NexthopGetRequest_Type); ok {
		return x.Type
	}
	return NexthopType_NEXTHOP_TYPE_NONE
}

func (m *NexthopGetRequest) GetId() []byte {
	if x, ok := m.GetGettype().(*NexthopGetRequest_Id); ok {
		return x.Id
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NexthopGetRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NexthopGetRequest_Type)(nil),
		(*NexthopGetRequest_Id)(nil),
	}
}

// nexthop get response
type NexthopGetResponse struct {
	// API status code for get operation
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// list of nexthops
	Response             []*Nexthop `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NexthopGetResponse) Reset()         { *m = NexthopGetResponse{} }
func (m *NexthopGetResponse) String() string { return proto.CompactTextString(m) }
func (*NexthopGetResponse) ProtoMessage()    {}
func (*NexthopGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{12}
}
func (m *NexthopGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopGetResponse.Merge(m, src)
}
func (m *NexthopGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *NexthopGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopGetResponse proto.InternalMessageInfo

func (m *NexthopGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NexthopGetResponse) GetResponse() []*Nexthop {
	if m != nil {
		return m.Response
	}
	return nil
}

// nexthop delete request
type NexthopDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// list of nexthops to delete
	Id                   [][]byte `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NexthopDeleteRequest) Reset()         { *m = NexthopDeleteRequest{} }
func (m *NexthopDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NexthopDeleteRequest) ProtoMessage()    {}
func (*NexthopDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{13}
}
func (m *NexthopDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopDeleteRequest.Merge(m, src)
}
func (m *NexthopDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NexthopDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopDeleteRequest proto.InternalMessageInfo

func (m *NexthopDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NexthopDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// nexthop delete response
type NexthopDeleteResponse struct {
	// API status code for delete operation
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NexthopDeleteResponse) Reset()         { *m = NexthopDeleteResponse{} }
func (m *NexthopDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NexthopDeleteResponse) ProtoMessage()    {}
func (*NexthopDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{14}
}
func (m *NexthopDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NexthopDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NexthopDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NexthopDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NexthopDeleteResponse.Merge(m, src)
}
func (m *NexthopDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NexthopDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NexthopDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NexthopDeleteResponse proto.InternalMessageInfo

func (m *NexthopDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// nexthop group specification - a nextgroup consists of bunch of nexthops
type NhGroupSpec struct {
	// unique nexthop group id
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// type of the nexthop
	Type NhGroupType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.NhGroupType" json:"Type,omitempty" meta:mandatory`
	// zero or more member nexthops or nexthop groups
	Members              []*NexthopSpec `protobuf:"bytes,3,rep,name=Members,proto3" json:"Members,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NhGroupSpec) Reset()         { *m = NhGroupSpec{} }
func (m *NhGroupSpec) String() string { return proto.CompactTextString(m) }
func (*NhGroupSpec) ProtoMessage()    {}
func (*NhGroupSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{15}
}
func (m *NhGroupSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupSpec.Merge(m, src)
}
func (m *NhGroupSpec) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupSpec proto.InternalMessageInfo

func (m *NhGroupSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NhGroupSpec) GetType() NhGroupType {
	if m != nil {
		return m.Type
	}
	return NhGroupType_NEXTHOP_GROUP_TYPE_NONE
}

func (m *NhGroupSpec) GetMembers() []*NexthopSpec {
	if m != nil {
		return m.Members
	}
	return nil
}

// operational status of nexthop group, if any
type NhGroupStatus struct {
	// nexthop group hw id
	HwId                 uint32           `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	Members              []*NexthopStatus `protobuf:"bytes,2,rep,name=Members,proto3" json:"Members,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NhGroupStatus) Reset()         { *m = NhGroupStatus{} }
func (m *NhGroupStatus) String() string { return proto.CompactTextString(m) }
func (*NhGroupStatus) ProtoMessage()    {}
func (*NhGroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{16}
}
func (m *NhGroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupStatus.Merge(m, src)
}
func (m *NhGroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupStatus proto.InternalMessageInfo

func (m *NhGroupStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *NhGroupStatus) GetMembers() []*NexthopStatus {
	if m != nil {
		return m.Members
	}
	return nil
}

// stats of a nexthop group, if any
type NhGroupStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NhGroupStats) Reset()         { *m = NhGroupStats{} }
func (m *NhGroupStats) String() string { return proto.CompactTextString(m) }
func (*NhGroupStats) ProtoMessage()    {}
func (*NhGroupStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{17}
}
func (m *NhGroupStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupStats.Merge(m, src)
}
func (m *NhGroupStats) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupStats.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupStats proto.InternalMessageInfo

// nexthop group object
type NhGroup struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *NhGroupSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *NhGroupStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *NhGroupStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NhGroup) Reset()         { *m = NhGroup{} }
func (m *NhGroup) String() string { return proto.CompactTextString(m) }
func (*NhGroup) ProtoMessage()    {}
func (*NhGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{18}
}
func (m *NhGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroup.Merge(m, src)
}
func (m *NhGroup) XXX_Size() int {
	return m.Size()
}
func (m *NhGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroup.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroup proto.InternalMessageInfo

func (m *NhGroup) GetSpec() *NhGroupSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NhGroup) GetStatus() *NhGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NhGroup) GetStats() *NhGroupStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// nexthop group create and update request
type NhGroupRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched create or update requests
	Request              []*NhGroupSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NhGroupRequest) Reset()         { *m = NhGroupRequest{} }
func (m *NhGroupRequest) String() string { return proto.CompactTextString(m) }
func (*NhGroupRequest) ProtoMessage()    {}
func (*NhGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{19}
}
func (m *NhGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupRequest.Merge(m, src)
}
func (m *NhGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupRequest proto.InternalMessageInfo

func (m *NhGroupRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NhGroupRequest) GetRequest() []*NhGroupSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// nexthop group create and update response
type NhGroupResponse struct {
	// API status code for create & update operations
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// response containing operational status of the objects created/updated
	Response             []*NhGroupStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NhGroupResponse) Reset()         { *m = NhGroupResponse{} }
func (m *NhGroupResponse) String() string { return proto.CompactTextString(m) }
func (*NhGroupResponse) ProtoMessage()    {}
func (*NhGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{20}
}
func (m *NhGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupResponse.Merge(m, src)
}
func (m *NhGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupResponse proto.InternalMessageInfo

func (m *NhGroupResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NhGroupResponse) GetResponse() []*NhGroupStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// nexthop group get request
type NhGroupGetRequest struct {
	// Types that are valid to be assigned to Gettype:
	//	*NhGroupGetRequest_Type
	//	*NhGroupGetRequest_Id
	Gettype              isNhGroupGetRequest_Gettype `protobuf_oneof:"gettype"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *NhGroupGetRequest) Reset()         { *m = NhGroupGetRequest{} }
func (m *NhGroupGetRequest) String() string { return proto.CompactTextString(m) }
func (*NhGroupGetRequest) ProtoMessage()    {}
func (*NhGroupGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{21}
}
func (m *NhGroupGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupGetRequest.Merge(m, src)
}
func (m *NhGroupGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupGetRequest proto.InternalMessageInfo

type isNhGroupGetRequest_Gettype interface {
	isNhGroupGetRequest_Gettype()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NhGroupGetRequest_Type struct {
	Type NhGroupType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.NhGroupType,oneof"`
}
type NhGroupGetRequest_Id struct {
	Id []byte `protobuf:"bytes,2,opt,name=Id,proto3,oneof"`
}

func (*NhGroupGetRequest_Type) isNhGroupGetRequest_Gettype() {}
func (*NhGroupGetRequest_Id) isNhGroupGetRequest_Gettype()   {}

func (m *NhGroupGetRequest) GetGettype() isNhGroupGetRequest_Gettype {
	if m != nil {
		return m.Gettype
	}
	return nil
}

func (m *NhGroupGetRequest) GetType() NhGroupType {
	if x, ok := m.GetGettype().(*NhGroupGetRequest_Type); ok {
		return x.Type
	}
	return NhGroupType_NEXTHOP_GROUP_TYPE_NONE
}

func (m *NhGroupGetRequest) GetId() []byte {
	if x, ok := m.GetGettype().(*NhGroupGetRequest_Id); ok {
		return x.Id
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NhGroupGetRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NhGroupGetRequest_Type)(nil),
		(*NhGroupGetRequest_Id)(nil),
	}
}

// nexthop group get response
type NhGroupGetResponse struct {
	// API status code for get operation
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// list of nexthop groups
	Response             []*NhGroup `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NhGroupGetResponse) Reset()         { *m = NhGroupGetResponse{} }
func (m *NhGroupGetResponse) String() string { return proto.CompactTextString(m) }
func (*NhGroupGetResponse) ProtoMessage()    {}
func (*NhGroupGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{22}
}
func (m *NhGroupGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupGetResponse.Merge(m, src)
}
func (m *NhGroupGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupGetResponse proto.InternalMessageInfo

func (m *NhGroupGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NhGroupGetResponse) GetResponse() []*NhGroup {
	if m != nil {
		return m.Response
	}
	return nil
}

// nexthop group delete request
type NhGroupDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// list of nexthop groups to delete
	Id                   [][]byte `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NhGroupDeleteRequest) Reset()         { *m = NhGroupDeleteRequest{} }
func (m *NhGroupDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NhGroupDeleteRequest) ProtoMessage()    {}
func (*NhGroupDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{23}
}
func (m *NhGroupDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupDeleteRequest.Merge(m, src)
}
func (m *NhGroupDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupDeleteRequest proto.InternalMessageInfo

func (m *NhGroupDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NhGroupDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// nexthop group delete response
type NhGroupDeleteResponse struct {
	// API status code for delete operation
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NhGroupDeleteResponse) Reset()         { *m = NhGroupDeleteResponse{} }
func (m *NhGroupDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NhGroupDeleteResponse) ProtoMessage()    {}
func (*NhGroupDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aef971daa272fc64, []int{24}
}
func (m *NhGroupDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NhGroupDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NhGroupDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NhGroupDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NhGroupDeleteResponse.Merge(m, src)
}
func (m *NhGroupDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NhGroupDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NhGroupDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NhGroupDeleteResponse proto.InternalMessageInfo

func (m *NhGroupDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.NexthopType", NexthopType_name, NexthopType_value)
	proto.RegisterEnum("pds.NhGroupType", NhGroupType_name, NhGroupType_value)
	proto.RegisterType((*IPNhSpec)(nil), "pds.IPNhSpec")
	proto.RegisterType((*UnderlayNhSpec)(nil), "pds.UnderlayNhSpec")
	proto.RegisterType((*OverlayNhSpec)(nil), "pds.OverlayNhSpec")
	proto.RegisterType((*NexthopSpec)(nil), "pds.NexthopSpec")
	proto.RegisterType((*UnderlayNhStatus)(nil), "pds.UnderlayNhStatus")
	proto.RegisterType((*OverlayNhStatus)(nil), "pds.OverlayNhStatus")
	proto.RegisterType((*NexthopStatus)(nil), "pds.NexthopStatus")
	proto.RegisterType((*NexthopStats)(nil), "pds.NexthopStats")
	proto.RegisterType((*Nexthop)(nil), "pds.Nexthop")
	proto.RegisterType((*NexthopRequest)(nil), "pds.NexthopRequest")
	proto.RegisterType((*NexthopResponse)(nil), "pds.NexthopResponse")
	proto.RegisterType((*NexthopGetRequest)(nil), "pds.NexthopGetRequest")
	proto.RegisterType((*NexthopGetResponse)(nil), "pds.NexthopGetResponse")
	proto.RegisterType((*NexthopDeleteRequest)(nil), "pds.NexthopDeleteRequest")
	proto.RegisterType((*NexthopDeleteResponse)(nil), "pds.NexthopDeleteResponse")
	proto.RegisterType((*NhGroupSpec)(nil), "pds.NhGroupSpec")
	proto.RegisterType((*NhGroupStatus)(nil), "pds.NhGroupStatus")
	proto.RegisterType((*NhGroupStats)(nil), "pds.NhGroupStats")
	proto.RegisterType((*NhGroup)(nil), "pds.NhGroup")
	proto.RegisterType((*NhGroupRequest)(nil), "pds.NhGroupRequest")
	proto.RegisterType((*NhGroupResponse)(nil), "pds.NhGroupResponse")
	proto.RegisterType((*NhGroupGetRequest)(nil), "pds.NhGroupGetRequest")
	proto.RegisterType((*NhGroupGetResponse)(nil), "pds.NhGroupGetResponse")
	proto.RegisterType((*NhGroupDeleteRequest)(nil), "pds.NhGroupDeleteRequest")
	proto.RegisterType((*NhGroupDeleteResponse)(nil), "pds.NhGroupDeleteResponse")
}

func init() { proto.RegisterFile("nh.proto", fileDescriptor_aef971daa272fc64) }

var fileDescriptor_aef971daa272fc64 = []byte{
	// 1142 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
	0x17, 0x15, 0x29, 0xd9, 0x52, 0xae, 0xf5, 0xe7, 0xb1, 0x9c, 0x28, 0xfa, 0x3e, 0x58, 0x02, 0x5b,
	0x14, 0x82, 0x23, 0xa8, 0x40, 0xd2, 0x45, 0xe0, 0xa6, 0x70, 0x4d, 0xc7, 0xb0, 0x04, 0xc4, 0x92,
	0xca, 0xd8, 0x46, 0xb2, 0x32, 0x68, 0x69, 0x6c, 0xa9, 0x90, 0x48, 0x46, 0x1c, 0xa5, 0x31, 0xd0,
	0xd7, 0x28, 0xfa, 0x12, 0x7d, 0x89, 0xee, 0xba, 0xcc, 0x13, 0x08, 0x85, 0x97, 0x06, 0xba, 0xc9,
	0x13, 0x14, 0xf3, 0x43, 0x72, 0x46, 0xa6, 0xe1, 0xc4, 0xf0, 0xa2, 0x1b, 0x83, 0xbc, 0x73, 0xce,
	0xbd, 0x73, 0xcf, 0x9d, 0x39, 0x94, 0x21, 0xe3, 0x0c, 0x9b, 0xde, 0xd4, 0x25, 0x2e, 0x4a, 0x7a,
	0x03, 0xbf, 0x02, 0xe7, 0xee, 0xb9, 0xcb, 0x03, 0x95, 0xc2, 0x04, 0x13, 0xfb, 0x5b, 0xfa, 0x47,
	0x04, 0x56, 0xc8, 0x85, 0x87, 0x7d, 0xfe, 0x62, 0x0c, 0x21, 0xd3, 0xee, 0x75, 0x86, 0xaf, 0x3d,
	0xdc, 0x47, 0x25, 0x58, 0x3a, 0xee, 0xed, 0xb6, 0x07, 0x65, 0xad, 0xa6, 0xd5, 0xb3, 0x16, 0x7f,
	0x41, 0x35, 0xd0, 0xdb, 0xbd, 0xb2, 0x5e, 0xd3, 0xea, 0x2b, 0x4f, 0x8b, 0x4d, 0xce, 0x6d, 0xf7,
	0x76, 0x06, 0x83, 0x29, 0xf6, 0x7d, 0x4b, 0x6f, 0xf7, 0x10, 0x82, 0xd4, 0xf1, 0xd8, 0x76, 0xca,
	0xc9, 0x9a, 0x56, 0xcf, 0x59, 0xec, 0x19, 0x15, 0x21, 0x79, 0x60, 0xf7, 0xcb, 0xa9, 0x9a, 0x56,
	0x4f, 0x59, 0xf4, 0xd1, 0xf8, 0x15, 0xf2, 0x47, 0xce, 0x00, 0x4f, 0xc7, 0xf6, 0x85, 0xa8, 0xf7,
	0x1d, 0xac, 0xbc, 0x7a, 0xd6, 0x76, 0x08, 0x9e, 0x9e, 0xd9, 0x7d, 0xcc, 0xab, 0x9a, 0xe8, 0xd3,
	0xbc, 0x9a, 0xa7, 0xbb, 0xdd, 0x9a, 0xd8, 0xce, 0xc0, 0x26, 0xee, 0xf4, 0xc2, 0x92, 0x61, 0x94,
	0x15, 0xe4, 0x39, 0xd8, 0xd9, 0x65, 0x1b, 0x4b, 0xc5, 0xb3, 0x24, 0x98, 0xf1, 0x04, 0x72, 0xdd,
	0xf7, 0x72, 0xf1, 0x0a, 0x64, 0x0e, 0x67, 0x8e, 0x83, 0xc7, 0x61, 0xbf, 0xe1, 0xbb, 0xf1, 0x8f,
	0x06, 0x2b, 0x1d, 0xfc, 0x81, 0x0c, 0x5d, 0x8f, 0x61, 0x1b, 0xa0, 0x07, 0x28, 0xf3, 0xff, 0x9f,
	0xe6, 0xd5, 0xb2, 0x5a, 0xa9, 0x31, 0x9a, 0x4c, 0x66, 0xc4, 0x3e, 0x1d, 0x63, 0x4b, 0x6f, 0x0f,
	0xd0, 0x96, 0x54, 0xaa, 0xed, 0x9c, 0xb9, 0x42, 0x3b, 0xd4, 0xf4, 0x06, 0x7e, 0x53, 0xd9, 0x44,
	0x2b, 0x61, 0xa9, 0x50, 0xf4, 0x83, 0x2c, 0x12, 0x23, 0x27, 0x19, 0x79, 0x8d, 0x91, 0x55, 0xfd,
	0x5a, 0x09, 0x6b, 0x01, 0x8c, 0x9e, 0xf0, 0x69, 0x32, 0x62, 0x8a, 0x11, 0x73, 0x8c, 0x18, 0x8c,
	0xb8, 0x95, 0xb0, 0x42, 0x80, 0x99, 0x81, 0x65, 0x67, 0x38, 0x72, 0xce, 0x5c, 0x63, 0x0b, 0x8a,
	0x52, 0x6a, 0x62, 0x93, 0x99, 0x4f, 0x87, 0xda, 0x73, 0xa7, 0x84, 0x75, 0x9d, 0xb3, 0xd8, 0x73,
	0x38, 0x68, 0x3d, 0x1a, 0xb4, 0xb1, 0x0d, 0x85, 0xa8, 0x27, 0x4e, 0x6d, 0x84, 0xd2, 0xf6, 0x18,
	0x3d, 0xee, 0xdc, 0x84, 0x08, 0xe3, 0x0f, 0x0d, 0x72, 0x81, 0xd8, 0x61, 0xe9, 0xd6, 0x2f, 0x42,
	0xf0, 0x9c, 0xc5, 0x9e, 0xd1, 0xf6, 0x35, 0x61, 0xb8, 0xaa, 0xeb, 0x8b, 0xc2, 0xb0, 0x14, 0x31,
	0xd2, 0xbc, 0x58, 0x9c, 0x0a, 0x17, 0xb6, 0xb4, 0x30, 0x95, 0x80, 0xae, 0x82, 0x25, 0xad, 0xf2,
	0x90, 0x95, 0x76, 0xeb, 0x1b, 0x7f, 0xea, 0x90, 0x16, 0x01, 0xf4, 0x3d, 0x64, 0x0e, 0x2f, 0x3c,
	0x7c, 0x80, 0x89, 0x2d, 0x1a, 0xcf, 0x37, 0xd9, 0xc5, 0x0b, 0xa2, 0x66, 0xe1, 0xe3, 0xbc, 0xaa,
	0x5d, 0xcd, 0xab, 0xe9, 0xc6, 0xc8, 0x19, 0x8f, 0x1c, 0x6c, 0x85, 0x04, 0xb4, 0x0d, 0xe9, 0xee,
	0xe9, 0xcf, 0x8c, 0xab, 0x8b, 0xd1, 0x31, 0xae, 0x08, 0x9a, 0x0f, 0x05, 0x95, 0x1d, 0xf3, 0x86,
	0x3b, 0x19, 0x11, 0x3c, 0xf1, 0xc8, 0x85, 0x15, 0xb0, 0xd0, 0x73, 0x48, 0xd1, 0x19, 0x8b, 0xc6,
	0x8a, 0xac, 0x31, 0xe9, 0x14, 0x9b, 0x88, 0x92, 0x7d, 0x0f, 0xf7, 0x25, 0x32, 0x63, 0xa0, 0x1f,
	0x61, 0x99, 0x37, 0x2e, 0x0e, 0x0d, 0x52, 0xb8, 0x6c, 0xc5, 0x2c, 0x5d, 0xcd, 0xab, 0x45, 0x9f,
	0x3d, 0x4b, 0x7c, 0xc1, 0x43, 0x2f, 0x60, 0x89, 0xc9, 0x51, 0x5e, 0x62, 0x09, 0x56, 0x17, 0x13,
	0xf8, 0xe6, 0xda, 0xd5, 0xbc, 0x5a, 0xa0, 0x7c, 0x99, 0xce, 0x49, 0xc6, 0x18, 0xf2, 0x02, 0x6b,
	0xe1, 0x77, 0x33, 0xec, 0x13, 0xd4, 0x84, 0x07, 0xa6, 0x4d, 0xfa, 0xc3, 0x5d, 0xf2, 0x81, 0x2c,
	0x9c, 0xa1, 0x30, 0x6e, 0x45, 0x10, 0xb4, 0x09, 0x69, 0x41, 0x2d, 0xeb, 0xb5, 0x64, 0x5c, 0xfb,
	0x56, 0x00, 0x30, 0xde, 0x41, 0x21, 0xac, 0xe6, 0x7b, 0xae, 0xe3, 0x63, 0x5a, 0x6e, 0xc7, 0x1b,
	0x09, 0x0d, 0x68, 0xb9, 0x7c, 0x58, 0x2e, 0x8c, 0x5b, 0x11, 0x04, 0x35, 0x21, 0x13, 0x70, 0x45,
	0xbd, 0x18, 0xc9, 0xac, 0x10, 0x63, 0xbc, 0x81, 0x55, 0xb1, 0xb4, 0x8f, 0x49, 0xd0, 0xe3, 0x37,
	0x90, 0xa2, 0xc3, 0x0f, 0xeb, 0x49, 0x09, 0x68, 0xbc, 0x95, 0xb0, 0xd8, 0x3a, 0x2a, 0x32, 0xf7,
	0xa1, 0x67, 0x22, 0xdb, 0x4a, 0x50, 0x87, 0x31, 0x1f, 0x40, 0xfa, 0x1c, 0x13, 0xba, 0x3f, 0xc3,
	0x01, 0x24, 0x67, 0xbe, 0x63, 0x3f, 0xf5, 0x6b, 0xfd, 0x64, 0xe5, 0xed, 0x48, 0x9d, 0x1c, 0x43,
	0x49, 0x04, 0x5f, 0xe2, 0x31, 0x26, 0xf8, 0xae, 0x03, 0xcb, 0x8b, 0xa6, 0x92, 0xf5, 0x2c, 0x6d,
	0xc9, 0xd8, 0x87, 0xf5, 0x85, 0xbc, 0xf1, 0xad, 0x24, 0x6f, 0x69, 0xc5, 0xf8, 0x9d, 0x7a, 0xf7,
	0x70, 0x7f, 0xea, 0xce, 0xb8, 0x77, 0x1b, 0x92, 0x77, 0xc7, 0x7d, 0x25, 0xa8, 0x63, 0x3f, 0x17,
	0x93, 0xd0, 0xe5, 0x49, 0xf0, 0x1c, 0x34, 0x1e, 0xcb, 0xe3, 0xb3, 0xd9, 0x84, 0xf4, 0x01, 0x9e,
	0x9c, 0xe2, 0xa9, 0x5f, 0x4e, 0xde, 0x74, 0xee, 0x04, 0xc0, 0xf8, 0x09, 0x72, 0xc1, 0xc6, 0x6e,
	0xf6, 0xb9, 0x46, 0x94, 0xf0, 0xe6, 0x83, 0x15, 0xa6, 0xa4, 0x66, 0x14, 0xa5, 0x14, 0x66, 0xc4,
	0x03, 0xff, 0x45, 0x33, 0x8a, 0xc6, 0xf2, 0xe5, 0x66, 0x24, 0x2b, 0x77, 0x27, 0x33, 0x92, 0x74,
	0xba, 0xd5, 0x8c, 0x38, 0xf6, 0xbe, 0xcd, 0x28, 0x6a, 0x5f, 0x35, 0xa3, 0xa0, 0xda, 0x7d, 0x9b,
	0x91, 0x2c, 0xd9, 0x82, 0x19, 0xf1, 0xa5, 0xdb, 0xcc, 0x28, 0xba, 0x02, 0x9f, 0x6f, 0x46, 0x52,
	0xe6, 0xfb, 0x36, 0x23, 0xa1, 0x93, 0x6a, 0x46, 0x3c, 0x78, 0xff, 0x66, 0xa4, 0xe6, 0xbd, 0x9b,
	0x19, 0x6d, 0x3a, 0xe1, 0xef, 0x48, 0x26, 0xde, 0x3a, 0xac, 0x76, 0xf6, 0xde, 0x1c, 0xb6, 0xba,
	0xbd, 0x93, 0xc3, 0xb7, 0xbd, 0xbd, 0x93, 0x4e, 0xb7, 0xb3, 0x57, 0x4c, 0xa0, 0x35, 0x28, 0x28,
	0xe1, 0x76, 0xaf, 0xa8, 0xa1, 0xc7, 0xb0, 0xae, 0x04, 0x8f, 0x3a, 0x2f, 0xf7, 0xac, 0x57, 0x3b,
	0x6f, 0x8b, 0x3a, 0x2a, 0x43, 0x49, 0x59, 0xea, 0x1e, 0xf3, 0x95, 0xe4, 0xe6, 0x2c, 0xf4, 0x3e,
	0x56, 0xef, 0x7f, 0xf0, 0x28, 0x00, 0xee, 0x5b, 0xdd, 0x23, 0xb5, 0xea, 0x57, 0x50, 0x8d, 0x59,
	0x14, 0xb9, 0x4e, 0xf6, 0x76, 0x0f, 0xe8, 0x2e, 0xbe, 0x86, 0x5a, 0x0c, 0x28, 0xd8, 0x0b, 0x47,
	0xe9, 0x4f, 0x7f, 0x4b, 0xc1, 0x52, 0x67, 0xf8, 0xfa, 0x7d, 0x9f, 0xfe, 0xca, 0x12, 0x0d, 0xef,
	0x4e, 0xb1, 0x4d, 0x30, 0x5a, 0x53, 0xbe, 0x23, 0x7c, 0x3e, 0x95, 0x92, 0x1a, 0x14, 0xd3, 0x4c,
	0x48, 0xec, 0x23, 0x6f, 0xf0, 0xc5, 0xec, 0x6d, 0x80, 0xe8, 0x53, 0x88, 0x1e, 0xca, 0xa8, 0xe8,
	0xa0, 0x57, 0x1e, 0x5d, 0x8b, 0x87, 0x09, 0x5a, 0x61, 0x79, 0x3e, 0x76, 0xf4, 0x58, 0xc6, 0x2a,
	0x47, 0xac, 0x52, 0x89, 0x5b, 0x52, 0x1a, 0xe1, 0x73, 0x50, 0x65, 0x50, 0x7c, 0x25, 0x68, 0x44,
	0xbd, 0xfe, 0x0a, 0x5b, 0x95, 0xe1, 0xf3, 0xd8, 0x54, 0x86, 0xf0, 0x12, 0x06, 0x32, 0x2c, 0xde,
	0xf7, 0x40, 0x86, 0x6b, 0xb7, 0x55, 0xc8, 0x20, 0x9f, 0xfe, 0x40, 0x86, 0x98, 0x9b, 0x16, 0xc8,
	0x10, 0x77, 0x59, 0x8c, 0x84, 0x99, 0xfd, 0xeb, 0x72, 0x43, 0xfb, 0x78, 0xb9, 0xa1, 0xfd, 0x7d,
	0xb9, 0xa1, 0x9d, 0x2e, 0xb3, 0xff, 0x38, 0x9f, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xc6, 0xec,
	0x05, 0xc4, 0xac, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NhSvcClient is the client API for NhSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NhSvcClient interface {
	NexthopCreate(ctx context.Context, in *NexthopRequest, opts ...grpc.CallOption) (*NexthopResponse, error)
	NexthopUpdate(ctx context.Context, in *NexthopRequest, opts ...grpc.CallOption) (*NexthopResponse, error)
	NexthopGet(ctx context.Context, in *NexthopGetRequest, opts ...grpc.CallOption) (*NexthopGetResponse, error)
	NexthopDelete(ctx context.Context, in *NexthopDeleteRequest, opts ...grpc.CallOption) (*NexthopDeleteResponse, error)
	NhGroupCreate(ctx context.Context, in *NhGroupRequest, opts ...grpc.CallOption) (*NhGroupResponse, error)
	NhGroupUpdate(ctx context.Context, in *NhGroupRequest, opts ...grpc.CallOption) (*NhGroupResponse, error)
	NhGroupGet(ctx context.Context, in *NhGroupGetRequest, opts ...grpc.CallOption) (*NhGroupGetResponse, error)
	NhGroupDelete(ctx context.Context, in *NhGroupDeleteRequest, opts ...grpc.CallOption) (*NhGroupDeleteResponse, error)
}

type nhSvcClient struct {
	cc *grpc.ClientConn
}

func NewNhSvcClient(cc *grpc.ClientConn) NhSvcClient {
	return &nhSvcClient{cc}
}

func (c *nhSvcClient) NexthopCreate(ctx context.Context, in *NexthopRequest, opts ...grpc.CallOption) (*NexthopResponse, error) {
	out := new(NexthopResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NexthopCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NexthopUpdate(ctx context.Context, in *NexthopRequest, opts ...grpc.CallOption) (*NexthopResponse, error) {
	out := new(NexthopResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NexthopUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NexthopGet(ctx context.Context, in *NexthopGetRequest, opts ...grpc.CallOption) (*NexthopGetResponse, error) {
	out := new(NexthopGetResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NexthopGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NexthopDelete(ctx context.Context, in *NexthopDeleteRequest, opts ...grpc.CallOption) (*NexthopDeleteResponse, error) {
	out := new(NexthopDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NexthopDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NhGroupCreate(ctx context.Context, in *NhGroupRequest, opts ...grpc.CallOption) (*NhGroupResponse, error) {
	out := new(NhGroupResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NhGroupCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NhGroupUpdate(ctx context.Context, in *NhGroupRequest, opts ...grpc.CallOption) (*NhGroupResponse, error) {
	out := new(NhGroupResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NhGroupUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NhGroupGet(ctx context.Context, in *NhGroupGetRequest, opts ...grpc.CallOption) (*NhGroupGetResponse, error) {
	out := new(NhGroupGetResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NhGroupGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nhSvcClient) NhGroupDelete(ctx context.Context, in *NhGroupDeleteRequest, opts ...grpc.CallOption) (*NhGroupDeleteResponse, error) {
	out := new(NhGroupDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.NhSvc/NhGroupDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NhSvcServer is the server API for NhSvc service.
type NhSvcServer interface {
	NexthopCreate(context.Context, *NexthopRequest) (*NexthopResponse, error)
	NexthopUpdate(context.Context, *NexthopRequest) (*NexthopResponse, error)
	NexthopGet(context.Context, *NexthopGetRequest) (*NexthopGetResponse, error)
	NexthopDelete(context.Context, *NexthopDeleteRequest) (*NexthopDeleteResponse, error)
	NhGroupCreate(context.Context, *NhGroupRequest) (*NhGroupResponse, error)
	NhGroupUpdate(context.Context, *NhGroupRequest) (*NhGroupResponse, error)
	NhGroupGet(context.Context, *NhGroupGetRequest) (*NhGroupGetResponse, error)
	NhGroupDelete(context.Context, *NhGroupDeleteRequest) (*NhGroupDeleteResponse, error)
}

// UnimplementedNhSvcServer can be embedded to have forward compatible implementations.
type UnimplementedNhSvcServer struct {
}

func (*UnimplementedNhSvcServer) NexthopCreate(ctx context.Context, req *NexthopRequest) (*NexthopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopCreate not implemented")
}
func (*UnimplementedNhSvcServer) NexthopUpdate(ctx context.Context, req *NexthopRequest) (*NexthopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopUpdate not implemented")
}
func (*UnimplementedNhSvcServer) NexthopGet(ctx context.Context, req *NexthopGetRequest) (*NexthopGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopGet not implemented")
}
func (*UnimplementedNhSvcServer) NexthopDelete(ctx context.Context, req *NexthopDeleteRequest) (*NexthopDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopDelete not implemented")
}
func (*UnimplementedNhSvcServer) NhGroupCreate(ctx context.Context, req *NhGroupRequest) (*NhGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NhGroupCreate not implemented")
}
func (*UnimplementedNhSvcServer) NhGroupUpdate(ctx context.Context, req *NhGroupRequest) (*NhGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NhGroupUpdate not implemented")
}
func (*UnimplementedNhSvcServer) NhGroupGet(ctx context.Context, req *NhGroupGetRequest) (*NhGroupGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NhGroupGet not implemented")
}
func (*UnimplementedNhSvcServer) NhGroupDelete(ctx context.Context, req *NhGroupDeleteRequest) (*NhGroupDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NhGroupDelete not implemented")
}

func RegisterNhSvcServer(s *grpc.Server, srv NhSvcServer) {
	s.RegisterService(&_NhSvc_serviceDesc, srv)
}

func _NhSvc_NexthopCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NexthopCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NexthopCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NexthopCreate(ctx, req.(*NexthopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NexthopUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NexthopUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NexthopUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NexthopUpdate(ctx, req.(*NexthopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NexthopGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NexthopGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NexthopGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NexthopGet(ctx, req.(*NexthopGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NexthopDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NexthopDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NexthopDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NexthopDelete(ctx, req.(*NexthopDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NhGroupCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NhGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NhGroupCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NhGroupCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NhGroupCreate(ctx, req.(*NhGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NhGroupUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NhGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NhGroupUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NhGroupUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NhGroupUpdate(ctx, req.(*NhGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NhGroupGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NhGroupGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NhGroupGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NhGroupGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NhGroupGet(ctx, req.(*NhGroupGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NhSvc_NhGroupDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NhGroupDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NhSvcServer).NhGroupDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NhSvc/NhGroupDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NhSvcServer).NhGroupDelete(ctx, req.(*NhGroupDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NhSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.NhSvc",
	HandlerType: (*NhSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NexthopCreate",
			Handler:    _NhSvc_NexthopCreate_Handler,
		},
		{
			MethodName: "NexthopUpdate",
			Handler:    _NhSvc_NexthopUpdate_Handler,
		},
		{
			MethodName: "NexthopGet",
			Handler:    _NhSvc_NexthopGet_Handler,
		},
		{
			MethodName: "NexthopDelete",
			Handler:    _NhSvc_NexthopDelete_Handler,
		},
		{
			MethodName: "NhGroupCreate",
			Handler:    _NhSvc_NhGroupCreate_Handler,
		},
		{
			MethodName: "NhGroupUpdate",
			Handler:    _NhSvc_NhGroupUpdate_Handler,
		},
		{
			MethodName: "NhGroupGet",
			Handler:    _NhSvc_NhGroupGet_Handler,
		},
		{
			MethodName: "NhGroupDelete",
			Handler:    _NhSvc_NhGroupDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nh.proto",
}

func (m *IPNhSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPNhSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPNhSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mac != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.Mac))
		i--
		dAtA[i] = 0x20
	}
	if m.Vlan != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x18
	}
	if m.IP != nil {
		{
			size, err := m.IP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintNh(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnderlayNhSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnderlayNhSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnderlayNhSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnderlayMAC != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.UnderlayMAC))
		i--
		dAtA[i] = 0x10
	}
	if len(m.L3Interface) > 0 {
		i -= len(m.L3Interface)
		copy(dAtA[i:], m.L3Interface)
		i = encodeVarintNh(dAtA, i, uint64(len(m.L3Interface)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OverlayNhSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverlayNhSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OverlayNhSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TunnelId) > 0 {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintNh(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nhinfo != nil {
		{
			size := m.Nhinfo.Size()
			i -= size
			if _, err := m.Nhinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNh(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopSpec_OverlayNhInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopSpec_OverlayNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OverlayNhInfo != nil {
		{
			size, err := m.OverlayNhInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexthopSpec_UnderlayNhInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopSpec_UnderlayNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnderlayNhInfo != nil {
		{
			size, err := m.UnderlayNhInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexthopSpec_IPNhInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopSpec_IPNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPNhInfo != nil {
		{
			size, err := m.IPNhInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *UnderlayNhStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnderlayNhStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnderlayNhStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vlan != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x10
	}
	if m.Port != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OverlayNhStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverlayNhStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OverlayNhStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TunnelIP != nil {
		{
			size, err := m.TunnelIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nhinfo != nil {
		{
			size := m.Nhinfo.Size()
			i -= size
			if _, err := m.Nhinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.HwId != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NexthopStatus_UnderlayNhInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopStatus_UnderlayNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnderlayNhInfo != nil {
		{
			size, err := m.UnderlayNhInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexthopStatus_OverlayNhInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopStatus_OverlayNhInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OverlayNhInfo != nil {
		{
			size, err := m.OverlayNhInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NexthopStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Nexthop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nexthop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nexthop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NexthopGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gettype != nil {
		{
			size := m.Gettype.Size()
			i -= size
			if _, err := m.Gettype.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NexthopGetRequest_Type) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopGetRequest_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNh(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *NexthopGetRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NexthopGetRequest_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNh(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NexthopGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NexthopDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNh(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NexthopDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NexthopDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA16 := make([]byte, len(m.ApiStatus)*10)
		var j15 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintNh(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNh(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HwId != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NhGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gettype != nil {
		{
			size := m.Gettype.Size()
			i -= size
			if _, err := m.Gettype.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupGetRequest_Type) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NhGroupGetRequest_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNh(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *NhGroupGetRequest_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NhGroupGetRequest_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNh(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NhGroupGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNh(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNh(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNh(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NhGroupDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NhGroupDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NhGroupDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA25 := make([]byte, len(m.ApiStatus)*10)
		var j24 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintNh(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNh(dAtA []byte, offset int, v uint64) int {
	offset -= sovNh(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IPNhSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovNh(uint64(l))
	}
	if m.IP != nil {
		l = m.IP.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Vlan != 0 {
		n += 1 + sovNh(uint64(m.Vlan))
	}
	if m.Mac != 0 {
		n += 1 + sovNh(uint64(m.Mac))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnderlayNhSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.L3Interface)
	if l > 0 {
		n += 1 + l + sovNh(uint64(l))
	}
	if m.UnderlayMAC != 0 {
		n += 1 + sovNh(uint64(m.UnderlayMAC))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OverlayNhSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TunnelId)
	if l > 0 {
		n += 1 + l + sovNh(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Nhinfo != nil {
		n += m.Nhinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopSpec_OverlayNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlayNhInfo != nil {
		l = m.OverlayNhInfo.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NexthopSpec_UnderlayNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnderlayNhInfo != nil {
		l = m.UnderlayNhInfo.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NexthopSpec_IPNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPNhInfo != nil {
		l = m.IPNhInfo.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *UnderlayNhStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovNh(uint64(m.Port))
	}
	if m.Vlan != 0 {
		n += 1 + sovNh(uint64(m.Vlan))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OverlayNhStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelIP != nil {
		l = m.TunnelIP.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovNh(uint64(m.HwId))
	}
	if m.Nhinfo != nil {
		n += m.Nhinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopStatus_UnderlayNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnderlayNhInfo != nil {
		l = m.UnderlayNhInfo.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NexthopStatus_OverlayNhInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlayNhInfo != nil {
		l = m.OverlayNhInfo.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NexthopStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Nexthop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNh(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gettype != nil {
		n += m.Gettype.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopGetRequest_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNh(uint64(m.Type))
	return n
}
func (m *NexthopGetRequest_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NexthopGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNh(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NexthopDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNh(uint64(e))
		}
		n += 1 + sovNh(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNh(uint64(m.Type))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovNh(uint64(m.HwId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNh(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gettype != nil {
		n += m.Gettype.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupGetRequest_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNh(uint64(m.Type))
	return n
}
func (m *NhGroupGetRequest_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovNh(uint64(l))
	}
	return n
}
func (m *NhGroupGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNh(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNh(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNh(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NhGroupDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNh(uint64(e))
		}
		n += 1 + sovNh(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNh(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNh(x uint64) (n int) {
	return sovNh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IPNhSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPNhSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPNhSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IP == nil {
				m.IP = &IPAddress{}
			}
			if err := m.IP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			m.Mac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnderlayNhSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnderlayNhSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnderlayNhSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Interface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L3Interface = append(m.L3Interface[:0], dAtA[iNdEx:postIndex]...)
			if m.L3Interface == nil {
				m.L3Interface = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlayMAC", wireType)
			}
			m.UnderlayMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnderlayMAC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverlayNhSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverlayNhSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverlayNhSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelId = append(m.TunnelId[:0], dAtA[iNdEx:postIndex]...)
			if m.TunnelId == nil {
				m.TunnelId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayNhInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OverlayNhSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nhinfo = &NexthopSpec_OverlayNhInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlayNhInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnderlayNhSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nhinfo = &NexthopSpec_UnderlayNhInfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPNhInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPNhSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nhinfo = &NexthopSpec_IPNhInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnderlayNhStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnderlayNhStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnderlayNhStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverlayNhStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverlayNhStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverlayNhStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TunnelIP == nil {
				m.TunnelIP = &IPAddress{}
			}
			if err := m.TunnelIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlayNhInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnderlayNhStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nhinfo = &NexthopStatus_UnderlayNhInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayNhInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OverlayNhStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Nhinfo = &NexthopStatus_OverlayNhInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nexthop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nexthop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nexthop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NexthopSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NexthopStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NexthopStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NexthopSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NexthopStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v NexthopType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= NexthopType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gettype = &NexthopGetRequest_Type{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Gettype = &NexthopGetRequest_Id{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Nexthop{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NhGroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &NexthopSpec{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &NexthopStatus{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NhGroupSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NhGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NhGroupStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NhGroupSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NhGroupStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v NhGroupType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= NhGroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gettype = &NhGroupGetRequest_Type{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Gettype = &NhGroupGetRequest_Id{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NhGroup{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NhGroupDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NhGroupDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NhGroupDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNh
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNh
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNh
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNh(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNh
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNh = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNh   = fmt.Errorf("proto: integer overflow")
)
