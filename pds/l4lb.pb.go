// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: l4lb.proto

package pds

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// protocol types (i.e., traffic types) that can be load balanced based
type L4LBProtocol int32

const (
	L4LBProtocol_L4LB_PROTO_NONE L4LBProtocol = 0
	L4LBProtocol_L4LB_PROTO_TCP  L4LBProtocol = 6
	L4LBProtocol_L4LB_PROTO_UDP  L4LBProtocol = 17
)

var L4LBProtocol_name = map[int32]string{
	0:  "L4LB_PROTO_NONE",
	6:  "L4LB_PROTO_TCP",
	17: "L4LB_PROTO_UDP",
}

var L4LBProtocol_value = map[string]int32{
	"L4LB_PROTO_NONE": 0,
	"L4LB_PROTO_TCP":  6,
	"L4LB_PROTO_UDP":  17,
}

func (x L4LBProtocol) String() string {
	return proto.EnumName(L4LBProtocol_name, int32(x))
}

func (L4LBProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{0}
}

// IP protocol type supported for LB probes
type L4LBProbeProtocol int32

const (
	L4LBProbeProtocol_L4LB_PROBE_PROTO_NONE   L4LBProbeProtocol = 0
	L4LBProbeProtocol_L4LB_PROBE_PROTO_ICMP   L4LBProbeProtocol = 1
	L4LBProbeProtocol_L4LB_PROBE_PROTO_TCP    L4LBProbeProtocol = 6
	L4LBProbeProtocol_L4LB_PROBE_PROTO_UDP    L4LBProbeProtocol = 17
	L4LBProbeProtocol_L4LB_PROBE_PROTO_ICMPV6 L4LBProbeProtocol = 58
)

var L4LBProbeProtocol_name = map[int32]string{
	0:  "L4LB_PROBE_PROTO_NONE",
	1:  "L4LB_PROBE_PROTO_ICMP",
	6:  "L4LB_PROBE_PROTO_TCP",
	17: "L4LB_PROBE_PROTO_UDP",
	58: "L4LB_PROBE_PROTO_ICMPV6",
}

var L4LBProbeProtocol_value = map[string]int32{
	"L4LB_PROBE_PROTO_NONE":   0,
	"L4LB_PROBE_PROTO_ICMP":   1,
	"L4LB_PROBE_PROTO_TCP":    6,
	"L4LB_PROBE_PROTO_UDP":    17,
	"L4LB_PROBE_PROTO_ICMPV6": 58,
}

func (x L4LBProbeProtocol) String() string {
	return proto.EnumName(L4LBProbeProtocol_name, int32(x))
}

func (L4LBProbeProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{1}
}

// Backend identifies backend by its IP and/or its port
type Backend struct {
	// IP address of the backend behind the service Virtual IP
	BackendIP *IPAddress `protobuf:"bytes,1,opt,name=BackendIP,proto3" json:"BackendIP,omitempty" meta:mandatory`
	// Port to rewrite with before sending the packet to the backend
	BackendPort          uint32   `protobuf:"varint,2,opt,name=BackendPort,proto3" json:"BackendPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Backend) Reset()         { *m = Backend{} }
func (m *Backend) String() string { return proto.CompactTextString(m) }
func (*Backend) ProtoMessage()    {}
func (*Backend) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{0}
}
func (m *Backend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Backend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Backend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backend.Merge(m, src)
}
func (m *Backend) XXX_Size() int {
	return m.Size()
}
func (m *Backend) XXX_DiscardUnknown() {
	xxx_messageInfo_Backend.DiscardUnknown(m)
}

var xxx_messageInfo_Backend proto.InternalMessageInfo

func (m *Backend) GetBackendIP() *IPAddress {
	if m != nil {
		return m.BackendIP
	}
	return nil
}

func (m *Backend) GetBackendPort() uint32 {
	if m != nil {
		return m.BackendPort
	}
	return 0
}

// HealthCheck captures the L4 LB health check configuration for the backends
type BackendHealthCheck struct {
	ProbePort            uint32            `protobuf:"fixed32,1,opt,name=ProbePort,proto3" json:"ProbePort,omitempty"`
	ProbeProtocol        L4LBProbeProtocol `protobuf:"varint,2,opt,name=ProbeProtocol,proto3,enum=pds.L4LBProbeProtocol" json:"ProbeProtocol,omitempty"`
	ProbeInterval        uint32            `protobuf:"fixed32,3,opt,name=ProbeInterval,proto3" json:"ProbeInterval,omitempty"`
	ProbesPerInterval    uint32            `protobuf:"fixed32,4,opt,name=ProbesPerInterval,proto3" json:"ProbesPerInterval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BackendHealthCheck) Reset()         { *m = BackendHealthCheck{} }
func (m *BackendHealthCheck) String() string { return proto.CompactTextString(m) }
func (*BackendHealthCheck) ProtoMessage()    {}
func (*BackendHealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{1}
}
func (m *BackendHealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackendHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackendHealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackendHealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackendHealthCheck.Merge(m, src)
}
func (m *BackendHealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *BackendHealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_BackendHealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_BackendHealthCheck proto.InternalMessageInfo

func (m *BackendHealthCheck) GetProbePort() uint32 {
	if m != nil {
		return m.ProbePort
	}
	return 0
}

func (m *BackendHealthCheck) GetProbeProtocol() L4LBProbeProtocol {
	if m != nil {
		return m.ProbeProtocol
	}
	return L4LBProbeProtocol_L4LB_PROBE_PROTO_NONE
}

func (m *BackendHealthCheck) GetProbeInterval() uint32 {
	if m != nil {
		return m.ProbeInterval
	}
	return 0
}

func (m *BackendHealthCheck) GetProbesPerInterval() uint32 {
	if m != nil {
		return m.ProbesPerInterval
	}
	return 0
}

type L4LbPolicySpec struct {
	// unique identifier of L4Lb policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// unique key/identifier of VPC in which service is running
	VPCId []byte `protobuf:"bytes,2,opt,name=VPCId,proto3" json:"VPCId,omitempty" meta:mandatory`
	// service Virtual IP (VIP)
	ServiceIP *IPAddress `protobuf:"bytes,3,opt,name=ServiceIP,proto3" json:"ServiceIP,omitempty" meta:mandatory`
	// IP protocol - TCP or UDP
	IPProtocol L4LBProtocol `protobuf:"varint,4,opt,name=IPProtocol,proto3,enum=pds.L4LBProtocol" json:"IPProtocol,omitempty" meta:mandatory`
	// service port
	ServicePort uint32 `protobuf:"varint,5,opt,name=ServicePort,proto3" json:"ServicePort,omitempty"`
	// set ProxyARP to true to enable proxy ARP for VIP
	ProxyARP bool `protobuf:"varint,6,opt,name=ProxyARP,proto3" json:"ProxyARP,omitempty"`
	// backend servers behind the VIP
	Backends []*Backend `protobuf:"bytes,7,rep,name=Backends,proto3" json:"Backends,omitempty" meta:mandatory`
	// health check policy to determine if a backend is dead or alive, if any
	HealthChecks         *BackendHealthCheck `protobuf:"bytes,8,opt,name=HealthChecks,proto3" json:"HealthChecks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *L4LbPolicySpec) Reset()         { *m = L4LbPolicySpec{} }
func (m *L4LbPolicySpec) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicySpec) ProtoMessage()    {}
func (*L4LbPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{2}
}
func (m *L4LbPolicySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicySpec.Merge(m, src)
}
func (m *L4LbPolicySpec) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicySpec.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicySpec proto.InternalMessageInfo

func (m *L4LbPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *L4LbPolicySpec) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *L4LbPolicySpec) GetServiceIP() *IPAddress {
	if m != nil {
		return m.ServiceIP
	}
	return nil
}

func (m *L4LbPolicySpec) GetIPProtocol() L4LBProtocol {
	if m != nil {
		return m.IPProtocol
	}
	return L4LBProtocol_L4LB_PROTO_NONE
}

func (m *L4LbPolicySpec) GetServicePort() uint32 {
	if m != nil {
		return m.ServicePort
	}
	return 0
}

func (m *L4LbPolicySpec) GetProxyARP() bool {
	if m != nil {
		return m.ProxyARP
	}
	return false
}

func (m *L4LbPolicySpec) GetBackends() []*Backend {
	if m != nil {
		return m.Backends
	}
	return nil
}

func (m *L4LbPolicySpec) GetHealthChecks() *BackendHealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

// operational status of L4Lb policy, if any
type L4LbPolicyStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L4LbPolicyStatus) Reset()         { *m = L4LbPolicyStatus{} }
func (m *L4LbPolicyStatus) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyStatus) ProtoMessage()    {}
func (*L4LbPolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{3}
}
func (m *L4LbPolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyStatus.Merge(m, src)
}
func (m *L4LbPolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyStatus proto.InternalMessageInfo

// stats of L4Lb policy, if any
type L4LbPolicyStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L4LbPolicyStats) Reset()         { *m = L4LbPolicyStats{} }
func (m *L4LbPolicyStats) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyStats) ProtoMessage()    {}
func (*L4LbPolicyStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{4}
}
func (m *L4LbPolicyStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyStats.Merge(m, src)
}
func (m *L4LbPolicyStats) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyStats) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyStats.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyStats proto.InternalMessageInfo

// L4Lb policy object
type L4LbPolicy struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *L4LbPolicySpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *L4LbPolicyStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *L4LbPolicyStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *L4LbPolicy) Reset()         { *m = L4LbPolicy{} }
func (m *L4LbPolicy) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicy) ProtoMessage()    {}
func (*L4LbPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{5}
}
func (m *L4LbPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicy.Merge(m, src)
}
func (m *L4LbPolicy) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicy proto.InternalMessageInfo

func (m *L4LbPolicy) GetSpec() *L4LbPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *L4LbPolicy) GetStatus() *L4LbPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *L4LbPolicy) GetStats() *L4LbPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// L4Lb policy create and update request
type L4LbPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt        `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*L4LbPolicySpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *L4LbPolicyRequest) Reset()         { *m = L4LbPolicyRequest{} }
func (m *L4LbPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyRequest) ProtoMessage()    {}
func (*L4LbPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{6}
}
func (m *L4LbPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyRequest.Merge(m, src)
}
func (m *L4LbPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyRequest proto.InternalMessageInfo

func (m *L4LbPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *L4LbPolicyRequest) GetRequest() []*L4LbPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// L4Lb policy create and update response
type L4LbPolicyResponse struct {
	ApiStatus            ApiStatus           `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*L4LbPolicyStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *L4LbPolicyResponse) Reset()         { *m = L4LbPolicyResponse{} }
func (m *L4LbPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyResponse) ProtoMessage()    {}
func (*L4LbPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{7}
}
func (m *L4LbPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyResponse.Merge(m, src)
}
func (m *L4LbPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyResponse proto.InternalMessageInfo

func (m *L4LbPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L4LbPolicyResponse) GetResponse() []*L4LbPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4Lb policy get request
type L4LbPolicyGetRequest struct {
	// list of keys of interest
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L4LbPolicyGetRequest) Reset()         { *m = L4LbPolicyGetRequest{} }
func (m *L4LbPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyGetRequest) ProtoMessage()    {}
func (*L4LbPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{8}
}
func (m *L4LbPolicyGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyGetRequest.Merge(m, src)
}
func (m *L4LbPolicyGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyGetRequest proto.InternalMessageInfo

func (m *L4LbPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// L4Lb policy get response
type L4LbPolicyGetResponse struct {
	ApiStatus            ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*L4LbPolicy `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *L4LbPolicyGetResponse) Reset()         { *m = L4LbPolicyGetResponse{} }
func (m *L4LbPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyGetResponse) ProtoMessage()    {}
func (*L4LbPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{9}
}
func (m *L4LbPolicyGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyGetResponse.Merge(m, src)
}
func (m *L4LbPolicyGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyGetResponse proto.InternalMessageInfo

func (m *L4LbPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *L4LbPolicyGetResponse) GetResponse() []*L4LbPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// L4Lb policy delete request
type L4LbPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *L4LbPolicyDeleteRequest) Reset()         { *m = L4LbPolicyDeleteRequest{} }
func (m *L4LbPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyDeleteRequest) ProtoMessage()    {}
func (*L4LbPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{10}
}
func (m *L4LbPolicyDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyDeleteRequest.Merge(m, src)
}
func (m *L4LbPolicyDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyDeleteRequest proto.InternalMessageInfo

func (m *L4LbPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *L4LbPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// L4Lb policy delete response
type L4LbPolicyDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *L4LbPolicyDeleteResponse) Reset()         { *m = L4LbPolicyDeleteResponse{} }
func (m *L4LbPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*L4LbPolicyDeleteResponse) ProtoMessage()    {}
func (*L4LbPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_693dda9d07e1878b, []int{11}
}
func (m *L4LbPolicyDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4LbPolicyDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L4LbPolicyDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L4LbPolicyDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4LbPolicyDeleteResponse.Merge(m, src)
}
func (m *L4LbPolicyDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *L4LbPolicyDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L4LbPolicyDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L4LbPolicyDeleteResponse proto.InternalMessageInfo

func (m *L4LbPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.L4LBProtocol", L4LBProtocol_name, L4LBProtocol_value)
	proto.RegisterEnum("pds.L4LBProbeProtocol", L4LBProbeProtocol_name, L4LBProbeProtocol_value)
	proto.RegisterType((*Backend)(nil), "pds.Backend")
	proto.RegisterType((*BackendHealthCheck)(nil), "pds.BackendHealthCheck")
	proto.RegisterType((*L4LbPolicySpec)(nil), "pds.L4LbPolicySpec")
	proto.RegisterType((*L4LbPolicyStatus)(nil), "pds.L4LbPolicyStatus")
	proto.RegisterType((*L4LbPolicyStats)(nil), "pds.L4LbPolicyStats")
	proto.RegisterType((*L4LbPolicy)(nil), "pds.L4LbPolicy")
	proto.RegisterType((*L4LbPolicyRequest)(nil), "pds.L4LbPolicyRequest")
	proto.RegisterType((*L4LbPolicyResponse)(nil), "pds.L4LbPolicyResponse")
	proto.RegisterType((*L4LbPolicyGetRequest)(nil), "pds.L4LbPolicyGetRequest")
	proto.RegisterType((*L4LbPolicyGetResponse)(nil), "pds.L4LbPolicyGetResponse")
	proto.RegisterType((*L4LbPolicyDeleteRequest)(nil), "pds.L4LbPolicyDeleteRequest")
	proto.RegisterType((*L4LbPolicyDeleteResponse)(nil), "pds.L4LbPolicyDeleteResponse")
}

func init() { proto.RegisterFile("l4lb.proto", fileDescriptor_693dda9d07e1878b) }

var fileDescriptor_693dda9d07e1878b = []byte{
	// 897 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x0e, 0x25, 0xdb, 0x52, 0x46, 0xb2, 0x25, 0x8d, 0x1d, 0x9b, 0x51, 0x5d, 0x4b, 0x20, 0x8a,
	0x42, 0x48, 0x55, 0x15, 0x55, 0x8d, 0x1e, 0xe2, 0x00, 0x81, 0xa9, 0x18, 0x0d, 0x5b, 0x27, 0x66,
	0x69, 0x27, 0x40, 0x4f, 0x01, 0x45, 0x2e, 0x60, 0x35, 0x94, 0xc8, 0x92, 0x6b, 0x37, 0x7a, 0x95,
	0x3e, 0x43, 0x8f, 0x7d, 0x84, 0x1e, 0x7a, 0x29, 0x90, 0x27, 0x10, 0x0a, 0x1f, 0x7d, 0xcc, 0x13,
	0x14, 0x1c, 0xfe, 0x2d, 0x25, 0x16, 0x0d, 0x7c, 0x31, 0xb8, 0xdf, 0xcc, 0xf7, 0xed, 0xec, 0x7c,
	0xb3, 0x6b, 0x01, 0x38, 0x87, 0xce, 0x78, 0xe0, 0xf9, 0x2e, 0x77, 0xb1, 0xec, 0xd9, 0x41, 0xbb,
	0x31, 0x65, 0xdc, 0xfc, 0x2a, 0xfc, 0x13, 0xa1, 0xed, 0x1a, 0x9f, 0x7b, 0x2c, 0x88, 0x16, 0x8a,
	0x0b, 0x15, 0xd5, 0xb4, 0xde, 0xb2, 0x99, 0x8d, 0x2a, 0xdc, 0x8f, 0x3f, 0x35, 0x5d, 0x96, 0xba,
	0x52, 0xaf, 0x36, 0x6c, 0x0e, 0xa2, 0x5c, 0x4d, 0x3f, 0xb6, 0x6d, 0x9f, 0x05, 0x81, 0x8a, 0x1f,
	0x16, 0x9d, 0xad, 0x50, 0xec, 0xf1, 0xd4, 0x9c, 0xd9, 0x26, 0x77, 0xfd, 0xb9, 0x91, 0xd1, 0xb0,
	0x0b, 0xb5, 0x78, 0xa1, 0xbb, 0x3e, 0x97, 0x4b, 0x5d, 0xa9, 0xb7, 0x69, 0x88, 0x90, 0xf2, 0xa7,
	0x04, 0x18, 0xaf, 0x9f, 0x33, 0xd3, 0xe1, 0x97, 0xa3, 0x4b, 0x66, 0xbd, 0xc5, 0x7d, 0xb8, 0xaf,
	0xfb, 0xee, 0x98, 0x11, 0x2d, 0xdc, 0xbc, 0x62, 0x64, 0x00, 0x3e, 0x81, 0xcd, 0x68, 0x11, 0xd6,
	0x6c, 0xb9, 0x0e, 0x09, 0x6f, 0x0d, 0x77, 0x07, 0x9e, 0x1d, 0x0c, 0x4e, 0x0f, 0x4f, 0xd5, 0x5c,
	0xd4, 0xc8, 0x27, 0xe3, 0x67, 0x31, 0x5b, 0x9b, 0x71, 0xe6, 0x5f, 0x9b, 0x8e, 0x5c, 0x26, 0xfd,
	0x3c, 0x88, 0x7d, 0x68, 0x11, 0x10, 0xe8, 0xcc, 0x4f, 0x33, 0xd7, 0x28, 0x73, 0x35, 0xa0, 0xfc,
	0x5e, 0x86, 0xad, 0xd3, 0xc3, 0xd3, 0xb1, 0xee, 0x3a, 0x13, 0x6b, 0x7e, 0xee, 0x31, 0x0b, 0xfb,
	0x50, 0xd2, 0x6c, 0xaa, 0xbd, 0xae, 0xee, 0x7f, 0x58, 0x74, 0xe4, 0x7c, 0x9b, 0xfa, 0x93, 0xe9,
	0xf4, 0x8a, 0x9b, 0x63, 0x87, 0x19, 0x25, 0xcd, 0xc6, 0x1e, 0xac, 0xbf, 0xd6, 0x47, 0x9a, 0x4d,
	0x47, 0xa9, 0x17, 0xf6, 0x35, 0x4a, 0x08, 0x7d, 0x39, 0x67, 0xfe, 0xf5, 0xc4, 0x62, 0x9a, 0x4e,
	0xa5, 0x7f, 0xb4, 0x2f, 0x29, 0x0d, 0x4f, 0x00, 0x34, 0x3d, 0xed, 0xde, 0x1a, 0x75, 0xaf, 0x25,
	0x76, 0x8f, 0x02, 0x85, 0x2a, 0x02, 0x31, 0xb4, 0x37, 0xd6, 0x24, 0x9f, 0xd6, 0x23, 0x7b, 0x05,
	0x08, 0xdb, 0x50, 0xd5, 0x7d, 0xf7, 0xdd, 0xfc, 0xd8, 0xd0, 0xe5, 0x8d, 0xae, 0xd4, 0xab, 0x1a,
	0xe9, 0x1a, 0x9f, 0x40, 0x35, 0x76, 0x3e, 0x90, 0x2b, 0xdd, 0x72, 0xaf, 0x36, 0xac, 0x53, 0x09,
	0x31, 0x58, 0xb8, 0x7b, 0xca, 0xc0, 0x23, 0xa8, 0x0b, 0x03, 0x13, 0xc8, 0x55, 0xea, 0xc4, 0x9e,
	0xa8, 0x20, 0xc4, 0x8d, 0x5c, 0xb2, 0x82, 0xd0, 0x14, 0xdc, 0xe2, 0x26, 0xbf, 0x0a, 0x94, 0x16,
	0x34, 0xf2, 0x58, 0xa0, 0xfc, 0x5d, 0x02, 0xc8, 0x30, 0x3c, 0x82, 0xea, 0xc5, 0xdc, 0x63, 0x2f,
	0x18, 0x37, 0xe3, 0x0b, 0xb1, 0x35, 0xa0, 0x8b, 0x94, 0xa0, 0x6a, 0xe3, 0xfd, 0xa2, 0x23, 0xdd,
	0x2e, 0x3a, 0x95, 0xfe, 0x64, 0xe6, 0x4c, 0x66, 0xcc, 0x48, 0x09, 0xf8, 0x14, 0x2a, 0x67, 0xe3,
	0x9f, 0x89, 0x5b, 0x22, 0xee, 0x66, 0xc4, 0x8d, 0x41, 0x75, 0x37, 0xa6, 0xd2, 0x89, 0xfb, 0xee,
	0x74, 0xc2, 0xd9, 0xd4, 0xe3, 0x73, 0x23, 0x61, 0xe1, 0x11, 0xac, 0x85, 0x73, 0x15, 0x5b, 0xbe,
	0x9d, 0xb8, 0x25, 0x8c, 0x9c, 0x8a, 0x21, 0x3f, 0xf0, 0x98, 0x25, 0xf0, 0x89, 0x84, 0x23, 0xd8,
	0x88, 0x8e, 0x49, 0x66, 0xd7, 0x86, 0x0f, 0x96, 0xe9, 0x14, 0x54, 0x77, 0x6e, 0x17, 0x9d, 0x66,
	0x40, 0xdf, 0x82, 0x44, 0x4c, 0xc5, 0xa7, 0xb0, 0x4e, 0x7d, 0x21, 0xa3, 0x6b, 0xc3, 0x9d, 0x02,
	0x8d, 0x40, 0xdd, 0xbe, 0x5d, 0x74, 0x1a, 0xa1, 0x84, 0xa8, 0x10, 0xf1, 0x14, 0x1f, 0x5a, 0x59,
	0xba, 0xc1, 0x7e, 0xb9, 0x62, 0x01, 0xc7, 0x41, 0xf8, 0xce, 0x70, 0xeb, 0x72, 0xc4, 0xdf, 0xf1,
	0xa5, 0x77, 0x26, 0xc5, 0x8d, 0x2c, 0x05, 0xbf, 0x84, 0x4a, 0x4c, 0x95, 0x4b, 0x34, 0x35, 0x45,
	0xad, 0x30, 0x92, 0x1c, 0xe5, 0x57, 0x40, 0x71, 0xcf, 0xc0, 0x73, 0x67, 0x01, 0x0b, 0x37, 0x3d,
	0xf6, 0x26, 0x71, 0x4b, 0x24, 0x9a, 0xff, 0x64, 0xd3, 0x14, 0x37, 0xb2, 0x14, 0xfc, 0x1a, 0xaa,
	0x09, 0x37, 0xde, 0xb5, 0xb8, 0x83, 0x46, 0x9a, 0xa6, 0x7c, 0x0e, 0x3b, 0x59, 0xf4, 0x3b, 0xc6,
	0x93, 0xf3, 0x6e, 0xc5, 0xef, 0x42, 0xb9, 0x57, 0x0f, 0x6f, 0xbe, 0xc2, 0xe1, 0xc1, 0x52, 0xde,
	0x1d, 0x6b, 0xfc, 0x62, 0xa5, 0xc6, 0xc6, 0x52, 0x8d, 0x42, 0x75, 0x3f, 0xc1, 0x5e, 0x86, 0x3f,
	0x63, 0x0e, 0xe3, 0xec, 0xae, 0x86, 0x44, 0x07, 0x2a, 0xa5, 0x07, 0xfa, 0x1e, 0xe4, 0x55, 0xe9,
	0xe2, 0x33, 0x95, 0xff, 0xe7, 0x4c, 0x8f, 0x7e, 0x80, 0xba, 0xf8, 0x22, 0xe1, 0x36, 0x5d, 0x52,
	0xf5, 0x8d, 0x6e, 0x9c, 0x5d, 0x9c, 0xbd, 0x79, 0x79, 0xf6, 0xf2, 0xa4, 0x79, 0x0f, 0x91, 0xde,
	0xde, 0x04, 0xbc, 0x18, 0xe9, 0xcd, 0x8d, 0x25, 0xec, 0xd5, 0x33, 0xbd, 0xd9, 0x7a, 0xf4, 0x9b,
	0x44, 0xf3, 0x97, 0xff, 0xef, 0x80, 0x0f, 0xa9, 0xff, 0x94, 0xa9, 0x9e, 0xe4, 0x85, 0x8b, 0x42,
	0xda, 0xe8, 0x85, 0xde, 0x94, 0x50, 0x26, 0x77, 0xf3, 0xa1, 0x68, 0xe7, 0xa2, 0x08, 0xed, 0x8f,
	0x9f, 0x50, 0xcf, 0x57, 0xe5, 0x5e, 0x7f, 0xdb, 0x7c, 0x3c, 0xfc, 0xa3, 0x04, 0x95, 0xb0, 0x6d,
	0xe7, 0xd7, 0x16, 0x9e, 0x88, 0xcf, 0xd3, 0xc8, 0x67, 0x26, 0x67, 0xb8, 0xbb, 0xec, 0x65, 0xe4,
	0x56, 0x7b, 0x6f, 0x05, 0x8f, 0x1d, 0xbe, 0x97, 0x97, 0x79, 0xe5, 0xd9, 0x77, 0x94, 0x79, 0x0e,
	0x9b, 0xb9, 0x01, 0xc5, 0x87, 0x4b, 0xb9, 0xd9, 0x70, 0xb7, 0xdb, 0x45, 0xa1, 0x54, 0xe9, 0x47,
	0xb1, 0xa0, 0x68, 0x32, 0x70, 0x7f, 0x89, 0x91, 0x9b, 0xc5, 0xf6, 0xa7, 0xff, 0x11, 0x4d, 0x24,
	0xd5, 0xfa, 0x5f, 0x37, 0x07, 0xd2, 0xfb, 0x9b, 0x03, 0xe9, 0x9f, 0x9b, 0x03, 0x69, 0xbc, 0x41,
	0xbf, 0x62, 0xbe, 0xf9, 0x37, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x31, 0x73, 0x49, 0xf6, 0x08, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// L4LbSvcClient is the client API for L4LbSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type L4LbSvcClient interface {
	L4LbPolicyCreate(ctx context.Context, in *L4LbPolicyRequest, opts ...grpc.CallOption) (*L4LbPolicyResponse, error)
	L4LbPolicyUpdate(ctx context.Context, in *L4LbPolicyRequest, opts ...grpc.CallOption) (*L4LbPolicyResponse, error)
	L4LbPolicyGet(ctx context.Context, in *L4LbPolicyGetRequest, opts ...grpc.CallOption) (*L4LbPolicyGetResponse, error)
	L4LbPolicyDelete(ctx context.Context, in *L4LbPolicyDeleteRequest, opts ...grpc.CallOption) (*L4LbPolicyDeleteResponse, error)
}

type l4LbSvcClient struct {
	cc *grpc.ClientConn
}

func NewL4LbSvcClient(cc *grpc.ClientConn) L4LbSvcClient {
	return &l4LbSvcClient{cc}
}

func (c *l4LbSvcClient) L4LbPolicyCreate(ctx context.Context, in *L4LbPolicyRequest, opts ...grpc.CallOption) (*L4LbPolicyResponse, error) {
	out := new(L4LbPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.L4LbSvc/L4LbPolicyCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l4LbSvcClient) L4LbPolicyUpdate(ctx context.Context, in *L4LbPolicyRequest, opts ...grpc.CallOption) (*L4LbPolicyResponse, error) {
	out := new(L4LbPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.L4LbSvc/L4LbPolicyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l4LbSvcClient) L4LbPolicyGet(ctx context.Context, in *L4LbPolicyGetRequest, opts ...grpc.CallOption) (*L4LbPolicyGetResponse, error) {
	out := new(L4LbPolicyGetResponse)
	err := c.cc.Invoke(ctx, "/pds.L4LbSvc/L4LbPolicyGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *l4LbSvcClient) L4LbPolicyDelete(ctx context.Context, in *L4LbPolicyDeleteRequest, opts ...grpc.CallOption) (*L4LbPolicyDeleteResponse, error) {
	out := new(L4LbPolicyDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.L4LbSvc/L4LbPolicyDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// L4LbSvcServer is the server API for L4LbSvc service.
type L4LbSvcServer interface {
	L4LbPolicyCreate(context.Context, *L4LbPolicyRequest) (*L4LbPolicyResponse, error)
	L4LbPolicyUpdate(context.Context, *L4LbPolicyRequest) (*L4LbPolicyResponse, error)
	L4LbPolicyGet(context.Context, *L4LbPolicyGetRequest) (*L4LbPolicyGetResponse, error)
	L4LbPolicyDelete(context.Context, *L4LbPolicyDeleteRequest) (*L4LbPolicyDeleteResponse, error)
}

// UnimplementedL4LbSvcServer can be embedded to have forward compatible implementations.
type UnimplementedL4LbSvcServer struct {
}

func (*UnimplementedL4LbSvcServer) L4LbPolicyCreate(ctx context.Context, req *L4LbPolicyRequest) (*L4LbPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method L4LbPolicyCreate not implemented")
}
func (*UnimplementedL4LbSvcServer) L4LbPolicyUpdate(ctx context.Context, req *L4LbPolicyRequest) (*L4LbPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method L4LbPolicyUpdate not implemented")
}
func (*UnimplementedL4LbSvcServer) L4LbPolicyGet(ctx context.Context, req *L4LbPolicyGetRequest) (*L4LbPolicyGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method L4LbPolicyGet not implemented")
}
func (*UnimplementedL4LbSvcServer) L4LbPolicyDelete(ctx context.Context, req *L4LbPolicyDeleteRequest) (*L4LbPolicyDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method L4LbPolicyDelete not implemented")
}

func RegisterL4LbSvcServer(s *grpc.Server, srv L4LbSvcServer) {
	s.RegisterService(&_L4LbSvc_serviceDesc, srv)
}

func _L4LbSvc_L4LbPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L4LbPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L4LbSvcServer).L4LbPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.L4LbSvc/L4LbPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L4LbSvcServer).L4LbPolicyCreate(ctx, req.(*L4LbPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _L4LbSvc_L4LbPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L4LbPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L4LbSvcServer).L4LbPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.L4LbSvc/L4LbPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L4LbSvcServer).L4LbPolicyUpdate(ctx, req.(*L4LbPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _L4LbSvc_L4LbPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L4LbPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L4LbSvcServer).L4LbPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.L4LbSvc/L4LbPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L4LbSvcServer).L4LbPolicyGet(ctx, req.(*L4LbPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _L4LbSvc_L4LbPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L4LbPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(L4LbSvcServer).L4LbPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.L4LbSvc/L4LbPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(L4LbSvcServer).L4LbPolicyDelete(ctx, req.(*L4LbPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _L4LbSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.L4LbSvc",
	HandlerType: (*L4LbSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "L4LbPolicyCreate",
			Handler:    _L4LbSvc_L4LbPolicyCreate_Handler,
		},
		{
			MethodName: "L4LbPolicyUpdate",
			Handler:    _L4LbSvc_L4LbPolicyUpdate_Handler,
		},
		{
			MethodName: "L4LbPolicyGet",
			Handler:    _L4LbSvc_L4LbPolicyGet_Handler,
		},
		{
			MethodName: "L4LbPolicyDelete",
			Handler:    _L4LbSvc_L4LbPolicyDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "l4lb.proto",
}

func (m *Backend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Backend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BackendPort != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.BackendPort))
		i--
		dAtA[i] = 0x10
	}
	if m.BackendIP != nil {
		{
			size, err := m.BackendIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BackendHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackendHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackendHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProbesPerInterval != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbesPerInterval))
		i--
		dAtA[i] = 0x25
	}
	if m.ProbeInterval != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbeInterval))
		i--
		dAtA[i] = 0x1d
	}
	if m.ProbeProtocol != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ProbeProtocol))
		i--
		dAtA[i] = 0x10
	}
	if m.ProbePort != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ProbePort))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HealthChecks != nil {
		{
			size, err := m.HealthChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Backends) > 0 {
		for iNdEx := len(m.Backends) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Backends[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintL4Lb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ProxyARP {
		i--
		if m.ProxyARP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ServicePort != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ServicePort))
		i--
		dAtA[i] = 0x28
	}
	if m.IPProtocol != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.IPProtocol))
		i--
		dAtA[i] = 0x20
	}
	if m.ServiceIP != nil {
		{
			size, err := m.ServiceIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintL4Lb(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintL4Lb(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintL4Lb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintL4Lb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintL4Lb(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintL4Lb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintL4Lb(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintL4Lb(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintL4Lb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L4LbPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4LbPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4LbPolicyDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA12 := make([]byte, len(m.ApiStatus)*10)
		var j11 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintL4Lb(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintL4Lb(dAtA []byte, offset int, v uint64) int {
	offset -= sovL4Lb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Backend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BackendIP != nil {
		l = m.BackendIP.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.BackendPort != 0 {
		n += 1 + sovL4Lb(uint64(m.BackendPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackendHealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProbePort != 0 {
		n += 5
	}
	if m.ProbeProtocol != 0 {
		n += 1 + sovL4Lb(uint64(m.ProbeProtocol))
	}
	if m.ProbeInterval != 0 {
		n += 5
	}
	if m.ProbesPerInterval != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovL4Lb(uint64(l))
	}
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.ServiceIP != nil {
		l = m.ServiceIP.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.IPProtocol != 0 {
		n += 1 + sovL4Lb(uint64(m.IPProtocol))
	}
	if m.ServicePort != 0 {
		n += 1 + sovL4Lb(uint64(m.ServicePort))
	}
	if m.ProxyARP {
		n += 2
	}
	if len(m.Backends) > 0 {
		for _, e := range m.Backends {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.HealthChecks != nil {
		l = m.HealthChecks.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovL4Lb(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovL4Lb(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovL4Lb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L4LbPolicyDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovL4Lb(uint64(e))
		}
		n += 1 + sovL4Lb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovL4Lb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozL4Lb(x uint64) (n int) {
	return sovL4Lb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Backend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Backend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Backend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackendIP == nil {
				m.BackendIP = &IPAddress{}
			}
			if err := m.BackendIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendPort", wireType)
			}
			m.BackendPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackendPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackendHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackendHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackendHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbePort", wireType)
			}
			m.ProbePort = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbePort = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeProtocol", wireType)
			}
			m.ProbeProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeProtocol |= L4LBProbeProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeInterval", wireType)
			}
			m.ProbeInterval = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbeInterval = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbesPerInterval", wireType)
			}
			m.ProbesPerInterval = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbesPerInterval = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceIP == nil {
				m.ServiceIP = &IPAddress{}
			}
			if err := m.ServiceIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProtocol", wireType)
			}
			m.IPProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProtocol |= L4LBProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyARP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProxyARP = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backends = append(m.Backends, &Backend{})
			if err := m.Backends[len(m.Backends)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthChecks == nil {
				m.HealthChecks = &BackendHealthCheck{}
			}
			if err := m.HealthChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &L4LbPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &L4LbPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &L4LbPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &L4LbPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &L4LbPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthL4Lb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthL4Lb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4LbPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4LbPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4LbPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthL4Lb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthL4Lb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowL4Lb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipL4Lb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthL4Lb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipL4Lb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowL4Lb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowL4Lb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthL4Lb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthL4Lb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowL4Lb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipL4Lb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthL4Lb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthL4Lb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowL4Lb   = fmt.Errorf("proto: integer overflow")
)
