// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: session.proto

package pds

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Flow struct {
	Key                  *FlowKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Vpc                  uint32   `protobuf:"varint,2,opt,name=Vpc,proto3" json:"Vpc,omitempty"`
	FlowRole             uint32   `protobuf:"varint,3,opt,name=FlowRole,proto3" json:"FlowRole,omitempty"`
	SessionIdx           uint32   `protobuf:"varint,4,opt,name=SessionIdx,proto3" json:"SessionIdx,omitempty"`
	Epoch                uint32   `protobuf:"varint,5,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{0}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return m.Size()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetKey() *FlowKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Flow) GetVpc() uint32 {
	if m != nil {
		return m.Vpc
	}
	return 0
}

func (m *Flow) GetFlowRole() uint32 {
	if m != nil {
		return m.FlowRole
	}
	return 0
}

func (m *Flow) GetSessionIdx() uint32 {
	if m != nil {
		return m.SessionIdx
	}
	return 0
}

func (m *Flow) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type FlowMsg struct {
	FlowEntryCount       uint32   `protobuf:"varint,1,opt,name=FlowEntryCount,proto3" json:"FlowEntryCount,omitempty"`
	FlowEntry            *Flow    `protobuf:"bytes,2,opt,name=FlowEntry,proto3" json:"FlowEntry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowMsg) Reset()         { *m = FlowMsg{} }
func (m *FlowMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMsg) ProtoMessage()    {}
func (*FlowMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{1}
}
func (m *FlowMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowMsg.Merge(m, src)
}
func (m *FlowMsg) XXX_Size() int {
	return m.Size()
}
func (m *FlowMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowMsg.DiscardUnknown(m)
}

var xxx_messageInfo_FlowMsg proto.InternalMessageInfo

func (m *FlowMsg) GetFlowEntryCount() uint32 {
	if m != nil {
		return m.FlowEntryCount
	}
	return 0
}

func (m *FlowMsg) GetFlowEntry() *Flow {
	if m != nil {
		return m.FlowEntry
	}
	return nil
}

type FlowGetRequest struct {
	Summary              bool        `protobuf:"varint,1,opt,name=Summary,proto3" json:"Summary,omitempty"`
	Filter               *FlowFilter `protobuf:"bytes,2,opt,name=Filter,proto3" json:"Filter,omitempty"`
	Alg                  bool        `protobuf:"varint,3,opt,name=Alg,proto3" json:"Alg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FlowGetRequest) Reset()         { *m = FlowGetRequest{} }
func (m *FlowGetRequest) String() string { return proto.CompactTextString(m) }
func (*FlowGetRequest) ProtoMessage()    {}
func (*FlowGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{2}
}
func (m *FlowGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowGetRequest.Merge(m, src)
}
func (m *FlowGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlowGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlowGetRequest proto.InternalMessageInfo

func (m *FlowGetRequest) GetSummary() bool {
	if m != nil {
		return m.Summary
	}
	return false
}

func (m *FlowGetRequest) GetFilter() *FlowFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FlowGetRequest) GetAlg() bool {
	if m != nil {
		return m.Alg
	}
	return false
}

type Session struct {
	InitiatorFlow        *Flow    `protobuf:"bytes,1,opt,name=InitiatorFlow,proto3" json:"InitiatorFlow,omitempty"`
	ResponderFlow        *Flow    `protobuf:"bytes,2,opt,name=ResponderFlow,proto3" json:"ResponderFlow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{3}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetInitiatorFlow() *Flow {
	if m != nil {
		return m.InitiatorFlow
	}
	return nil
}

func (m *Session) GetResponderFlow() *Flow {
	if m != nil {
		return m.ResponderFlow
	}
	return nil
}

type SessionGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Session              []*Session `protobuf:"bytes,2,rep,name=Session,proto3" json:"Session,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SessionGetResponse) Reset()         { *m = SessionGetResponse{} }
func (m *SessionGetResponse) String() string { return proto.CompactTextString(m) }
func (*SessionGetResponse) ProtoMessage()    {}
func (*SessionGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{4}
}
func (m *SessionGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionGetResponse.Merge(m, src)
}
func (m *SessionGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionGetResponse proto.InternalMessageInfo

func (m *SessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SessionGetResponse) GetSession() []*Session {
	if m != nil {
		return m.Session
	}
	return nil
}

type FlowGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Flow                 []*Flow   `protobuf:"bytes,2,rep,name=Flow,proto3" json:"Flow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FlowGetResponse) Reset()         { *m = FlowGetResponse{} }
func (m *FlowGetResponse) String() string { return proto.CompactTextString(m) }
func (*FlowGetResponse) ProtoMessage()    {}
func (*FlowGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{5}
}
func (m *FlowGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowGetResponse.Merge(m, src)
}
func (m *FlowGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *FlowGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FlowGetResponse proto.InternalMessageInfo

func (m *FlowGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowGetResponse) GetFlow() []*Flow {
	if m != nil {
		return m.Flow
	}
	return nil
}

type SessionFilter struct {
	Vpc                  uint32     `protobuf:"varint,1,opt,name=Vpc,proto3" json:"Vpc,omitempty"`
	SrcAddr              *IPAddress `protobuf:"bytes,2,opt,name=SrcAddr,proto3" json:"SrcAddr,omitempty"`
	DstAddr              *IPAddress `protobuf:"bytes,3,opt,name=DstAddr,proto3" json:"DstAddr,omitempty"`
	SrcPort              uint32     `protobuf:"varint,4,opt,name=SrcPort,proto3" json:"SrcPort,omitempty" meta:range:0-65535`
	DstPort              uint32     `protobuf:"varint,5,opt,name=DstPort,proto3" json:"DstPort,omitempty" meta:range:0-65535`
	IPProto              uint32     `protobuf:"varint,6,opt,name=IPProto,proto3" json:"IPProto,omitempty" meta:range:0-255`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SessionFilter) Reset()         { *m = SessionFilter{} }
func (m *SessionFilter) String() string { return proto.CompactTextString(m) }
func (*SessionFilter) ProtoMessage()    {}
func (*SessionFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{6}
}
func (m *SessionFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionFilter.Merge(m, src)
}
func (m *SessionFilter) XXX_Size() int {
	return m.Size()
}
func (m *SessionFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SessionFilter proto.InternalMessageInfo

func (m *SessionFilter) GetVpc() uint32 {
	if m != nil {
		return m.Vpc
	}
	return 0
}

func (m *SessionFilter) GetSrcAddr() *IPAddress {
	if m != nil {
		return m.SrcAddr
	}
	return nil
}

func (m *SessionFilter) GetDstAddr() *IPAddress {
	if m != nil {
		return m.DstAddr
	}
	return nil
}

func (m *SessionFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SessionFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SessionFilter) GetIPProto() uint32 {
	if m != nil {
		return m.IPProto
	}
	return 0
}

type SessionClearResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SessionClearResponse) Reset()         { *m = SessionClearResponse{} }
func (m *SessionClearResponse) String() string { return proto.CompactTextString(m) }
func (*SessionClearResponse) ProtoMessage()    {}
func (*SessionClearResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{7}
}
func (m *SessionClearResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClearResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClearResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionClearResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClearResponse.Merge(m, src)
}
func (m *SessionClearResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionClearResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClearResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClearResponse proto.InternalMessageInfo

func (m *SessionClearResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type SessionClearRequest struct {
	Filter               *SessionFilter `protobuf:"bytes,1,opt,name=Filter,proto3" json:"Filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SessionClearRequest) Reset()         { *m = SessionClearRequest{} }
func (m *SessionClearRequest) String() string { return proto.CompactTextString(m) }
func (*SessionClearRequest) ProtoMessage()    {}
func (*SessionClearRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{8}
}
func (m *SessionClearRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClearRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClearRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionClearRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClearRequest.Merge(m, src)
}
func (m *SessionClearRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionClearRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClearRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClearRequest proto.InternalMessageInfo

func (m *SessionClearRequest) GetFilter() *SessionFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type FlowFilter struct {
	Vpc                  uint32     `protobuf:"varint,1,opt,name=Vpc,proto3" json:"Vpc,omitempty"`
	SrcAddr              *IPAddress `protobuf:"bytes,2,opt,name=SrcAddr,proto3" json:"SrcAddr,omitempty"`
	DstAddr              *IPAddress `protobuf:"bytes,3,opt,name=DstAddr,proto3" json:"DstAddr,omitempty"`
	SrcPort              uint32     `protobuf:"varint,4,opt,name=SrcPort,proto3" json:"SrcPort,omitempty" meta:range:0-65535`
	DstPort              uint32     `protobuf:"varint,5,opt,name=DstPort,proto3" json:"DstPort,omitempty" meta:range:0-65535`
	IPProto              uint32     `protobuf:"varint,6,opt,name=IPProto,proto3" json:"IPProto,omitempty" meta:range:0-255`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *FlowFilter) Reset()         { *m = FlowFilter{} }
func (m *FlowFilter) String() string { return proto.CompactTextString(m) }
func (*FlowFilter) ProtoMessage()    {}
func (*FlowFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{9}
}
func (m *FlowFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowFilter.Merge(m, src)
}
func (m *FlowFilter) XXX_Size() int {
	return m.Size()
}
func (m *FlowFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FlowFilter proto.InternalMessageInfo

func (m *FlowFilter) GetVpc() uint32 {
	if m != nil {
		return m.Vpc
	}
	return 0
}

func (m *FlowFilter) GetSrcAddr() *IPAddress {
	if m != nil {
		return m.SrcAddr
	}
	return nil
}

func (m *FlowFilter) GetDstAddr() *IPAddress {
	if m != nil {
		return m.DstAddr
	}
	return nil
}

func (m *FlowFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *FlowFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *FlowFilter) GetIPProto() uint32 {
	if m != nil {
		return m.IPProto
	}
	return 0
}

type FlowClearResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FlowClearResponse) Reset()         { *m = FlowClearResponse{} }
func (m *FlowClearResponse) String() string { return proto.CompactTextString(m) }
func (*FlowClearResponse) ProtoMessage()    {}
func (*FlowClearResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{10}
}
func (m *FlowClearResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowClearResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowClearResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowClearResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowClearResponse.Merge(m, src)
}
func (m *FlowClearResponse) XXX_Size() int {
	return m.Size()
}
func (m *FlowClearResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowClearResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FlowClearResponse proto.InternalMessageInfo

func (m *FlowClearResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type FlowClearRequest struct {
	Filter               *FlowFilter `protobuf:"bytes,1,opt,name=Filter,proto3" json:"Filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FlowClearRequest) Reset()         { *m = FlowClearRequest{} }
func (m *FlowClearRequest) String() string { return proto.CompactTextString(m) }
func (*FlowClearRequest) ProtoMessage()    {}
func (*FlowClearRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a6be1b361fa6f14, []int{11}
}
func (m *FlowClearRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowClearRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowClearRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowClearRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowClearRequest.Merge(m, src)
}
func (m *FlowClearRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlowClearRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowClearRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlowClearRequest proto.InternalMessageInfo

func (m *FlowClearRequest) GetFilter() *FlowFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func init() {
	proto.RegisterType((*Flow)(nil), "pds.Flow")
	proto.RegisterType((*FlowMsg)(nil), "pds.FlowMsg")
	proto.RegisterType((*FlowGetRequest)(nil), "pds.FlowGetRequest")
	proto.RegisterType((*Session)(nil), "pds.Session")
	proto.RegisterType((*SessionGetResponse)(nil), "pds.SessionGetResponse")
	proto.RegisterType((*FlowGetResponse)(nil), "pds.FlowGetResponse")
	proto.RegisterType((*SessionFilter)(nil), "pds.SessionFilter")
	proto.RegisterType((*SessionClearResponse)(nil), "pds.SessionClearResponse")
	proto.RegisterType((*SessionClearRequest)(nil), "pds.SessionClearRequest")
	proto.RegisterType((*FlowFilter)(nil), "pds.FlowFilter")
	proto.RegisterType((*FlowClearResponse)(nil), "pds.FlowClearResponse")
	proto.RegisterType((*FlowClearRequest)(nil), "pds.FlowClearRequest")
}

func init() { proto.RegisterFile("session.proto", fileDescriptor_3a6be1b361fa6f14) }

var fileDescriptor_3a6be1b361fa6f14 = []byte{
	// 651 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x55, 0xcd, 0x4e, 0x13, 0x51,
	0x14, 0x76, 0x3a, 0x40, 0xe1, 0xb4, 0x85, 0x7a, 0xac, 0x38, 0x36, 0xb1, 0x34, 0xb3, 0x00, 0x42,
	0x62, 0xc1, 0x21, 0xd5, 0x04, 0xdd, 0x14, 0x28, 0xa4, 0x21, 0x26, 0xcd, 0x6d, 0xe2, 0xc2, 0x95,
	0x63, 0xe7, 0x06, 0x1b, 0xa7, 0x33, 0xe3, 0xdc, 0x5b, 0xb5, 0xaf, 0x60, 0xf4, 0xbd, 0x5c, 0xfa,
	0x04, 0xc4, 0xf0, 0x08, 0xec, 0x4d, 0xcc, 0xfd, 0x99, 0xe9, 0x4c, 0x11, 0x17, 0xb8, 0x74, 0xd3,
	0xcc, 0x3d, 0xe7, 0xfb, 0xbe, 0xf3, 0x7b, 0x6f, 0xa1, 0xc2, 0x28, 0x63, 0xa3, 0x30, 0x68, 0x45,
	0x71, 0xc8, 0x43, 0x34, 0x23, 0x8f, 0xd5, 0xd7, 0xc6, 0x94, 0xbb, 0xbb, 0xe2, 0x47, 0x59, 0xeb,
	0x25, 0x3e, 0x8d, 0x28, 0x53, 0x07, 0xfb, 0xab, 0x01, 0x0b, 0x27, 0x7e, 0xf8, 0x09, 0x9b, 0x60,
	0x9e, 0xd1, 0xa9, 0x65, 0x34, 0x8d, 0xed, 0x92, 0xb3, 0xda, 0x52, 0x18, 0xe1, 0x39, 0xa3, 0x53,
	0x22, 0x5c, 0x58, 0x05, 0xf3, 0x55, 0x34, 0xb4, 0x0a, 0x4d, 0x63, 0xbb, 0x42, 0xc4, 0x27, 0xd6,
	0x61, 0x59, 0x20, 0x48, 0xe8, 0x53, 0xcb, 0x94, 0xe6, 0xf4, 0x8c, 0x0d, 0x80, 0x81, 0x4a, 0xa6,
	0xe7, 0x7d, 0xb6, 0x16, 0xa4, 0x37, 0x63, 0xc1, 0x1a, 0x2c, 0x76, 0xa3, 0x70, 0xf8, 0xce, 0x5a,
	0x94, 0x2e, 0x75, 0xb0, 0x5f, 0x43, 0x51, 0x28, 0xbc, 0x64, 0xe7, 0xb8, 0x09, 0xab, 0xe2, 0xb3,
	0x1b, 0xf0, 0x78, 0x7a, 0x14, 0x4e, 0x02, 0x2e, 0x73, 0xab, 0x90, 0x39, 0x2b, 0x6e, 0xc1, 0x4a,
	0x6a, 0x91, 0xc9, 0x95, 0x9c, 0x95, 0x56, 0xe4, 0xa9, 0xe4, 0xc9, 0xcc, 0x67, 0x53, 0x25, 0x78,
	0x4a, 0x39, 0xa1, 0x1f, 0x26, 0x94, 0x71, 0xb4, 0xa0, 0x38, 0x98, 0x8c, 0xc7, 0x6e, 0xac, 0xea,
	0x5e, 0x26, 0xc9, 0x11, 0xb7, 0x60, 0xe9, 0x64, 0xe4, 0x73, 0x1a, 0x6b, 0xc5, 0xb5, 0x54, 0x51,
	0x99, 0x89, 0x76, 0x8b, 0xa6, 0x74, 0xfc, 0x73, 0x59, 0xfd, 0x32, 0x11, 0x9f, 0xf6, 0x7b, 0x28,
	0xea, 0x32, 0x71, 0x17, 0x2a, 0xbd, 0x60, 0xc4, 0x47, 0x2e, 0x0f, 0x63, 0xc1, 0xd5, 0xdd, 0xcd,
	0xa4, 0x97, 0xf7, 0x0b, 0x02, 0xa1, 0x2c, 0x0a, 0x03, 0x8f, 0x2a, 0xc2, 0xb5, 0x7a, 0xf2, 0x7e,
	0xdb, 0x07, 0xd4, 0xc1, 0x64, 0x59, 0xc2, 0xc5, 0x28, 0xb6, 0x60, 0xa5, 0x13, 0x8d, 0x06, 0xdc,
	0xe5, 0x13, 0x26, 0x63, 0xae, 0x3a, 0x55, 0x3d, 0xd1, 0xd4, 0x4e, 0x66, 0x10, 0xdc, 0x4c, 0x53,
	0xb6, 0x0a, 0x4d, 0x73, 0xbb, 0xe4, 0x94, 0x65, 0x40, 0x6d, 0x23, 0x89, 0xd3, 0x7e, 0x03, 0x6b,
	0x69, 0x07, 0x6f, 0x19, 0xea, 0x91, 0x5a, 0x37, 0x1d, 0x27, 0x53, 0x98, 0x34, 0xdb, 0xdf, 0x0a,
	0x50, 0xd1, 0xd1, 0x66, 0x0d, 0x16, 0x5b, 0x67, 0xcc, 0xb6, 0x6e, 0x07, 0x8a, 0x83, 0x78, 0xd8,
	0xf1, 0xbc, 0x64, 0x38, 0x49, 0xc0, 0x5e, 0x5f, 0x18, 0x29, 0x63, 0x24, 0x01, 0x08, 0xec, 0x31,
	0xe3, 0x12, 0x6b, 0xde, 0x84, 0xd5, 0x00, 0xdc, 0x93, 0xba, 0xfd, 0x30, 0xe6, 0x6a, 0x5d, 0x0f,
	0xd7, 0xaf, 0x2e, 0x36, 0x50, 0x5c, 0x9c, 0x83, 0xd8, 0x0d, 0xce, 0xe9, 0xc1, 0xde, 0xe3, 0xa7,
	0xed, 0xf6, 0x7e, 0x9b, 0x24, 0x30, 0xc1, 0x38, 0x66, 0x5c, 0x32, 0x16, 0xff, 0xce, 0xd0, 0x30,
	0x6c, 0x41, 0xb1, 0xd7, 0xef, 0x8b, 0x9b, 0x67, 0x2d, 0x49, 0x46, 0xed, 0xea, 0x62, 0xa3, 0x9a,
	0x63, 0x38, 0xed, 0x36, 0x49, 0x40, 0xf6, 0x09, 0xd4, 0x74, 0x3b, 0x8e, 0x7c, 0xea, 0xc6, 0xb7,
	0x6d, 0xbb, 0xdd, 0x81, 0x7b, 0x79, 0x1d, 0x75, 0x01, 0x76, 0xd2, 0x35, 0x57, 0x9b, 0x89, 0xd9,
	0xb9, 0xe7, 0x37, 0xdd, 0xfe, 0x52, 0x00, 0x98, 0x5d, 0x80, 0xff, 0x7c, 0x2e, 0x47, 0x70, 0x57,
	0xf4, 0xe2, 0xdf, 0x86, 0xf2, 0x1c, 0xaa, 0x19, 0x11, 0x35, 0x91, 0xad, 0xb9, 0x89, 0xdc, 0xf4,
	0xf0, 0x38, 0xbf, 0x8c, 0xf4, 0x81, 0x1d, 0x7c, 0x1c, 0xe2, 0x13, 0xf5, 0x70, 0x9e, 0x52, 0x8e,
	0x65, 0x1d, 0xb3, 0x3b, 0x8e, 0xf8, 0xb4, 0x5e, 0x4b, 0x05, 0x32, 0xd7, 0xd6, 0xbe, 0xb3, 0x67,
	0xe0, 0xb3, 0x54, 0xe0, 0x3a, 0xeb, 0x41, 0x76, 0x11, 0xe6, 0x89, 0x2f, 0xd4, 0x8b, 0x2b, 0xf3,
	0xc6, 0xfb, 0xa9, 0x7e, 0xb6, 0x8e, 0xfa, 0xfa, 0xbc, 0x39, 0xe1, 0x63, 0x17, 0xca, 0xd9, 0x55,
	0x44, 0x2b, 0x1b, 0x2a, 0xa7, 0xf1, 0xf0, 0x0f, 0x9e, 0x44, 0xe6, 0xb0, 0xfc, 0xfd, 0xb2, 0x61,
	0xfc, 0xb8, 0x6c, 0x18, 0x3f, 0x2f, 0x1b, 0xc6, 0xdb, 0x25, 0xf9, 0x6f, 0xb6, 0xff, 0x3b, 0x00,
	0x00, 0xff, 0xff, 0x47, 0xc0, 0x5f, 0xf0, 0x01, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SessionSvcClient is the client API for SessionSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SessionSvcClient interface {
	FlowGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (SessionSvc_FlowGetClient, error)
	SessionGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (SessionSvc_SessionGetClient, error)
	FlowClear(ctx context.Context, in *FlowClearRequest, opts ...grpc.CallOption) (*FlowClearResponse, error)
	SessionClear(ctx context.Context, in *SessionClearRequest, opts ...grpc.CallOption) (*SessionClearResponse, error)
}

type sessionSvcClient struct {
	cc *grpc.ClientConn
}

func NewSessionSvcClient(cc *grpc.ClientConn) SessionSvcClient {
	return &sessionSvcClient{cc}
}

func (c *sessionSvcClient) FlowGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (SessionSvc_FlowGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SessionSvc_serviceDesc.Streams[0], "/pds.SessionSvc/FlowGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionSvcFlowGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionSvc_FlowGetClient interface {
	Recv() (*FlowGetResponse, error)
	grpc.ClientStream
}

type sessionSvcFlowGetClient struct {
	grpc.ClientStream
}

func (x *sessionSvcFlowGetClient) Recv() (*FlowGetResponse, error) {
	m := new(FlowGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionSvcClient) SessionGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (SessionSvc_SessionGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SessionSvc_serviceDesc.Streams[1], "/pds.SessionSvc/SessionGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionSvcSessionGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionSvc_SessionGetClient interface {
	Recv() (*SessionGetResponse, error)
	grpc.ClientStream
}

type sessionSvcSessionGetClient struct {
	grpc.ClientStream
}

func (x *sessionSvcSessionGetClient) Recv() (*SessionGetResponse, error) {
	m := new(SessionGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionSvcClient) FlowClear(ctx context.Context, in *FlowClearRequest, opts ...grpc.CallOption) (*FlowClearResponse, error) {
	out := new(FlowClearResponse)
	err := c.cc.Invoke(ctx, "/pds.SessionSvc/FlowClear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionSvcClient) SessionClear(ctx context.Context, in *SessionClearRequest, opts ...grpc.CallOption) (*SessionClearResponse, error) {
	out := new(SessionClearResponse)
	err := c.cc.Invoke(ctx, "/pds.SessionSvc/SessionClear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionSvcServer is the server API for SessionSvc service.
type SessionSvcServer interface {
	FlowGet(*Empty, SessionSvc_FlowGetServer) error
	SessionGet(*Empty, SessionSvc_SessionGetServer) error
	FlowClear(context.Context, *FlowClearRequest) (*FlowClearResponse, error)
	SessionClear(context.Context, *SessionClearRequest) (*SessionClearResponse, error)
}

// UnimplementedSessionSvcServer can be embedded to have forward compatible implementations.
type UnimplementedSessionSvcServer struct {
}

func (*UnimplementedSessionSvcServer) FlowGet(req *Empty, srv SessionSvc_FlowGetServer) error {
	return status.Errorf(codes.Unimplemented, "method FlowGet not implemented")
}
func (*UnimplementedSessionSvcServer) SessionGet(req *Empty, srv SessionSvc_SessionGetServer) error {
	return status.Errorf(codes.Unimplemented, "method SessionGet not implemented")
}
func (*UnimplementedSessionSvcServer) FlowClear(ctx context.Context, req *FlowClearRequest) (*FlowClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlowClear not implemented")
}
func (*UnimplementedSessionSvcServer) SessionClear(ctx context.Context, req *SessionClearRequest) (*SessionClearResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionClear not implemented")
}

func RegisterSessionSvcServer(s *grpc.Server, srv SessionSvcServer) {
	s.RegisterService(&_SessionSvc_serviceDesc, srv)
}

func _SessionSvc_FlowGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionSvcServer).FlowGet(m, &sessionSvcFlowGetServer{stream})
}

type SessionSvc_FlowGetServer interface {
	Send(*FlowGetResponse) error
	grpc.ServerStream
}

type sessionSvcFlowGetServer struct {
	grpc.ServerStream
}

func (x *sessionSvcFlowGetServer) Send(m *FlowGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SessionSvc_SessionGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionSvcServer).SessionGet(m, &sessionSvcSessionGetServer{stream})
}

type SessionSvc_SessionGetServer interface {
	Send(*SessionGetResponse) error
	grpc.ServerStream
}

type sessionSvcSessionGetServer struct {
	grpc.ServerStream
}

func (x *sessionSvcSessionGetServer) Send(m *SessionGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SessionSvc_FlowClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionSvcServer).FlowClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SessionSvc/FlowClear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionSvcServer).FlowClear(ctx, req.(*FlowClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionSvc_SessionClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionSvcServer).SessionClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.SessionSvc/SessionClear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionSvcServer).SessionClear(ctx, req.(*SessionClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SessionSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.SessionSvc",
	HandlerType: (*SessionSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FlowClear",
			Handler:    _SessionSvc_FlowClear_Handler,
		},
		{
			MethodName: "SessionClear",
			Handler:    _SessionSvc_SessionClear_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FlowGet",
			Handler:       _SessionSvc_FlowGet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SessionGet",
			Handler:       _SessionSvc_SessionGet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "session.proto",
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x28
	}
	if m.SessionIdx != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.SessionIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.FlowRole != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.FlowRole))
		i--
		dAtA[i] = 0x18
	}
	if m.Vpc != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.Vpc))
		i--
		dAtA[i] = 0x10
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FlowEntry != nil {
		{
			size, err := m.FlowEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FlowEntryCount != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.FlowEntryCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Alg {
		i--
		if m.Alg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Summary {
		i--
		if m.Summary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResponderFlow != nil {
		{
			size, err := m.ResponderFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.InitiatorFlow != nil {
		{
			size, err := m.InitiatorFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Session) > 0 {
		for iNdEx := len(m.Session) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Session[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSession(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Flow) > 0 {
		for iNdEx := len(m.Flow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSession(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPProto != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.IPProto))
		i--
		dAtA[i] = 0x30
	}
	if m.DstPort != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x28
	}
	if m.SrcPort != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x20
	}
	if m.DstAddr != nil {
		{
			size, err := m.DstAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcAddr != nil {
		{
			size, err := m.SrcAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Vpc != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.Vpc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionClearResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClearResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionClearResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionClearRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClearRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionClearRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPProto != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.IPProto))
		i--
		dAtA[i] = 0x30
	}
	if m.DstPort != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x28
	}
	if m.SrcPort != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x20
	}
	if m.DstAddr != nil {
		{
			size, err := m.DstAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcAddr != nil {
		{
			size, err := m.SrcAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Vpc != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.Vpc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowClearResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowClearResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowClearResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintSession(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowClearRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowClearRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowClearRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSession(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSession(dAtA []byte, offset int, v uint64) int {
	offset -= sovSession(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Flow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Vpc != 0 {
		n += 1 + sovSession(uint64(m.Vpc))
	}
	if m.FlowRole != 0 {
		n += 1 + sovSession(uint64(m.FlowRole))
	}
	if m.SessionIdx != 0 {
		n += 1 + sovSession(uint64(m.SessionIdx))
	}
	if m.Epoch != 0 {
		n += 1 + sovSession(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowEntryCount != 0 {
		n += 1 + sovSession(uint64(m.FlowEntryCount))
	}
	if m.FlowEntry != nil {
		l = m.FlowEntry.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Summary {
		n += 2
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.Alg {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitiatorFlow != nil {
		l = m.InitiatorFlow.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.ResponderFlow != nil {
		l = m.ResponderFlow.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if len(m.Session) > 0 {
		for _, e := range m.Session {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if len(m.Flow) > 0 {
		for _, e := range m.Flow {
			l = e.Size()
			n += 1 + l + sovSession(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vpc != 0 {
		n += 1 + sovSession(uint64(m.Vpc))
	}
	if m.SrcAddr != nil {
		l = m.SrcAddr.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.DstAddr != nil {
		l = m.DstAddr.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovSession(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovSession(uint64(m.DstPort))
	}
	if m.IPProto != 0 {
		n += 1 + sovSession(uint64(m.IPProto))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClearResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClearRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vpc != 0 {
		n += 1 + sovSession(uint64(m.Vpc))
	}
	if m.SrcAddr != nil {
		l = m.SrcAddr.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.DstAddr != nil {
		l = m.DstAddr.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovSession(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovSession(uint64(m.DstPort))
	}
	if m.IPProto != 0 {
		n += 1 + sovSession(uint64(m.IPProto))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowClearResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovSession(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowClearRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovSession(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSession(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSession(x uint64) (n int) {
	return sovSession(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &FlowKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			m.Vpc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vpc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRole", wireType)
			}
			m.FlowRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowRole |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdx", wireType)
			}
			m.SessionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowEntryCount", wireType)
			}
			m.FlowEntryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowEntryCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowEntry == nil {
				m.FlowEntry = &Flow{}
			}
			if err := m.FlowEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Summary = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &FlowFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alg = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorFlow == nil {
				m.InitiatorFlow = &Flow{}
			}
			if err := m.InitiatorFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponderFlow == nil {
				m.ResponderFlow = &Flow{}
			}
			if err := m.ResponderFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Session = append(m.Session, &Session{})
			if err := m.Session[len(m.Session)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = append(m.Flow, &Flow{})
			if err := m.Flow[len(m.Flow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			m.Vpc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vpc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcAddr == nil {
				m.SrcAddr = &IPAddress{}
			}
			if err := m.SrcAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAddr == nil {
				m.DstAddr = &IPAddress{}
			}
			if err := m.DstAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProto", wireType)
			}
			m.IPProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProto |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClearResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClearResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClearResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClearRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClearRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClearRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &SessionFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			m.Vpc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vpc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcAddr == nil {
				m.SrcAddr = &IPAddress{}
			}
			if err := m.SrcAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAddr == nil {
				m.DstAddr = &IPAddress{}
			}
			if err := m.DstAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProto", wireType)
			}
			m.IPProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProto |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowClearResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowClearResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowClearResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowClearRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowClearRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowClearRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSession
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSession
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &FlowFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSession(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSession
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSession
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSession
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSession
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSession(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSession
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSession = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSession   = fmt.Errorf("proto: integer overflow")
)
