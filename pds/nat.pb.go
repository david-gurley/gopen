// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto

package pds

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NatPool struct {
	Addresses            []*Address `protobuf:"bytes,1,rep,name=Addresses,proto3" json:"Addresses,omitempty" meta:mandatory`
	Ports                *PortRange `protobuf:"bytes,2,opt,name=Ports,proto3" json:"Ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NatPool) Reset()         { *m = NatPool{} }
func (m *NatPool) String() string { return proto.CompactTextString(m) }
func (*NatPool) ProtoMessage()    {}
func (*NatPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{0}
}
func (m *NatPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPool.Merge(m, src)
}
func (m *NatPool) XXX_Size() int {
	return m.Size()
}
func (m *NatPool) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPool.DiscardUnknown(m)
}

var xxx_messageInfo_NatPool proto.InternalMessageInfo

func (m *NatPool) GetAddresses() []*Address {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *NatPool) GetPorts() *PortRange {
	if m != nil {
		return m.Ports
	}
	return nil
}

type NatRuleAction struct {
	// source NAT action
	SrcNatAction NatAction `protobuf:"varint,1,opt,name=SrcNatAction,proto3,enum=types.NatAction" json:"SrcNatAction,omitempty"`
	// NAT pool to use
	NatPool              *NatPool `protobuf:"bytes,2,opt,name=NatPool,proto3" json:"NatPool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatRuleAction) Reset()         { *m = NatRuleAction{} }
func (m *NatRuleAction) String() string { return proto.CompactTextString(m) }
func (*NatRuleAction) ProtoMessage()    {}
func (*NatRuleAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{1}
}
func (m *NatRuleAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatRuleAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatRuleAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatRuleAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatRuleAction.Merge(m, src)
}
func (m *NatRuleAction) XXX_Size() int {
	return m.Size()
}
func (m *NatRuleAction) XXX_DiscardUnknown() {
	xxx_messageInfo_NatRuleAction.DiscardUnknown(m)
}

var xxx_messageInfo_NatRuleAction proto.InternalMessageInfo

func (m *NatRuleAction) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_ACTION_NONE
}

func (m *NatRuleAction) GetNatPool() *NatPool {
	if m != nil {
		return m.NatPool
	}
	return nil
}

type NatRule struct {
	// unique NAT rule id
	Id uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// rule match criteria
	Match *RuleMatch `protobuf:"bytes,2,opt,name=Match,proto3" json:"Match,omitempty"`
	// NAT rule action
	Action               *NatRuleAction `protobuf:"bytes,3,opt,name=Action,proto3" json:"Action,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NatRule) Reset()         { *m = NatRule{} }
func (m *NatRule) String() string { return proto.CompactTextString(m) }
func (*NatRule) ProtoMessage()    {}
func (*NatRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{2}
}
func (m *NatRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatRule.Merge(m, src)
}
func (m *NatRule) XXX_Size() int {
	return m.Size()
}
func (m *NatRule) XXX_DiscardUnknown() {
	xxx_messageInfo_NatRule.DiscardUnknown(m)
}

var xxx_messageInfo_NatRule proto.InternalMessageInfo

func (m *NatRule) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NatRule) GetMatch() *RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *NatRule) GetAction() *NatRuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

type NatPolicySpec struct {
	// unique identifier of NAT policy
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// IPv4 or IPv6 policy
	AddrFamily IPAF `protobuf:"varint,2,opt,name=AddrFamily,proto3,enum=types.IPAF" json:"AddrFamily,omitempty" meta:mandatory`
	// direction in which the policy should be enforced
	Direction RuleDir `protobuf:"varint,3,opt,name=Direction,proto3,enum=types.RuleDir" json:"Direction,omitempty" meta:mandatory`
	// list of NAT rules
	Rules                []*NatRule `protobuf:"bytes,4,rep,name=Rules,proto3" json:"Rules,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NatPolicySpec) Reset()         { *m = NatPolicySpec{} }
func (m *NatPolicySpec) String() string { return proto.CompactTextString(m) }
func (*NatPolicySpec) ProtoMessage()    {}
func (*NatPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{3}
}
func (m *NatPolicySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicySpec.Merge(m, src)
}
func (m *NatPolicySpec) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicySpec.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicySpec proto.InternalMessageInfo

func (m *NatPolicySpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NatPolicySpec) GetAddrFamily() IPAF {
	if m != nil {
		return m.AddrFamily
	}
	return IPAF_IP_AF_NONE
}

func (m *NatPolicySpec) GetDirection() RuleDir {
	if m != nil {
		return m.Direction
	}
	return RuleDir_RULE_DIR_NONE
}

func (m *NatPolicySpec) GetRules() []*NatRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// operational status of NAT policy, if any
type NatPolicyStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPolicyStatus) Reset()         { *m = NatPolicyStatus{} }
func (m *NatPolicyStatus) String() string { return proto.CompactTextString(m) }
func (*NatPolicyStatus) ProtoMessage()    {}
func (*NatPolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{4}
}
func (m *NatPolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyStatus.Merge(m, src)
}
func (m *NatPolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyStatus proto.InternalMessageInfo

// stats of NAT policy, if any
type NatPolicyStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPolicyStats) Reset()         { *m = NatPolicyStats{} }
func (m *NatPolicyStats) String() string { return proto.CompactTextString(m) }
func (*NatPolicyStats) ProtoMessage()    {}
func (*NatPolicyStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{5}
}
func (m *NatPolicyStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyStats.Merge(m, src)
}
func (m *NatPolicyStats) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyStats.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyStats proto.InternalMessageInfo

// NAT policy object
type NatPolicy struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *NatPolicySpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *NatPolicyStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *NatPolicyStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NatPolicy) Reset()         { *m = NatPolicy{} }
func (m *NatPolicy) String() string { return proto.CompactTextString(m) }
func (*NatPolicy) ProtoMessage()    {}
func (*NatPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{6}
}
func (m *NatPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicy.Merge(m, src)
}
func (m *NatPolicy) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicy proto.InternalMessageInfo

func (m *NatPolicy) GetSpec() *NatPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatPolicy) GetStatus() *NatPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatPolicy) GetStats() *NatPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NAT policy create and update request
type NatPolicyRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt       `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*NatPolicySpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NatPolicyRequest) Reset()         { *m = NatPolicyRequest{} }
func (m *NatPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*NatPolicyRequest) ProtoMessage()    {}
func (*NatPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{7}
}
func (m *NatPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyRequest.Merge(m, src)
}
func (m *NatPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyRequest proto.InternalMessageInfo

func (m *NatPolicyRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NatPolicyRequest) GetRequest() []*NatPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NAT policy create and update response
type NatPolicyResponse struct {
	ApiStatus            ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*NatPolicyStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *NatPolicyResponse) Reset()         { *m = NatPolicyResponse{} }
func (m *NatPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*NatPolicyResponse) ProtoMessage()    {}
func (*NatPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{8}
}
func (m *NatPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyResponse.Merge(m, src)
}
func (m *NatPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyResponse proto.InternalMessageInfo

func (m *NatPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyResponse) GetResponse() []*NatPolicyStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// NAT policy get request
type NatPolicyGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPolicyGetRequest) Reset()         { *m = NatPolicyGetRequest{} }
func (m *NatPolicyGetRequest) String() string { return proto.CompactTextString(m) }
func (*NatPolicyGetRequest) ProtoMessage()    {}
func (*NatPolicyGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{9}
}
func (m *NatPolicyGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyGetRequest.Merge(m, src)
}
func (m *NatPolicyGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyGetRequest proto.InternalMessageInfo

func (m *NatPolicyGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// NAT policy get response
type NatPolicyGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*NatPolicy `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NatPolicyGetResponse) Reset()         { *m = NatPolicyGetResponse{} }
func (m *NatPolicyGetResponse) String() string { return proto.CompactTextString(m) }
func (*NatPolicyGetResponse) ProtoMessage()    {}
func (*NatPolicyGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{10}
}
func (m *NatPolicyGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyGetResponse.Merge(m, src)
}
func (m *NatPolicyGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyGetResponse proto.InternalMessageInfo

func (m *NatPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPolicyGetResponse) GetResponse() []*NatPolicy {
	if m != nil {
		return m.Response
	}
	return nil
}

// NAT policy delete request
type NatPolicyDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NatPolicyDeleteRequest) Reset()         { *m = NatPolicyDeleteRequest{} }
func (m *NatPolicyDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NatPolicyDeleteRequest) ProtoMessage()    {}
func (*NatPolicyDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{11}
}
func (m *NatPolicyDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyDeleteRequest.Merge(m, src)
}
func (m *NatPolicyDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyDeleteRequest proto.InternalMessageInfo

func (m *NatPolicyDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NatPolicyDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// NAT policy delete response
type NatPolicyDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NatPolicyDeleteResponse) Reset()         { *m = NatPolicyDeleteResponse{} }
func (m *NatPolicyDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NatPolicyDeleteResponse) ProtoMessage()    {}
func (*NatPolicyDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{12}
}
func (m *NatPolicyDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPolicyDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPolicyDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPolicyDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPolicyDeleteResponse.Merge(m, src)
}
func (m *NatPolicyDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPolicyDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPolicyDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPolicyDeleteResponse proto.InternalMessageInfo

func (m *NatPolicyDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// NAT port block specification
type NatPortBlockSpec struct {
	// unique key identifying the port block
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// VPC identifier this port block is tied to
	VpcId []byte `protobuf:"bytes,2,opt,name=VpcId,proto3" json:"VpcId,omitempty"`
	// IP protocol this port block is to be used for
	Protocol uint32 `protobuf:"varint,3,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	// NAT address to be used with this port block
	NatAddress *Address `protobuf:"bytes,4,opt,name=NatAddress,proto3" json:"NatAddress,omitempty"`
	// range of ports to be use for NAT
	Ports *PortRange `protobuf:"bytes,5,opt,name=Ports,proto3" json:"Ports,omitempty"`
	// NAT address is from Internet or Cloud Infra space
	AddressType AddressType `protobuf:"varint,6,opt,name=AddressType,proto3,enum=types.AddressType" json:"AddressType,omitempty"`
	// ports usage threshold (percent) to generate alerts. 0 disables alerts
	Threshold            uint32   `protobuf:"varint,7,opt,name=Threshold,proto3" json:"Threshold,omitempty" meta:range:0-99, meta:default=0`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPortBlockSpec) Reset()         { *m = NatPortBlockSpec{} }
func (m *NatPortBlockSpec) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockSpec) ProtoMessage()    {}
func (*NatPortBlockSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{13}
}
func (m *NatPortBlockSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockSpec.Merge(m, src)
}
func (m *NatPortBlockSpec) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockSpec proto.InternalMessageInfo

func (m *NatPortBlockSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NatPortBlockSpec) GetVpcId() []byte {
	if m != nil {
		return m.VpcId
	}
	return nil
}

func (m *NatPortBlockSpec) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *NatPortBlockSpec) GetNatAddress() *Address {
	if m != nil {
		return m.NatAddress
	}
	return nil
}

func (m *NatPortBlockSpec) GetPorts() *PortRange {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *NatPortBlockSpec) GetAddressType() AddressType {
	if m != nil {
		return m.AddressType
	}
	return AddressType_ADDR_TYPE_NONE
}

func (m *NatPortBlockSpec) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// operational status of NAT port block
type NatPortBlockStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPortBlockStatus) Reset()         { *m = NatPortBlockStatus{} }
func (m *NatPortBlockStatus) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockStatus) ProtoMessage()    {}
func (*NatPortBlockStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{14}
}
func (m *NatPortBlockStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockStatus.Merge(m, src)
}
func (m *NatPortBlockStatus) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockStatus proto.InternalMessageInfo

// stats of NAT port block, if any
type NatPortBlockStats struct {
	// number of NAT ports in use
	InUseCount uint32 `protobuf:"varint,1,opt,name=InUseCount,proto3" json:"InUseCount,omitempty"`
	// number of sessions using the port block
	SessionCount uint32 `protobuf:"varint,2,opt,name=SessionCount,proto3" json:"SessionCount,omitempty"`
	// Total number of ports allocated from this port block till now.
	TotalUseCount uint64 `protobuf:"varint,3,opt,name=TotalUseCount,proto3" json:"TotalUseCount,omitempty"`
	// Total number of sessions used/using the port block
	TotalSessionCount uint64 `protobuf:"varint,4,opt,name=TotalSessionCount,proto3" json:"TotalSessionCount,omitempty"`
	// Total number of failed flows that couldn't get a port in this PB.
	// This counter is incremented only when its last PB for port lookup
	// if failed to get new port.
	TotalFailedCount     uint64   `protobuf:"varint,5,opt,name=TotalFailedCount,proto3" json:"TotalFailedCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPortBlockStats) Reset()         { *m = NatPortBlockStats{} }
func (m *NatPortBlockStats) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockStats) ProtoMessage()    {}
func (*NatPortBlockStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{15}
}
func (m *NatPortBlockStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockStats.Merge(m, src)
}
func (m *NatPortBlockStats) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockStats.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockStats proto.InternalMessageInfo

func (m *NatPortBlockStats) GetInUseCount() uint32 {
	if m != nil {
		return m.InUseCount
	}
	return 0
}

func (m *NatPortBlockStats) GetSessionCount() uint32 {
	if m != nil {
		return m.SessionCount
	}
	return 0
}

func (m *NatPortBlockStats) GetTotalUseCount() uint64 {
	if m != nil {
		return m.TotalUseCount
	}
	return 0
}

func (m *NatPortBlockStats) GetTotalSessionCount() uint64 {
	if m != nil {
		return m.TotalSessionCount
	}
	return 0
}

func (m *NatPortBlockStats) GetTotalFailedCount() uint64 {
	if m != nil {
		return m.TotalFailedCount
	}
	return 0
}

// NAT port block object
type NatPortBlock struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *NatPortBlockSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *NatPortBlockStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *NatPortBlockStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NatPortBlock) Reset()         { *m = NatPortBlock{} }
func (m *NatPortBlock) String() string { return proto.CompactTextString(m) }
func (*NatPortBlock) ProtoMessage()    {}
func (*NatPortBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{16}
}
func (m *NatPortBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlock.Merge(m, src)
}
func (m *NatPortBlock) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlock.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlock proto.InternalMessageInfo

func (m *NatPortBlock) GetSpec() *NatPortBlockSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatPortBlock) GetStatus() *NatPortBlockStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatPortBlock) GetStats() *NatPortBlockStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NAT port block create and update request
type NatPortBlockRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt          `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*NatPortBlockSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NatPortBlockRequest) Reset()         { *m = NatPortBlockRequest{} }
func (m *NatPortBlockRequest) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockRequest) ProtoMessage()    {}
func (*NatPortBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{17}
}
func (m *NatPortBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockRequest.Merge(m, src)
}
func (m *NatPortBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockRequest proto.InternalMessageInfo

func (m *NatPortBlockRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NatPortBlockRequest) GetRequest() []*NatPortBlockSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NAT port block create and update response
type NatPortBlockResponse struct {
	ApiStatus            ApiStatus             `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*NatPortBlockStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *NatPortBlockResponse) Reset()         { *m = NatPortBlockResponse{} }
func (m *NatPortBlockResponse) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockResponse) ProtoMessage()    {}
func (*NatPortBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{18}
}
func (m *NatPortBlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockResponse.Merge(m, src)
}
func (m *NatPortBlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockResponse proto.InternalMessageInfo

func (m *NatPortBlockResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPortBlockResponse) GetResponse() []*NatPortBlockStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// NAT port block get request
type NatPortBlockGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatPortBlockGetRequest) Reset()         { *m = NatPortBlockGetRequest{} }
func (m *NatPortBlockGetRequest) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockGetRequest) ProtoMessage()    {}
func (*NatPortBlockGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{19}
}
func (m *NatPortBlockGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockGetRequest.Merge(m, src)
}
func (m *NatPortBlockGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockGetRequest proto.InternalMessageInfo

func (m *NatPortBlockGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// NAT port block get response
type NatPortBlockGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*NatPortBlock `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *NatPortBlockGetResponse) Reset()         { *m = NatPortBlockGetResponse{} }
func (m *NatPortBlockGetResponse) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockGetResponse) ProtoMessage()    {}
func (*NatPortBlockGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{20}
}
func (m *NatPortBlockGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockGetResponse.Merge(m, src)
}
func (m *NatPortBlockGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockGetResponse proto.InternalMessageInfo

func (m *NatPortBlockGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatPortBlockGetResponse) GetResponse() []*NatPortBlock {
	if m != nil {
		return m.Response
	}
	return nil
}

// NAT port block delete request
type NatPortBlockDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NatPortBlockDeleteRequest) Reset()         { *m = NatPortBlockDeleteRequest{} }
func (m *NatPortBlockDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockDeleteRequest) ProtoMessage()    {}
func (*NatPortBlockDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{21}
}
func (m *NatPortBlockDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockDeleteRequest.Merge(m, src)
}
func (m *NatPortBlockDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockDeleteRequest proto.InternalMessageInfo

func (m *NatPortBlockDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *NatPortBlockDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// NAT port block delete response
type NatPortBlockDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NatPortBlockDeleteResponse) Reset()         { *m = NatPortBlockDeleteResponse{} }
func (m *NatPortBlockDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NatPortBlockDeleteResponse) ProtoMessage()    {}
func (*NatPortBlockDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b068cc89cf40d7de, []int{22}
}
func (m *NatPortBlockDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatPortBlockDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatPortBlockDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatPortBlockDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatPortBlockDeleteResponse.Merge(m, src)
}
func (m *NatPortBlockDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NatPortBlockDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NatPortBlockDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NatPortBlockDeleteResponse proto.InternalMessageInfo

func (m *NatPortBlockDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*NatPool)(nil), "pds.NatPool")
	proto.RegisterType((*NatRuleAction)(nil), "pds.NatRuleAction")
	proto.RegisterType((*NatRule)(nil), "pds.NatRule")
	proto.RegisterType((*NatPolicySpec)(nil), "pds.NatPolicySpec")
	proto.RegisterType((*NatPolicyStatus)(nil), "pds.NatPolicyStatus")
	proto.RegisterType((*NatPolicyStats)(nil), "pds.NatPolicyStats")
	proto.RegisterType((*NatPolicy)(nil), "pds.NatPolicy")
	proto.RegisterType((*NatPolicyRequest)(nil), "pds.NatPolicyRequest")
	proto.RegisterType((*NatPolicyResponse)(nil), "pds.NatPolicyResponse")
	proto.RegisterType((*NatPolicyGetRequest)(nil), "pds.NatPolicyGetRequest")
	proto.RegisterType((*NatPolicyGetResponse)(nil), "pds.NatPolicyGetResponse")
	proto.RegisterType((*NatPolicyDeleteRequest)(nil), "pds.NatPolicyDeleteRequest")
	proto.RegisterType((*NatPolicyDeleteResponse)(nil), "pds.NatPolicyDeleteResponse")
	proto.RegisterType((*NatPortBlockSpec)(nil), "pds.NatPortBlockSpec")
	proto.RegisterType((*NatPortBlockStatus)(nil), "pds.NatPortBlockStatus")
	proto.RegisterType((*NatPortBlockStats)(nil), "pds.NatPortBlockStats")
	proto.RegisterType((*NatPortBlock)(nil), "pds.NatPortBlock")
	proto.RegisterType((*NatPortBlockRequest)(nil), "pds.NatPortBlockRequest")
	proto.RegisterType((*NatPortBlockResponse)(nil), "pds.NatPortBlockResponse")
	proto.RegisterType((*NatPortBlockGetRequest)(nil), "pds.NatPortBlockGetRequest")
	proto.RegisterType((*NatPortBlockGetResponse)(nil), "pds.NatPortBlockGetResponse")
	proto.RegisterType((*NatPortBlockDeleteRequest)(nil), "pds.NatPortBlockDeleteRequest")
	proto.RegisterType((*NatPortBlockDeleteResponse)(nil), "pds.NatPortBlockDeleteResponse")
}

func init() { proto.RegisterFile("nat.proto", fileDescriptor_b068cc89cf40d7de) }

var fileDescriptor_b068cc89cf40d7de = []byte{
	// 1117 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xee, 0x3a, 0x76, 0x3e, 0xde, 0xd8, 0x4e, 0x32, 0x49, 0xd3, 0xad, 0x41, 0x71, 0xb4, 0x40,
	0x15, 0x55, 0xae, 0x1b, 0xa5, 0x15, 0x52, 0x83, 0xda, 0xe2, 0x4d, 0x1a, 0x64, 0x41, 0x8d, 0x35,
	0x49, 0x01, 0x89, 0xd3, 0xd6, 0x3b, 0x90, 0x85, 0xf5, 0xee, 0xb2, 0x33, 0xae, 0x6a, 0xf1, 0x3b,
	0x38, 0x72, 0xe4, 0xbf, 0xc0, 0xad, 0x17, 0xc4, 0xcd, 0x42, 0x39, 0xe6, 0xc0, 0xa1, 0xbf, 0x00,
	0xcd, 0x87, 0x77, 0x67, 0xbd, 0x9b, 0x80, 0x2c, 0x24, 0x2e, 0x55, 0xf7, 0x99, 0xe7, 0x79, 0xe7,
	0xfd, 0x98, 0x79, 0xc6, 0x81, 0x95, 0xc0, 0x61, 0xed, 0x28, 0x0e, 0x59, 0x88, 0x16, 0x22, 0x97,
	0x36, 0xd6, 0x86, 0x84, 0x39, 0xf7, 0xf9, 0x3f, 0x12, 0x6d, 0xac, 0xb2, 0x71, 0x44, 0xa8, 0xfc,
	0xb0, 0x28, 0x2c, 0xf5, 0x1c, 0xd6, 0x0f, 0x43, 0x1f, 0x7d, 0x0c, 0x2b, 0x1d, 0xd7, 0x8d, 0x09,
	0xa5, 0x84, 0x9a, 0xc6, 0xee, 0xc2, 0xde, 0xea, 0x41, 0xbd, 0x2d, 0xb9, 0x0a, 0xb7, 0xd1, 0xdb,
	0x49, 0xb3, 0xce, 0x43, 0x1d, 0x0e, 0x9d, 0xc0, 0x75, 0x58, 0x18, 0x8f, 0x71, 0x2a, 0x42, 0x77,
	0xa0, 0xd2, 0x0f, 0x63, 0x46, 0xcd, 0xd2, 0xae, 0xb1, 0xb7, 0x7a, 0xb0, 0xae, 0xd4, 0x1c, 0xc3,
	0x4e, 0xf0, 0x2d, 0xc1, 0x72, 0xd9, 0x1a, 0x42, 0xad, 0xe7, 0x30, 0x3c, 0xf2, 0x49, 0x67, 0xc0,
	0xbc, 0x30, 0x40, 0x0f, 0xa1, 0x7a, 0x1a, 0x0f, 0x7a, 0x0e, 0x93, 0xdf, 0xa6, 0xb1, 0x6b, 0xec,
	0xd5, 0x13, 0x7d, 0x82, 0xe3, 0x0c, 0x0b, 0xdd, 0x49, 0x72, 0x57, 0x1b, 0x56, 0xdb, 0x91, 0x2b,
	0xe8, 0x1c, 0xc3, 0xd3, 0x45, 0xeb, 0x27, 0x43, 0x10, 0xf9, 0x7e, 0xc8, 0x82, 0x52, 0xd7, 0x15,
	0xf1, 0x6b, 0x85, 0xd5, 0x94, 0xba, 0x2e, 0x2f, 0xe3, 0xb9, 0xc3, 0x06, 0xe7, 0x33, 0x65, 0x70,
	0xbd, 0xc0, 0xb1, 0x5c, 0x46, 0x4f, 0x60, 0x51, 0xe5, 0xbb, 0x20, 0x88, 0x68, 0xba, 0x7d, 0x5a,
	0x59, 0xe1, 0x1e, 0x4a, 0x65, 0xfd, 0x65, 0x88, 0x3e, 0xf4, 0x43, 0xdf, 0x1b, 0x8c, 0x4f, 0x23,
	0x32, 0xd0, 0xb2, 0xab, 0x5e, 0x99, 0xdd, 0x53, 0x00, 0xde, 0xf1, 0x13, 0x67, 0xe8, 0xf9, 0x63,
	0x91, 0x62, 0xfd, 0x60, 0x55, 0xa5, 0xd8, 0xed, 0x77, 0x4e, 0x0a, 0x85, 0x9a, 0x84, 0xcf, 0xf9,
	0xd8, 0x8b, 0x49, 0x9a, 0x79, 0x3d, 0x99, 0x33, 0x4f, 0xfc, 0xd8, 0x8b, 0x8b, 0xe7, 0x9c, 0x88,
	0xd0, 0x87, 0x50, 0xe1, 0x4c, 0x6a, 0x96, 0xc5, 0x29, 0xa9, 0xea, 0x75, 0x17, 0x6a, 0x25, 0xdd,
	0xda, 0x80, 0xb5, 0xb4, 0x5e, 0xe6, 0xb0, 0x11, 0xb5, 0xd6, 0xa1, 0x9e, 0x81, 0xa8, 0xf5, 0x5b,
	0x09, 0x56, 0x12, 0x08, 0x7d, 0x04, 0xcb, 0x67, 0xe3, 0x88, 0x3c, 0x27, 0xcc, 0x11, 0x7d, 0xe1,
	0x67, 0x52, 0x9c, 0xe5, 0x29, 0x6a, 0xaf, 0xbd, 0x99, 0x34, 0x8d, 0xcb, 0x49, 0x73, 0xa9, 0xe5,
	0x05, 0xbe, 0x17, 0x10, 0x9c, 0x08, 0xd0, 0x53, 0x58, 0xfa, 0xfc, 0xe5, 0x77, 0x42, 0x2b, 0x47,
	0x59, 0x93, 0x5a, 0x05, 0xda, 0xdb, 0x4a, 0x2a, 0xd2, 0x6d, 0x85, 0x43, 0x8f, 0x91, 0x61, 0xc4,
	0xc6, 0x78, 0xaa, 0x42, 0x87, 0x50, 0xe6, 0x73, 0x99, 0x9d, 0x6f, 0x3a, 0x31, 0x1b, 0x71, 0x39,
	0x8d, 0xc8, 0x40, 0x93, 0x0b, 0x0d, 0xb2, 0x61, 0x51, 0xd6, 0x68, 0x96, 0x85, 0x7a, 0x6b, 0x46,
	0x2d, 0xd6, 0xec, 0xad, 0xcb, 0x49, 0x73, 0x9d, 0x8a, 0xff, 0x6b, 0x11, 0x94, 0x12, 0x3d, 0x81,
	0x8a, 0x68, 0x8a, 0x59, 0x11, 0x21, 0x36, 0xf3, 0x21, 0xa8, 0xbd, 0x79, 0x39, 0x69, 0xae, 0xf1,
	0x08, 0x7a, 0x00, 0x29, 0xb3, 0x22, 0x58, 0x4f, 0xd8, 0x98, 0xfc, 0x30, 0x22, 0x94, 0xa1, 0x36,
	0xac, 0xd8, 0xfc, 0xf8, 0x1e, 0xb1, 0xd7, 0x4c, 0xb5, 0x74, 0x7a, 0xc2, 0x13, 0x1c, 0xa7, 0x14,
	0xd4, 0x82, 0x25, 0x25, 0x35, 0x4b, 0x62, 0xdc, 0x05, 0x6d, 0xc0, 0x53, 0x8a, 0x35, 0x82, 0x0d,
	0x6d, 0x47, 0x1a, 0x85, 0x01, 0x25, 0x7c, 0xcb, 0x4e, 0xe4, 0xa9, 0x6e, 0x64, 0xef, 0x76, 0x82,
	0xe3, 0x94, 0x82, 0xf6, 0x61, 0x79, 0xaa, 0x55, 0x7b, 0x16, 0x36, 0x0f, 0x27, 0x2c, 0xeb, 0x03,
	0xd8, 0x4c, 0x16, 0x3f, 0x21, 0x6c, 0x5a, 0x6b, 0x5d, 0xdd, 0xa7, 0x85, 0xbd, 0x2a, 0xbf, 0x3b,
	0x56, 0x0c, 0x5b, 0x59, 0xda, 0x9c, 0x09, 0xde, 0xcd, 0x25, 0x58, 0xcf, 0x26, 0xa8, 0xa5, 0xf6,
	0x15, 0x6c, 0x27, 0xf0, 0x31, 0xf1, 0x09, 0x23, 0xf3, 0x4e, 0x42, 0x56, 0x53, 0x4a, 0xaa, 0xe9,
	0xc2, 0xad, 0x5c, 0xe4, 0xe2, 0x82, 0x16, 0xfe, 0xa1, 0x20, 0xeb, 0x97, 0x92, 0x3a, 0x29, 0x31,
	0xb3, 0xfd, 0x70, 0xf0, 0xbd, 0x38, 0xc1, 0xf5, 0xd4, 0x8d, 0x84, 0xf3, 0x6c, 0x41, 0xe5, 0x8b,
	0x68, 0x20, 0x52, 0xe0, 0x90, 0xfc, 0x40, 0x0d, 0x58, 0xee, 0xf3, 0xa7, 0x64, 0x10, 0xfa, 0xe2,
	0x9e, 0xd4, 0x70, 0xf2, 0x8d, 0xda, 0x00, 0xdc, 0xae, 0xe5, 0x03, 0xa1, 0xee, 0xc1, 0xcc, 0x9b,
	0x82, 0x35, 0x46, 0xfa, 0x80, 0x54, 0xae, 0x7d, 0x40, 0xd0, 0x43, 0x58, 0x55, 0x12, 0x7e, 0xd7,
	0xcd, 0x45, 0x31, 0x31, 0x94, 0x0d, 0xcc, 0x57, 0xb0, 0x4e, 0x43, 0x1d, 0x58, 0x39, 0x3b, 0x8f,
	0x09, 0x3d, 0x0f, 0x7d, 0xd7, 0x5c, 0x12, 0x4f, 0xc0, 0x7b, 0x6f, 0x27, 0xcd, 0xa6, 0x30, 0xab,
	0x98, 0xc7, 0x3f, 0xdc, 0xbf, 0xf7, 0xe8, 0x51, 0x6b, 0x57, 0x00, 0x2e, 0xf9, 0xc6, 0x19, 0xf9,
	0xec, 0xf1, 0x3e, 0x4e, 0x55, 0xd6, 0x16, 0xa0, 0x4c, 0x9b, 0x64, 0xf7, 0xfe, 0x30, 0xd4, 0xa9,
	0xd7, 0x60, 0x8a, 0x76, 0x00, 0xba, 0xc1, 0x0b, 0x4a, 0x8e, 0xc2, 0x51, 0x20, 0xe7, 0x5b, 0xc3,
	0x1a, 0x82, 0x2c, 0xa8, 0x9e, 0x12, 0x4a, 0xbd, 0x30, 0x90, 0x8c, 0x92, 0x60, 0x64, 0x30, 0xf4,
	0x3e, 0xd4, 0xce, 0x42, 0xe6, 0xf8, 0x49, 0x18, 0xde, 0xe1, 0x32, 0xce, 0x82, 0xa8, 0x05, 0x1b,
	0x02, 0xc8, 0x84, 0x2b, 0x0b, 0x66, 0x7e, 0x01, 0xdd, 0x85, 0x75, 0x01, 0x9e, 0x38, 0x9e, 0x4f,
	0x5c, 0x49, 0xae, 0x08, 0x72, 0x0e, 0xb7, 0x7e, 0x2f, 0x41, 0x55, 0xaf, 0xec, 0x7f, 0xf6, 0xe3,
	0xc7, 0x19, 0x3f, 0xbe, 0x99, 0xde, 0x39, 0xed, 0xd8, 0x5e, 0x63, 0xc9, 0xcf, 0x66, 0x2c, 0xf9,
	0x56, 0x3e, 0xc0, 0xbf, 0x71, 0xe5, 0x4e, 0xd6, 0x95, 0xb7, 0x0b, 0xa3, 0x5c, 0x6f, 0xcc, 0xaf,
	0x94, 0x5f, 0x29, 0xc1, 0xbc, 0x8e, 0x70, 0x7f, 0xd6, 0x9b, 0x8b, 0x5b, 0x92, 0xda, 0xf3, 0x8f,
	0xca, 0x00, 0x93, 0x7d, 0xe7, 0x34, 0xc0, 0x07, 0x39, 0x03, 0xbc, 0xaa, 0x97, 0x9a, 0x13, 0xee,
	0x29, 0x27, 0x54, 0xeb, 0xd7, 0xf8, 0xf4, 0x6b, 0xe5, 0x6c, 0x3a, 0x73, 0xce, 0x4c, 0xef, 0xe5,
	0x32, 0xdd, 0xc8, 0x65, 0xaa, 0xe5, 0xf8, 0x35, 0xdc, 0xd6, 0x57, 0xfe, 0x5b, 0xc3, 0xfe, 0x0c,
	0x1a, 0x45, 0xc1, 0xe7, 0xf3, 0xec, 0x83, 0x9f, 0xcb, 0xb0, 0xd8, 0x73, 0xd8, 0xe9, 0x2b, 0xfe,
	0x5b, 0x23, 0xfd, 0x61, 0x75, 0x14, 0x13, 0x87, 0x11, 0x74, 0x73, 0xe6, 0x41, 0x92, 0x25, 0x34,
	0xb6, 0x67, 0x61, 0x55, 0xf7, 0x8d, 0x4c, 0x8c, 0x17, 0x91, 0x3b, 0x57, 0x8c, 0x67, 0xca, 0x2d,
	0xd4, 0xfb, 0x8a, 0xcc, 0x2c, 0x33, 0x9d, 0x78, 0xe3, 0x76, 0xc1, 0x4a, 0x12, 0xa6, 0xa7, 0xa5,
	0x22, 0x9b, 0x84, 0xde, 0xc9, 0xf2, 0x33, 0x73, 0x69, 0xbc, 0x5b, 0xbc, 0x98, 0xc4, 0xfb, 0x34,
	0xeb, 0xda, 0xaa, 0x43, 0x66, 0xfe, 0x1c, 0xe4, 0x93, 0x9b, 0xb9, 0x28, 0xd6, 0x0d, 0xf4, 0x65,
	0x36, 0x98, 0xca, 0x6f, 0x27, 0x27, 0xc9, 0xa6, 0xd8, 0xbc, 0x72, 0x3d, 0x57, 0x75, 0x7a, 0xe8,
	0xf5, 0xaa, 0x73, 0x97, 0x46, 0xaf, 0x3a, 0x7f, 0x4f, 0xac, 0x1b, 0x76, 0xf5, 0xd7, 0x8b, 0x1d,
	0xe3, 0xcd, 0xc5, 0x8e, 0xf1, 0xe7, 0xc5, 0x8e, 0xf1, 0x72, 0x51, 0xfc, 0xbd, 0xf7, 0xe0, 0xef,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x40, 0x90, 0x02, 0xc5, 0x1f, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NatSvcClient is the client API for NatSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NatSvcClient interface {
	NatPolicyCreate(ctx context.Context, in *NatPolicyRequest, opts ...grpc.CallOption) (*NatPolicyResponse, error)
	NatPolicyUpdate(ctx context.Context, in *NatPolicyRequest, opts ...grpc.CallOption) (*NatPolicyResponse, error)
	NatPolicyGet(ctx context.Context, in *NatPolicyGetRequest, opts ...grpc.CallOption) (*NatPolicyGetResponse, error)
	NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequest, opts ...grpc.CallOption) (*NatPolicyDeleteResponse, error)
	NatPortBlockCreate(ctx context.Context, in *NatPortBlockRequest, opts ...grpc.CallOption) (*NatPortBlockResponse, error)
	NatPortBlockDelete(ctx context.Context, in *NatPortBlockDeleteRequest, opts ...grpc.CallOption) (*NatPortBlockDeleteResponse, error)
	NatPortBlockGet(ctx context.Context, in *NatPortBlockGetRequest, opts ...grpc.CallOption) (*NatPortBlockGetResponse, error)
}

type natSvcClient struct {
	cc *grpc.ClientConn
}

func NewNatSvcClient(cc *grpc.ClientConn) NatSvcClient {
	return &natSvcClient{cc}
}

func (c *natSvcClient) NatPolicyCreate(ctx context.Context, in *NatPolicyRequest, opts ...grpc.CallOption) (*NatPolicyResponse, error) {
	out := new(NatPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPolicyCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPolicyUpdate(ctx context.Context, in *NatPolicyRequest, opts ...grpc.CallOption) (*NatPolicyResponse, error) {
	out := new(NatPolicyResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPolicyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPolicyGet(ctx context.Context, in *NatPolicyGetRequest, opts ...grpc.CallOption) (*NatPolicyGetResponse, error) {
	out := new(NatPolicyGetResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPolicyGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPolicyDelete(ctx context.Context, in *NatPolicyDeleteRequest, opts ...grpc.CallOption) (*NatPolicyDeleteResponse, error) {
	out := new(NatPolicyDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPolicyDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPortBlockCreate(ctx context.Context, in *NatPortBlockRequest, opts ...grpc.CallOption) (*NatPortBlockResponse, error) {
	out := new(NatPortBlockResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPortBlockCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPortBlockDelete(ctx context.Context, in *NatPortBlockDeleteRequest, opts ...grpc.CallOption) (*NatPortBlockDeleteResponse, error) {
	out := new(NatPortBlockDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPortBlockDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natSvcClient) NatPortBlockGet(ctx context.Context, in *NatPortBlockGetRequest, opts ...grpc.CallOption) (*NatPortBlockGetResponse, error) {
	out := new(NatPortBlockGetResponse)
	err := c.cc.Invoke(ctx, "/pds.NatSvc/NatPortBlockGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NatSvcServer is the server API for NatSvc service.
type NatSvcServer interface {
	NatPolicyCreate(context.Context, *NatPolicyRequest) (*NatPolicyResponse, error)
	NatPolicyUpdate(context.Context, *NatPolicyRequest) (*NatPolicyResponse, error)
	NatPolicyGet(context.Context, *NatPolicyGetRequest) (*NatPolicyGetResponse, error)
	NatPolicyDelete(context.Context, *NatPolicyDeleteRequest) (*NatPolicyDeleteResponse, error)
	NatPortBlockCreate(context.Context, *NatPortBlockRequest) (*NatPortBlockResponse, error)
	NatPortBlockDelete(context.Context, *NatPortBlockDeleteRequest) (*NatPortBlockDeleteResponse, error)
	NatPortBlockGet(context.Context, *NatPortBlockGetRequest) (*NatPortBlockGetResponse, error)
}

// UnimplementedNatSvcServer can be embedded to have forward compatible implementations.
type UnimplementedNatSvcServer struct {
}

func (*UnimplementedNatSvcServer) NatPolicyCreate(ctx context.Context, req *NatPolicyRequest) (*NatPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPolicyCreate not implemented")
}
func (*UnimplementedNatSvcServer) NatPolicyUpdate(ctx context.Context, req *NatPolicyRequest) (*NatPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPolicyUpdate not implemented")
}
func (*UnimplementedNatSvcServer) NatPolicyGet(ctx context.Context, req *NatPolicyGetRequest) (*NatPolicyGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPolicyGet not implemented")
}
func (*UnimplementedNatSvcServer) NatPolicyDelete(ctx context.Context, req *NatPolicyDeleteRequest) (*NatPolicyDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPolicyDelete not implemented")
}
func (*UnimplementedNatSvcServer) NatPortBlockCreate(ctx context.Context, req *NatPortBlockRequest) (*NatPortBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPortBlockCreate not implemented")
}
func (*UnimplementedNatSvcServer) NatPortBlockDelete(ctx context.Context, req *NatPortBlockDeleteRequest) (*NatPortBlockDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPortBlockDelete not implemented")
}
func (*UnimplementedNatSvcServer) NatPortBlockGet(ctx context.Context, req *NatPortBlockGetRequest) (*NatPortBlockGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatPortBlockGet not implemented")
}

func RegisterNatSvcServer(s *grpc.Server, srv NatSvcServer) {
	s.RegisterService(&_NatSvc_serviceDesc, srv)
}

func _NatSvc_NatPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPolicyCreate(ctx, req.(*NatPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPolicyUpdate(ctx, req.(*NatPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPolicyGet(ctx, req.(*NatPolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPolicyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPolicyDelete(ctx, req.(*NatPolicyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPortBlockCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPortBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPortBlockCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPortBlockCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPortBlockCreate(ctx, req.(*NatPortBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPortBlockDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPortBlockDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPortBlockDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPortBlockDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPortBlockDelete(ctx, req.(*NatPortBlockDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NatSvc_NatPortBlockGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatPortBlockGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatSvcServer).NatPortBlockGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.NatSvc/NatPortBlockGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatSvcServer).NatPortBlockGet(ctx, req.(*NatPortBlockGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NatSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.NatSvc",
	HandlerType: (*NatSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatPolicyCreate",
			Handler:    _NatSvc_NatPolicyCreate_Handler,
		},
		{
			MethodName: "NatPolicyUpdate",
			Handler:    _NatSvc_NatPolicyUpdate_Handler,
		},
		{
			MethodName: "NatPolicyGet",
			Handler:    _NatSvc_NatPolicyGet_Handler,
		},
		{
			MethodName: "NatPolicyDelete",
			Handler:    _NatSvc_NatPolicyDelete_Handler,
		},
		{
			MethodName: "NatPortBlockCreate",
			Handler:    _NatSvc_NatPortBlockCreate_Handler,
		},
		{
			MethodName: "NatPortBlockDelete",
			Handler:    _NatSvc_NatPortBlockDelete_Handler,
		},
		{
			MethodName: "NatPortBlockGet",
			Handler:    _NatSvc_NatPortBlockGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nat.proto",
}

func (m *NatPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ports != nil {
		{
			size, err := m.Ports.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Addresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NatRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatRuleAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NatPool != nil {
		{
			size, err := m.NatPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcNatAction != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.SrcNatAction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Direction != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x18
	}
	if m.AddrFamily != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.AddrFamily))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNat(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNat(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNat(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPolicyDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA13 := make([]byte, len(m.ApiStatus)*10)
		var j12 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintNat(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Threshold != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x38
	}
	if m.AddressType != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.AddressType))
		i--
		dAtA[i] = 0x30
	}
	if m.Ports != nil {
		{
			size, err := m.Ports.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NatAddress != nil {
		{
			size, err := m.NatAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Protocol != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintNat(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNat(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalFailedCount != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.TotalFailedCount))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSessionCount != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.TotalSessionCount))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalUseCount != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.TotalUseCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionCount != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.SessionCount))
		i--
		dAtA[i] = 0x10
	}
	if m.InUseCount != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.InUseCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNat(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintNat(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintNat(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatPortBlockDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPortBlockDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatPortBlockDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA24 := make([]byte, len(m.ApiStatus)*10)
		var j23 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintNat(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNat(dAtA []byte, offset int, v uint64) int {
	offset -= sovNat(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NatPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatRuleAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcNatAction != 0 {
		n += 1 + sovNat(uint64(m.SrcNatAction))
	}
	if m.NatPool != nil {
		l = m.NatPool.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovNat(uint64(m.Id))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	if m.AddrFamily != 0 {
		n += 1 + sovNat(uint64(m.AddrFamily))
	}
	if m.Direction != 0 {
		n += 1 + sovNat(uint64(m.Direction))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPolicyDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovNat(uint64(m.Protocol))
	}
	if m.NatAddress != nil {
		l = m.NatAddress.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.AddressType != 0 {
		n += 1 + sovNat(uint64(m.AddressType))
	}
	if m.Threshold != 0 {
		n += 1 + sovNat(uint64(m.Threshold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InUseCount != 0 {
		n += 1 + sovNat(uint64(m.InUseCount))
	}
	if m.SessionCount != 0 {
		n += 1 + sovNat(uint64(m.SessionCount))
	}
	if m.TotalUseCount != 0 {
		n += 1 + sovNat(uint64(m.TotalUseCount))
	}
	if m.TotalSessionCount != 0 {
		n += 1 + sovNat(uint64(m.TotalSessionCount))
	}
	if m.TotalFailedCount != 0 {
		n += 1 + sovNat(uint64(m.TotalFailedCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNat(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovNat(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovNat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatPortBlockDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovNat(uint64(e))
		}
		n += 1 + sovNat(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNat(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNat(x uint64) (n int) {
	return sovNat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, &Address{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = &PortRange{}
			}
			if err := m.Ports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= NatAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatPool == nil {
				m.NatPool = &NatPool{}
			}
			if err := m.NatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &NatRuleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrFamily", wireType)
			}
			m.AddrFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrFamily |= IPAF(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= RuleDir(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &NatRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicyStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPolicy{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = append(m.VpcId[:0], dAtA[iNdEx:postIndex]...)
			if m.VpcId == nil {
				m.VpcId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NatAddress == nil {
				m.NatAddress = &Address{}
			}
			if err := m.NatAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = &PortRange{}
			}
			if err := m.Ports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressType", wireType)
			}
			m.AddressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressType |= AddressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUseCount", wireType)
			}
			m.InUseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUseCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCount", wireType)
			}
			m.SessionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUseCount", wireType)
			}
			m.TotalUseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUseCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSessionCount", wireType)
			}
			m.TotalSessionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSessionCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFailedCount", wireType)
			}
			m.TotalFailedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFailedCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatPortBlockSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatPortBlockStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatPortBlockStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatPortBlockSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPortBlockStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatPortBlock{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNat
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatPortBlockDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPortBlockDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPortBlockDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNat
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNat
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNat   = fmt.Errorf("proto: integer overflow")
)
