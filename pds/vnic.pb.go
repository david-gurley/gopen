// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vnic.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VNIC specification
// NOTE: Vnic ids are not scoped under VPC or subnet, they are globally
//       unique across VPCs
type VnicSpec struct {
	// unique vnic id
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// id of the subnet this vnic belongs to
	SubnetId []byte `protobuf:"bytes,2,opt,name=SubnetId,proto3" json:"SubnetId,omitempty" meta:mandatory,immutable`
	// vnic encap information to be used while sending packets to this vnic
	VnicEncap *Encap `protobuf:"bytes,3,opt,name=VnicEncap,proto3" json:"VnicEncap,omitempty" meta:mandatory,immutable`
	// overlay MAC of this VNIC
	MACAddress uint64 `protobuf:"varint,4,opt,name=MACAddress,proto3" json:"MACAddress,omitempty" meta:mandatory,immutable`
	// enable or disable reverse path checks while sending traffic to this vnic
	// or while receiving traffic from this vnic
	SourceGuardEnable bool `protobuf:"varint,5,opt,name=SourceGuardEnable,proto3" json:"SourceGuardEnable,omitempty"`
	// fabric encap information to be used for traffic originated from this vnic
	FabricEncap *Encap `protobuf:"bytes,6,opt,name=FabricEncap,proto3" json:"FabricEncap,omitempty" meta:immutable`
	// Tx/egress mirror session id list, if any
	// NOTE: when Tx mirroring is enabled, original packet sent by the vnic is
	//       mirrored as-is (including dot1q tag, if any) towards the collector
	TxMirrorSessionId [][]byte `protobuf:"bytes,7,rep,name=TxMirrorSessionId,proto3" json:"TxMirrorSessionId,omitempty"`
	// Rx/ingress mirror session id list, if any
	// NOTE: when Rx mirroring is enabled, the packet that is mirrored is same as
	//       the packet that is ultimately sent to the vnic (i.e., the mirrored
	//       packet has no VxLAN header and has all packet rewrites done)
	RxMirrorSessionId [][]byte `protobuf:"bytes,8,rep,name=RxMirrorSessionId,proto3" json:"RxMirrorSessionId,omitempty"`
	// VNF (potentially virtualized) workloads/appliances like firewalls, virtual
	// switches/bridges, security monitoring appliances etc. are the kind of
	// workloads that act as devices in the middle providing bump in the wire
	// services and they can receive traffic from various IP and MAC addresses
	// and also generate traffic with different sources and MAC addresses
	// (potentially looping back the received traffic after performing the
	// services and/or doing certain packet rewrites). For such workloads,
	// VNF attribute is set to true and the source IP address in the traffic from
	// the PF/VF will be ignored for learning purposes
	VNF bool `protobuf:"varint,9,opt,name=VNF,proto3" json:"VNF,omitempty"`
	// identifier of ingress IPv4 security policy to be enforced
	IngV4SecurityPolicyId [][]byte `protobuf:"bytes,10,rep,name=IngV4SecurityPolicyId,proto3" json:"IngV4SecurityPolicyId,omitempty"`
	// identifier of ingress IPv6 security policy to be enforced
	IngV6SecurityPolicyId [][]byte `protobuf:"bytes,11,rep,name=IngV6SecurityPolicyId,proto3" json:"IngV6SecurityPolicyId,omitempty"`
	// identifier of egress IPv4 security policy to be enforced
	EgV4SecurityPolicyId [][]byte `protobuf:"bytes,12,rep,name=EgV4SecurityPolicyId,proto3" json:"EgV4SecurityPolicyId,omitempty"`
	// identifier of egress IPv6 security policy to be enforced
	EgV6SecurityPolicyId [][]byte `protobuf:"bytes,13,rep,name=EgV6SecurityPolicyId,proto3" json:"EgV6SecurityPolicyId,omitempty"`
	// Types that are valid to be assigned to Ifinfo:
	//	*VnicSpec_HostIf
	//	*VnicSpec_TunnelId
	Ifinfo isVnicSpec_Ifinfo `protobuf_oneof:"ifinfo"`
	// policer to be applied on the traffic coming from vnic
	TxPolicerId []byte `protobuf:"bytes,16,opt,name=TxPolicerId,proto3" json:"TxPolicerId,omitempty"`
	// policer to be applied on the traffic going to vnic
	RxPolicerId []byte `protobuf:"bytes,17,opt,name=RxPolicerId,proto3" json:"RxPolicerId,omitempty"`
	// if a vnic is not marked as primary, DHCP offer sent to such vnics
	// will not have gateway IP, hostname options filled in the DHCP offer
	Primary bool `protobuf:"varint,18,opt,name=Primary,proto3" json:"Primary,omitempty" meta:immutable`
	// hostname of the vnic to be returned in the DHCP offer when DHCP policy
	// is enabled on the vnic's subnet
	HostName string `protobuf:"bytes,19,opt,name=HostName,proto3" json:"HostName,omitempty"`
	// MaxSessions, if set, is number of active sessions allowed from/to this vnic
	// if MaxSessions is 0, no limit is enforced
	// NOTE:
	// no active sessions will be pruned if the value changes, but once the
	// session count comes down to a value below this limit, new sessions
	// won't be installed in h/w (packet will be dropped)
	// 1 session = forward flow + reverse flow
	MaxSessions uint32 `protobuf:"varint,20,opt,name=MaxSessions,proto3" json:"MaxSessions,omitempty"`
	// controls for flow logging
	FlowLogSpec *FlowLogSpec `protobuf:"bytes,21,opt,name=FlowLogSpec,proto3" json:"FlowLogSpec,omitempty"`
	// if MeterEn is true, when traffic from a vnic hits a route with metering
	// enabled, such traffic is accounted (bytes & packets) against the vnic
	// NOTE:
	// when MeterEn is set to true, meter bucket is derived from either
	// vnic level meter policy, if configured or else vpc level meter
	// policy, if configured or else from the route table (route can provide
	// the meter bucket/class directly)
	MeterEn bool `protobuf:"varint,22,opt,name=MeterEn,proto3" json:"MeterEn,omitempty"`
	// granular metering policy, if any, to be applied for ipv4 traffic
	// ingressing/egressing the vnic
	// NOTE:
	// when V4MeterPolicy is set, MeterEn is implicitly set to true
	// (i.e. user doesn't have to set to true explicitly) as metering is enabled
	// by setting this attribute explicitly
	V4MeterPolicy []byte `protobuf:"bytes,23,opt,name=V4MeterPolicy,proto3" json:"V4MeterPolicy,omitempty"`
	// granular metering policy, if any, to be applied for ipv6 traffic
	// ingressing/egressing the vnic
	// NOTE:
	// when V6MeterPolicy is set, MeterEn is implicitly set to true
	// (i.e. user doesn't have to set to true explicitly) as metering enabled by
	// setting this attribute explicitly
	V6MeterPolicy []byte `protobuf:"bytes,24,opt,name=V6MeterPolicy,proto3" json:"V6MeterPolicy,omitempty"`
	// PublicMAC, if set, is used to translate the vnic's MAC address;
	// in the Tx direction, when vnic sends traffic with its private MAC
	// (MACAddress attribute in this object) as source MAC, it gets NAT-ed to
	// PublicMACAddress before the packet is put on the wire (or delivered locally
	// to another vnic on same DSC) and in the Rx direction when traffic is
	// received with destination as PublicMACAddress, it gets translated to
	// vnic's private MAC address before the packet is delivered to the vnic
	PublicMACAddress uint64 `protobuf:"varint,25,opt,name=PublicMACAddress,proto3" json:"PublicMACAddress,omitempty" meta:immutable`
	// when HAEnabled attribute is set to true, vnic state (e.g. flow information)
	// is synced to peer DSC
	HAEnabled bool `protobuf:"varint,26,opt,name=HAEnabled,proto3" json:"HAEnabled,omitempty"`
	// when a workload that is acting as a backend of some service (identified by
	// VIP or (VIP, port)) is running on top of a vnic, such vnic can be
	// identified in the fabric using a globally unique label (if LBBackendId is
	// zero, vnic is not considered as load balancing member pool)
	LBBackendId uint64 `protobuf:"varint,27,opt,name=LBBackendId,proto3" json:"LBBackendId,omitempty"`
	// if AllowInternetAccess is set to false and traffic from the vnic hits a
	// route of class ROUTE_CLASS_INTERNET, then traffic is dropped. To allow
	// Internet connectivity for the vnic, AllowInternetAccess must be set to
	// true
	AllowInternetAccess bool `protobuf:"varint,28,opt,name=AllowInternetAccess,proto3" json:"AllowInternetAccess,omitempty"`
	// MaxCPS, if non-zero, is the maximum no. of connections per second (cps)
	// allowed for this vnic and if cps exceeds this configured limit all
	// new connections will get dropped
	// NOTE:
	// 1. if this value exceeds max cps supported by the pipeline, this limit
	//    will never be hit and so it is as good as unlimited cps
	// 2. A value 0 indicates that the cps for the vnic is unlimited and not
	//    enforced (i.e., cps limit is as much as the pipeline can sustain)
	// 3. the cumulative MaxCPS values configured across all vnics must not
	//    exceed the pipeline supported cps, if certain number of vnics have
	//    higher cps limits so that they take most of the pipeline supported
	//    cps, rest of the vnics can starve w.r.t cps
	MaxCPS uint32 `protobuf:"varint,29,opt,name=MaxCPS,proto3" json:"MaxCPS,omitempty"`
	// CPS burst to be absorbed when CPS exceeds MaxCPS
	// NOTE: CPSBurst is not used if MaxCPS  is 0
	CPSBurst uint32 `protobuf:"varint,30,opt,name=CPSBurst,proto3" json:"CPSBurst,omitempty" meta:default=1000000`
	// when DisablePublicGWNAT is set to true, sessions initiated by the vnic
	// hitting a route (potentially default route) with SNAT action set to
	// NAT_ACTION_NAPT_PUBLIC will not be NAT-ed (i.e. NAT action is ignored)
	DisablePublicGWNAT bool `protobuf:"varint,31,opt,name=DisablePublicGWNAT,proto3" json:"DisablePublicGWNAT,omitempty" meta:default=false`
	// multiple vnics can be created with same MAC but only of them can be primary
	// VNIC and all 2nd-ary vnics refer to the primary vnic, both primary and
	// 2nd-dary vnic can have one or more local IP mappings behind them
	PrimaryVnic          []byte   `protobuf:"bytes,32,opt,name=PrimaryVnic,proto3" json:"PrimaryVnic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicSpec) Reset()         { *m = VnicSpec{} }
func (m *VnicSpec) String() string { return proto.CompactTextString(m) }
func (*VnicSpec) ProtoMessage()    {}
func (*VnicSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{0}
}
func (m *VnicSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicSpec.Merge(m, src)
}
func (m *VnicSpec) XXX_Size() int {
	return m.Size()
}
func (m *VnicSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VnicSpec proto.InternalMessageInfo

type isVnicSpec_Ifinfo interface {
	isVnicSpec_Ifinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type VnicSpec_HostIf struct {
	HostIf []byte `protobuf:"bytes,14,opt,name=HostIf,proto3,oneof"`
}
type VnicSpec_TunnelId struct {
	TunnelId []byte `protobuf:"bytes,15,opt,name=TunnelId,proto3,oneof"`
}

func (*VnicSpec_HostIf) isVnicSpec_Ifinfo()   {}
func (*VnicSpec_TunnelId) isVnicSpec_Ifinfo() {}

func (m *VnicSpec) GetIfinfo() isVnicSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (m *VnicSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *VnicSpec) GetSubnetId() []byte {
	if m != nil {
		return m.SubnetId
	}
	return nil
}

func (m *VnicSpec) GetVnicEncap() *Encap {
	if m != nil {
		return m.VnicEncap
	}
	return nil
}

func (m *VnicSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

func (m *VnicSpec) GetSourceGuardEnable() bool {
	if m != nil {
		return m.SourceGuardEnable
	}
	return false
}

func (m *VnicSpec) GetFabricEncap() *Encap {
	if m != nil {
		return m.FabricEncap
	}
	return nil
}

func (m *VnicSpec) GetTxMirrorSessionId() [][]byte {
	if m != nil {
		return m.TxMirrorSessionId
	}
	return nil
}

func (m *VnicSpec) GetRxMirrorSessionId() [][]byte {
	if m != nil {
		return m.RxMirrorSessionId
	}
	return nil
}

func (m *VnicSpec) GetVNF() bool {
	if m != nil {
		return m.VNF
	}
	return false
}

func (m *VnicSpec) GetIngV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV4SecurityPolicyId
	}
	return nil
}

func (m *VnicSpec) GetIngV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.IngV6SecurityPolicyId
	}
	return nil
}

func (m *VnicSpec) GetEgV4SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV4SecurityPolicyId
	}
	return nil
}

func (m *VnicSpec) GetEgV6SecurityPolicyId() [][]byte {
	if m != nil {
		return m.EgV6SecurityPolicyId
	}
	return nil
}

func (m *VnicSpec) GetHostIf() []byte {
	if x, ok := m.GetIfinfo().(*VnicSpec_HostIf); ok {
		return x.HostIf
	}
	return nil
}

func (m *VnicSpec) GetTunnelId() []byte {
	if x, ok := m.GetIfinfo().(*VnicSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (m *VnicSpec) GetTxPolicerId() []byte {
	if m != nil {
		return m.TxPolicerId
	}
	return nil
}

func (m *VnicSpec) GetRxPolicerId() []byte {
	if m != nil {
		return m.RxPolicerId
	}
	return nil
}

func (m *VnicSpec) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *VnicSpec) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *VnicSpec) GetMaxSessions() uint32 {
	if m != nil {
		return m.MaxSessions
	}
	return 0
}

func (m *VnicSpec) GetFlowLogSpec() *FlowLogSpec {
	if m != nil {
		return m.FlowLogSpec
	}
	return nil
}

func (m *VnicSpec) GetMeterEn() bool {
	if m != nil {
		return m.MeterEn
	}
	return false
}

func (m *VnicSpec) GetV4MeterPolicy() []byte {
	if m != nil {
		return m.V4MeterPolicy
	}
	return nil
}

func (m *VnicSpec) GetV6MeterPolicy() []byte {
	if m != nil {
		return m.V6MeterPolicy
	}
	return nil
}

func (m *VnicSpec) GetPublicMACAddress() uint64 {
	if m != nil {
		return m.PublicMACAddress
	}
	return 0
}

func (m *VnicSpec) GetHAEnabled() bool {
	if m != nil {
		return m.HAEnabled
	}
	return false
}

func (m *VnicSpec) GetLBBackendId() uint64 {
	if m != nil {
		return m.LBBackendId
	}
	return 0
}

func (m *VnicSpec) GetAllowInternetAccess() bool {
	if m != nil {
		return m.AllowInternetAccess
	}
	return false
}

func (m *VnicSpec) GetMaxCPS() uint32 {
	if m != nil {
		return m.MaxCPS
	}
	return 0
}

func (m *VnicSpec) GetCPSBurst() uint32 {
	if m != nil {
		return m.CPSBurst
	}
	return 0
}

func (m *VnicSpec) GetDisablePublicGWNAT() bool {
	if m != nil {
		return m.DisablePublicGWNAT
	}
	return false
}

func (m *VnicSpec) GetPrimaryVnic() []byte {
	if m != nil {
		return m.PrimaryVnic
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VnicSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VnicSpec_HostIf)(nil),
		(*VnicSpec_TunnelId)(nil),
	}
}

// operational status of Vnic, if any
type VnicStatus struct {
	HwId                 uint32   `protobuf:"varint,1,opt,name=HwId,proto3" json:"HwId,omitempty"`
	NhHwId               uint32   `protobuf:"varint,2,opt,name=NhHwId,proto3" json:"NhHwId,omitempty"`
	Epoch                uint32   `protobuf:"varint,3,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	V4MeterPolicyId      []byte   `protobuf:"bytes,4,opt,name=V4MeterPolicyId,proto3" json:"V4MeterPolicyId,omitempty"`
	V6MeterPolicyId      []byte   `protobuf:"bytes,5,opt,name=V6MeterPolicyId,proto3" json:"V6MeterPolicyId,omitempty"`
	CPSCoppHwId          uint32   `protobuf:"varint,6,opt,name=CPSCoppHwId,proto3" json:"CPSCoppHwId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicStatus) Reset()         { *m = VnicStatus{} }
func (m *VnicStatus) String() string { return proto.CompactTextString(m) }
func (*VnicStatus) ProtoMessage()    {}
func (*VnicStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{1}
}
func (m *VnicStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicStatus.Merge(m, src)
}
func (m *VnicStatus) XXX_Size() int {
	return m.Size()
}
func (m *VnicStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VnicStatus proto.InternalMessageInfo

func (m *VnicStatus) GetHwId() uint32 {
	if m != nil {
		return m.HwId
	}
	return 0
}

func (m *VnicStatus) GetNhHwId() uint32 {
	if m != nil {
		return m.NhHwId
	}
	return 0
}

func (m *VnicStatus) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *VnicStatus) GetV4MeterPolicyId() []byte {
	if m != nil {
		return m.V4MeterPolicyId
	}
	return nil
}

func (m *VnicStatus) GetV6MeterPolicyId() []byte {
	if m != nil {
		return m.V6MeterPolicyId
	}
	return nil
}

func (m *VnicStatus) GetCPSCoppHwId() uint32 {
	if m != nil {
		return m.CPSCoppHwId
	}
	return 0
}

// vnic meter statistics
type VnicMeterStats struct {
	// meter class/bucket
	MeterClass uint32 `protobuf:"varint,1,opt,name=MeterClass,proto3" json:"MeterClass,omitempty"`
	// transmitted packets
	MeterTxPackets uint64 `protobuf:"varint,2,opt,name=MeterTxPackets,proto3" json:"MeterTxPackets,omitempty"`
	// transmitted bytes
	MeterTxBytes uint64 `protobuf:"varint,3,opt,name=MeterTxBytes,proto3" json:"MeterTxBytes,omitempty"`
	// received packets
	MeterRxPackets uint64 `protobuf:"varint,4,opt,name=MeterRxPackets,proto3" json:"MeterRxPackets,omitempty"`
	// received bytes
	MeterRxBytes         uint64   `protobuf:"varint,5,opt,name=MeterRxBytes,proto3" json:"MeterRxBytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicMeterStats) Reset()         { *m = VnicMeterStats{} }
func (m *VnicMeterStats) String() string { return proto.CompactTextString(m) }
func (*VnicMeterStats) ProtoMessage()    {}
func (*VnicMeterStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{2}
}
func (m *VnicMeterStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicMeterStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicMeterStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicMeterStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicMeterStats.Merge(m, src)
}
func (m *VnicMeterStats) XXX_Size() int {
	return m.Size()
}
func (m *VnicMeterStats) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicMeterStats.DiscardUnknown(m)
}

var xxx_messageInfo_VnicMeterStats proto.InternalMessageInfo

func (m *VnicMeterStats) GetMeterClass() uint32 {
	if m != nil {
		return m.MeterClass
	}
	return 0
}

func (m *VnicMeterStats) GetMeterTxPackets() uint64 {
	if m != nil {
		return m.MeterTxPackets
	}
	return 0
}

func (m *VnicMeterStats) GetMeterTxBytes() uint64 {
	if m != nil {
		return m.MeterTxBytes
	}
	return 0
}

func (m *VnicMeterStats) GetMeterRxPackets() uint64 {
	if m != nil {
		return m.MeterRxPackets
	}
	return 0
}

func (m *VnicMeterStats) GetMeterRxBytes() uint64 {
	if m != nil {
		return m.MeterRxBytes
	}
	return 0
}

// stats of Vnic, if any
type VnicStats struct {
	// number of bytes transmitted by the vnic
	TxBytes uint64 `protobuf:"varint,1,opt,name=TxBytes,proto3" json:"TxBytes,omitempty"`
	// number of packets transmitted by the vnic
	TxPackets uint64 `protobuf:"varint,2,opt,name=TxPackets,proto3" json:"TxPackets,omitempty"`
	// number of bytes received by the vnic
	RxBytes uint64 `protobuf:"varint,3,opt,name=RxBytes,proto3" json:"RxBytes,omitempty"`
	// number of packets received by the vnic
	RxPackets uint64 `protobuf:"varint,4,opt,name=RxPackets,proto3" json:"RxPackets,omitempty"`
	// number of active sessions on the vnic
	ActiveSessions uint64 `protobuf:"varint,5,opt,name=ActiveSessions,proto3" json:"ActiveSessions,omitempty"`
	// vnic meter statistics
	MeterStats []*VnicMeterStats `protobuf:"bytes,6,rep,name=MeterStats,proto3" json:"MeterStats,omitempty"`
	// vnic drop statistics
	DropStats            []*Counter `protobuf:"bytes,7,rep,name=DropStats,proto3" json:"DropStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VnicStats) Reset()         { *m = VnicStats{} }
func (m *VnicStats) String() string { return proto.CompactTextString(m) }
func (*VnicStats) ProtoMessage()    {}
func (*VnicStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{3}
}
func (m *VnicStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicStats.Merge(m, src)
}
func (m *VnicStats) XXX_Size() int {
	return m.Size()
}
func (m *VnicStats) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicStats.DiscardUnknown(m)
}

var xxx_messageInfo_VnicStats proto.InternalMessageInfo

func (m *VnicStats) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *VnicStats) GetTxPackets() uint64 {
	if m != nil {
		return m.TxPackets
	}
	return 0
}

func (m *VnicStats) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *VnicStats) GetRxPackets() uint64 {
	if m != nil {
		return m.RxPackets
	}
	return 0
}

func (m *VnicStats) GetActiveSessions() uint64 {
	if m != nil {
		return m.ActiveSessions
	}
	return 0
}

func (m *VnicStats) GetMeterStats() []*VnicMeterStats {
	if m != nil {
		return m.MeterStats
	}
	return nil
}

func (m *VnicStats) GetDropStats() []*Counter {
	if m != nil {
		return m.DropStats
	}
	return nil
}

// vnic object
type Vnic struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *VnicSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *VnicStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *VnicStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Vnic) Reset()         { *m = Vnic{} }
func (m *Vnic) String() string { return proto.CompactTextString(m) }
func (*Vnic) ProtoMessage()    {}
func (*Vnic) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{4}
}
func (m *Vnic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vnic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vnic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vnic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vnic.Merge(m, src)
}
func (m *Vnic) XXX_Size() int {
	return m.Size()
}
func (m *Vnic) XXX_DiscardUnknown() {
	xxx_messageInfo_Vnic.DiscardUnknown(m)
}

var xxx_messageInfo_Vnic proto.InternalMessageInfo

func (m *Vnic) GetSpec() *VnicSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Vnic) GetStatus() *VnicStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Vnic) GetStats() *VnicStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// vnic create and update request
type VnicRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Request              []*VnicSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VnicRequest) Reset()         { *m = VnicRequest{} }
func (m *VnicRequest) String() string { return proto.CompactTextString(m) }
func (*VnicRequest) ProtoMessage()    {}
func (*VnicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{5}
}
func (m *VnicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicRequest.Merge(m, src)
}
func (m *VnicRequest) XXX_Size() int {
	return m.Size()
}
func (m *VnicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VnicRequest proto.InternalMessageInfo

func (m *VnicRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VnicRequest) GetRequest() []*VnicSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// vnic create and update response
type VnicResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// batched response
	Response             []*VnicStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VnicResponse) Reset()         { *m = VnicResponse{} }
func (m *VnicResponse) String() string { return proto.CompactTextString(m) }
func (*VnicResponse) ProtoMessage()    {}
func (*VnicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{6}
}
func (m *VnicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicResponse.Merge(m, src)
}
func (m *VnicResponse) XXX_Size() int {
	return m.Size()
}
func (m *VnicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VnicResponse proto.InternalMessageInfo

func (m *VnicResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VnicResponse) GetResponse() []*VnicStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// vnic get request
type VnicGetRequest struct {
	// batched request
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicGetRequest) Reset()         { *m = VnicGetRequest{} }
func (m *VnicGetRequest) String() string { return proto.CompactTextString(m) }
func (*VnicGetRequest) ProtoMessage()    {}
func (*VnicGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{7}
}
func (m *VnicGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicGetRequest.Merge(m, src)
}
func (m *VnicGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *VnicGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VnicGetRequest proto.InternalMessageInfo

func (m *VnicGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// vnic get response
type VnicGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// batched response
	Response             []*Vnic  `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicGetResponse) Reset()         { *m = VnicGetResponse{} }
func (m *VnicGetResponse) String() string { return proto.CompactTextString(m) }
func (*VnicGetResponse) ProtoMessage()    {}
func (*VnicGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{8}
}
func (m *VnicGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicGetResponse.Merge(m, src)
}
func (m *VnicGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *VnicGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VnicGetResponse proto.InternalMessageInfo

func (m *VnicGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *VnicGetResponse) GetResponse() []*Vnic {
	if m != nil {
		return m.Response
	}
	return nil
}

// vnic delete request
type VnicDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched request
	Id                   [][]byte `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicDeleteRequest) Reset()         { *m = VnicDeleteRequest{} }
func (m *VnicDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*VnicDeleteRequest) ProtoMessage()    {}
func (*VnicDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{9}
}
func (m *VnicDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicDeleteRequest.Merge(m, src)
}
func (m *VnicDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *VnicDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VnicDeleteRequest proto.InternalMessageInfo

func (m *VnicDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *VnicDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// vnic delete response
type VnicDeleteResponse struct {
	// batched response
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VnicDeleteResponse) Reset()         { *m = VnicDeleteResponse{} }
func (m *VnicDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*VnicDeleteResponse) ProtoMessage()    {}
func (*VnicDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{10}
}
func (m *VnicDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicDeleteResponse.Merge(m, src)
}
func (m *VnicDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *VnicDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VnicDeleteResponse proto.InternalMessageInfo

func (m *VnicDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// vnic stats reset request
type VnicStatsResetRequest struct {
	// given a uuid of a vnic, clear its stats or else clear stats of all vnics
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// if ClearMeterStats is set to true, meter stats corresponding to vnic are
	// also cleared
	ClearMeterStats      bool     `protobuf:"varint,2,opt,name=ClearMeterStats,proto3" json:"ClearMeterStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VnicStatsResetRequest) Reset()         { *m = VnicStatsResetRequest{} }
func (m *VnicStatsResetRequest) String() string { return proto.CompactTextString(m) }
func (*VnicStatsResetRequest) ProtoMessage()    {}
func (*VnicStatsResetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1134eeba4d52f496, []int{11}
}
func (m *VnicStatsResetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VnicStatsResetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VnicStatsResetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VnicStatsResetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VnicStatsResetRequest.Merge(m, src)
}
func (m *VnicStatsResetRequest) XXX_Size() int {
	return m.Size()
}
func (m *VnicStatsResetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VnicStatsResetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VnicStatsResetRequest proto.InternalMessageInfo

func (m *VnicStatsResetRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *VnicStatsResetRequest) GetClearMeterStats() bool {
	if m != nil {
		return m.ClearMeterStats
	}
	return false
}

func init() {
	proto.RegisterType((*VnicSpec)(nil), "pds.VnicSpec")
	proto.RegisterType((*VnicStatus)(nil), "pds.VnicStatus")
	proto.RegisterType((*VnicMeterStats)(nil), "pds.VnicMeterStats")
	proto.RegisterType((*VnicStats)(nil), "pds.VnicStats")
	proto.RegisterType((*Vnic)(nil), "pds.Vnic")
	proto.RegisterType((*VnicRequest)(nil), "pds.VnicRequest")
	proto.RegisterType((*VnicResponse)(nil), "pds.VnicResponse")
	proto.RegisterType((*VnicGetRequest)(nil), "pds.VnicGetRequest")
	proto.RegisterType((*VnicGetResponse)(nil), "pds.VnicGetResponse")
	proto.RegisterType((*VnicDeleteRequest)(nil), "pds.VnicDeleteRequest")
	proto.RegisterType((*VnicDeleteResponse)(nil), "pds.VnicDeleteResponse")
	proto.RegisterType((*VnicStatsResetRequest)(nil), "pds.VnicStatsResetRequest")
}

func init() { proto.RegisterFile("vnic.proto", fileDescriptor_1134eeba4d52f496) }

var fileDescriptor_1134eeba4d52f496 = []byte{
	// 1349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcb, 0x6e, 0xdb, 0xc6,
	0x1a, 0x0e, 0x65, 0x59, 0x92, 0x7f, 0xc9, 0x92, 0x3d, 0x76, 0x9c, 0x39, 0x3a, 0x3e, 0x96, 0x20,
	0x9c, 0x73, 0x2a, 0xa0, 0x82, 0x9b, 0x3a, 0xae, 0xd1, 0x4b, 0xd2, 0x40, 0x94, 0x6f, 0x02, 0x62,
	0x57, 0x1d, 0xb9, 0xee, 0x9a, 0x26, 0xc7, 0x36, 0x1b, 0x89, 0x64, 0xc9, 0x51, 0x62, 0xbd, 0x40,
	0x1f, 0xa5, 0x8b, 0xee, 0xfb, 0x06, 0x5d, 0x64, 0x99, 0x27, 0x10, 0x8a, 0x2c, 0xb3, 0xf4, 0x13,
	0x14, 0x73, 0x21, 0x39, 0xba, 0x00, 0x69, 0xe3, 0x85, 0xc1, 0xff, 0x9b, 0xef, 0xfb, 0x6f, 0xf3,
	0xcf, 0x90, 0x02, 0x78, 0xe5, 0xb9, 0xf6, 0x6e, 0x10, 0xfa, 0xcc, 0x47, 0x4b, 0x81, 0x13, 0x55,
	0xe1, 0xc6, 0xbf, 0xf1, 0x25, 0x50, 0xad, 0x0c, 0x29, 0xb3, 0x3e, 0xe3, 0xff, 0x14, 0x50, 0x64,
	0xe3, 0x80, 0x46, 0xd2, 0x68, 0xfc, 0x5a, 0x84, 0xc2, 0xa5, 0xe7, 0xda, 0xfd, 0x80, 0xda, 0xa8,
	0x05, 0x99, 0xae, 0x83, 0x8d, 0xba, 0xd1, 0x2c, 0x99, 0xdb, 0xf7, 0x93, 0x1a, 0xe6, 0xaa, 0xaf,
	0x87, 0x96, 0xe7, 0x58, 0xcc, 0x0f, 0xc7, 0x2d, 0x77, 0x38, 0x1c, 0x31, 0xeb, 0x6a, 0x40, 0x49,
	0xa6, 0xeb, 0xa0, 0x2f, 0xa1, 0xd0, 0x1f, 0x5d, 0x79, 0x94, 0x75, 0x1d, 0x9c, 0xf9, 0x1b, 0x9a,
	0x84, 0x8d, 0x4e, 0x61, 0x85, 0xc7, 0x3c, 0xf2, 0x6c, 0x2b, 0xc0, 0x4b, 0x75, 0xa3, 0x59, 0xdc,
	0x2b, 0xed, 0xca, 0xac, 0x04, 0xf6, 0x01, 0x47, 0xa9, 0x18, 0x3d, 0x05, 0x38, 0x6b, 0x77, 0xda,
	0x8e, 0x13, 0xd2, 0x28, 0xc2, 0xd9, 0xba, 0xd1, 0xcc, 0x7e, 0x40, 0xac, 0xf1, 0x51, 0x0b, 0xd6,
	0xfb, 0xfe, 0x28, 0xb4, 0xe9, 0xc9, 0xc8, 0x0a, 0x9d, 0x23, 0x8f, 0x13, 0xf0, 0x72, 0xdd, 0x68,
	0x16, 0xc8, 0xfc, 0x02, 0x32, 0xa1, 0x78, 0x6c, 0x5d, 0x85, 0x71, 0xde, 0xb9, 0x05, 0x79, 0xa3,
	0xfb, 0x49, 0xad, 0x2c, 0x42, 0xa7, 0x01, 0x75, 0x11, 0x8f, 0x78, 0x71, 0x77, 0xe6, 0x86, 0xa1,
	0x1f, 0xf6, 0x69, 0x14, 0xb9, 0xbe, 0xd7, 0x75, 0x70, 0xbe, 0xbe, 0xd4, 0x2c, 0x91, 0xf9, 0x05,
	0xce, 0x26, 0x73, 0xec, 0x82, 0x64, 0xcf, 0x2d, 0xa0, 0x35, 0x58, 0xba, 0x3c, 0x3f, 0xc6, 0x2b,
	0x22, 0x7f, 0xfe, 0x88, 0xf6, 0xe1, 0x61, 0xd7, 0xbb, 0xb9, 0xdc, 0xef, 0x53, 0x7b, 0x14, 0xba,
	0x6c, 0xdc, 0xf3, 0x07, 0xae, 0x3d, 0xee, 0x3a, 0x18, 0x84, 0x8f, 0xc5, 0x8b, 0xb1, 0xea, 0x60,
	0x4e, 0x55, 0x4c, 0x55, 0x73, 0x8b, 0x68, 0x0f, 0x36, 0x8f, 0x16, 0x85, 0x2a, 0x09, 0xd1, 0xc2,
	0x35, 0xa5, 0x99, 0x0f, 0xb4, 0x9a, 0x68, 0xe6, 0xe3, 0x60, 0xc8, 0x9d, 0xfa, 0x11, 0xeb, 0x5e,
	0xe3, 0x32, 0x9f, 0xb9, 0xd3, 0x07, 0x44, 0xd9, 0x68, 0x1b, 0x0a, 0x17, 0x23, 0xcf, 0xa3, 0x83,
	0xae, 0x83, 0x2b, 0x6a, 0x2d, 0x41, 0x50, 0x1d, 0x8a, 0x17, 0x77, 0xc2, 0x0b, 0x0d, 0xbb, 0x0e,
	0x5e, 0xe3, 0x04, 0xa2, 0x43, 0x9c, 0x41, 0x34, 0xc6, 0xba, 0x64, 0x68, 0x10, 0x6a, 0x41, 0xbe,
	0x17, 0xba, 0x43, 0x2b, 0x1c, 0x63, 0xc4, 0xbb, 0xbc, 0x70, 0xbf, 0x63, 0x0a, 0xaa, 0x42, 0x81,
	0x67, 0x76, 0x6e, 0x0d, 0x29, 0xde, 0xa8, 0x1b, 0xcd, 0x15, 0x92, 0xd8, 0x3c, 0xd6, 0x99, 0x75,
	0xa7, 0xf6, 0x2e, 0xc2, 0x9b, 0x75, 0xa3, 0xb9, 0x4a, 0x74, 0x08, 0xed, 0x43, 0xf1, 0x78, 0xe0,
	0xbf, 0x7e, 0xe1, 0xdf, 0xf0, 0xa3, 0x89, 0x1f, 0x8a, 0x69, 0x43, 0x6a, 0xda, 0xb4, 0x15, 0xa2,
	0xd3, 0x10, 0x86, 0xfc, 0x19, 0x65, 0x34, 0x3c, 0xf2, 0xf0, 0x96, 0x98, 0x83, 0xd8, 0x44, 0xff,
	0x85, 0xd5, 0xcb, 0x7d, 0x61, 0xc8, 0x56, 0xe2, 0x47, 0xa2, 0xbe, 0x69, 0x50, 0xb0, 0x0e, 0x74,
	0x16, 0x56, 0x2c, 0x1d, 0x44, 0xdf, 0xc2, 0x5a, 0x6f, 0x74, 0x35, 0x70, 0x6d, 0xed, 0xec, 0xfd,
	0x4b, 0x9c, 0xbd, 0x45, 0x0d, 0x99, 0xe3, 0xa2, 0x6d, 0x58, 0x39, 0x6d, 0xcb, 0x53, 0xe5, 0xe0,
	0xaa, 0xc8, 0x33, 0x05, 0x78, 0x6f, 0x5e, 0x98, 0xa6, 0x65, 0xbf, 0xa4, 0x9e, 0xd3, 0x75, 0xf0,
	0xbf, 0xb9, 0x63, 0xa2, 0x43, 0xe8, 0x31, 0x6c, 0xb4, 0x07, 0x03, 0xff, 0x75, 0xd7, 0x63, 0x34,
	0xf4, 0x28, 0x6b, 0xdb, 0x36, 0x4f, 0x61, 0x5b, 0x78, 0x5a, 0xb4, 0x84, 0xb6, 0x20, 0x77, 0x66,
	0xdd, 0x75, 0x7a, 0x7d, 0xfc, 0x1f, 0xd1, 0x6a, 0x65, 0xa1, 0x7d, 0x28, 0x74, 0x7a, 0x7d, 0x73,
	0x14, 0x46, 0x0c, 0xef, 0xf0, 0x15, 0x13, 0xdf, 0x4f, 0x6a, 0x9b, 0xa2, 0x02, 0x87, 0x5e, 0x5b,
	0xa3, 0x01, 0x7b, 0xf6, 0xf9, 0x63, 0xf1, 0x47, 0x12, 0x26, 0x3a, 0x06, 0x74, 0xe8, 0x46, 0x3c,
	0x5b, 0x59, 0xda, 0xc9, 0x8f, 0xe7, 0xed, 0x0b, 0x5c, 0x13, 0x23, 0xb1, 0x75, 0x3f, 0xa9, 0xa1,
	0x29, 0xfd, 0xb5, 0x35, 0x88, 0x28, 0x59, 0xa0, 0xe0, 0x95, 0xaa, 0x61, 0xe1, 0x37, 0x1a, 0xae,
	0xcb, 0x89, 0xd3, 0x20, 0xb3, 0x00, 0x39, 0xf7, 0xda, 0xf5, 0xae, 0xfd, 0xc6, 0x1f, 0x06, 0x80,
	0xb8, 0xa8, 0x99, 0xc5, 0x46, 0x11, 0x42, 0x90, 0x3d, 0x7d, 0xad, 0x2e, 0xeb, 0x55, 0x22, 0x9e,
	0x79, 0x91, 0xe7, 0xb7, 0x02, 0xcd, 0xc8, 0x22, 0xa5, 0x85, 0x36, 0x61, 0xf9, 0x28, 0xf0, 0xed,
	0x5b, 0x71, 0xd5, 0xae, 0x12, 0x69, 0xa0, 0x26, 0x54, 0xa6, 0xf6, 0xbe, 0xeb, 0x88, 0xfb, 0xb3,
	0x44, 0x66, 0x61, 0xc1, 0x3c, 0x98, 0x66, 0x2e, 0x2b, 0xe6, 0x34, 0xcc, 0x0b, 0xea, 0xf4, 0xfa,
	0x1d, 0x3f, 0x08, 0x44, 0x1a, 0x39, 0x39, 0xd6, 0x1a, 0xd4, 0x78, 0x63, 0x40, 0x99, 0x97, 0x21,
	0x74, 0xbc, 0x96, 0x08, 0xed, 0x00, 0x08, 0xab, 0x33, 0xb0, 0xa2, 0x48, 0x15, 0xa4, 0x21, 0xe8,
	0xff, 0x50, 0x16, 0xd6, 0xc5, 0x5d, 0x8f, 0x4f, 0x00, 0x8b, 0x44, 0x79, 0x59, 0x32, 0x83, 0xa2,
	0x06, 0x94, 0x14, 0x62, 0x8e, 0x19, 0x8d, 0x44, 0xb5, 0x59, 0x32, 0x85, 0x25, 0xbe, 0x48, 0xe2,
	0x2b, 0xab, 0xf9, 0x22, 0x73, 0xbe, 0x88, 0xf2, 0xb5, 0xac, 0xf9, 0x52, 0x58, 0xe3, 0x97, 0x8c,
	0x7c, 0x8d, 0xc9, 0x2a, 0x30, 0xe4, 0xe3, 0xc0, 0x86, 0x20, 0xc7, 0x26, 0x9f, 0xf6, 0xd9, 0xd4,
	0x53, 0x80, 0xeb, 0xc8, 0x54, 0xc2, 0xb1, 0xc9, 0x75, 0xb3, 0x69, 0xa6, 0x00, 0xaf, 0xa4, 0x6d,
	0x33, 0xf7, 0x15, 0x4d, 0x2e, 0x11, 0x99, 0xe3, 0x0c, 0x8a, 0x9e, 0xa8, 0xee, 0x8a, 0x2c, 0x71,
	0xae, 0xbe, 0xd4, 0x2c, 0xee, 0x6d, 0xec, 0x06, 0x4e, 0xb4, 0x3b, 0xbd, 0x0d, 0x44, 0xa3, 0xa1,
	0x16, 0xac, 0x1c, 0x86, 0x7e, 0x20, 0x35, 0x79, 0xa1, 0x29, 0xab, 0xab, 0xa7, 0xe3, 0x8f, 0xf8,
	0xd1, 0x22, 0x29, 0xa1, 0xf1, 0x7b, 0x06, 0xb2, 0xdc, 0x19, 0xfa, 0x06, 0x0a, 0x17, 0xe3, 0x80,
	0x9e, 0x51, 0x66, 0x89, 0x26, 0x70, 0x95, 0xf8, 0xf0, 0x88, 0x51, 0xb3, 0xf2, 0x76, 0x52, 0x33,
	0xde, 0x4f, 0x6a, 0xf9, 0x96, 0xeb, 0x0d, 0x5c, 0x8f, 0x92, 0x44, 0x80, 0x9e, 0x43, 0xfe, 0xbb,
	0xab, 0x9f, 0x84, 0x36, 0x23, 0xb4, 0xab, 0x52, 0xab, 0x40, 0x73, 0x4b, 0x49, 0xc5, 0xf5, 0xd2,
	0xf2, 0x87, 0x2e, 0xa3, 0xc3, 0x80, 0x8d, 0x49, 0xac, 0x42, 0x5f, 0x40, 0x56, 0x5c, 0x95, 0x4b,
	0x4a, 0x1d, 0xd7, 0xc8, 0x41, 0x13, 0x71, 0x65, 0x14, 0x50, 0x5b, 0x53, 0x0a, 0x3a, 0x7a, 0x06,
	0x39, 0x79, 0xa6, 0x44, 0x8f, 0x8b, 0x7b, 0x95, 0x54, 0x28, 0x60, 0x73, 0xf3, 0xfd, 0xa4, 0xb6,
	0x16, 0x89, 0x67, 0x4d, 0xac, 0x44, 0xe8, 0x2b, 0x58, 0x96, 0x6d, 0x5a, 0x56, 0x05, 0xeb, 0xea,
	0xc8, 0xdc, 0x78, 0x3f, 0xa9, 0x55, 0xb8, 0x58, 0xd7, 0x4a, 0x45, 0xe3, 0x1a, 0x8a, 0x9c, 0x48,
	0xe8, 0xcf, 0x23, 0x1a, 0x31, 0xb4, 0x0b, 0x2b, 0xa6, 0xc5, 0xec, 0xdb, 0x0e, 0xbb, 0x63, 0xaa,
	0x7d, 0x6b, 0xaa, 0xe9, 0x09, 0x4e, 0x52, 0x0a, 0xfa, 0x04, 0xf2, 0x4a, 0x8a, 0x33, 0x62, 0x8b,
	0xa6, 0x4b, 0x26, 0xf1, 0x6a, 0xe3, 0x25, 0x94, 0x64, 0x9c, 0x28, 0xf0, 0xbd, 0x88, 0xf2, 0x40,
	0xed, 0xc0, 0x55, 0x45, 0xf3, 0x40, 0xe5, 0x24, 0x50, 0x82, 0x93, 0x94, 0x82, 0x3e, 0x85, 0x42,
	0xac, 0x55, 0x91, 0x66, 0x7b, 0x44, 0x12, 0x42, 0xa3, 0x2e, 0xcf, 0xf7, 0x09, 0x65, 0x71, 0x5d,
	0x65, 0xf5, 0x55, 0xc9, 0xdf, 0xe9, 0x99, 0xae, 0xd3, 0xb8, 0x85, 0x4a, 0xc2, 0xf8, 0xc8, 0x8c,
	0xfe, 0x37, 0x97, 0xd1, 0x4a, 0x92, 0x91, 0x96, 0x4b, 0x1f, 0xd6, 0x39, 0x72, 0x48, 0x07, 0x94,
	0xd1, 0x8f, 0x6d, 0xb3, 0x4c, 0x3f, 0x93, 0xa4, 0x7f, 0x08, 0x48, 0x77, 0xba, 0xb8, 0x82, 0xa5,
	0x0f, 0x54, 0xd0, 0xf8, 0x1e, 0x1e, 0x26, 0x43, 0x42, 0x68, 0x34, 0xdf, 0x2d, 0x43, 0x86, 0xe3,
	0x97, 0x6f, 0x67, 0x40, 0xad, 0x50, 0x3b, 0xc4, 0x19, 0xf1, 0x9e, 0x9b, 0x85, 0xf7, 0x7e, 0xcb,
	0x40, 0x5e, 0xf8, 0x7c, 0x65, 0xf3, 0x53, 0xcf, 0x1f, 0x3b, 0x21, 0xb5, 0x18, 0x45, 0x6b, 0x69,
	0x73, 0x64, 0x94, 0xea, 0xba, 0x86, 0xa8, 0x66, 0x3d, 0x88, 0x45, 0x3f, 0x04, 0xce, 0x3f, 0x10,
	0x1d, 0xc8, 0xa0, 0x27, 0x94, 0xa1, 0xf4, 0x5a, 0x49, 0x77, 0xbf, 0xba, 0x39, 0x0d, 0x26, 0xba,
	0xe7, 0x32, 0x98, 0x6c, 0x23, 0xda, 0x4a, 0x58, 0x53, 0x9b, 0x55, 0x7d, 0x34, 0x87, 0x27, 0x0e,
	0x9e, 0xca, 0x41, 0x4b, 0x3b, 0x88, 0xaa, 0xd3, 0x67, 0x4f, 0x6f, 0x6b, 0x35, 0xf9, 0x4e, 0xe7,
	0x07, 0xb0, 0xf1, 0xc0, 0x2c, 0xbd, 0x79, 0xb7, 0x63, 0xbc, 0x7d, 0xb7, 0x63, 0xfc, 0xf9, 0x6e,
	0xc7, 0xb8, 0xca, 0x89, 0x1f, 0x43, 0x4f, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xb6, 0xaa, 0xce,
	0xa0, 0x49, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VnicSvcClient is the client API for VnicSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VnicSvcClient interface {
	VnicCreate(ctx context.Context, in *VnicRequest, opts ...grpc.CallOption) (*VnicResponse, error)
	VnicUpdate(ctx context.Context, in *VnicRequest, opts ...grpc.CallOption) (*VnicResponse, error)
	VnicGet(ctx context.Context, in *VnicGetRequest, opts ...grpc.CallOption) (*VnicGetResponse, error)
	VnicDelete(ctx context.Context, in *VnicDeleteRequest, opts ...grpc.CallOption) (*VnicDeleteResponse, error)
	VnicStatsReset(ctx context.Context, in *VnicStatsResetRequest, opts ...grpc.CallOption) (*Empty, error)
}

type vnicSvcClient struct {
	cc *grpc.ClientConn
}

func NewVnicSvcClient(cc *grpc.ClientConn) VnicSvcClient {
	return &vnicSvcClient{cc}
}

func (c *vnicSvcClient) VnicCreate(ctx context.Context, in *VnicRequest, opts ...grpc.CallOption) (*VnicResponse, error) {
	out := new(VnicResponse)
	err := c.cc.Invoke(ctx, "/pds.VnicSvc/VnicCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vnicSvcClient) VnicUpdate(ctx context.Context, in *VnicRequest, opts ...grpc.CallOption) (*VnicResponse, error) {
	out := new(VnicResponse)
	err := c.cc.Invoke(ctx, "/pds.VnicSvc/VnicUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vnicSvcClient) VnicGet(ctx context.Context, in *VnicGetRequest, opts ...grpc.CallOption) (*VnicGetResponse, error) {
	out := new(VnicGetResponse)
	err := c.cc.Invoke(ctx, "/pds.VnicSvc/VnicGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vnicSvcClient) VnicDelete(ctx context.Context, in *VnicDeleteRequest, opts ...grpc.CallOption) (*VnicDeleteResponse, error) {
	out := new(VnicDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.VnicSvc/VnicDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vnicSvcClient) VnicStatsReset(ctx context.Context, in *VnicStatsResetRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.VnicSvc/VnicStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VnicSvcServer is the server API for VnicSvc service.
type VnicSvcServer interface {
	VnicCreate(context.Context, *VnicRequest) (*VnicResponse, error)
	VnicUpdate(context.Context, *VnicRequest) (*VnicResponse, error)
	VnicGet(context.Context, *VnicGetRequest) (*VnicGetResponse, error)
	VnicDelete(context.Context, *VnicDeleteRequest) (*VnicDeleteResponse, error)
	VnicStatsReset(context.Context, *VnicStatsResetRequest) (*Empty, error)
}

// UnimplementedVnicSvcServer can be embedded to have forward compatible implementations.
type UnimplementedVnicSvcServer struct {
}

func (*UnimplementedVnicSvcServer) VnicCreate(ctx context.Context, req *VnicRequest) (*VnicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VnicCreate not implemented")
}
func (*UnimplementedVnicSvcServer) VnicUpdate(ctx context.Context, req *VnicRequest) (*VnicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VnicUpdate not implemented")
}
func (*UnimplementedVnicSvcServer) VnicGet(ctx context.Context, req *VnicGetRequest) (*VnicGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VnicGet not implemented")
}
func (*UnimplementedVnicSvcServer) VnicDelete(ctx context.Context, req *VnicDeleteRequest) (*VnicDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VnicDelete not implemented")
}
func (*UnimplementedVnicSvcServer) VnicStatsReset(ctx context.Context, req *VnicStatsResetRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VnicStatsReset not implemented")
}

func RegisterVnicSvcServer(s *grpc.Server, srv VnicSvcServer) {
	s.RegisterService(&_VnicSvc_serviceDesc, srv)
}

func _VnicSvc_VnicCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VnicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VnicSvcServer).VnicCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VnicSvc/VnicCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VnicSvcServer).VnicCreate(ctx, req.(*VnicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VnicSvc_VnicUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VnicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VnicSvcServer).VnicUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VnicSvc/VnicUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VnicSvcServer).VnicUpdate(ctx, req.(*VnicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VnicSvc_VnicGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VnicGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VnicSvcServer).VnicGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VnicSvc/VnicGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VnicSvcServer).VnicGet(ctx, req.(*VnicGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VnicSvc_VnicDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VnicDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VnicSvcServer).VnicDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VnicSvc/VnicDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VnicSvcServer).VnicDelete(ctx, req.(*VnicDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VnicSvc_VnicStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VnicStatsResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VnicSvcServer).VnicStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.VnicSvc/VnicStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VnicSvcServer).VnicStatsReset(ctx, req.(*VnicStatsResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VnicSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.VnicSvc",
	HandlerType: (*VnicSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VnicCreate",
			Handler:    _VnicSvc_VnicCreate_Handler,
		},
		{
			MethodName: "VnicUpdate",
			Handler:    _VnicSvc_VnicUpdate_Handler,
		},
		{
			MethodName: "VnicGet",
			Handler:    _VnicSvc_VnicGet_Handler,
		},
		{
			MethodName: "VnicDelete",
			Handler:    _VnicSvc_VnicDelete_Handler,
		},
		{
			MethodName: "VnicStatsReset",
			Handler:    _VnicSvc_VnicStatsReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vnic.proto",
}

func (m *VnicSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrimaryVnic) > 0 {
		i -= len(m.PrimaryVnic)
		copy(dAtA[i:], m.PrimaryVnic)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.PrimaryVnic)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.DisablePublicGWNAT {
		i--
		if m.DisablePublicGWNAT {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CPSBurst != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.CPSBurst))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.MaxCPS != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MaxCPS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.AllowInternetAccess {
		i--
		if m.AllowInternetAccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.LBBackendId != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.LBBackendId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.HAEnabled {
		i--
		if m.HAEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.PublicMACAddress != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.PublicMACAddress))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.V6MeterPolicy) > 0 {
		i -= len(m.V6MeterPolicy)
		copy(dAtA[i:], m.V6MeterPolicy)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.V6MeterPolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.V4MeterPolicy) > 0 {
		i -= len(m.V4MeterPolicy)
		copy(dAtA[i:], m.V4MeterPolicy)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.V4MeterPolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.MeterEn {
		i--
		if m.MeterEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.FlowLogSpec != nil {
		{
			size, err := m.FlowLogSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MaxSessions != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MaxSessions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.RxPolicerId) > 0 {
		i -= len(m.RxPolicerId)
		copy(dAtA[i:], m.RxPolicerId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.RxPolicerId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TxPolicerId) > 0 {
		i -= len(m.TxPolicerId)
		copy(dAtA[i:], m.TxPolicerId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.TxPolicerId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Ifinfo != nil {
		{
			size := m.Ifinfo.Size()
			i -= size
			if _, err := m.Ifinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV6SecurityPolicyId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.EgV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.EgV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EgV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.EgV4SecurityPolicyId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.EgV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV6SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV6SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV6SecurityPolicyId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.IngV6SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for iNdEx := len(m.IngV4SecurityPolicyId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IngV4SecurityPolicyId[iNdEx])
			copy(dAtA[i:], m.IngV4SecurityPolicyId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.IngV4SecurityPolicyId[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.VNF {
		i--
		if m.VNF {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.RxMirrorSessionId) > 0 {
		for iNdEx := len(m.RxMirrorSessionId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RxMirrorSessionId[iNdEx])
			copy(dAtA[i:], m.RxMirrorSessionId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.RxMirrorSessionId[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TxMirrorSessionId) > 0 {
		for iNdEx := len(m.TxMirrorSessionId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TxMirrorSessionId[iNdEx])
			copy(dAtA[i:], m.TxMirrorSessionId[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.TxMirrorSessionId[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.FabricEncap != nil {
		{
			size, err := m.FabricEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SourceGuardEnable {
		i--
		if m.SourceGuardEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MACAddress != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x20
	}
	if m.VnicEncap != nil {
		{
			size, err := m.VnicEncap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VnicSpec_HostIf) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *VnicSpec_HostIf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostIf != nil {
		i -= len(m.HostIf)
		copy(dAtA[i:], m.HostIf)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.HostIf)))
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *VnicSpec_TunnelId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *VnicSpec_TunnelId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelId != nil {
		i -= len(m.TunnelId)
		copy(dAtA[i:], m.TunnelId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.TunnelId)))
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *VnicStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CPSCoppHwId != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.CPSCoppHwId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.V6MeterPolicyId) > 0 {
		i -= len(m.V6MeterPolicyId)
		copy(dAtA[i:], m.V6MeterPolicyId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.V6MeterPolicyId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.V4MeterPolicyId) > 0 {
		i -= len(m.V4MeterPolicyId)
		copy(dAtA[i:], m.V4MeterPolicyId)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.V4MeterPolicyId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Epoch != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if m.NhHwId != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.NhHwId))
		i--
		dAtA[i] = 0x10
	}
	if m.HwId != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.HwId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VnicMeterStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicMeterStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicMeterStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MeterRxBytes != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MeterRxBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.MeterRxPackets != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MeterRxPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.MeterTxBytes != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MeterTxBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.MeterTxPackets != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MeterTxPackets))
		i--
		dAtA[i] = 0x10
	}
	if m.MeterClass != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.MeterClass))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VnicStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DropStats) > 0 {
		for iNdEx := len(m.DropStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DropStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVnic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.MeterStats) > 0 {
		for iNdEx := len(m.MeterStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeterStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVnic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ActiveSessions != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.ActiveSessions))
		i--
		dAtA[i] = 0x28
	}
	if m.RxPackets != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.RxPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.RxBytes != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.RxBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.TxPackets != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.TxPackets))
		i--
		dAtA[i] = 0x10
	}
	if m.TxBytes != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.TxBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vnic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vnic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vnic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VnicRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVnic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VnicResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVnic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VnicGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VnicGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVnic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintVnic(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VnicDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintVnic(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVnic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VnicDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA12 := make([]byte, len(m.ApiStatus)*10)
		var j11 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintVnic(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VnicStatsResetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnicStatsResetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VnicStatsResetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClearMeterStats {
		i--
		if m.ClearMeterStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintVnic(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintVnic(dAtA []byte, offset int, v uint64) int {
	offset -= sovVnic(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VnicSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVnic(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.VnicEncap != nil {
		l = m.VnicEncap.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovVnic(uint64(m.MACAddress))
	}
	if m.SourceGuardEnable {
		n += 2
	}
	if m.FabricEncap != nil {
		l = m.FabricEncap.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.VNF {
		n += 2
	}
	if len(m.IngV4SecurityPolicyId) > 0 {
		for _, b := range m.IngV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if len(m.IngV6SecurityPolicyId) > 0 {
		for _, b := range m.IngV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if len(m.EgV4SecurityPolicyId) > 0 {
		for _, b := range m.EgV4SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if len(m.EgV6SecurityPolicyId) > 0 {
		for _, b := range m.EgV6SecurityPolicyId {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.Ifinfo != nil {
		n += m.Ifinfo.Size()
	}
	l = len(m.TxPolicerId)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	l = len(m.RxPolicerId)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	if m.Primary {
		n += 3
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	if m.MaxSessions != 0 {
		n += 2 + sovVnic(uint64(m.MaxSessions))
	}
	if m.FlowLogSpec != nil {
		l = m.FlowLogSpec.Size()
		n += 2 + l + sovVnic(uint64(l))
	}
	if m.MeterEn {
		n += 3
	}
	l = len(m.V4MeterPolicy)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	l = len(m.V6MeterPolicy)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	if m.PublicMACAddress != 0 {
		n += 2 + sovVnic(uint64(m.PublicMACAddress))
	}
	if m.HAEnabled {
		n += 3
	}
	if m.LBBackendId != 0 {
		n += 2 + sovVnic(uint64(m.LBBackendId))
	}
	if m.AllowInternetAccess {
		n += 3
	}
	if m.MaxCPS != 0 {
		n += 2 + sovVnic(uint64(m.MaxCPS))
	}
	if m.CPSBurst != 0 {
		n += 2 + sovVnic(uint64(m.CPSBurst))
	}
	if m.DisablePublicGWNAT {
		n += 3
	}
	l = len(m.PrimaryVnic)
	if l > 0 {
		n += 2 + l + sovVnic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicSpec_HostIf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostIf != nil {
		l = len(m.HostIf)
		n += 1 + l + sovVnic(uint64(l))
	}
	return n
}
func (m *VnicSpec_TunnelId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		l = len(m.TunnelId)
		n += 1 + l + sovVnic(uint64(l))
	}
	return n
}
func (m *VnicStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HwId != 0 {
		n += 1 + sovVnic(uint64(m.HwId))
	}
	if m.NhHwId != 0 {
		n += 1 + sovVnic(uint64(m.NhHwId))
	}
	if m.Epoch != 0 {
		n += 1 + sovVnic(uint64(m.Epoch))
	}
	l = len(m.V4MeterPolicyId)
	if l > 0 {
		n += 1 + l + sovVnic(uint64(l))
	}
	l = len(m.V6MeterPolicyId)
	if l > 0 {
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.CPSCoppHwId != 0 {
		n += 1 + sovVnic(uint64(m.CPSCoppHwId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicMeterStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MeterClass != 0 {
		n += 1 + sovVnic(uint64(m.MeterClass))
	}
	if m.MeterTxPackets != 0 {
		n += 1 + sovVnic(uint64(m.MeterTxPackets))
	}
	if m.MeterTxBytes != 0 {
		n += 1 + sovVnic(uint64(m.MeterTxBytes))
	}
	if m.MeterRxPackets != 0 {
		n += 1 + sovVnic(uint64(m.MeterRxPackets))
	}
	if m.MeterRxBytes != 0 {
		n += 1 + sovVnic(uint64(m.MeterRxBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxBytes != 0 {
		n += 1 + sovVnic(uint64(m.TxBytes))
	}
	if m.TxPackets != 0 {
		n += 1 + sovVnic(uint64(m.TxPackets))
	}
	if m.RxBytes != 0 {
		n += 1 + sovVnic(uint64(m.RxBytes))
	}
	if m.RxPackets != 0 {
		n += 1 + sovVnic(uint64(m.RxPackets))
	}
	if m.ActiveSessions != 0 {
		n += 1 + sovVnic(uint64(m.ActiveSessions))
	}
	if len(m.MeterStats) > 0 {
		for _, e := range m.MeterStats {
			l = e.Size()
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if len(m.DropStats) > 0 {
		for _, e := range m.DropStats {
			l = e.Size()
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vnic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVnic(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovVnic(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovVnic(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovVnic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovVnic(uint64(e))
		}
		n += 1 + sovVnic(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VnicStatsResetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVnic(uint64(l))
	}
	if m.ClearMeterStats {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVnic(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVnic(x uint64) (n int) {
	return sovVnic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VnicSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = append(m.SubnetId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubnetId == nil {
				m.SubnetId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnicEncap == nil {
				m.VnicEncap = &Encap{}
			}
			if err := m.VnicEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGuardEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceGuardEnable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FabricEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FabricEncap == nil {
				m.FabricEncap = &Encap{}
			}
			if err := m.FabricEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMirrorSessionId = append(m.TxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.TxMirrorSessionId[len(m.TxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxMirrorSessionId = append(m.RxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.RxMirrorSessionId[len(m.RxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNF", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VNF = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV4SecurityPolicyId = append(m.IngV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV4SecurityPolicyId[len(m.IngV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngV6SecurityPolicyId = append(m.IngV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.IngV6SecurityPolicyId[len(m.IngV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV4SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV4SecurityPolicyId = append(m.EgV4SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV4SecurityPolicyId[len(m.EgV4SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgV6SecurityPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgV6SecurityPolicyId = append(m.EgV6SecurityPolicyId, make([]byte, postIndex-iNdEx))
			copy(m.EgV6SecurityPolicyId[len(m.EgV6SecurityPolicyId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Ifinfo = &VnicSpec_HostIf{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Ifinfo = &VnicSpec_TunnelId{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPolicerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxPolicerId = append(m.TxPolicerId[:0], dAtA[iNdEx:postIndex]...)
			if m.TxPolicerId == nil {
				m.TxPolicerId = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPolicerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxPolicerId = append(m.RxPolicerId[:0], dAtA[iNdEx:postIndex]...)
			if m.RxPolicerId == nil {
				m.RxPolicerId = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLogSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowLogSpec == nil {
				m.FlowLogSpec = &FlowLogSpec{}
			}
			if err := m.FlowLogSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MeterEn = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4MeterPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4MeterPolicy = append(m.V4MeterPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.V4MeterPolicy == nil {
				m.V4MeterPolicy = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6MeterPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6MeterPolicy = append(m.V6MeterPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.V6MeterPolicy == nil {
				m.V6MeterPolicy = []byte{}
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicMACAddress", wireType)
			}
			m.PublicMACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicMACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HAEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HAEnabled = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LBBackendId", wireType)
			}
			m.LBBackendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LBBackendId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowInternetAccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowInternetAccess = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCPS", wireType)
			}
			m.MaxCPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCPS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPSBurst", wireType)
			}
			m.CPSBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CPSBurst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePublicGWNAT", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePublicGWNAT = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryVnic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryVnic = append(m.PrimaryVnic[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryVnic == nil {
				m.PrimaryVnic = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwId", wireType)
			}
			m.HwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NhHwId", wireType)
			}
			m.NhHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NhHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4MeterPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4MeterPolicyId = append(m.V4MeterPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.V4MeterPolicyId == nil {
				m.V4MeterPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6MeterPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6MeterPolicyId = append(m.V6MeterPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.V6MeterPolicyId == nil {
				m.V6MeterPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPSCoppHwId", wireType)
			}
			m.CPSCoppHwId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CPSCoppHwId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicMeterStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicMeterStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicMeterStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterClass", wireType)
			}
			m.MeterClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterClass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterTxPackets", wireType)
			}
			m.MeterTxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterTxPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterTxBytes", wireType)
			}
			m.MeterTxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterTxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterRxPackets", wireType)
			}
			m.MeterRxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterRxPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterRxBytes", wireType)
			}
			m.MeterRxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterRxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
			}
			m.TxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
			}
			m.RxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveSessions", wireType)
			}
			m.ActiveSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveSessions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeterStats = append(m.MeterStats, &VnicMeterStats{})
			if err := m.MeterStats[len(m.MeterStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropStats = append(m.DropStats, &Counter{})
			if err := m.DropStats[len(m.DropStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vnic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vnic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vnic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &VnicSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &VnicStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &VnicStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &VnicSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &VnicStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Vnic{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVnic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVnic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVnic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVnic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVnic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnicStatsResetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnicStatsResetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnicStatsResetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVnic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVnic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearMeterStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearMeterStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVnic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVnic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVnic
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVnic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVnic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVnic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVnic
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVnic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVnic   = fmt.Errorf("proto: integer overflow")
)
