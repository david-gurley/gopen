// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lim.proto

package pds

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LimIfOperStatus int32

const (
	LimIfOperStatus_OPER_NONE           LimIfOperStatus = 0
	LimIfOperStatus_OPER_UP             LimIfOperStatus = 1
	LimIfOperStatus_OPER_DOWN           LimIfOperStatus = 2
	LimIfOperStatus_OPER_TESTING        LimIfOperStatus = 3
	LimIfOperStatus_OPER_UNKNOWN        LimIfOperStatus = 4
	LimIfOperStatus_OPER_DORMANT        LimIfOperStatus = 5
	LimIfOperStatus_OPER_NOT_PRESENT    LimIfOperStatus = 6
	LimIfOperStatus_OPER_LOWER_LAYER_DN LimIfOperStatus = 7
)

var LimIfOperStatus_name = map[int32]string{
	0: "OPER_NONE",
	1: "OPER_UP",
	2: "OPER_DOWN",
	3: "OPER_TESTING",
	4: "OPER_UNKNOWN",
	5: "OPER_DORMANT",
	6: "OPER_NOT_PRESENT",
	7: "OPER_LOWER_LAYER_DN",
}

var LimIfOperStatus_value = map[string]int32{
	"OPER_NONE":           0,
	"OPER_UP":             1,
	"OPER_DOWN":           2,
	"OPER_TESTING":        3,
	"OPER_UNKNOWN":        4,
	"OPER_DORMANT":        5,
	"OPER_NOT_PRESENT":    6,
	"OPER_LOWER_LAYER_DN": 7,
}

func (x LimIfOperStatus) String() string {
	return proto.EnumName(LimIfOperStatus_name, int32(x))
}

func (LimIfOperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{0}
}

type LimIfType int32

const (
	LimIfType_IFTYP_NONE              LimIfType = 0
	LimIfType_IFTYP_OTHER             LimIfType = 1
	LimIfType_IFTYP_ETHERNET_CSMACD   LimIfType = 6
	LimIfType_IFTYP_SOFTWARE_LOOPBACK LimIfType = 24
	LimIfType_IFTYP_PROP_VIRTUAL      LimIfType = 53
	LimIfType_IFTYP_TUNNEL            LimIfType = 131
	LimIfType_IFTYP_L2VLAN            LimIfType = 135
	LimIfType_IFTYP_L3IPVLAN          LimIfType = 136
	LimIfType_IFTYP_IP_FORWARD        LimIfType = 142
	LimIfType_IFTYP_MPLS_TUNNEL       LimIfType = 150
	LimIfType_IFTYP_8023AD_LAG        LimIfType = 161
	LimIfType_IFTYP_MPLS              LimIfType = 166
	LimIfType_IFTYP_IF_PW_TYPE        LimIfType = 246
	LimIfType_IFTYP_HQOS_NODE         LimIfType = 4096
	LimIfType_IFTYP_FLOW              LimIfType = 4097
)

var LimIfType_name = map[int32]string{
	0:    "IFTYP_NONE",
	1:    "IFTYP_OTHER",
	6:    "IFTYP_ETHERNET_CSMACD",
	24:   "IFTYP_SOFTWARE_LOOPBACK",
	53:   "IFTYP_PROP_VIRTUAL",
	131:  "IFTYP_TUNNEL",
	135:  "IFTYP_L2VLAN",
	136:  "IFTYP_L3IPVLAN",
	142:  "IFTYP_IP_FORWARD",
	150:  "IFTYP_MPLS_TUNNEL",
	161:  "IFTYP_8023AD_LAG",
	166:  "IFTYP_MPLS",
	246:  "IFTYP_IF_PW_TYPE",
	4096: "IFTYP_HQOS_NODE",
	4097: "IFTYP_FLOW",
}

var LimIfType_value = map[string]int32{
	"IFTYP_NONE":              0,
	"IFTYP_OTHER":             1,
	"IFTYP_ETHERNET_CSMACD":   6,
	"IFTYP_SOFTWARE_LOOPBACK": 24,
	"IFTYP_PROP_VIRTUAL":      53,
	"IFTYP_TUNNEL":            131,
	"IFTYP_L2VLAN":            135,
	"IFTYP_L3IPVLAN":          136,
	"IFTYP_IP_FORWARD":        142,
	"IFTYP_MPLS_TUNNEL":       150,
	"IFTYP_8023AD_LAG":        161,
	"IFTYP_MPLS":              166,
	"IFTYP_IF_PW_TYPE":        246,
	"IFTYP_HQOS_NODE":         4096,
	"IFTYP_FLOW":              4097,
}

func (x LimIfType) String() string {
	return proto.EnumName(LimIfType_name, int32(x))
}

func (LimIfType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{1}
}

type LimIfLoopbackMode int32

const (
	LimIfLoopbackMode_LOOPBACK_NONE LimIfLoopbackMode = 0
	LimIfLoopbackMode_MAC_LOOPBACK  LimIfLoopbackMode = 1
)

var LimIfLoopbackMode_name = map[int32]string{
	0: "LOOPBACK_NONE",
	1: "MAC_LOOPBACK",
}

var LimIfLoopbackMode_value = map[string]int32{
	"LOOPBACK_NONE": 0,
	"MAC_LOOPBACK":  1,
}

func (x LimIfLoopbackMode) String() string {
	return proto.EnumName(LimIfLoopbackMode_name, int32(x))
}

func (LimIfLoopbackMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{2}
}

type LimOperReason int32

const (
	LimOperReason_OPR_RSN_EMPTY           LimOperReason = 0
	LimOperReason_OPR_RSN_NONE            LimOperReason = 1
	LimOperReason_OPR_RSN_ENT_NOT_UP      LimOperReason = 2
	LimOperReason_OPR_RSN_ADMIN_CFG       LimOperReason = 3
	LimOperReason_OPR_RSN_PROG            LimOperReason = 4
	LimOperReason_OPR_RSN_HQOS_SET        LimOperReason = 5
	LimOperReason_OPR_RSN_HQOS_LVL        LimOperReason = 6
	LimOperReason_OPR_RSN_HQOS_NO_SRC_IF  LimOperReason = 7
	LimOperReason_OPR_RSN_HQOS_OVRLP_CFG  LimOperReason = 8
	LimOperReason_OPR_RSN_HQOS_INCMPLT_TR LimOperReason = 9
	LimOperReason_OPR_RSN_HQOS_DFLT_BRNCH LimOperReason = 10
	LimOperReason_OPR_RSN_Q_NO_IF         LimOperReason = 11
	LimOperReason_OPR_RSN_HQOS_NODE_NO_IF LimOperReason = 12
	LimOperReason_OPR_RSN_RSRC_FAIL       LimOperReason = 13
	LimOperReason_OPR_RSN_HQOS_PT_MSMTCH  LimOperReason = 14
	LimOperReason_OPR_RSN_Q_WRONG_IF      LimOperReason = 15
	LimOperReason_OPR_RSN_HQOS_WRONG_SRC  LimOperReason = 16
	LimOperReason_OPR_RSN_SUBIF_NO_MATCH  LimOperReason = 17
	LimOperReason_OPR_RSN_SUBIF_M_NO_IF   LimOperReason = 18
	LimOperReason_OPR_RSN_SUBIF_NO_PARENT LimOperReason = 19
	LimOperReason_OPR_RSN_LOCAL_IF_ERROR  LimOperReason = 20
	LimOperReason_OPR_RSN_SUBIF_R_NO_IF   LimOperReason = 21
	LimOperReason_OPR_RSN_SLOT_DOWN       LimOperReason = 22
)

var LimOperReason_name = map[int32]string{
	0:  "OPR_RSN_EMPTY",
	1:  "OPR_RSN_NONE",
	2:  "OPR_RSN_ENT_NOT_UP",
	3:  "OPR_RSN_ADMIN_CFG",
	4:  "OPR_RSN_PROG",
	5:  "OPR_RSN_HQOS_SET",
	6:  "OPR_RSN_HQOS_LVL",
	7:  "OPR_RSN_HQOS_NO_SRC_IF",
	8:  "OPR_RSN_HQOS_OVRLP_CFG",
	9:  "OPR_RSN_HQOS_INCMPLT_TR",
	10: "OPR_RSN_HQOS_DFLT_BRNCH",
	11: "OPR_RSN_Q_NO_IF",
	12: "OPR_RSN_HQOS_NODE_NO_IF",
	13: "OPR_RSN_RSRC_FAIL",
	14: "OPR_RSN_HQOS_PT_MSMTCH",
	15: "OPR_RSN_Q_WRONG_IF",
	16: "OPR_RSN_HQOS_WRONG_SRC",
	17: "OPR_RSN_SUBIF_NO_MATCH",
	18: "OPR_RSN_SUBIF_M_NO_IF",
	19: "OPR_RSN_SUBIF_NO_PARENT",
	20: "OPR_RSN_LOCAL_IF_ERROR",
	21: "OPR_RSN_SUBIF_R_NO_IF",
	22: "OPR_RSN_SLOT_DOWN",
}

var LimOperReason_value = map[string]int32{
	"OPR_RSN_EMPTY":           0,
	"OPR_RSN_NONE":            1,
	"OPR_RSN_ENT_NOT_UP":      2,
	"OPR_RSN_ADMIN_CFG":       3,
	"OPR_RSN_PROG":            4,
	"OPR_RSN_HQOS_SET":        5,
	"OPR_RSN_HQOS_LVL":        6,
	"OPR_RSN_HQOS_NO_SRC_IF":  7,
	"OPR_RSN_HQOS_OVRLP_CFG":  8,
	"OPR_RSN_HQOS_INCMPLT_TR": 9,
	"OPR_RSN_HQOS_DFLT_BRNCH": 10,
	"OPR_RSN_Q_NO_IF":         11,
	"OPR_RSN_HQOS_NODE_NO_IF": 12,
	"OPR_RSN_RSRC_FAIL":       13,
	"OPR_RSN_HQOS_PT_MSMTCH":  14,
	"OPR_RSN_Q_WRONG_IF":      15,
	"OPR_RSN_HQOS_WRONG_SRC":  16,
	"OPR_RSN_SUBIF_NO_MATCH":  17,
	"OPR_RSN_SUBIF_M_NO_IF":   18,
	"OPR_RSN_SUBIF_NO_PARENT": 19,
	"OPR_RSN_LOCAL_IF_ERROR":  20,
	"OPR_RSN_SUBIF_R_NO_IF":   21,
	"OPR_RSN_SLOT_DOWN":       22,
}

func (x LimOperReason) String() string {
	return proto.EnumName(LimOperReason_name, int32(x))
}

func (LimOperReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{3}
}

type LimOperStatus int32

const (
	LimOperStatus_OPER_STATUS_NONE        LimOperStatus = 0
	LimOperStatus_OPER_STATUS_UP          LimOperStatus = 1
	LimOperStatus_OPER_STATUS_DOWN        LimOperStatus = 2
	LimOperStatus_OPER_STATUS_GOING_UP    LimOperStatus = 3
	LimOperStatus_OPER_STATUS_GOING_DOWN  LimOperStatus = 4
	LimOperStatus_OPER_STATUS_FAILED      LimOperStatus = 5
	LimOperStatus_OPER_STATUS_FAILED_PERM LimOperStatus = 10
	LimOperStatus_OPER_STATUS_FAILING     LimOperStatus = 11
)

var LimOperStatus_name = map[int32]string{
	0:  "OPER_STATUS_NONE",
	1:  "OPER_STATUS_UP",
	2:  "OPER_STATUS_DOWN",
	3:  "OPER_STATUS_GOING_UP",
	4:  "OPER_STATUS_GOING_DOWN",
	5:  "OPER_STATUS_FAILED",
	10: "OPER_STATUS_FAILED_PERM",
	11: "OPER_STATUS_FAILING",
}

var LimOperStatus_value = map[string]int32{
	"OPER_STATUS_NONE":        0,
	"OPER_STATUS_UP":          1,
	"OPER_STATUS_DOWN":        2,
	"OPER_STATUS_GOING_UP":    3,
	"OPER_STATUS_GOING_DOWN":  4,
	"OPER_STATUS_FAILED":      5,
	"OPER_STATUS_FAILED_PERM": 10,
	"OPER_STATUS_FAILING":     11,
}

func (x LimOperStatus) String() string {
	return proto.EnumName(LimOperStatus_name, int32(x))
}

func (LimOperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{4}
}

type LimSoftwareType int32

const (
	LimSoftwareType_LIM_SOFTWIF_NONE     LimSoftwareType = 0
	LimSoftwareType_LIM_SOFTWIF_LOOPBACK LimSoftwareType = 1
	LimSoftwareType_LIM_SOFTWIF_DUMMY    LimSoftwareType = 2
	LimSoftwareType_LIM_SOFTWIF_NULL     LimSoftwareType = 3
)

var LimSoftwareType_name = map[int32]string{
	0: "LIM_SOFTWIF_NONE",
	1: "LIM_SOFTWIF_LOOPBACK",
	2: "LIM_SOFTWIF_DUMMY",
	3: "LIM_SOFTWIF_NULL",
}

var LimSoftwareType_value = map[string]int32{
	"LIM_SOFTWIF_NONE":     0,
	"LIM_SOFTWIF_LOOPBACK": 1,
	"LIM_SOFTWIF_DUMMY":    2,
	"LIM_SOFTWIF_NULL":     3,
}

func (x LimSoftwareType) String() string {
	return proto.EnumName(LimSoftwareType_name, int32(x))
}

func (LimSoftwareType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{5}
}

type LimIfStatus struct {
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	IfIndex     uint32 `protobuf:"varint,2,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// Operational status of the interface.
	OperStatus LimIfOperStatus `protobuf:"varint,3,opt,name=OperStatus,proto3,enum=pds.LimIfOperStatus" json:"OperStatus,omitempty"`
	// The assigned name of the interface.
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// The assigned description of the interface.
	Description string `protobuf:"bytes,5,opt,name=Description,proto3" json:"Description,omitempty"`
	// The type of interface.
	Type LimIfType `protobuf:"varint,6,opt,name=Type,proto3,enum=pds.LimIfType" json:"Type,omitempty"`
	// The MAC address of the interface.
	MacAddr []byte `protobuf:"bytes,7,opt,name=MacAddr,proto3" json:"MacAddr,omitempty"`
	// The MTU of the interface
	Mtu uint32 `protobuf:"varint,8,opt,name=Mtu,proto3" json:"Mtu,omitempty"`
	// The loopback mode used on this interface.
	LoopBackMode LimIfLoopbackMode `protobuf:"varint,9,opt,name=LoopBackMode,proto3,enum=pds.LimIfLoopbackMode" json:"LoopBackMode,omitempty"`
	// Wrapping count of the number of link flaps detected.
	FlapCount uint32 `protobuf:"varint,10,opt,name=FlapCount,proto3" json:"FlapCount,omitempty"`
	// The reason for the interface to be in its current oper status.
	OperReason           LimOperReason `protobuf:"varint,11,opt,name=OperReason,proto3,enum=pds.LimOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LimIfStatus) Reset()         { *m = LimIfStatus{} }
func (m *LimIfStatus) String() string { return proto.CompactTextString(m) }
func (*LimIfStatus) ProtoMessage()    {}
func (*LimIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{0}
}
func (m *LimIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfStatus.Merge(m, src)
}
func (m *LimIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *LimIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfStatus proto.InternalMessageInfo

func (m *LimIfStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimIfStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LimIfStatus) GetOperStatus() LimIfOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return LimIfOperStatus_OPER_NONE
}

func (m *LimIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LimIfStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *LimIfStatus) GetType() LimIfType {
	if m != nil {
		return m.Type
	}
	return LimIfType_IFTYP_NONE
}

func (m *LimIfStatus) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *LimIfStatus) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *LimIfStatus) GetLoopBackMode() LimIfLoopbackMode {
	if m != nil {
		return m.LoopBackMode
	}
	return LimIfLoopbackMode_LOOPBACK_NONE
}

func (m *LimIfStatus) GetFlapCount() uint32 {
	if m != nil {
		return m.FlapCount
	}
	return 0
}

func (m *LimIfStatus) GetOperReason() LimOperReason {
	if m != nil {
		return m.OperReason
	}
	return LimOperReason_OPR_RSN_EMPTY
}

type LimIfStatusKey struct {
	EntityIndex          uint32   `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	IfIndex              uint32   `protobuf:"varint,2,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LimIfStatusKey) Reset()         { *m = LimIfStatusKey{} }
func (m *LimIfStatusKey) String() string { return proto.CompactTextString(m) }
func (*LimIfStatusKey) ProtoMessage()    {}
func (*LimIfStatusKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{1}
}
func (m *LimIfStatusKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfStatusKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfStatusKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfStatusKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfStatusKey.Merge(m, src)
}
func (m *LimIfStatusKey) XXX_Size() int {
	return m.Size()
}
func (m *LimIfStatusKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfStatusKey.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfStatusKey proto.InternalMessageInfo

func (m *LimIfStatusKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimIfStatusKey) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

type LimIf struct {
	Status               *LimIfStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LimIf) Reset()         { *m = LimIf{} }
func (m *LimIf) String() string { return proto.CompactTextString(m) }
func (*LimIf) ProtoMessage()    {}
func (*LimIf) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{2}
}
func (m *LimIf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIf.Merge(m, src)
}
func (m *LimIf) XXX_Size() int {
	return m.Size()
}
func (m *LimIf) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIf.DiscardUnknown(m)
}

var xxx_messageInfo_LimIf proto.InternalMessageInfo

func (m *LimIf) GetStatus() *LimIfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP NLRI prefix get response
type LimIfStatusGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LimIf  `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LimIfStatusGetResponse) Reset()         { *m = LimIfStatusGetResponse{} }
func (m *LimIfStatusGetResponse) String() string { return proto.CompactTextString(m) }
func (*LimIfStatusGetResponse) ProtoMessage()    {}
func (*LimIfStatusGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{3}
}
func (m *LimIfStatusGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfStatusGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfStatusGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfStatusGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfStatusGetResponse.Merge(m, src)
}
func (m *LimIfStatusGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LimIfStatusGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfStatusGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfStatusGetResponse proto.InternalMessageInfo

func (m *LimIfStatusGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LimIfStatusGetResponse) GetResponse() []*LimIf {
	if m != nil {
		return m.Response
	}
	return nil
}

// Lim Interface key handle
type LimIfStatusKeyHandle struct {
	Key                  *LimIfStatusKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LimIfStatusKeyHandle) Reset()         { *m = LimIfStatusKeyHandle{} }
func (m *LimIfStatusKeyHandle) String() string { return proto.CompactTextString(m) }
func (*LimIfStatusKeyHandle) ProtoMessage()    {}
func (*LimIfStatusKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{4}
}
func (m *LimIfStatusKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfStatusKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfStatusKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfStatusKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfStatusKeyHandle.Merge(m, src)
}
func (m *LimIfStatusKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *LimIfStatusKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfStatusKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfStatusKeyHandle proto.InternalMessageInfo

func (m *LimIfStatusKeyHandle) GetKey() *LimIfStatusKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// Lim Interface status get request
type LimIfStatusGetRequest struct {
	Request              []*LimIfStatusKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LimIfStatusGetRequest) Reset()         { *m = LimIfStatusGetRequest{} }
func (m *LimIfStatusGetRequest) String() string { return proto.CompactTextString(m) }
func (*LimIfStatusGetRequest) ProtoMessage()    {}
func (*LimIfStatusGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{5}
}
func (m *LimIfStatusGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfStatusGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfStatusGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfStatusGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfStatusGetRequest.Merge(m, src)
}
func (m *LimIfStatusGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LimIfStatusGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfStatusGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfStatusGetRequest proto.InternalMessageInfo

func (m *LimIfStatusGetRequest) GetRequest() []*LimIfStatusKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// LimIfAddrTableStatus table
type LimIfAddrTableStatus struct {
	EntityIndex          uint32        `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	IfIndex              uint32        `protobuf:"varint,2,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	IPAddr               *IPAddress    `protobuf:"bytes,3,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	OperStatus           LimOperStatus `protobuf:"varint,4,opt,name=OperStatus,proto3,enum=pds.LimOperStatus" json:"OperStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LimIfAddrTableStatus) Reset()         { *m = LimIfAddrTableStatus{} }
func (m *LimIfAddrTableStatus) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTableStatus) ProtoMessage()    {}
func (*LimIfAddrTableStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{6}
}
func (m *LimIfAddrTableStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTableStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTableStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTableStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTableStatus.Merge(m, src)
}
func (m *LimIfAddrTableStatus) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTableStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTableStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTableStatus proto.InternalMessageInfo

func (m *LimIfAddrTableStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimIfAddrTableStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LimIfAddrTableStatus) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

func (m *LimIfAddrTableStatus) GetOperStatus() LimOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return LimOperStatus_OPER_STATUS_NONE
}

type LimIfAddrTableKey struct {
	EntityIndex          uint32     `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	IfIndex              uint32     `protobuf:"varint,2,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	IPAddr               *IPAddress `protobuf:"bytes,3,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LimIfAddrTableKey) Reset()         { *m = LimIfAddrTableKey{} }
func (m *LimIfAddrTableKey) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTableKey) ProtoMessage()    {}
func (*LimIfAddrTableKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{7}
}
func (m *LimIfAddrTableKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTableKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTableKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTableKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTableKey.Merge(m, src)
}
func (m *LimIfAddrTableKey) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTableKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTableKey.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTableKey proto.InternalMessageInfo

func (m *LimIfAddrTableKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimIfAddrTableKey) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LimIfAddrTableKey) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

type LimIfAddrTable struct {
	Status               *LimIfAddrTableStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *LimIfAddrTable) Reset()         { *m = LimIfAddrTable{} }
func (m *LimIfAddrTable) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTable) ProtoMessage()    {}
func (*LimIfAddrTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{8}
}
func (m *LimIfAddrTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTable.Merge(m, src)
}
func (m *LimIfAddrTable) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTable) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTable.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTable proto.InternalMessageInfo

func (m *LimIfAddrTable) GetStatus() *LimIfAddrTableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type LimIfAddrTableGetResponse struct {
	ApiStatus            ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LimIfAddrTable `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LimIfAddrTableGetResponse) Reset()         { *m = LimIfAddrTableGetResponse{} }
func (m *LimIfAddrTableGetResponse) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTableGetResponse) ProtoMessage()    {}
func (*LimIfAddrTableGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{9}
}
func (m *LimIfAddrTableGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTableGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTableGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTableGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTableGetResponse.Merge(m, src)
}
func (m *LimIfAddrTableGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTableGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTableGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTableGetResponse proto.InternalMessageInfo

func (m *LimIfAddrTableGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LimIfAddrTableGetResponse) GetResponse() []*LimIfAddrTable {
	if m != nil {
		return m.Response
	}
	return nil
}

// Lim Interface key handle
type LimIfAddrTableKeyHandle struct {
	Key                  *LimIfAddrTableKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LimIfAddrTableKeyHandle) Reset()         { *m = LimIfAddrTableKeyHandle{} }
func (m *LimIfAddrTableKeyHandle) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTableKeyHandle) ProtoMessage()    {}
func (*LimIfAddrTableKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{10}
}
func (m *LimIfAddrTableKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTableKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTableKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTableKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTableKeyHandle.Merge(m, src)
}
func (m *LimIfAddrTableKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTableKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTableKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTableKeyHandle proto.InternalMessageInfo

func (m *LimIfAddrTableKeyHandle) GetKey() *LimIfAddrTableKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// Lim Interface status get request
type LimIfAddrTableGetRequest struct {
	Request              []*LimIfAddrTableKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *LimIfAddrTableGetRequest) Reset()         { *m = LimIfAddrTableGetRequest{} }
func (m *LimIfAddrTableGetRequest) String() string { return proto.CompactTextString(m) }
func (*LimIfAddrTableGetRequest) ProtoMessage()    {}
func (*LimIfAddrTableGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{11}
}
func (m *LimIfAddrTableGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimIfAddrTableGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimIfAddrTableGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimIfAddrTableGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimIfAddrTableGetRequest.Merge(m, src)
}
func (m *LimIfAddrTableGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LimIfAddrTableGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LimIfAddrTableGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LimIfAddrTableGetRequest proto.InternalMessageInfo

func (m *LimIfAddrTableGetRequest) GetRequest() []*LimIfAddrTableKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// LIM Vrf table
type LimVrfStatus struct {
	// Identifies a DC-LIM entity
	EntityIndex uint32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// The VRF name
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// A description of the VRF
	Desc string `protobuf:"bytes,4,opt,name=Desc,proto3" json:"Desc,omitempty"`
	// Operational status of the VRF
	OperStatus LimOperStatus `protobuf:"varint,5,opt,name=OperStatus,proto3,enum=pds.LimOperStatus" json:"OperStatus,omitempty"`
	// The number of interfaces enslaved to this VRF
	NumInterfaces uint32 `protobuf:"varint,6,opt,name=NumInterfaces,proto3" json:"NumInterfaces,omitempty"`
	// The reason for the VRF to be in its current oper status
	OperReason           LimOperReason `protobuf:"varint,7,opt,name=OperReason,proto3,enum=pds.LimOperReason" json:"OperReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LimVrfStatus) Reset()         { *m = LimVrfStatus{} }
func (m *LimVrfStatus) String() string { return proto.CompactTextString(m) }
func (*LimVrfStatus) ProtoMessage()    {}
func (*LimVrfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{12}
}
func (m *LimVrfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrfStatus.Merge(m, src)
}
func (m *LimVrfStatus) XXX_Size() int {
	return m.Size()
}
func (m *LimVrfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrfStatus proto.InternalMessageInfo

func (m *LimVrfStatus) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimVrfStatus) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *LimVrfStatus) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *LimVrfStatus) GetOperStatus() LimOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return LimOperStatus_OPER_STATUS_NONE
}

func (m *LimVrfStatus) GetNumInterfaces() uint32 {
	if m != nil {
		return m.NumInterfaces
	}
	return 0
}

func (m *LimVrfStatus) GetOperReason() LimOperReason {
	if m != nil {
		return m.OperReason
	}
	return LimOperReason_OPR_RSN_EMPTY
}

// LIM vrf key object
type LimVrfStatusKey struct {
	EntityIndex          uint32   `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	VrfName              string   `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LimVrfStatusKey) Reset()         { *m = LimVrfStatusKey{} }
func (m *LimVrfStatusKey) String() string { return proto.CompactTextString(m) }
func (*LimVrfStatusKey) ProtoMessage()    {}
func (*LimVrfStatusKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{13}
}
func (m *LimVrfStatusKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrfStatusKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrfStatusKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrfStatusKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrfStatusKey.Merge(m, src)
}
func (m *LimVrfStatusKey) XXX_Size() int {
	return m.Size()
}
func (m *LimVrfStatusKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrfStatusKey.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrfStatusKey proto.InternalMessageInfo

func (m *LimVrfStatusKey) GetEntityIndex() uint32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimVrfStatusKey) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

//LIM vrf object
type LimVrf struct {
	Status               *LimVrfStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LimVrf) Reset()         { *m = LimVrf{} }
func (m *LimVrf) String() string { return proto.CompactTextString(m) }
func (*LimVrf) ProtoMessage()    {}
func (*LimVrf) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{14}
}
func (m *LimVrf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrf.Merge(m, src)
}
func (m *LimVrf) XXX_Size() int {
	return m.Size()
}
func (m *LimVrf) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrf.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrf proto.InternalMessageInfo

func (m *LimVrf) GetStatus() *LimVrfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// LIM vrf get response
type LimVrfGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LimVrf `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LimVrfGetResponse) Reset()         { *m = LimVrfGetResponse{} }
func (m *LimVrfGetResponse) String() string { return proto.CompactTextString(m) }
func (*LimVrfGetResponse) ProtoMessage()    {}
func (*LimVrfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{15}
}
func (m *LimVrfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrfGetResponse.Merge(m, src)
}
func (m *LimVrfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LimVrfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrfGetResponse proto.InternalMessageInfo

func (m *LimVrfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LimVrfGetResponse) GetResponse() []*LimVrf {
	if m != nil {
		return m.Response
	}
	return nil
}

// Lim vrf key handle
type LimVrfKeyHandle struct {
	Key                  *LimVrfStatusKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LimVrfKeyHandle) Reset()         { *m = LimVrfKeyHandle{} }
func (m *LimVrfKeyHandle) String() string { return proto.CompactTextString(m) }
func (*LimVrfKeyHandle) ProtoMessage()    {}
func (*LimVrfKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{16}
}
func (m *LimVrfKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrfKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrfKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrfKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrfKeyHandle.Merge(m, src)
}
func (m *LimVrfKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *LimVrfKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrfKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrfKeyHandle proto.InternalMessageInfo

func (m *LimVrfKeyHandle) GetKey() *LimVrfStatusKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// Lim vrf get request
type LimVrfGetRequest struct {
	Request              []*LimVrfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LimVrfGetRequest) Reset()         { *m = LimVrfGetRequest{} }
func (m *LimVrfGetRequest) String() string { return proto.CompactTextString(m) }
func (*LimVrfGetRequest) ProtoMessage()    {}
func (*LimVrfGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{17}
}
func (m *LimVrfGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimVrfGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimVrfGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimVrfGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimVrfGetRequest.Merge(m, src)
}
func (m *LimVrfGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LimVrfGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LimVrfGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LimVrfGetRequest proto.InternalMessageInfo

func (m *LimVrfGetRequest) GetRequest() []*LimVrfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// LimSwIfStatus table
type LimSwIfStatus struct {
	// Identifies a DC-LIM entity
	EntityIndex int32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// The type of software interface being configured
	Type LimSoftwareType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.LimSoftwareType" json:"Type,omitempty"`
	// The IP address to be assigned.
	Index uint32 `protobuf:"varint,3,opt,name=Index,proto3" json:"Index,omitempty"`
	// Operational status of the interface
	OperStatus LimOperStatus `protobuf:"varint,4,opt,name=OperStatus,proto3,enum=pds.LimOperStatus" json:"OperStatus,omitempty"`
	// The assigned name of the software interface
	Name string `protobuf:"bytes,5,opt,name=Name,proto3" json:"Name,omitempty"`
	// The assigned control plane interface index
	IfIndex              int32    `protobuf:"varint,6,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LimSwIfStatus) Reset()         { *m = LimSwIfStatus{} }
func (m *LimSwIfStatus) String() string { return proto.CompactTextString(m) }
func (*LimSwIfStatus) ProtoMessage()    {}
func (*LimSwIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{18}
}
func (m *LimSwIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIfStatus.Merge(m, src)
}
func (m *LimSwIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIfStatus proto.InternalMessageInfo

func (m *LimSwIfStatus) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimSwIfStatus) GetType() LimSoftwareType {
	if m != nil {
		return m.Type
	}
	return LimSoftwareType_LIM_SOFTWIF_NONE
}

func (m *LimSwIfStatus) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LimSwIfStatus) GetOperStatus() LimOperStatus {
	if m != nil {
		return m.OperStatus
	}
	return LimOperStatus_OPER_STATUS_NONE
}

func (m *LimSwIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LimSwIfStatus) GetIfIndex() int32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

type LimSwIfKey struct {
	// Identifies a DC-LIM entity
	EntityIndex int32 `protobuf:"varint,1,opt,name=EntityIndex,proto3" json:"EntityIndex,omitempty"`
	// The type of software interface being configured
	Type LimSoftwareType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.LimSoftwareType" json:"Type,omitempty"`
	// The IP address to be assigned.
	Index                uint32   `protobuf:"varint,3,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LimSwIfKey) Reset()         { *m = LimSwIfKey{} }
func (m *LimSwIfKey) String() string { return proto.CompactTextString(m) }
func (*LimSwIfKey) ProtoMessage()    {}
func (*LimSwIfKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{19}
}
func (m *LimSwIfKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIfKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIfKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIfKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIfKey.Merge(m, src)
}
func (m *LimSwIfKey) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIfKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIfKey.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIfKey proto.InternalMessageInfo

func (m *LimSwIfKey) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *LimSwIfKey) GetType() LimSoftwareType {
	if m != nil {
		return m.Type
	}
	return LimSoftwareType_LIM_SOFTWIF_NONE
}

func (m *LimSwIfKey) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type LimSwIf struct {
	Status               *LimSwIfStatus `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LimSwIf) Reset()         { *m = LimSwIf{} }
func (m *LimSwIf) String() string { return proto.CompactTextString(m) }
func (*LimSwIf) ProtoMessage()    {}
func (*LimSwIf) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{20}
}
func (m *LimSwIf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIf.Merge(m, src)
}
func (m *LimSwIf) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIf) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIf.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIf proto.InternalMessageInfo

func (m *LimSwIf) GetStatus() *LimSwIfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type LimSwIfGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*LimSwIf `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LimSwIfGetResponse) Reset()         { *m = LimSwIfGetResponse{} }
func (m *LimSwIfGetResponse) String() string { return proto.CompactTextString(m) }
func (*LimSwIfGetResponse) ProtoMessage()    {}
func (*LimSwIfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{21}
}
func (m *LimSwIfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIfGetResponse.Merge(m, src)
}
func (m *LimSwIfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIfGetResponse proto.InternalMessageInfo

func (m *LimSwIfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LimSwIfGetResponse) GetResponse() []*LimSwIf {
	if m != nil {
		return m.Response
	}
	return nil
}

// Lim Interface key handle
type LimSwIfKeyHandle struct {
	Key                  *LimSwIfKey `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LimSwIfKeyHandle) Reset()         { *m = LimSwIfKeyHandle{} }
func (m *LimSwIfKeyHandle) String() string { return proto.CompactTextString(m) }
func (*LimSwIfKeyHandle) ProtoMessage()    {}
func (*LimSwIfKeyHandle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{22}
}
func (m *LimSwIfKeyHandle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIfKeyHandle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIfKeyHandle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIfKeyHandle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIfKeyHandle.Merge(m, src)
}
func (m *LimSwIfKeyHandle) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIfKeyHandle) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIfKeyHandle.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIfKeyHandle proto.InternalMessageInfo

func (m *LimSwIfKeyHandle) GetKey() *LimSwIfKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// Lim Interface status get request
type LimSwIfGetRequest struct {
	Request              []*LimSwIfKeyHandle `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LimSwIfGetRequest) Reset()         { *m = LimSwIfGetRequest{} }
func (m *LimSwIfGetRequest) String() string { return proto.CompactTextString(m) }
func (*LimSwIfGetRequest) ProtoMessage()    {}
func (*LimSwIfGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7281b20a4af1034, []int{23}
}
func (m *LimSwIfGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimSwIfGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimSwIfGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimSwIfGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimSwIfGetRequest.Merge(m, src)
}
func (m *LimSwIfGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LimSwIfGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LimSwIfGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LimSwIfGetRequest proto.InternalMessageInfo

func (m *LimSwIfGetRequest) GetRequest() []*LimSwIfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.LimIfOperStatus", LimIfOperStatus_name, LimIfOperStatus_value)
	proto.RegisterEnum("pds.LimIfType", LimIfType_name, LimIfType_value)
	proto.RegisterEnum("pds.LimIfLoopbackMode", LimIfLoopbackMode_name, LimIfLoopbackMode_value)
	proto.RegisterEnum("pds.LimOperReason", LimOperReason_name, LimOperReason_value)
	proto.RegisterEnum("pds.LimOperStatus", LimOperStatus_name, LimOperStatus_value)
	proto.RegisterEnum("pds.LimSoftwareType", LimSoftwareType_name, LimSoftwareType_value)
	proto.RegisterType((*LimIfStatus)(nil), "pds.LimIfStatus")
	proto.RegisterType((*LimIfStatusKey)(nil), "pds.LimIfStatusKey")
	proto.RegisterType((*LimIf)(nil), "pds.LimIf")
	proto.RegisterType((*LimIfStatusGetResponse)(nil), "pds.LimIfStatusGetResponse")
	proto.RegisterType((*LimIfStatusKeyHandle)(nil), "pds.LimIfStatusKeyHandle")
	proto.RegisterType((*LimIfStatusGetRequest)(nil), "pds.LimIfStatusGetRequest")
	proto.RegisterType((*LimIfAddrTableStatus)(nil), "pds.LimIfAddrTableStatus")
	proto.RegisterType((*LimIfAddrTableKey)(nil), "pds.LimIfAddrTableKey")
	proto.RegisterType((*LimIfAddrTable)(nil), "pds.LimIfAddrTable")
	proto.RegisterType((*LimIfAddrTableGetResponse)(nil), "pds.LimIfAddrTableGetResponse")
	proto.RegisterType((*LimIfAddrTableKeyHandle)(nil), "pds.LimIfAddrTableKeyHandle")
	proto.RegisterType((*LimIfAddrTableGetRequest)(nil), "pds.LimIfAddrTableGetRequest")
	proto.RegisterType((*LimVrfStatus)(nil), "pds.LimVrfStatus")
	proto.RegisterType((*LimVrfStatusKey)(nil), "pds.LimVrfStatusKey")
	proto.RegisterType((*LimVrf)(nil), "pds.LimVrf")
	proto.RegisterType((*LimVrfGetResponse)(nil), "pds.LimVrfGetResponse")
	proto.RegisterType((*LimVrfKeyHandle)(nil), "pds.LimVrfKeyHandle")
	proto.RegisterType((*LimVrfGetRequest)(nil), "pds.LimVrfGetRequest")
	proto.RegisterType((*LimSwIfStatus)(nil), "pds.LimSwIfStatus")
	proto.RegisterType((*LimSwIfKey)(nil), "pds.LimSwIfKey")
	proto.RegisterType((*LimSwIf)(nil), "pds.LimSwIf")
	proto.RegisterType((*LimSwIfGetResponse)(nil), "pds.LimSwIfGetResponse")
	proto.RegisterType((*LimSwIfKeyHandle)(nil), "pds.LimSwIfKeyHandle")
	proto.RegisterType((*LimSwIfGetRequest)(nil), "pds.LimSwIfGetRequest")
}

func init() { proto.RegisterFile("lim.proto", fileDescriptor_b7281b20a4af1034) }

var fileDescriptor_b7281b20a4af1034 = []byte{
	// 1591 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x6f, 0x22, 0x47,
	0x1a, 0x9e, 0x06, 0x03, 0xc3, 0x0b, 0x86, 0x72, 0x19, 0xe3, 0x1e, 0xcf, 0xac, 0xc5, 0xa2, 0xdd,
	0x59, 0xd6, 0x07, 0xcf, 0x0e, 0xde, 0x59, 0xcd, 0xae, 0x36, 0x8a, 0xda, 0xd0, 0xe0, 0x96, 0xfb,
	0x6b, 0xaa, 0x1b, 0x5b, 0x3e, 0xb5, 0x18, 0xbb, 0x3d, 0x42, 0xb1, 0x81, 0x00, 0xce, 0xc4, 0x52,
	0x0e, 0x89, 0x72, 0x48, 0x4e, 0xb9, 0x44, 0xca, 0x7d, 0x2e, 0x39, 0xe4, 0x94, 0x9f, 0x91, 0x43,
	0x14, 0x45, 0xca, 0x1f, 0x88, 0xe6, 0x9c, 0x73, 0xce, 0x51, 0x55, 0xf5, 0x47, 0xd1, 0x30, 0x91,
	0x13, 0xcf, 0xc5, 0xea, 0x7e, 0x9e, 0x7a, 0x3f, 0xeb, 0xe9, 0xb7, 0x0a, 0x43, 0xfe, 0x62, 0x70,
	0xb9, 0x3b, 0x9e, 0x8c, 0x66, 0x23, 0x9c, 0x1e, 0x9f, 0x4d, 0xb7, 0xe0, 0xc5, 0xe8, 0xc5, 0x88,
	0x03, 0x5b, 0xe5, 0x4b, 0x7f, 0xd6, 0x7f, 0x44, 0xff, 0x04, 0x40, 0x61, 0x76, 0x3d, 0xf6, 0xa7,
	0xfc, 0xa5, 0xfe, 0x65, 0x1a, 0x0a, 0xfa, 0xe0, 0x52, 0x3b, 0x77, 0x66, 0xfd, 0xd9, 0xd5, 0x14,
	0xd7, 0xa0, 0xa0, 0x0e, 0x67, 0x83, 0xd9, 0xb5, 0x36, 0x3c, 0xf3, 0x3f, 0x94, 0xa5, 0x9a, 0xd4,
	0x58, 0x25, 0x22, 0x84, 0x65, 0xc8, 0x69, 0xe7, 0x9c, 0x4d, 0x31, 0x36, 0x7c, 0xc5, 0xff, 0x06,
	0xb0, 0xc6, 0xfe, 0x84, 0x7b, 0x92, 0xd3, 0x35, 0xa9, 0x51, 0x6a, 0x56, 0x76, 0xc7, 0x67, 0xd3,
	0x5d, 0x16, 0x21, 0xe6, 0x88, 0xb0, 0x0e, 0x63, 0x58, 0x31, 0xfb, 0x97, 0xbe, 0xbc, 0x52, 0x93,
	0x1a, 0x79, 0xc2, 0x9e, 0x69, 0x16, 0x6d, 0x7f, 0x7a, 0x3a, 0x19, 0x8c, 0x67, 0x83, 0xd1, 0x50,
	0xce, 0x30, 0x4a, 0x84, 0x70, 0x1d, 0x56, 0xdc, 0xeb, 0xb1, 0x2f, 0x67, 0x59, 0x94, 0x52, 0x1c,
	0x85, 0xa2, 0x84, 0x71, 0x34, 0x53, 0xa3, 0x7f, 0xaa, 0x9c, 0x9d, 0x4d, 0xe4, 0x5c, 0x4d, 0x6a,
	0x14, 0x49, 0xf8, 0x8a, 0x11, 0xa4, 0x8d, 0xd9, 0x95, 0x7c, 0x97, 0xe5, 0x4f, 0x1f, 0xf1, 0xff,
	0xa0, 0xa8, 0x8f, 0x46, 0xe3, 0xfd, 0xfe, 0xe9, 0x7b, 0xc6, 0xe8, 0xcc, 0x97, 0xf3, 0xcc, 0x6f,
	0x35, 0xf6, 0x4b, 0xd9, 0xe7, 0x01, 0x4b, 0xe6, 0xd6, 0xe2, 0x07, 0x90, 0xef, 0x5c, 0xf4, 0xc7,
	0xad, 0xd1, 0xd5, 0x70, 0x26, 0x03, 0xf3, 0x19, 0x03, 0xb8, 0xc9, 0xbb, 0x42, 0xfc, 0xfe, 0x74,
	0x34, 0x94, 0x0b, 0xcc, 0x2f, 0x0e, 0xfd, 0xc6, 0x0c, 0x11, 0x56, 0xd5, 0x75, 0x28, 0x09, 0x9b,
	0x72, 0xe8, 0x5f, 0xdf, 0x66, 0x5f, 0xea, 0x8f, 0x21, 0xc3, 0xbc, 0xe1, 0x06, 0x64, 0x83, 0xcd,
	0xa1, 0xf6, 0x85, 0x26, 0x8a, 0xcb, 0x0b, 0x36, 0x26, 0xe0, 0xeb, 0x63, 0xa8, 0x0a, 0x70, 0xd7,
	0x9f, 0x11, 0x7f, 0x3a, 0x1e, 0x0d, 0xa7, 0x3e, 0xde, 0x85, 0xbc, 0x32, 0x1e, 0x08, 0x6e, 0x4a,
	0x4d, 0xb4, 0xcb, 0x15, 0x15, 0xe1, 0x24, 0x5e, 0x82, 0x1f, 0xc2, 0xdd, 0xd0, 0x56, 0x4e, 0xd5,
	0xd2, 0x8d, 0x42, 0x13, 0xe2, 0xa8, 0x24, 0xe2, 0xea, 0xef, 0x40, 0x65, 0xbe, 0xe4, 0x83, 0xfe,
	0xf0, 0xec, 0xc2, 0xc7, 0x7f, 0x87, 0xf4, 0xa1, 0x7f, 0x1d, 0x24, 0xbc, 0x9e, 0x4c, 0xf8, 0xd0,
	0xbf, 0x26, 0x94, 0xaf, 0xeb, 0xb0, 0x91, 0x4c, 0xf8, 0xfd, 0x2b, 0x7f, 0x3a, 0xc3, 0x7b, 0x90,
	0x0b, 0x1e, 0x65, 0x89, 0x85, 0xbf, 0xb7, 0xc4, 0x07, 0x8f, 0x45, 0xc2, 0x95, 0xf5, 0x6f, 0xa5,
	0x20, 0x1b, 0xaa, 0x16, 0xb7, 0xff, 0xfc, 0xc2, 0x7f, 0x0b, 0x9f, 0x47, 0x03, 0xb2, 0x9a, 0xcd,
	0xd4, 0x98, 0x0e, 0xba, 0xcf, 0xdb, 0xc6, 0x41, 0x7f, 0x3a, 0x25, 0x01, 0x1f, 0x4a, 0x26, 0x68,
	0xf2, 0xca, 0xa2, 0x64, 0x16, 0x3f, 0xa3, 0xfa, 0x35, 0xac, 0xcd, 0x67, 0x7c, 0x4b, 0xd5, 0xdc,
	0x3c, 0xdd, 0x7a, 0x2b, 0x50, 0x6b, 0x14, 0x1a, 0x3f, 0x4e, 0x08, 0x4d, 0xe8, 0x79, 0xa2, 0xa3,
	0x91, 0xe2, 0x3e, 0x82, 0x7b, 0xf3, 0xfc, 0x6d, 0x44, 0xf7, 0x68, 0x41, 0x74, 0xeb, 0x4b, 0x32,
	0x10, 0xd4, 0xd7, 0x82, 0xcd, 0x85, 0xee, 0x05, 0x02, 0x6c, 0x88, 0x02, 0xac, 0x2e, 0x71, 0x13,
	0x69, 0x90, 0x80, 0xbc, 0xa4, 0x04, 0x2e, 0xc3, 0xff, 0x24, 0x65, 0xf8, 0x60, 0xb9, 0xa7, 0xa4,
	0x12, 0x7f, 0x91, 0xa0, 0xa8, 0x0f, 0x2e, 0x8f, 0x26, 0x7f, 0x68, 0x40, 0x1f, 0x4d, 0xce, 0xd9,
	0x4c, 0x4d, 0xb1, 0xc1, 0x19, 0xbe, 0xd2, 0x51, 0x4b, 0x67, 0x68, 0x38, 0x6a, 0xe9, 0x73, 0x42,
	0x6b, 0x99, 0x9b, 0x68, 0x0d, 0xff, 0x0d, 0x56, 0xcd, 0xab, 0x4b, 0x6d, 0x38, 0xf3, 0x27, 0xe7,
	0xfd, 0x53, 0x7f, 0xca, 0xa6, 0xf0, 0x2a, 0x99, 0x07, 0x13, 0x83, 0x2f, 0x77, 0xa3, 0xc1, 0x67,
	0x40, 0x59, 0xac, 0xf6, 0xc6, 0x1a, 0x5e, 0x5e, 0x70, 0x7d, 0x0f, 0xb2, 0xdc, 0x1d, 0xfe, 0x67,
	0x42, 0x91, 0x6b, 0x61, 0x22, 0x51, 0xac, 0x48, 0x89, 0x17, 0xec, 0x4b, 0x3a, 0x9a, 0x9c, 0xdf,
	0x46, 0x81, 0xff, 0x58, 0x50, 0x60, 0x41, 0x88, 0x28, 0x28, 0xef, 0xbf, 0x61, 0xc5, 0xb1, 0xe2,
	0x1e, 0x8a, 0x8a, 0xab, 0x2c, 0x24, 0x1a, 0xe9, 0x6d, 0x1f, 0x90, 0x90, 0x28, 0xd7, 0xd9, 0x6e,
	0x52, 0x67, 0xa2, 0xfd, 0x12, 0x7d, 0xfd, 0x24, 0xc1, 0xaa, 0x3e, 0xb8, 0x74, 0x5e, 0xfe, 0xde,
	0x0d, 0x20, 0x33, 0xdf, 0xef, 0x46, 0x70, 0xf6, 0xa6, 0xe6, 0x4f, 0x78, 0x67, 0x74, 0x3e, 0x7b,
	0xd9, 0x9f, 0xf8, 0xc2, 0x09, 0x5c, 0x81, 0x0c, 0xf7, 0x92, 0x66, 0xbb, 0xc6, 0x5f, 0xfe, 0xcc,
	0x78, 0x8b, 0x6e, 0x09, 0x19, 0xe1, 0x96, 0x20, 0xcc, 0xae, 0x2c, 0xcb, 0x32, 0x3a, 0xf1, 0x86,
	0x00, 0x41, 0x51, 0x6f, 0x50, 0xd0, 0xdb, 0xad, 0xa8, 0xfe, 0x04, 0x72, 0x41, 0x3c, 0xbc, 0x93,
	0x10, 0x5a, 0x54, 0x58, 0xdc, 0xe2, 0x48, 0x69, 0x43, 0xc0, 0x01, 0x71, 0x1b, 0xa9, 0x35, 0x16,
	0xa4, 0x56, 0x14, 0x63, 0x0a, 0x5a, 0x7b, 0xc2, 0x04, 0x13, 0xb4, 0x25, 0x10, 0xdb, 0x5f, 0x45,
	0xb1, 0x95, 0x45, 0xc3, 0x48, 0x67, 0x6d, 0xf6, 0x41, 0x44, 0x69, 0x72, 0xa1, 0x3d, 0x4a, 0x0a,
	0x6d, 0x23, 0x61, 0x9b, 0x50, 0xda, 0xce, 0x2b, 0x89, 0x29, 0x5d, 0xbc, 0x07, 0xe2, 0x55, 0xc8,
	0x5b, 0xb6, 0x4a, 0x3c, 0xd3, 0x32, 0x55, 0x74, 0x07, 0x17, 0x20, 0xc7, 0x5e, 0x7b, 0x36, 0x92,
	0x22, 0xae, 0x6d, 0x1d, 0x9b, 0x28, 0x85, 0x11, 0x14, 0xd9, 0xab, 0xab, 0x3a, 0xae, 0x66, 0x76,
	0x51, 0x3a, 0x42, 0x7a, 0xe6, 0xa1, 0x49, 0xd7, 0xac, 0x44, 0x48, 0xdb, 0x22, 0x86, 0x62, 0xba,
	0x28, 0x83, 0x2b, 0x80, 0x82, 0x00, 0xae, 0x67, 0x13, 0xd5, 0x51, 0x4d, 0x17, 0x65, 0xf1, 0x26,
	0xac, 0x33, 0x54, 0xb7, 0x8e, 0xe9, 0x5f, 0xe5, 0x84, 0xda, 0x98, 0x28, 0xb7, 0xf3, 0x7d, 0x0a,
	0xf2, 0xd1, 0x2d, 0x12, 0x97, 0x00, 0xb4, 0x8e, 0x7b, 0x62, 0x87, 0xe9, 0x95, 0xa1, 0xc0, 0xdf,
	0x2d, 0xf7, 0x40, 0x25, 0x48, 0xc2, 0xf7, 0x60, 0x83, 0x03, 0x2a, 0x05, 0x4c, 0xd5, 0xf5, 0x5a,
	0x8e, 0xa1, 0xb4, 0xda, 0x28, 0x8b, 0xef, 0xc3, 0x26, 0xa7, 0x1c, 0xab, 0xe3, 0x1e, 0x2b, 0x44,
	0xf5, 0x74, 0xcb, 0xb2, 0xf7, 0x95, 0xd6, 0x21, 0x92, 0x71, 0x15, 0x30, 0x27, 0x6d, 0x62, 0xd9,
	0xde, 0x91, 0x46, 0xdc, 0x9e, 0xa2, 0xa3, 0x27, 0x78, 0x0d, 0x8a, 0x1c, 0x77, 0x7b, 0xa6, 0xa9,
	0xea, 0xe8, 0x53, 0x29, 0x86, 0xf4, 0xe6, 0x91, 0xae, 0x98, 0xe8, 0x33, 0x09, 0xaf, 0x43, 0x29,
	0x80, 0xf6, 0x34, 0x9b, 0x81, 0x9f, 0x4b, 0x78, 0x03, 0x10, 0x07, 0x35, 0xdb, 0xeb, 0x58, 0xe4,
	0x58, 0x21, 0x6d, 0xf4, 0x85, 0x84, 0xab, 0xb0, 0xc6, 0x61, 0xc3, 0xd6, 0x9d, 0xd0, 0xed, 0x57,
	0xc2, 0xf2, 0xa7, 0xff, 0x6a, 0xee, 0x29, 0x6d, 0x4f, 0x57, 0xba, 0xe8, 0x95, 0x84, 0xcb, 0x61,
	0xc5, 0x74, 0x39, 0xfa, 0x5a, 0x74, 0xdb, 0xf1, 0xec, 0x63, 0xcf, 0x3d, 0xb1, 0x55, 0xf4, 0xab,
	0x84, 0x2b, 0x50, 0xe6, 0xf0, 0xc1, 0x33, 0xcb, 0xf1, 0x4c, 0xab, 0xad, 0xa2, 0x8f, 0x6b, 0xb1,
	0x75, 0x47, 0xb7, 0x8e, 0xd1, 0x27, 0xb5, 0x9d, 0xa7, 0xc1, 0x9d, 0x44, 0xbc, 0x3b, 0xe3, 0x35,
	0x58, 0x0d, 0x5b, 0x11, 0x36, 0x16, 0x41, 0xd1, 0x50, 0x5a, 0x71, 0x87, 0xa4, 0x9d, 0x1f, 0x56,
	0xd8, 0x58, 0x8a, 0x4f, 0x06, 0x6a, 0x66, 0xd9, 0xc4, 0x23, 0x8e, 0xe9, 0xa9, 0x86, 0xed, 0x9e,
	0x70, 0xb3, 0x10, 0x62, 0x8e, 0x68, 0xb9, 0x38, 0x5a, 0x64, 0xba, 0x6c, 0xd7, 0x7b, 0x36, 0x4a,
	0xe1, 0x0d, 0x58, 0x0b, 0x71, 0xa5, 0x6d, 0x68, 0xa6, 0xd7, 0xea, 0x44, 0x0a, 0xe2, 0xb0, 0x4d,
	0xac, 0x2e, 0x5a, 0xe1, 0x7a, 0xe1, 0x08, 0x2b, 0xcd, 0x51, 0x23, 0x15, 0x09, 0xa8, 0x7e, 0xa4,
	0xa3, 0x2c, 0xde, 0x82, 0xea, 0x1c, 0x6a, 0x5a, 0x9e, 0x43, 0x5a, 0x9e, 0xd6, 0x41, 0xb9, 0x05,
	0xce, 0x3a, 0x22, 0xba, 0xcd, 0xa2, 0xde, 0xa5, 0xd2, 0x98, 0xe3, 0x34, 0xb3, 0x65, 0xd8, 0xba,
	0xeb, 0xb9, 0x04, 0xe5, 0x17, 0xc8, 0x76, 0x47, 0x77, 0xbd, 0x7d, 0x62, 0xb6, 0x0e, 0x10, 0xe0,
	0x75, 0x28, 0x87, 0xe4, 0x33, 0x1a, 0x4e, 0xeb, 0xa0, 0xc2, 0x82, 0x05, 0xdd, 0x8d, 0x80, 0x2c,
	0x8a, 0x85, 0x13, 0x9a, 0x5c, 0x47, 0xd1, 0x74, 0xb4, 0xba, 0x90, 0x9e, 0xed, 0x7a, 0x86, 0x63,
	0xb8, 0xad, 0x03, 0x54, 0x12, 0x7b, 0xf8, 0xcc, 0x3b, 0x26, 0x96, 0xd9, 0xa5, 0xae, 0xca, 0x0b,
	0x36, 0x9c, 0x72, 0x48, 0x0b, 0x21, 0x91, 0x73, 0x7a, 0xfb, 0x5a, 0x87, 0xc6, 0x37, 0x14, 0xea,
	0x6f, 0x8d, 0x7e, 0x24, 0xf3, 0x9c, 0x11, 0x64, 0x87, 0xc5, 0xd4, 0x23, 0x33, 0x5b, 0x21, 0xf4,
	0x23, 0x5d, 0x17, 0x7d, 0xea, 0x56, 0x4b, 0xd1, 0xa9, 0x04, 0x55, 0x42, 0x2c, 0x82, 0x2a, 0x8b,
	0x3e, 0x49, 0xe0, 0x73, 0x43, 0xac, 0xd8, 0xd1, 0x2d, 0x97, 0x8f, 0x8f, 0xea, 0x4e, 0x70, 0xce,
	0x09, 0xb3, 0x27, 0x1c, 0x0d, 0x8e, 0xab, 0xb8, 0x3d, 0x27, 0x94, 0x22, 0x86, 0x92, 0x88, 0xb2,
	0x49, 0x94, 0x58, 0x19, 0x0c, 0x24, 0x19, 0x2a, 0x22, 0xda, 0xb5, 0x34, 0xb3, 0x4b, 0xd7, 0xa7,
	0x79, 0xe6, 0x49, 0xa6, 0xcd, 0x47, 0x14, 0xeb, 0x6e, 0xcc, 0xd1, 0xfd, 0x50, 0xdb, 0x28, 0xc3,
	0x5b, 0x91, 0xc4, 0x3d, 0x5b, 0x25, 0x06, 0x82, 0x68, 0x5e, 0x09, 0x24, 0x1d, 0x81, 0x85, 0x9d,
	0x21, 0x1b, 0xa9, 0xe2, 0x31, 0x45, 0x93, 0xd5, 0x35, 0x83, 0x8f, 0x1d, 0xd6, 0x51, 0x56, 0x96,
	0x0c, 0x15, 0x11, 0x8d, 0xbf, 0x34, 0xda, 0x2f, 0x91, 0x69, 0xf7, 0x0c, 0xe3, 0x04, 0xa5, 0x16,
	0xdc, 0xf4, 0x74, 0x1d, 0xa5, 0x9b, 0xdf, 0xa4, 0xd8, 0x85, 0xca, 0xf9, 0xe0, 0x14, 0x1f, 0xce,
	0xfd, 0x44, 0xed, 0xfa, 0x33, 0xbc, 0x95, 0xfc, 0x61, 0x15, 0x9f, 0x16, 0x5b, 0xf7, 0x97, 0x72,
	0xc1, 0xb1, 0x74, 0x07, 0xbb, 0xc9, 0x1f, 0x2f, 0xd4, 0xdf, 0x5f, 0x96, 0xdc, 0x90, 0x05, 0x97,
	0xdb, 0x6f, 0xa2, 0x23, 0xaf, 0xff, 0x67, 0xc3, 0x9c, 0xdf, 0x8f, 0xf0, 0x86, 0x70, 0x0f, 0x12,
	0xbc, 0x54, 0x93, 0x70, 0x64, 0xfd, 0x6e, 0x74, 0x87, 0xa0, 0xe6, 0x55, 0xf1, 0x74, 0x13, 0xec,
	0x37, 0x17, 0xf0, 0xd0, 0xc1, 0x7e, 0xf1, 0xbb, 0xd7, 0xdb, 0xd2, 0x8f, 0xaf, 0xb7, 0xa5, 0x9f,
	0x5f, 0x6f, 0x4b, 0xcf, 0xb3, 0xec, 0xff, 0x2d, 0x7b, 0xbf, 0x05, 0x00, 0x00, 0xff, 0xff, 0xf3,
	0xf2, 0xb6, 0xd6, 0xab, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LimSvcClient is the client API for LimSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LimSvcClient interface {
	LimIfStatusGet(ctx context.Context, in *LimIfStatusGetRequest, opts ...grpc.CallOption) (*LimIfStatusGetResponse, error)
	LimIfAddrTableGet(ctx context.Context, in *LimIfAddrTableGetRequest, opts ...grpc.CallOption) (*LimIfAddrTableGetResponse, error)
	LimVrfGet(ctx context.Context, in *LimVrfGetRequest, opts ...grpc.CallOption) (*LimVrfGetResponse, error)
	LimSwIfGet(ctx context.Context, in *LimSwIfGetRequest, opts ...grpc.CallOption) (*LimSwIfGetResponse, error)
}

type limSvcClient struct {
	cc *grpc.ClientConn
}

func NewLimSvcClient(cc *grpc.ClientConn) LimSvcClient {
	return &limSvcClient{cc}
}

func (c *limSvcClient) LimIfStatusGet(ctx context.Context, in *LimIfStatusGetRequest, opts ...grpc.CallOption) (*LimIfStatusGetResponse, error) {
	out := new(LimIfStatusGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LimSvc/LimIfStatusGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *limSvcClient) LimIfAddrTableGet(ctx context.Context, in *LimIfAddrTableGetRequest, opts ...grpc.CallOption) (*LimIfAddrTableGetResponse, error) {
	out := new(LimIfAddrTableGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LimSvc/LimIfAddrTableGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *limSvcClient) LimVrfGet(ctx context.Context, in *LimVrfGetRequest, opts ...grpc.CallOption) (*LimVrfGetResponse, error) {
	out := new(LimVrfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LimSvc/LimVrfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *limSvcClient) LimSwIfGet(ctx context.Context, in *LimSwIfGetRequest, opts ...grpc.CallOption) (*LimSwIfGetResponse, error) {
	out := new(LimSwIfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.LimSvc/LimSwIfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LimSvcServer is the server API for LimSvc service.
type LimSvcServer interface {
	LimIfStatusGet(context.Context, *LimIfStatusGetRequest) (*LimIfStatusGetResponse, error)
	LimIfAddrTableGet(context.Context, *LimIfAddrTableGetRequest) (*LimIfAddrTableGetResponse, error)
	LimVrfGet(context.Context, *LimVrfGetRequest) (*LimVrfGetResponse, error)
	LimSwIfGet(context.Context, *LimSwIfGetRequest) (*LimSwIfGetResponse, error)
}

// UnimplementedLimSvcServer can be embedded to have forward compatible implementations.
type UnimplementedLimSvcServer struct {
}

func (*UnimplementedLimSvcServer) LimIfStatusGet(ctx context.Context, req *LimIfStatusGetRequest) (*LimIfStatusGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimIfStatusGet not implemented")
}
func (*UnimplementedLimSvcServer) LimIfAddrTableGet(ctx context.Context, req *LimIfAddrTableGetRequest) (*LimIfAddrTableGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimIfAddrTableGet not implemented")
}
func (*UnimplementedLimSvcServer) LimVrfGet(ctx context.Context, req *LimVrfGetRequest) (*LimVrfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimVrfGet not implemented")
}
func (*UnimplementedLimSvcServer) LimSwIfGet(ctx context.Context, req *LimSwIfGetRequest) (*LimSwIfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LimSwIfGet not implemented")
}

func RegisterLimSvcServer(s *grpc.Server, srv LimSvcServer) {
	s.RegisterService(&_LimSvc_serviceDesc, srv)
}

func _LimSvc_LimIfStatusGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LimIfStatusGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LimSvcServer).LimIfStatusGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LimSvc/LimIfStatusGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LimSvcServer).LimIfStatusGet(ctx, req.(*LimIfStatusGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LimSvc_LimIfAddrTableGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LimIfAddrTableGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LimSvcServer).LimIfAddrTableGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LimSvc/LimIfAddrTableGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LimSvcServer).LimIfAddrTableGet(ctx, req.(*LimIfAddrTableGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LimSvc_LimVrfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LimVrfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LimSvcServer).LimVrfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LimSvc/LimVrfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LimSvcServer).LimVrfGet(ctx, req.(*LimVrfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LimSvc_LimSwIfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LimSwIfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LimSvcServer).LimSwIfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.LimSvc/LimSwIfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LimSvcServer).LimSwIfGet(ctx, req.(*LimSwIfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LimSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.LimSvc",
	HandlerType: (*LimSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LimIfStatusGet",
			Handler:    _LimSvc_LimIfStatusGet_Handler,
		},
		{
			MethodName: "LimIfAddrTableGet",
			Handler:    _LimSvc_LimIfAddrTableGet_Handler,
		},
		{
			MethodName: "LimVrfGet",
			Handler:    _LimSvc_LimVrfGet_Handler,
		},
		{
			MethodName: "LimSwIfGet",
			Handler:    _LimSvc_LimSwIfGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lim.proto",
}

func (m *LimIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x58
	}
	if m.FlapCount != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.FlapCount))
		i--
		dAtA[i] = 0x50
	}
	if m.LoopBackMode != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.LoopBackMode))
		i--
		dAtA[i] = 0x48
	}
	if m.Mtu != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x40
	}
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintLim(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Type != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLim(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLim(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.OperStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.IfIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIfStatusKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfStatusKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfStatusKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimIfStatusGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfStatusGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfStatusGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIfStatusKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfStatusKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfStatusKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimIfStatusGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfStatusGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfStatusGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTableStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTableStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IfIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTableKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTableKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTableKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IfIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTableGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTableGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTableGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTableKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTableKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTableKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimIfAddrTableGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimIfAddrTableGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimIfAddrTableGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LimVrfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperReason != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperReason))
		i--
		dAtA[i] = 0x38
	}
	if m.NumInterfaces != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.NumInterfaces))
		i--
		dAtA[i] = 0x30
	}
	if m.OperStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintLim(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VrfName) > 0 {
		i -= len(m.VrfName)
		copy(dAtA[i:], m.VrfName)
		i = encodeVarintLim(dAtA, i, uint64(len(m.VrfName)))
		i--
		dAtA[i] = 0x12
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimVrfStatusKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrfStatusKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrfStatusKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VrfName) > 0 {
		i -= len(m.VrfName)
		copy(dAtA[i:], m.VrfName)
		i = encodeVarintLim(dAtA, i, uint64(len(m.VrfName)))
		i--
		dAtA[i] = 0x12
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimVrf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimVrfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimVrfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrfKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimVrfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimVrfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimVrfGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLim(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.Index != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIfKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIfKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.EntityIndex != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.EntityIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLim(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIfKeyHandle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LimSwIfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimSwIfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimSwIfGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintLim(dAtA []byte, offset int, v uint64) int {
	offset -= sovLim(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LimIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.IfIndex != 0 {
		n += 1 + sovLim(uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovLim(uint64(m.OperStatus))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovLim(uint64(m.Type))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovLim(uint64(m.Mtu))
	}
	if m.LoopBackMode != 0 {
		n += 1 + sovLim(uint64(m.LoopBackMode))
	}
	if m.FlapCount != 0 {
		n += 1 + sovLim(uint64(m.FlapCount))
	}
	if m.OperReason != 0 {
		n += 1 + sovLim(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfStatusKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.IfIndex != 0 {
		n += 1 + sovLim(uint64(m.IfIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfStatusGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLim(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfStatusKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfStatusGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTableStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.IfIndex != 0 {
		n += 1 + sovLim(uint64(m.IfIndex))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.OperStatus != 0 {
		n += 1 + sovLim(uint64(m.OperStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTableKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.IfIndex != 0 {
		n += 1 + sovLim(uint64(m.IfIndex))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTableGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLim(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTableKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimIfAddrTableGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	if m.OperStatus != 0 {
		n += 1 + sovLim(uint64(m.OperStatus))
	}
	if m.NumInterfaces != 0 {
		n += 1 + sovLim(uint64(m.NumInterfaces))
	}
	if m.OperReason != 0 {
		n += 1 + sovLim(uint64(m.OperReason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrfStatusKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLim(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrfKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimVrfGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.Type != 0 {
		n += 1 + sovLim(uint64(m.Type))
	}
	if m.Index != 0 {
		n += 1 + sovLim(uint64(m.Index))
	}
	if m.OperStatus != 0 {
		n += 1 + sovLim(uint64(m.OperStatus))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLim(uint64(l))
	}
	if m.IfIndex != 0 {
		n += 1 + sovLim(uint64(m.IfIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIfKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityIndex != 0 {
		n += 1 + sovLim(uint64(m.EntityIndex))
	}
	if m.Type != 0 {
		n += 1 + sovLim(uint64(m.Type))
	}
	if m.Index != 0 {
		n += 1 + sovLim(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLim(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIfKeyHandle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovLim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LimSwIfGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLim(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLim(x uint64) (n int) {
	return sovLim(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LimIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= LimIfOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LimIfType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = append(m.MacAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.MacAddr == nil {
				m.MacAddr = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopBackMode", wireType)
			}
			m.LoopBackMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopBackMode |= LimIfLoopbackMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapCount", wireType)
			}
			m.FlapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlapCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= LimOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfStatusKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfStatusKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfStatusKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LimIfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfStatusGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfStatusGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfStatusGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LimIf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfStatusKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfStatusKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfStatusKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LimIfStatusKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfStatusGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfStatusGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfStatusGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LimIfStatusKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= LimOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTableKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTableKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTableKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LimIfAddrTableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTableGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTableGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTableGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LimIfAddrTable{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTableKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTableKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTableKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LimIfAddrTableKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimIfAddrTableGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimIfAddrTableGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimIfAddrTableGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LimIfAddrTableKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= LimOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInterfaces", wireType)
			}
			m.NumInterfaces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInterfaces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperReason", wireType)
			}
			m.OperReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperReason |= LimOperReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrfStatusKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrfStatusKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrfStatusKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LimVrfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LimVrf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LimVrfStatusKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimVrfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimVrfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimVrfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LimVrfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LimSoftwareType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= LimOperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LimSoftwareType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LimSwIfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &LimSwIf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &LimSwIfKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimSwIfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimSwIfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimSwIfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LimSwIfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLim(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLim
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLim
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLim
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLim
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLim(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLim
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLim = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLim   = fmt.Errorf("proto: integer overflow")
)
