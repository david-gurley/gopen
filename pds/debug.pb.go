// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: debug.proto

package pds

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TraceLevel int32

const (
	TraceLevel_TRACE_LEVEL_NONE    TraceLevel = 0
	TraceLevel_TRACE_LEVEL_ERROR   TraceLevel = 1
	TraceLevel_TRACE_LEVEL_DEBUG   TraceLevel = 2
	TraceLevel_TRACE_LEVEL_WARN    TraceLevel = 3
	TraceLevel_TRACE_LEVEL_INFO    TraceLevel = 4
	TraceLevel_TRACE_LEVEL_VERBOSE TraceLevel = 5
)

var TraceLevel_name = map[int32]string{
	0: "TRACE_LEVEL_NONE",
	1: "TRACE_LEVEL_ERROR",
	2: "TRACE_LEVEL_DEBUG",
	3: "TRACE_LEVEL_WARN",
	4: "TRACE_LEVEL_INFO",
	5: "TRACE_LEVEL_VERBOSE",
}

var TraceLevel_value = map[string]int32{
	"TRACE_LEVEL_NONE":    0,
	"TRACE_LEVEL_ERROR":   1,
	"TRACE_LEVEL_DEBUG":   2,
	"TRACE_LEVEL_WARN":    3,
	"TRACE_LEVEL_INFO":    4,
	"TRACE_LEVEL_VERBOSE": 5,
}

func (x TraceLevel) String() string {
	return proto.EnumName(TraceLevel_name, int32(x))
}

func (TraceLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{0}
}

type TableApiStatsType int32

const (
	TableApiStatsType_TABLE_API_STATS_INSERT           TableApiStatsType = 0
	TableApiStatsType_TABLE_API_STATS_INSERT_DUPLICATE TableApiStatsType = 1
	TableApiStatsType_TABLE_API_STATS_INSERT_FAIL      TableApiStatsType = 2
	TableApiStatsType_TABLE_API_STATS_REMOVE           TableApiStatsType = 3
	TableApiStatsType_TABLE_API_STATS_REMOVE_NOT_FOUND TableApiStatsType = 4
	TableApiStatsType_TABLE_API_STATS_REMOVE_FAIL      TableApiStatsType = 5
	TableApiStatsType_TABLE_API_STATS_UPDATE           TableApiStatsType = 6
	TableApiStatsType_TABLE_API_STATS_UPDATE_FAIL      TableApiStatsType = 7
	TableApiStatsType_TABLE_API_STATS_GET              TableApiStatsType = 8
	TableApiStatsType_TABLE_API_STATS_GET_FAIL         TableApiStatsType = 9
	TableApiStatsType_TABLE_API_STATS_RESERVE          TableApiStatsType = 10
	TableApiStatsType_TABLE_API_STATS_RESERVE_FAIL     TableApiStatsType = 11
	TableApiStatsType_TABLE_API_STATS_RELEASE          TableApiStatsType = 12
	TableApiStatsType_TABLE_API_STATS_RELEASE_FAIL     TableApiStatsType = 13
)

var TableApiStatsType_name = map[int32]string{
	0:  "TABLE_API_STATS_INSERT",
	1:  "TABLE_API_STATS_INSERT_DUPLICATE",
	2:  "TABLE_API_STATS_INSERT_FAIL",
	3:  "TABLE_API_STATS_REMOVE",
	4:  "TABLE_API_STATS_REMOVE_NOT_FOUND",
	5:  "TABLE_API_STATS_REMOVE_FAIL",
	6:  "TABLE_API_STATS_UPDATE",
	7:  "TABLE_API_STATS_UPDATE_FAIL",
	8:  "TABLE_API_STATS_GET",
	9:  "TABLE_API_STATS_GET_FAIL",
	10: "TABLE_API_STATS_RESERVE",
	11: "TABLE_API_STATS_RESERVE_FAIL",
	12: "TABLE_API_STATS_RELEASE",
	13: "TABLE_API_STATS_RELEASE_FAIL",
}

var TableApiStatsType_value = map[string]int32{
	"TABLE_API_STATS_INSERT":           0,
	"TABLE_API_STATS_INSERT_DUPLICATE": 1,
	"TABLE_API_STATS_INSERT_FAIL":      2,
	"TABLE_API_STATS_REMOVE":           3,
	"TABLE_API_STATS_REMOVE_NOT_FOUND": 4,
	"TABLE_API_STATS_REMOVE_FAIL":      5,
	"TABLE_API_STATS_UPDATE":           6,
	"TABLE_API_STATS_UPDATE_FAIL":      7,
	"TABLE_API_STATS_GET":              8,
	"TABLE_API_STATS_GET_FAIL":         9,
	"TABLE_API_STATS_RESERVE":          10,
	"TABLE_API_STATS_RESERVE_FAIL":     11,
	"TABLE_API_STATS_RELEASE":          12,
	"TABLE_API_STATS_RELEASE_FAIL":     13,
}

func (x TableApiStatsType) String() string {
	return proto.EnumName(TableApiStatsType_name, int32(x))
}

func (TableApiStatsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{1}
}

type TableStatsType int32

const (
	TableStatsType_TABLE_STATS_ENTRIES    TableStatsType = 0
	TableStatsType_TABLE_STATS_COLLISIONS TableStatsType = 1
)

var TableStatsType_name = map[int32]string{
	0: "TABLE_STATS_ENTRIES",
	1: "TABLE_STATS_COLLISIONS",
}

var TableStatsType_value = map[string]int32{
	"TABLE_STATS_ENTRIES":    0,
	"TABLE_STATS_COLLISIONS": 1,
}

func (x TableStatsType) String() string {
	return proto.EnumName(TableStatsType_name, int32(x))
}

func (TableStatsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{2}
}

type LlcCounterType int32

const (
	LlcCounterType_LLC_COUNTER_CACHE_NONE        LlcCounterType = 0
	LlcCounterType_LLC_COUNTER_CACHE_READ        LlcCounterType = 1
	LlcCounterType_LLC_COUNTER_CACHE_WRITE       LlcCounterType = 2
	LlcCounterType_LLC_COUNTER_SCRATCHPAD_ACCESS LlcCounterType = 3
	LlcCounterType_LLC_COUNTER_CACHE_HIT         LlcCounterType = 4
	LlcCounterType_LLC_COUNTER_CACHE_MISS        LlcCounterType = 5
	LlcCounterType_LLC_COUNTER_PARTIAL_WRITE     LlcCounterType = 6
	LlcCounterType_LLC_COUNTER_CACHE_MAINT_OP    LlcCounterType = 7
	LlcCounterType_LLC_COUNTER_EVICTION          LlcCounterType = 8
	LlcCounterType_LLC_COUNTER_RETRY_NEEDED      LlcCounterType = 9
	LlcCounterType_LLC_COUNTER_RETRY_ACCESS      LlcCounterType = 10
)

var LlcCounterType_name = map[int32]string{
	0:  "LLC_COUNTER_CACHE_NONE",
	1:  "LLC_COUNTER_CACHE_READ",
	2:  "LLC_COUNTER_CACHE_WRITE",
	3:  "LLC_COUNTER_SCRATCHPAD_ACCESS",
	4:  "LLC_COUNTER_CACHE_HIT",
	5:  "LLC_COUNTER_CACHE_MISS",
	6:  "LLC_COUNTER_PARTIAL_WRITE",
	7:  "LLC_COUNTER_CACHE_MAINT_OP",
	8:  "LLC_COUNTER_EVICTION",
	9:  "LLC_COUNTER_RETRY_NEEDED",
	10: "LLC_COUNTER_RETRY_ACCESS",
}

var LlcCounterType_value = map[string]int32{
	"LLC_COUNTER_CACHE_NONE":        0,
	"LLC_COUNTER_CACHE_READ":        1,
	"LLC_COUNTER_CACHE_WRITE":       2,
	"LLC_COUNTER_SCRATCHPAD_ACCESS": 3,
	"LLC_COUNTER_CACHE_HIT":         4,
	"LLC_COUNTER_CACHE_MISS":        5,
	"LLC_COUNTER_PARTIAL_WRITE":     6,
	"LLC_COUNTER_CACHE_MAINT_OP":    7,
	"LLC_COUNTER_EVICTION":          8,
	"LLC_COUNTER_RETRY_NEEDED":      9,
	"LLC_COUNTER_RETRY_ACCESS":      10,
}

func (x LlcCounterType) String() string {
	return proto.EnumName(LlcCounterType_name, int32(x))
}

func (LlcCounterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{3}
}

type OflowFifoDropType int32

const (
	OflowFifoDropType_OCCUPANCY_DROP                OflowFifoDropType = 0
	OflowFifoDropType_EMERGENCY_STOP_DROP           OflowFifoDropType = 1
	OflowFifoDropType_WRITE_BUFFER_ACK_FILL_UP_DROP OflowFifoDropType = 2
	OflowFifoDropType_WRITE_BUFFER_ACK_FULL_DROP    OflowFifoDropType = 3
	OflowFifoDropType_WRITE_BUFFER_FULL_DROP        OflowFifoDropType = 4
	OflowFifoDropType_CONTROL_FIFO_FULL_DROP        OflowFifoDropType = 5
)

var OflowFifoDropType_name = map[int32]string{
	0: "OCCUPANCY_DROP",
	1: "EMERGENCY_STOP_DROP",
	2: "WRITE_BUFFER_ACK_FILL_UP_DROP",
	3: "WRITE_BUFFER_ACK_FULL_DROP",
	4: "WRITE_BUFFER_FULL_DROP",
	5: "CONTROL_FIFO_FULL_DROP",
}

var OflowFifoDropType_value = map[string]int32{
	"OCCUPANCY_DROP":                0,
	"EMERGENCY_STOP_DROP":           1,
	"WRITE_BUFFER_ACK_FILL_UP_DROP": 2,
	"WRITE_BUFFER_ACK_FULL_DROP":    3,
	"WRITE_BUFFER_FULL_DROP":        4,
	"CONTROL_FIFO_FULL_DROP":        5,
}

func (x OflowFifoDropType) String() string {
	return proto.EnumName(OflowFifoDropType_name, int32(x))
}

func (OflowFifoDropType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{4}
}

type BufferDropReasons int32

const (
	BufferDropReasons_INTRINSIC_DROP            BufferDropReasons = 0
	BufferDropReasons_DISCARDED                 BufferDropReasons = 1
	BufferDropReasons_ADMITTED                  BufferDropReasons = 2
	BufferDropReasons_OUT_OF_CELLS_DROP         BufferDropReasons = 3
	BufferDropReasons_OUT_OF_CELLS_DROP_2       BufferDropReasons = 4
	BufferDropReasons_OUT_OF_CREDIT_DROP        BufferDropReasons = 5
	BufferDropReasons_TRUNCATION_DROP           BufferDropReasons = 6
	BufferDropReasons_PORT_DISABLED_DROP        BufferDropReasons = 7
	BufferDropReasons_COPY_TO_CPU_TAIL_DROP     BufferDropReasons = 8
	BufferDropReasons_SPAN_TAIL_DROP            BufferDropReasons = 9
	BufferDropReasons_MIN_SIZE_VIOLATION_DROP   BufferDropReasons = 10
	BufferDropReasons_ENQUEUE_ERROR_DROP        BufferDropReasons = 11
	BufferDropReasons_INVALID_PORT_DROP         BufferDropReasons = 12
	BufferDropReasons_INVALID_OUTPUT_QUEUE_DROP BufferDropReasons = 13
)

var BufferDropReasons_name = map[int32]string{
	0:  "INTRINSIC_DROP",
	1:  "DISCARDED",
	2:  "ADMITTED",
	3:  "OUT_OF_CELLS_DROP",
	4:  "OUT_OF_CELLS_DROP_2",
	5:  "OUT_OF_CREDIT_DROP",
	6:  "TRUNCATION_DROP",
	7:  "PORT_DISABLED_DROP",
	8:  "COPY_TO_CPU_TAIL_DROP",
	9:  "SPAN_TAIL_DROP",
	10: "MIN_SIZE_VIOLATION_DROP",
	11: "ENQUEUE_ERROR_DROP",
	12: "INVALID_PORT_DROP",
	13: "INVALID_OUTPUT_QUEUE_DROP",
}

var BufferDropReasons_value = map[string]int32{
	"INTRINSIC_DROP":            0,
	"DISCARDED":                 1,
	"ADMITTED":                  2,
	"OUT_OF_CELLS_DROP":         3,
	"OUT_OF_CELLS_DROP_2":       4,
	"OUT_OF_CREDIT_DROP":        5,
	"TRUNCATION_DROP":           6,
	"PORT_DISABLED_DROP":        7,
	"COPY_TO_CPU_TAIL_DROP":     8,
	"SPAN_TAIL_DROP":            9,
	"MIN_SIZE_VIOLATION_DROP":   10,
	"ENQUEUE_ERROR_DROP":        11,
	"INVALID_PORT_DROP":         12,
	"INVALID_OUTPUT_QUEUE_DROP": 13,
}

func (x BufferDropReasons) String() string {
	return proto.EnumName(BufferDropReasons_name, int32(x))
}

func (BufferDropReasons) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{5}
}

type PacketBufferPortType int32

const (
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_DMA    PacketBufferPortType = 0
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_P4IG   PacketBufferPortType = 1
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_P4EG   PacketBufferPortType = 2
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_UPLINK PacketBufferPortType = 3
)

var PacketBufferPortType_name = map[int32]string{
	0: "PACKET_BUFFER_PORT_TYPE_DMA",
	1: "PACKET_BUFFER_PORT_TYPE_P4IG",
	2: "PACKET_BUFFER_PORT_TYPE_P4EG",
	3: "PACKET_BUFFER_PORT_TYPE_UPLINK",
}

var PacketBufferPortType_value = map[string]int32{
	"PACKET_BUFFER_PORT_TYPE_DMA":    0,
	"PACKET_BUFFER_PORT_TYPE_P4IG":   1,
	"PACKET_BUFFER_PORT_TYPE_P4EG":   2,
	"PACKET_BUFFER_PORT_TYPE_UPLINK": 3,
}

func (x PacketBufferPortType) String() string {
	return proto.EnumName(PacketBufferPortType_name, int32(x))
}

func (PacketBufferPortType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{6}
}

type MappingDumpType int32

const (
	MappingDumpType_MAPPING_DUMP_LOCAL_L2  MappingDumpType = 0
	MappingDumpType_MAPPING_DUMP_LOCAL_L3  MappingDumpType = 1
	MappingDumpType_MAPPING_DUMP_REMOTE_L2 MappingDumpType = 2
	MappingDumpType_MAPPING_DUMP_REMOTE_L3 MappingDumpType = 3
)

var MappingDumpType_name = map[int32]string{
	0: "MAPPING_DUMP_LOCAL_L2",
	1: "MAPPING_DUMP_LOCAL_L3",
	2: "MAPPING_DUMP_REMOTE_L2",
	3: "MAPPING_DUMP_REMOTE_L3",
}

var MappingDumpType_value = map[string]int32{
	"MAPPING_DUMP_LOCAL_L2":  0,
	"MAPPING_DUMP_LOCAL_L3":  1,
	"MAPPING_DUMP_REMOTE_L2": 2,
	"MAPPING_DUMP_REMOTE_L3": 3,
}

func (x MappingDumpType) String() string {
	return proto.EnumName(MappingDumpType_name, int32(x))
}

func (MappingDumpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{7}
}

type Command int32

const (
	Command_CMD_NONE                          Command = 0
	Command_CMD_MAPPING_DUMP                  Command = 1
	Command_CMD_RXDMA_MAPPING_DUMP            Command = 2
	Command_CMD_INTR_DUMP                     Command = 3
	Command_CMD_INTR_CLEAR                    Command = 4
	Command_CMD_API_ENGINE_STATS_DUMP         Command = 5
	Command_CMD_FLOW_DUMP                     Command = 6
	Command_CMD_STORE_STATS_DUMP              Command = 7
	Command_CMD_NAT_FLOW_DUMP                 Command = 8
	Command_CMD_NACL_DUMP                     Command = 9
	Command_CMD_PORT_FSM_DUMP                 Command = 10
	Command_CMD_NAT_GLOBAL_STATS              Command = 11
	Command_CMD_LIF_STATS_DUMP                Command = 12
	Command_CMD_IF_STATS_DUMP                 Command = 13
	Command_CMD_FLOW_TRACE                    Command = 14
	Command_CMD_MIRROR_POLICY_DUMP            Command = 15
	Command_CMD_LIF_VLAN_DUMP                 Command = 16
	Command_CMD_VNI_DUMP                      Command = 17
	Command_CMD_SVC_DB_DUMP                   Command = 18
	Command_CMD_VNIC_TCAM_DUMP                Command = 19
	Command_CMD_SYSTEM_RECOVERABILITY_ENABLE  Command = 20
	Command_CMD_SYSTEM_RECOVERABILITY_DISABLE Command = 21
	Command_CMD_MANUFACTURING_MODE_ENABLE     Command = 22
	Command_CMD_MANUFACTURING_MODE_DISABLE    Command = 23
	Command_CMD_DATAPATH_ASSIST               Command = 24
	Command_CMD_INTR_ALL_DUMP                 Command = 25
	Command_CMD_EXTERNAL_GRPC_ENABLE          Command = 26
	Command_CMD_EXTERNAL_GRPC_DISABLE         Command = 27
)

var Command_name = map[int32]string{
	0:  "CMD_NONE",
	1:  "CMD_MAPPING_DUMP",
	2:  "CMD_RXDMA_MAPPING_DUMP",
	3:  "CMD_INTR_DUMP",
	4:  "CMD_INTR_CLEAR",
	5:  "CMD_API_ENGINE_STATS_DUMP",
	6:  "CMD_FLOW_DUMP",
	7:  "CMD_STORE_STATS_DUMP",
	8:  "CMD_NAT_FLOW_DUMP",
	9:  "CMD_NACL_DUMP",
	10: "CMD_PORT_FSM_DUMP",
	11: "CMD_NAT_GLOBAL_STATS",
	12: "CMD_LIF_STATS_DUMP",
	13: "CMD_IF_STATS_DUMP",
	14: "CMD_FLOW_TRACE",
	15: "CMD_MIRROR_POLICY_DUMP",
	16: "CMD_LIF_VLAN_DUMP",
	17: "CMD_VNI_DUMP",
	18: "CMD_SVC_DB_DUMP",
	19: "CMD_VNIC_TCAM_DUMP",
	20: "CMD_SYSTEM_RECOVERABILITY_ENABLE",
	21: "CMD_SYSTEM_RECOVERABILITY_DISABLE",
	22: "CMD_MANUFACTURING_MODE_ENABLE",
	23: "CMD_MANUFACTURING_MODE_DISABLE",
	24: "CMD_DATAPATH_ASSIST",
	25: "CMD_INTR_ALL_DUMP",
	26: "CMD_EXTERNAL_GRPC_ENABLE",
	27: "CMD_EXTERNAL_GRPC_DISABLE",
}

var Command_value = map[string]int32{
	"CMD_NONE":                          0,
	"CMD_MAPPING_DUMP":                  1,
	"CMD_RXDMA_MAPPING_DUMP":            2,
	"CMD_INTR_DUMP":                     3,
	"CMD_INTR_CLEAR":                    4,
	"CMD_API_ENGINE_STATS_DUMP":         5,
	"CMD_FLOW_DUMP":                     6,
	"CMD_STORE_STATS_DUMP":              7,
	"CMD_NAT_FLOW_DUMP":                 8,
	"CMD_NACL_DUMP":                     9,
	"CMD_PORT_FSM_DUMP":                 10,
	"CMD_NAT_GLOBAL_STATS":              11,
	"CMD_LIF_STATS_DUMP":                12,
	"CMD_IF_STATS_DUMP":                 13,
	"CMD_FLOW_TRACE":                    14,
	"CMD_MIRROR_POLICY_DUMP":            15,
	"CMD_LIF_VLAN_DUMP":                 16,
	"CMD_VNI_DUMP":                      17,
	"CMD_SVC_DB_DUMP":                   18,
	"CMD_VNIC_TCAM_DUMP":                19,
	"CMD_SYSTEM_RECOVERABILITY_ENABLE":  20,
	"CMD_SYSTEM_RECOVERABILITY_DISABLE": 21,
	"CMD_MANUFACTURING_MODE_ENABLE":     22,
	"CMD_MANUFACTURING_MODE_DISABLE":    23,
	"CMD_DATAPATH_ASSIST":               24,
	"CMD_INTR_ALL_DUMP":                 25,
	"CMD_EXTERNAL_GRPC_ENABLE":          26,
	"CMD_EXTERNAL_GRPC_DISABLE":         27,
}

func (x Command) String() string {
	return proto.EnumName(Command_name, int32(x))
}

func (Command) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{8}
}

type IntPortDplxMode int32

const (
	IntPortDplxMode_HALF_DUPLEX IntPortDplxMode = 0
	IntPortDplxMode_FULL_DUPLEX IntPortDplxMode = 1
)

var IntPortDplxMode_name = map[int32]string{
	0: "HALF_DUPLEX",
	1: "FULL_DUPLEX",
}

var IntPortDplxMode_value = map[string]int32{
	"HALF_DUPLEX": 0,
	"FULL_DUPLEX": 1,
}

func (x IntPortDplxMode) String() string {
	return proto.EnumName(IntPortDplxMode_name, int32(x))
}

func (IntPortDplxMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{9}
}

type Pipeline int32

const (
	Pipeline_PIPELINE_NONE       Pipeline = 0
	Pipeline_PIPELINE_TXDMA      Pipeline = 1
	Pipeline_PIPELINE_RXDMA      Pipeline = 2
	Pipeline_PIPELINE_P4_INGRESS Pipeline = 3
	Pipeline_PIPELINE_P4_EGRESS  Pipeline = 4
	Pipeline_PIPELINE_SXDMA      Pipeline = 5
)

var Pipeline_name = map[int32]string{
	0: "PIPELINE_NONE",
	1: "PIPELINE_TXDMA",
	2: "PIPELINE_RXDMA",
	3: "PIPELINE_P4_INGRESS",
	4: "PIPELINE_P4_EGRESS",
	5: "PIPELINE_SXDMA",
}

var Pipeline_value = map[string]int32{
	"PIPELINE_NONE":       0,
	"PIPELINE_TXDMA":      1,
	"PIPELINE_RXDMA":      2,
	"PIPELINE_P4_INGRESS": 3,
	"PIPELINE_P4_EGRESS":  4,
	"PIPELINE_SXDMA":      5,
}

func (x Pipeline) String() string {
	return proto.EnumName(Pipeline_name, int32(x))
}

func (Pipeline) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{10}
}

// scheduling policy of the thread
type SchedPolicy int32

const (
	SchedPolicy_SCHED_POLICY_NONE  SchedPolicy = 0
	SchedPolicy_SCHED_POLICY_OTHER SchedPolicy = 1
	SchedPolicy_SCHED_POLICY_FIFO  SchedPolicy = 2
	SchedPolicy_SCHED_POLICY_RR    SchedPolicy = 3
)

var SchedPolicy_name = map[int32]string{
	0: "SCHED_POLICY_NONE",
	1: "SCHED_POLICY_OTHER",
	2: "SCHED_POLICY_FIFO",
	3: "SCHED_POLICY_RR",
}

var SchedPolicy_value = map[string]int32{
	"SCHED_POLICY_NONE":  0,
	"SCHED_POLICY_OTHER": 1,
	"SCHED_POLICY_FIFO":  2,
	"SCHED_POLICY_RR":    3,
}

func (x SchedPolicy) String() string {
	return proto.EnumName(SchedPolicy_name, int32(x))
}

func (SchedPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{11}
}

// role of the thread
type ThreadRole int32

const (
	// invalid thread role
	ThreadRole_THREAD_ROLE_NONE ThreadRole = 0
	// control thread
	ThreadRole_THREAD_ROLE_CONTROL ThreadRole = 1
	// data thread
	ThreadRole_THREAD_ROLE_DATA ThreadRole = 2
)

var ThreadRole_name = map[int32]string{
	0: "THREAD_ROLE_NONE",
	1: "THREAD_ROLE_CONTROL",
	2: "THREAD_ROLE_DATA",
}

var ThreadRole_value = map[string]int32{
	"THREAD_ROLE_NONE":    0,
	"THREAD_ROLE_CONTROL": 1,
	"THREAD_ROLE_DATA":    2,
}

func (x ThreadRole) String() string {
	return proto.EnumName(ThreadRole_name, int32(x))
}

func (ThreadRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{12}
}

type NaclRequest_PacketDir int32

const (
	NaclRequest_PACKET_DIR_NONE NaclRequest_PacketDir = 0
	// packets originated from vnic (i.e. sent by vnic)
	NaclRequest_PACKET_DIR_EGRESS NaclRequest_PacketDir = 1
	// packets received by vnic (i.e. sent to vnic)
	NaclRequest_PACKET_DIR_INGRESS NaclRequest_PacketDir = 2
)

var NaclRequest_PacketDir_name = map[int32]string{
	0: "PACKET_DIR_NONE",
	1: "PACKET_DIR_EGRESS",
	2: "PACKET_DIR_INGRESS",
}

var NaclRequest_PacketDir_value = map[string]int32{
	"PACKET_DIR_NONE":    0,
	"PACKET_DIR_EGRESS":  1,
	"PACKET_DIR_INGRESS": 2,
}

func (x NaclRequest_PacketDir) String() string {
	return proto.EnumName(NaclRequest_PacketDir_name, int32(x))
}

func (NaclRequest_PacketDir) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 0}
}

type TraceRequest struct {
	TraceLevel           TraceLevel `protobuf:"varint,1,opt,name=trace_level,json=traceLevel,proto3,enum=pds.TraceLevel" json:"trace_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TraceRequest) Reset()         { *m = TraceRequest{} }
func (m *TraceRequest) String() string { return proto.CompactTextString(m) }
func (*TraceRequest) ProtoMessage()    {}
func (*TraceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{0}
}
func (m *TraceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceRequest.Merge(m, src)
}
func (m *TraceRequest) XXX_Size() int {
	return m.Size()
}
func (m *TraceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TraceRequest proto.InternalMessageInfo

func (m *TraceRequest) GetTraceLevel() TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return TraceLevel_TRACE_LEVEL_NONE
}

type TraceResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	TraceLevel           TraceLevel `protobuf:"varint,2,opt,name=TraceLevel,proto3,enum=pds.TraceLevel" json:"TraceLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TraceResponse) Reset()         { *m = TraceResponse{} }
func (m *TraceResponse) String() string { return proto.CompactTextString(m) }
func (*TraceResponse) ProtoMessage()    {}
func (*TraceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{1}
}
func (m *TraceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceResponse.Merge(m, src)
}
func (m *TraceResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceResponse proto.InternalMessageInfo

func (m *TraceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TraceResponse) GetTraceLevel() TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return TraceLevel_TRACE_LEVEL_NONE
}

// TraceLevelGetResponse carries the current trace level in GET response
type TraceLevelGetResponse struct {
	TraceLevel           TraceLevel `protobuf:"varint,1,opt,name=TraceLevel,proto3,enum=pds.TraceLevel" json:"TraceLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TraceLevelGetResponse) Reset()         { *m = TraceLevelGetResponse{} }
func (m *TraceLevelGetResponse) String() string { return proto.CompactTextString(m) }
func (*TraceLevelGetResponse) ProtoMessage()    {}
func (*TraceLevelGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{2}
}
func (m *TraceLevelGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceLevelGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceLevelGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceLevelGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceLevelGetResponse.Merge(m, src)
}
func (m *TraceLevelGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceLevelGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceLevelGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceLevelGetResponse proto.InternalMessageInfo

func (m *TraceLevelGetResponse) GetTraceLevel() TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return TraceLevel_TRACE_LEVEL_NONE
}

type TableApiStatsEntry struct {
	Type                 TableApiStatsType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.TableApiStatsType" json:"Type,omitempty"`
	Count                uint32            `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TableApiStatsEntry) Reset()         { *m = TableApiStatsEntry{} }
func (m *TableApiStatsEntry) String() string { return proto.CompactTextString(m) }
func (*TableApiStatsEntry) ProtoMessage()    {}
func (*TableApiStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{3}
}
func (m *TableApiStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableApiStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableApiStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableApiStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableApiStatsEntry.Merge(m, src)
}
func (m *TableApiStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *TableApiStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TableApiStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TableApiStatsEntry proto.InternalMessageInfo

func (m *TableApiStatsEntry) GetType() TableApiStatsType {
	if m != nil {
		return m.Type
	}
	return TableApiStatsType_TABLE_API_STATS_INSERT
}

func (m *TableApiStatsEntry) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type TableApiStats struct {
	Entry                []*TableApiStatsEntry `protobuf:"bytes,1,rep,name=Entry,proto3" json:"Entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TableApiStats) Reset()         { *m = TableApiStats{} }
func (m *TableApiStats) String() string { return proto.CompactTextString(m) }
func (*TableApiStats) ProtoMessage()    {}
func (*TableApiStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{4}
}
func (m *TableApiStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableApiStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableApiStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableApiStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableApiStats.Merge(m, src)
}
func (m *TableApiStats) XXX_Size() int {
	return m.Size()
}
func (m *TableApiStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TableApiStats.DiscardUnknown(m)
}

var xxx_messageInfo_TableApiStats proto.InternalMessageInfo

func (m *TableApiStats) GetEntry() []*TableApiStatsEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type TableStatsEntry struct {
	Type                 TableStatsType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.TableStatsType" json:"Type,omitempty"`
	Count                uint32         `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableStatsEntry) Reset()         { *m = TableStatsEntry{} }
func (m *TableStatsEntry) String() string { return proto.CompactTextString(m) }
func (*TableStatsEntry) ProtoMessage()    {}
func (*TableStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{5}
}
func (m *TableStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsEntry.Merge(m, src)
}
func (m *TableStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsEntry proto.InternalMessageInfo

func (m *TableStatsEntry) GetType() TableStatsType {
	if m != nil {
		return m.Type
	}
	return TableStatsType_TABLE_STATS_ENTRIES
}

func (m *TableStatsEntry) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type TableStats struct {
	Entry                []*TableStatsEntry `protobuf:"bytes,1,rep,name=Entry,proto3" json:"Entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TableStats) Reset()         { *m = TableStats{} }
func (m *TableStats) String() string { return proto.CompactTextString(m) }
func (*TableStats) ProtoMessage()    {}
func (*TableStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{6}
}
func (m *TableStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStats.Merge(m, src)
}
func (m *TableStats) XXX_Size() int {
	return m.Size()
}
func (m *TableStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStats.DiscardUnknown(m)
}

var xxx_messageInfo_TableStats proto.InternalMessageInfo

func (m *TableStats) GetEntry() []*TableStatsEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type TableStatsResponse struct {
	TableName            string         `protobuf:"bytes,1,opt,name=TableName,proto3" json:"TableName,omitempty"`
	ApiStats             *TableApiStats `protobuf:"bytes,2,opt,name=ApiStats,proto3" json:"ApiStats,omitempty"`
	TableStats           *TableStats    `protobuf:"bytes,3,opt,name=TableStats,proto3" json:"TableStats,omitempty"`
	TableSize            uint32         `protobuf:"varint,4,opt,name=TableSize,proto3" json:"TableSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableStatsResponse) Reset()         { *m = TableStatsResponse{} }
func (m *TableStatsResponse) String() string { return proto.CompactTextString(m) }
func (*TableStatsResponse) ProtoMessage()    {}
func (*TableStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{7}
}
func (m *TableStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsResponse.Merge(m, src)
}
func (m *TableStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsResponse proto.InternalMessageInfo

func (m *TableStatsResponse) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TableStatsResponse) GetApiStats() *TableApiStats {
	if m != nil {
		return m.ApiStats
	}
	return nil
}

func (m *TableStatsResponse) GetTableStats() *TableStats {
	if m != nil {
		return m.TableStats
	}
	return nil
}

func (m *TableStatsResponse) GetTableSize() uint32 {
	if m != nil {
		return m.TableSize
	}
	return 0
}

type TableStatsGetResponse struct {
	ApiStatus            ApiStatus             `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TableStatsResponse `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TableStatsGetResponse) Reset()         { *m = TableStatsGetResponse{} }
func (m *TableStatsGetResponse) String() string { return proto.CompactTextString(m) }
func (*TableStatsGetResponse) ProtoMessage()    {}
func (*TableStatsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{8}
}
func (m *TableStatsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableStatsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableStatsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatsGetResponse.Merge(m, src)
}
func (m *TableStatsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TableStatsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatsGetResponse proto.InternalMessageInfo

func (m *TableStatsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TableStatsGetResponse) GetResponse() []*TableStatsResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type LlcSetupRequest struct {
	Type                 LlcCounterType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.LlcCounterType" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LlcSetupRequest) Reset()         { *m = LlcSetupRequest{} }
func (m *LlcSetupRequest) String() string { return proto.CompactTextString(m) }
func (*LlcSetupRequest) ProtoMessage()    {}
func (*LlcSetupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{9}
}
func (m *LlcSetupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LlcSetupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LlcSetupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LlcSetupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LlcSetupRequest.Merge(m, src)
}
func (m *LlcSetupRequest) XXX_Size() int {
	return m.Size()
}
func (m *LlcSetupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LlcSetupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LlcSetupRequest proto.InternalMessageInfo

func (m *LlcSetupRequest) GetType() LlcCounterType {
	if m != nil {
		return m.Type
	}
	return LlcCounterType_LLC_COUNTER_CACHE_NONE
}

type LlcSetupResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LlcSetupResponse) Reset()         { *m = LlcSetupResponse{} }
func (m *LlcSetupResponse) String() string { return proto.CompactTextString(m) }
func (*LlcSetupResponse) ProtoMessage()    {}
func (*LlcSetupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{10}
}
func (m *LlcSetupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LlcSetupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LlcSetupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LlcSetupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LlcSetupResponse.Merge(m, src)
}
func (m *LlcSetupResponse) XXX_Size() int {
	return m.Size()
}
func (m *LlcSetupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LlcSetupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LlcSetupResponse proto.InternalMessageInfo

func (m *LlcSetupResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type LlcStats struct {
	Type                 LlcCounterType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.LlcCounterType" json:"Type,omitempty"`
	Count                []uint32       `protobuf:"varint,2,rep,packed,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LlcStats) Reset()         { *m = LlcStats{} }
func (m *LlcStats) String() string { return proto.CompactTextString(m) }
func (*LlcStats) ProtoMessage()    {}
func (*LlcStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{11}
}
func (m *LlcStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LlcStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LlcStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LlcStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LlcStats.Merge(m, src)
}
func (m *LlcStats) XXX_Size() int {
	return m.Size()
}
func (m *LlcStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LlcStats.DiscardUnknown(m)
}

var xxx_messageInfo_LlcStats proto.InternalMessageInfo

func (m *LlcStats) GetType() LlcCounterType {
	if m != nil {
		return m.Type
	}
	return LlcCounterType_LLC_COUNTER_CACHE_NONE
}

func (m *LlcStats) GetCount() []uint32 {
	if m != nil {
		return m.Count
	}
	return nil
}

type LlcStatsGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Stats                *LlcStats `protobuf:"bytes,2,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LlcStatsGetResponse) Reset()         { *m = LlcStatsGetResponse{} }
func (m *LlcStatsGetResponse) String() string { return proto.CompactTextString(m) }
func (*LlcStatsGetResponse) ProtoMessage()    {}
func (*LlcStatsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{12}
}
func (m *LlcStatsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LlcStatsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LlcStatsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LlcStatsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LlcStatsGetResponse.Merge(m, src)
}
func (m *LlcStatsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LlcStatsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LlcStatsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LlcStatsGetResponse proto.InternalMessageInfo

func (m *LlcStatsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LlcStatsGetResponse) GetStats() *LlcStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type OflowFifoDropStatsEntry struct {
	Type                 OflowFifoDropType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.OflowFifoDropType" json:"Type,omitempty"`
	Count                uint32            `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OflowFifoDropStatsEntry) Reset()         { *m = OflowFifoDropStatsEntry{} }
func (m *OflowFifoDropStatsEntry) String() string { return proto.CompactTextString(m) }
func (*OflowFifoDropStatsEntry) ProtoMessage()    {}
func (*OflowFifoDropStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{13}
}
func (m *OflowFifoDropStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OflowFifoDropStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OflowFifoDropStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OflowFifoDropStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OflowFifoDropStatsEntry.Merge(m, src)
}
func (m *OflowFifoDropStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *OflowFifoDropStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_OflowFifoDropStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_OflowFifoDropStatsEntry proto.InternalMessageInfo

func (m *OflowFifoDropStatsEntry) GetType() OflowFifoDropType {
	if m != nil {
		return m.Type
	}
	return OflowFifoDropType_OCCUPANCY_DROP
}

func (m *OflowFifoDropStatsEntry) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type OflowFifoDropStats struct {
	Entry                []*OflowFifoDropStatsEntry `protobuf:"bytes,1,rep,name=Entry,proto3" json:"Entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *OflowFifoDropStats) Reset()         { *m = OflowFifoDropStats{} }
func (m *OflowFifoDropStats) String() string { return proto.CompactTextString(m) }
func (*OflowFifoDropStats) ProtoMessage()    {}
func (*OflowFifoDropStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{14}
}
func (m *OflowFifoDropStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OflowFifoDropStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OflowFifoDropStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OflowFifoDropStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OflowFifoDropStats.Merge(m, src)
}
func (m *OflowFifoDropStats) XXX_Size() int {
	return m.Size()
}
func (m *OflowFifoDropStats) XXX_DiscardUnknown() {
	xxx_messageInfo_OflowFifoDropStats.DiscardUnknown(m)
}

var xxx_messageInfo_OflowFifoDropStats proto.InternalMessageInfo

func (m *OflowFifoDropStats) GetEntry() []*OflowFifoDropStatsEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

// OflowFifoStats captures instantaneous counters at the overflow fifo interface
type OflowFifoStats struct {
	SopCountIn           uint32              `protobuf:"varint,1,opt,name=SopCountIn,proto3" json:"SopCountIn,omitempty"`
	EopCountIn           uint32              `protobuf:"varint,2,opt,name=EopCountIn,proto3" json:"EopCountIn,omitempty"`
	SopCountOut          uint32              `protobuf:"varint,3,opt,name=SopCountOut,proto3" json:"SopCountOut,omitempty"`
	EopCountOut          uint32              `protobuf:"varint,4,opt,name=EopCountOut,proto3" json:"EopCountOut,omitempty"`
	DropCounts           *OflowFifoDropStats `protobuf:"bytes,5,opt,name=DropCounts,proto3" json:"DropCounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *OflowFifoStats) Reset()         { *m = OflowFifoStats{} }
func (m *OflowFifoStats) String() string { return proto.CompactTextString(m) }
func (*OflowFifoStats) ProtoMessage()    {}
func (*OflowFifoStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{15}
}
func (m *OflowFifoStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OflowFifoStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OflowFifoStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OflowFifoStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OflowFifoStats.Merge(m, src)
}
func (m *OflowFifoStats) XXX_Size() int {
	return m.Size()
}
func (m *OflowFifoStats) XXX_DiscardUnknown() {
	xxx_messageInfo_OflowFifoStats.DiscardUnknown(m)
}

var xxx_messageInfo_OflowFifoStats proto.InternalMessageInfo

func (m *OflowFifoStats) GetSopCountIn() uint32 {
	if m != nil {
		return m.SopCountIn
	}
	return 0
}

func (m *OflowFifoStats) GetEopCountIn() uint32 {
	if m != nil {
		return m.EopCountIn
	}
	return 0
}

func (m *OflowFifoStats) GetSopCountOut() uint32 {
	if m != nil {
		return m.SopCountOut
	}
	return 0
}

func (m *OflowFifoStats) GetEopCountOut() uint32 {
	if m != nil {
		return m.EopCountOut
	}
	return 0
}

func (m *OflowFifoStats) GetDropCounts() *OflowFifoDropStats {
	if m != nil {
		return m.DropCounts
	}
	return nil
}

type BufferDropStatsEntry struct {
	Reasons              BufferDropReasons `protobuf:"varint,1,opt,name=Reasons,proto3,enum=pds.BufferDropReasons" json:"Reasons,omitempty"`
	DropCount            uint32            `protobuf:"varint,2,opt,name=DropCount,proto3" json:"DropCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BufferDropStatsEntry) Reset()         { *m = BufferDropStatsEntry{} }
func (m *BufferDropStatsEntry) String() string { return proto.CompactTextString(m) }
func (*BufferDropStatsEntry) ProtoMessage()    {}
func (*BufferDropStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{16}
}
func (m *BufferDropStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferDropStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BufferDropStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BufferDropStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferDropStatsEntry.Merge(m, src)
}
func (m *BufferDropStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *BufferDropStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferDropStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BufferDropStatsEntry proto.InternalMessageInfo

func (m *BufferDropStatsEntry) GetReasons() BufferDropReasons {
	if m != nil {
		return m.Reasons
	}
	return BufferDropReasons_INTRINSIC_DROP
}

func (m *BufferDropStatsEntry) GetDropCount() uint32 {
	if m != nil {
		return m.DropCount
	}
	return 0
}

type BufferDropStats struct {
	StatsEntries         []*BufferDropStatsEntry `protobuf:"bytes,1,rep,name=StatsEntries,proto3" json:"StatsEntries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BufferDropStats) Reset()         { *m = BufferDropStats{} }
func (m *BufferDropStats) String() string { return proto.CompactTextString(m) }
func (*BufferDropStats) ProtoMessage()    {}
func (*BufferDropStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{17}
}
func (m *BufferDropStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferDropStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BufferDropStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BufferDropStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferDropStats.Merge(m, src)
}
func (m *BufferDropStats) XXX_Size() int {
	return m.Size()
}
func (m *BufferDropStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferDropStats.DiscardUnknown(m)
}

var xxx_messageInfo_BufferDropStats proto.InternalMessageInfo

func (m *BufferDropStats) GetStatsEntries() []*BufferDropStatsEntry {
	if m != nil {
		return m.StatsEntries
	}
	return nil
}

type BufferStats struct {
	SopCountIn           uint32           `protobuf:"varint,1,opt,name=SopCountIn,proto3" json:"SopCountIn,omitempty"`
	EopCountIn           uint32           `protobuf:"varint,2,opt,name=EopCountIn,proto3" json:"EopCountIn,omitempty"`
	SopCountOut          uint32           `protobuf:"varint,3,opt,name=SopCountOut,proto3" json:"SopCountOut,omitempty"`
	EopCountOut          uint32           `protobuf:"varint,4,opt,name=EopCountOut,proto3" json:"EopCountOut,omitempty"`
	DropCounts           *BufferDropStats `protobuf:"bytes,5,opt,name=DropCounts,proto3" json:"DropCounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BufferStats) Reset()         { *m = BufferStats{} }
func (m *BufferStats) String() string { return proto.CompactTextString(m) }
func (*BufferStats) ProtoMessage()    {}
func (*BufferStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{18}
}
func (m *BufferStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BufferStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BufferStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferStats.Merge(m, src)
}
func (m *BufferStats) XXX_Size() int {
	return m.Size()
}
func (m *BufferStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferStats.DiscardUnknown(m)
}

var xxx_messageInfo_BufferStats proto.InternalMessageInfo

func (m *BufferStats) GetSopCountIn() uint32 {
	if m != nil {
		return m.SopCountIn
	}
	return 0
}

func (m *BufferStats) GetEopCountIn() uint32 {
	if m != nil {
		return m.EopCountIn
	}
	return 0
}

func (m *BufferStats) GetSopCountOut() uint32 {
	if m != nil {
		return m.SopCountOut
	}
	return 0
}

func (m *BufferStats) GetEopCountOut() uint32 {
	if m != nil {
		return m.EopCountOut
	}
	return 0
}

func (m *BufferStats) GetDropCounts() *BufferDropStats {
	if m != nil {
		return m.DropCounts
	}
	return nil
}

type PacketBufferPort struct {
	PortType             PacketBufferPortType `protobuf:"varint,1,opt,name=PortType,proto3,enum=pds.PacketBufferPortType" json:"PortType,omitempty"`
	PortNum              uint32               `protobuf:"varint,2,opt,name=PortNum,proto3" json:"PortNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PacketBufferPort) Reset()         { *m = PacketBufferPort{} }
func (m *PacketBufferPort) String() string { return proto.CompactTextString(m) }
func (*PacketBufferPort) ProtoMessage()    {}
func (*PacketBufferPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{19}
}
func (m *PacketBufferPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketBufferPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketBufferPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketBufferPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketBufferPort.Merge(m, src)
}
func (m *PacketBufferPort) XXX_Size() int {
	return m.Size()
}
func (m *PacketBufferPort) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketBufferPort.DiscardUnknown(m)
}

var xxx_messageInfo_PacketBufferPort proto.InternalMessageInfo

func (m *PacketBufferPort) GetPortType() PacketBufferPortType {
	if m != nil {
		return m.PortType
	}
	return PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_DMA
}

func (m *PacketBufferPort) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

type QosInputOflowQueueStats struct {
	GoodPktsIn           uint64   `protobuf:"varint,1,opt,name=GoodPktsIn,proto3" json:"GoodPktsIn,omitempty"`
	GoodPktsOut          uint64   `protobuf:"varint,2,opt,name=GoodPktsOut,proto3" json:"GoodPktsOut,omitempty"`
	ErroredPktsIn        uint64   `protobuf:"varint,3,opt,name=ErroredPktsIn,proto3" json:"ErroredPktsIn,omitempty"`
	FifoDepth            uint32   `protobuf:"varint,4,opt,name=FifoDepth,proto3" json:"FifoDepth,omitempty"`
	MaxFifoDepth         uint32   `protobuf:"varint,5,opt,name=MaxFifoDepth,proto3" json:"MaxFifoDepth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosInputOflowQueueStats) Reset()         { *m = QosInputOflowQueueStats{} }
func (m *QosInputOflowQueueStats) String() string { return proto.CompactTextString(m) }
func (*QosInputOflowQueueStats) ProtoMessage()    {}
func (*QosInputOflowQueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{20}
}
func (m *QosInputOflowQueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosInputOflowQueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosInputOflowQueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosInputOflowQueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosInputOflowQueueStats.Merge(m, src)
}
func (m *QosInputOflowQueueStats) XXX_Size() int {
	return m.Size()
}
func (m *QosInputOflowQueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QosInputOflowQueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_QosInputOflowQueueStats proto.InternalMessageInfo

func (m *QosInputOflowQueueStats) GetGoodPktsIn() uint64 {
	if m != nil {
		return m.GoodPktsIn
	}
	return 0
}

func (m *QosInputOflowQueueStats) GetGoodPktsOut() uint64 {
	if m != nil {
		return m.GoodPktsOut
	}
	return 0
}

func (m *QosInputOflowQueueStats) GetErroredPktsIn() uint64 {
	if m != nil {
		return m.ErroredPktsIn
	}
	return 0
}

func (m *QosInputOflowQueueStats) GetFifoDepth() uint32 {
	if m != nil {
		return m.FifoDepth
	}
	return 0
}

func (m *QosInputOflowQueueStats) GetMaxFifoDepth() uint32 {
	if m != nil {
		return m.MaxFifoDepth
	}
	return 0
}

type QosInputQueueStats struct {
	InputQueueIdx        uint32                   `protobuf:"varint,1,opt,name=InputQueueIdx,proto3" json:"InputQueueIdx,omitempty"`
	OflowFifoStats       *QosInputOflowQueueStats `protobuf:"bytes,2,opt,name=OflowFifoStats,proto3" json:"OflowFifoStats,omitempty"`
	BufferOccupancy      uint32                   `protobuf:"varint,3,opt,name=BufferOccupancy,proto3" json:"BufferOccupancy,omitempty"`
	PeakOccupancy        uint32                   `protobuf:"varint,4,opt,name=PeakOccupancy,proto3" json:"PeakOccupancy,omitempty"`
	PortMonitor          uint64                   `protobuf:"varint,5,opt,name=PortMonitor,proto3" json:"PortMonitor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *QosInputQueueStats) Reset()         { *m = QosInputQueueStats{} }
func (m *QosInputQueueStats) String() string { return proto.CompactTextString(m) }
func (*QosInputQueueStats) ProtoMessage()    {}
func (*QosInputQueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{21}
}
func (m *QosInputQueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosInputQueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosInputQueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosInputQueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosInputQueueStats.Merge(m, src)
}
func (m *QosInputQueueStats) XXX_Size() int {
	return m.Size()
}
func (m *QosInputQueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QosInputQueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_QosInputQueueStats proto.InternalMessageInfo

func (m *QosInputQueueStats) GetInputQueueIdx() uint32 {
	if m != nil {
		return m.InputQueueIdx
	}
	return 0
}

func (m *QosInputQueueStats) GetOflowFifoStats() *QosInputOflowQueueStats {
	if m != nil {
		return m.OflowFifoStats
	}
	return nil
}

func (m *QosInputQueueStats) GetBufferOccupancy() uint32 {
	if m != nil {
		return m.BufferOccupancy
	}
	return 0
}

func (m *QosInputQueueStats) GetPeakOccupancy() uint32 {
	if m != nil {
		return m.PeakOccupancy
	}
	return 0
}

func (m *QosInputQueueStats) GetPortMonitor() uint64 {
	if m != nil {
		return m.PortMonitor
	}
	return 0
}

type QosOutputQueueStats struct {
	OutputQueueIdx       uint32   `protobuf:"varint,1,opt,name=OutputQueueIdx,proto3" json:"OutputQueueIdx,omitempty"`
	QueueDepth           uint32   `protobuf:"varint,2,opt,name=QueueDepth,proto3" json:"QueueDepth,omitempty"`
	PortMonitor          uint64   `protobuf:"varint,3,opt,name=PortMonitor,proto3" json:"PortMonitor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosOutputQueueStats) Reset()         { *m = QosOutputQueueStats{} }
func (m *QosOutputQueueStats) String() string { return proto.CompactTextString(m) }
func (*QosOutputQueueStats) ProtoMessage()    {}
func (*QosOutputQueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{22}
}
func (m *QosOutputQueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosOutputQueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosOutputQueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosOutputQueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosOutputQueueStats.Merge(m, src)
}
func (m *QosOutputQueueStats) XXX_Size() int {
	return m.Size()
}
func (m *QosOutputQueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QosOutputQueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_QosOutputQueueStats proto.InternalMessageInfo

func (m *QosOutputQueueStats) GetOutputQueueIdx() uint32 {
	if m != nil {
		return m.OutputQueueIdx
	}
	return 0
}

func (m *QosOutputQueueStats) GetQueueDepth() uint32 {
	if m != nil {
		return m.QueueDepth
	}
	return 0
}

func (m *QosOutputQueueStats) GetPortMonitor() uint64 {
	if m != nil {
		return m.PortMonitor
	}
	return 0
}

type QosQueueStats struct {
	InputQueueStats      []*QosInputQueueStats  `protobuf:"bytes,1,rep,name=InputQueueStats,proto3" json:"InputQueueStats,omitempty"`
	OutputQueueStats     []*QosOutputQueueStats `protobuf:"bytes,2,rep,name=OutputQueueStats,proto3" json:"OutputQueueStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *QosQueueStats) Reset()         { *m = QosQueueStats{} }
func (m *QosQueueStats) String() string { return proto.CompactTextString(m) }
func (*QosQueueStats) ProtoMessage()    {}
func (*QosQueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{23}
}
func (m *QosQueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosQueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosQueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosQueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosQueueStats.Merge(m, src)
}
func (m *QosQueueStats) XXX_Size() int {
	return m.Size()
}
func (m *QosQueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QosQueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_QosQueueStats proto.InternalMessageInfo

func (m *QosQueueStats) GetInputQueueStats() []*QosInputQueueStats {
	if m != nil {
		return m.InputQueueStats
	}
	return nil
}

func (m *QosQueueStats) GetOutputQueueStats() []*QosOutputQueueStats {
	if m != nil {
		return m.OutputQueueStats
	}
	return nil
}

type PacketBufferPortStats struct {
	PacketBufferPort     *PacketBufferPort `protobuf:"bytes,1,opt,name=PacketBufferPort,proto3" json:"PacketBufferPort,omitempty"`
	BufferStats          *BufferStats      `protobuf:"bytes,2,opt,name=BufferStats,proto3" json:"BufferStats,omitempty"`
	OflowFifoStats       *OflowFifoStats   `protobuf:"bytes,3,opt,name=OflowFifoStats,proto3" json:"OflowFifoStats,omitempty"`
	QosQueueStats        *QosQueueStats    `protobuf:"bytes,4,opt,name=QosQueueStats,proto3" json:"QosQueueStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PacketBufferPortStats) Reset()         { *m = PacketBufferPortStats{} }
func (m *PacketBufferPortStats) String() string { return proto.CompactTextString(m) }
func (*PacketBufferPortStats) ProtoMessage()    {}
func (*PacketBufferPortStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{24}
}
func (m *PacketBufferPortStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketBufferPortStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketBufferPortStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketBufferPortStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketBufferPortStats.Merge(m, src)
}
func (m *PacketBufferPortStats) XXX_Size() int {
	return m.Size()
}
func (m *PacketBufferPortStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketBufferPortStats.DiscardUnknown(m)
}

var xxx_messageInfo_PacketBufferPortStats proto.InternalMessageInfo

func (m *PacketBufferPortStats) GetPacketBufferPort() *PacketBufferPort {
	if m != nil {
		return m.PacketBufferPort
	}
	return nil
}

func (m *PacketBufferPortStats) GetBufferStats() *BufferStats {
	if m != nil {
		return m.BufferStats
	}
	return nil
}

func (m *PacketBufferPortStats) GetOflowFifoStats() *OflowFifoStats {
	if m != nil {
		return m.OflowFifoStats
	}
	return nil
}

func (m *PacketBufferPortStats) GetQosQueueStats() *QosQueueStats {
	if m != nil {
		return m.QosQueueStats
	}
	return nil
}

// PacketBufferStats captures all the statistics of the packet buffering module
type PacketBufferStats struct {
	PortStats            []*PacketBufferPortStats `protobuf:"bytes,1,rep,name=PortStats,proto3" json:"PortStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *PacketBufferStats) Reset()         { *m = PacketBufferStats{} }
func (m *PacketBufferStats) String() string { return proto.CompactTextString(m) }
func (*PacketBufferStats) ProtoMessage()    {}
func (*PacketBufferStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{25}
}
func (m *PacketBufferStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketBufferStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketBufferStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketBufferStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketBufferStats.Merge(m, src)
}
func (m *PacketBufferStats) XXX_Size() int {
	return m.Size()
}
func (m *PacketBufferStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketBufferStats.DiscardUnknown(m)
}

var xxx_messageInfo_PacketBufferStats proto.InternalMessageInfo

func (m *PacketBufferStats) GetPortStats() []*PacketBufferPortStats {
	if m != nil {
		return m.PortStats
	}
	return nil
}

type PbStatsGetResponse struct {
	ApiStatus            ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	PbStats              *PacketBufferStats `protobuf:"bytes,2,opt,name=PbStats,proto3" json:"PbStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PbStatsGetResponse) Reset()         { *m = PbStatsGetResponse{} }
func (m *PbStatsGetResponse) String() string { return proto.CompactTextString(m) }
func (*PbStatsGetResponse) ProtoMessage()    {}
func (*PbStatsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{26}
}
func (m *PbStatsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbStatsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbStatsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbStatsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbStatsGetResponse.Merge(m, src)
}
func (m *PbStatsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *PbStatsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PbStatsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PbStatsGetResponse proto.InternalMessageInfo

func (m *PbStatsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *PbStatsGetResponse) GetPbStats() *PacketBufferStats {
	if m != nil {
		return m.PbStats
	}
	return nil
}

type PbStatsSummary struct {
	// number of pkts coming into PB from MAC (across all ports)
	TotalMacPktsIn uint64 `protobuf:"varint,1,opt,name=TotalMacPktsIn,proto3" json:"TotalMacPktsIn,omitempty"`
	// number of pkts going out of MAC (across all ports) from PB
	TotalMacPktsOut uint64 `protobuf:"varint,2,opt,name=TotalMacPktsOut,proto3" json:"TotalMacPktsOut,omitempty"`
	// number of pkts coming into PB from Host
	TotalHostPktsIn uint64 `protobuf:"varint,3,opt,name=TotalHostPktsIn,proto3" json:"TotalHostPktsIn,omitempty"`
	// number of pkts towards Host from PB
	TotalHostPktsOut uint64 `protobuf:"varint,4,opt,name=TotalHostPktsOut,proto3" json:"TotalHostPktsOut,omitempty"`
	// number of pkts dropped in PB Block
	TotalPBDrops uint64 `protobuf:"varint,5,opt,name=TotalPBDrops,proto3" json:"TotalPBDrops,omitempty"`
	// number of pkts dropped in PRD Block
	TotalPRDDrops        uint64   `protobuf:"varint,6,opt,name=TotalPRDDrops,proto3" json:"TotalPRDDrops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PbStatsSummary) Reset()         { *m = PbStatsSummary{} }
func (m *PbStatsSummary) String() string { return proto.CompactTextString(m) }
func (*PbStatsSummary) ProtoMessage()    {}
func (*PbStatsSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{27}
}
func (m *PbStatsSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbStatsSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbStatsSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbStatsSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbStatsSummary.Merge(m, src)
}
func (m *PbStatsSummary) XXX_Size() int {
	return m.Size()
}
func (m *PbStatsSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_PbStatsSummary.DiscardUnknown(m)
}

var xxx_messageInfo_PbStatsSummary proto.InternalMessageInfo

func (m *PbStatsSummary) GetTotalMacPktsIn() uint64 {
	if m != nil {
		return m.TotalMacPktsIn
	}
	return 0
}

func (m *PbStatsSummary) GetTotalMacPktsOut() uint64 {
	if m != nil {
		return m.TotalMacPktsOut
	}
	return 0
}

func (m *PbStatsSummary) GetTotalHostPktsIn() uint64 {
	if m != nil {
		return m.TotalHostPktsIn
	}
	return 0
}

func (m *PbStatsSummary) GetTotalHostPktsOut() uint64 {
	if m != nil {
		return m.TotalHostPktsOut
	}
	return 0
}

func (m *PbStatsSummary) GetTotalPBDrops() uint64 {
	if m != nil {
		return m.TotalPBDrops
	}
	return 0
}

func (m *PbStatsSummary) GetTotalPRDDrops() uint64 {
	if m != nil {
		return m.TotalPRDDrops
	}
	return 0
}

type PbStatsSummaryGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	PbStatsSummary       *PbStatsSummary `protobuf:"bytes,2,opt,name=PbStatsSummary,proto3" json:"PbStatsSummary,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PbStatsSummaryGetResponse) Reset()         { *m = PbStatsSummaryGetResponse{} }
func (m *PbStatsSummaryGetResponse) String() string { return proto.CompactTextString(m) }
func (*PbStatsSummaryGetResponse) ProtoMessage()    {}
func (*PbStatsSummaryGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{28}
}
func (m *PbStatsSummaryGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PbStatsSummaryGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PbStatsSummaryGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PbStatsSummaryGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PbStatsSummaryGetResponse.Merge(m, src)
}
func (m *PbStatsSummaryGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *PbStatsSummaryGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PbStatsSummaryGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PbStatsSummaryGetResponse proto.InternalMessageInfo

func (m *PbStatsSummaryGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *PbStatsSummaryGetResponse) GetPbStatsSummary() *PbStatsSummary {
	if m != nil {
		return m.PbStatsSummary
	}
	return nil
}

type MemTrackSpec struct {
	AllocId              uint32   `protobuf:"varint,1,opt,name=AllocId,proto3" json:"AllocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemTrackSpec) Reset()         { *m = MemTrackSpec{} }
func (m *MemTrackSpec) String() string { return proto.CompactTextString(m) }
func (*MemTrackSpec) ProtoMessage()    {}
func (*MemTrackSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{29}
}
func (m *MemTrackSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemTrackSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemTrackSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemTrackSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemTrackSpec.Merge(m, src)
}
func (m *MemTrackSpec) XXX_Size() int {
	return m.Size()
}
func (m *MemTrackSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MemTrackSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MemTrackSpec proto.InternalMessageInfo

func (m *MemTrackSpec) GetAllocId() uint32 {
	if m != nil {
		return m.AllocId
	}
	return 0
}

// operational status of memory tracker object
type MemTrackStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemTrackStatus) Reset()         { *m = MemTrackStatus{} }
func (m *MemTrackStatus) String() string { return proto.CompactTextString(m) }
func (*MemTrackStatus) ProtoMessage()    {}
func (*MemTrackStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{30}
}
func (m *MemTrackStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemTrackStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemTrackStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemTrackStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemTrackStatus.Merge(m, src)
}
func (m *MemTrackStatus) XXX_Size() int {
	return m.Size()
}
func (m *MemTrackStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MemTrackStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MemTrackStatus proto.InternalMessageInfo

// stats per memory tracker object
type MemTrackStats struct {
	NumAllocs            uint32   `protobuf:"varint,1,opt,name=NumAllocs,proto3" json:"NumAllocs,omitempty"`
	NumFrees             uint32   `protobuf:"varint,2,opt,name=NumFrees,proto3" json:"NumFrees,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemTrackStats) Reset()         { *m = MemTrackStats{} }
func (m *MemTrackStats) String() string { return proto.CompactTextString(m) }
func (*MemTrackStats) ProtoMessage()    {}
func (*MemTrackStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{31}
}
func (m *MemTrackStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemTrackStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemTrackStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemTrackStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemTrackStats.Merge(m, src)
}
func (m *MemTrackStats) XXX_Size() int {
	return m.Size()
}
func (m *MemTrackStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MemTrackStats.DiscardUnknown(m)
}

var xxx_messageInfo_MemTrackStats proto.InternalMessageInfo

func (m *MemTrackStats) GetNumAllocs() uint32 {
	if m != nil {
		return m.NumAllocs
	}
	return 0
}

func (m *MemTrackStats) GetNumFrees() uint32 {
	if m != nil {
		return m.NumFrees
	}
	return 0
}

// MemTrackGetRequest is request msg with allocation id that info is requested for
type MemTrackGetRequest struct {
	Spec                 *MemTrackSpec `protobuf:"bytes,1,opt,name=Spec,proto3" json:"Spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MemTrackGetRequest) Reset()         { *m = MemTrackGetRequest{} }
func (m *MemTrackGetRequest) String() string { return proto.CompactTextString(m) }
func (*MemTrackGetRequest) ProtoMessage()    {}
func (*MemTrackGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{32}
}
func (m *MemTrackGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemTrackGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemTrackGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemTrackGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemTrackGetRequest.Merge(m, src)
}
func (m *MemTrackGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *MemTrackGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MemTrackGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MemTrackGetRequest proto.InternalMessageInfo

func (m *MemTrackGetRequest) GetSpec() *MemTrackSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// MemTrackGetResponse captures debug information per allocation id
type MemTrackGetResponse struct {
	ApiStatus            ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Spec                 *MemTrackSpec   `protobuf:"bytes,2,opt,name=Spec,proto3" json:"Spec,omitempty"`
	Status               *MemTrackStatus `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
	Stats                *MemTrackStats  `protobuf:"bytes,4,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MemTrackGetResponse) Reset()         { *m = MemTrackGetResponse{} }
func (m *MemTrackGetResponse) String() string { return proto.CompactTextString(m) }
func (*MemTrackGetResponse) ProtoMessage()    {}
func (*MemTrackGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{33}
}
func (m *MemTrackGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemTrackGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemTrackGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemTrackGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemTrackGetResponse.Merge(m, src)
}
func (m *MemTrackGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemTrackGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemTrackGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemTrackGetResponse proto.InternalMessageInfo

func (m *MemTrackGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MemTrackGetResponse) GetSpec() *MemTrackSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MemTrackGetResponse) GetStatus() *MemTrackStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *MemTrackGetResponse) GetStats() *MemTrackStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type HeapStats struct {
	NumArenaBytesAlloc   uint32   `protobuf:"varint,1,opt,name=NumArenaBytesAlloc,proto3" json:"NumArenaBytesAlloc,omitempty"`
	NumFreeBlocks        uint32   `protobuf:"varint,2,opt,name=NumFreeBlocks,proto3" json:"NumFreeBlocks,omitempty"`
	NumFastBinFreeBlocks uint32   `protobuf:"varint,3,opt,name=NumFastBinFreeBlocks,proto3" json:"NumFastBinFreeBlocks,omitempty"`
	NumMmapBlocksAlloc   uint32   `protobuf:"varint,4,opt,name=NumMmapBlocksAlloc,proto3" json:"NumMmapBlocksAlloc,omitempty"`
	NumMmapBytesAlloc    uint32   `protobuf:"varint,5,opt,name=NumMmapBytesAlloc,proto3" json:"NumMmapBytesAlloc,omitempty"`
	MaxBlocksAlloc       uint32   `protobuf:"varint,6,opt,name=MaxBlocksAlloc,proto3" json:"MaxBlocksAlloc,omitempty"`
	NumFastBinFreeBytes  uint32   `protobuf:"varint,7,opt,name=NumFastBinFreeBytes,proto3" json:"NumFastBinFreeBytes,omitempty"`
	NumBytesAlloc        uint32   `protobuf:"varint,8,opt,name=NumBytesAlloc,proto3" json:"NumBytesAlloc,omitempty"`
	NumFreeBytes         uint32   `protobuf:"varint,9,opt,name=NumFreeBytes,proto3" json:"NumFreeBytes,omitempty"`
	ReleasableFreeBytes  uint32   `protobuf:"varint,10,opt,name=ReleasableFreeBytes,proto3" json:"ReleasableFreeBytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeapStats) Reset()         { *m = HeapStats{} }
func (m *HeapStats) String() string { return proto.CompactTextString(m) }
func (*HeapStats) ProtoMessage()    {}
func (*HeapStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{34}
}
func (m *HeapStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeapStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeapStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeapStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeapStats.Merge(m, src)
}
func (m *HeapStats) XXX_Size() int {
	return m.Size()
}
func (m *HeapStats) XXX_DiscardUnknown() {
	xxx_messageInfo_HeapStats.DiscardUnknown(m)
}

var xxx_messageInfo_HeapStats proto.InternalMessageInfo

func (m *HeapStats) GetNumArenaBytesAlloc() uint32 {
	if m != nil {
		return m.NumArenaBytesAlloc
	}
	return 0
}

func (m *HeapStats) GetNumFreeBlocks() uint32 {
	if m != nil {
		return m.NumFreeBlocks
	}
	return 0
}

func (m *HeapStats) GetNumFastBinFreeBlocks() uint32 {
	if m != nil {
		return m.NumFastBinFreeBlocks
	}
	return 0
}

func (m *HeapStats) GetNumMmapBlocksAlloc() uint32 {
	if m != nil {
		return m.NumMmapBlocksAlloc
	}
	return 0
}

func (m *HeapStats) GetNumMmapBytesAlloc() uint32 {
	if m != nil {
		return m.NumMmapBytesAlloc
	}
	return 0
}

func (m *HeapStats) GetMaxBlocksAlloc() uint32 {
	if m != nil {
		return m.MaxBlocksAlloc
	}
	return 0
}

func (m *HeapStats) GetNumFastBinFreeBytes() uint32 {
	if m != nil {
		return m.NumFastBinFreeBytes
	}
	return 0
}

func (m *HeapStats) GetNumBytesAlloc() uint32 {
	if m != nil {
		return m.NumBytesAlloc
	}
	return 0
}

func (m *HeapStats) GetNumFreeBytes() uint32 {
	if m != nil {
		return m.NumFreeBytes
	}
	return 0
}

func (m *HeapStats) GetReleasableFreeBytes() uint32 {
	if m != nil {
		return m.ReleasableFreeBytes
	}
	return 0
}

type HeapGetRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeapGetRequest) Reset()         { *m = HeapGetRequest{} }
func (m *HeapGetRequest) String() string { return proto.CompactTextString(m) }
func (*HeapGetRequest) ProtoMessage()    {}
func (*HeapGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{35}
}
func (m *HeapGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeapGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeapGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeapGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeapGetRequest.Merge(m, src)
}
func (m *HeapGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeapGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeapGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeapGetRequest proto.InternalMessageInfo

type HeapGetResponse struct {
	ApiStatus            ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Stats                *HeapStats `protobuf:"bytes,2,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HeapGetResponse) Reset()         { *m = HeapGetResponse{} }
func (m *HeapGetResponse) String() string { return proto.CompactTextString(m) }
func (*HeapGetResponse) ProtoMessage()    {}
func (*HeapGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{36}
}
func (m *HeapGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeapGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeapGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeapGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeapGetResponse.Merge(m, src)
}
func (m *HeapGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeapGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeapGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeapGetResponse proto.InternalMessageInfo

func (m *HeapGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *HeapGetResponse) GetStats() *HeapStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type L3HWMappingKey struct {
	VPCId                uint32     `protobuf:"varint,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	IPAddr               *IPAddress `protobuf:"bytes,2,opt,name=IPAddr,proto3" json:"IPAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *L3HWMappingKey) Reset()         { *m = L3HWMappingKey{} }
func (m *L3HWMappingKey) String() string { return proto.CompactTextString(m) }
func (*L3HWMappingKey) ProtoMessage()    {}
func (*L3HWMappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{37}
}
func (m *L3HWMappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3HWMappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3HWMappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3HWMappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3HWMappingKey.Merge(m, src)
}
func (m *L3HWMappingKey) XXX_Size() int {
	return m.Size()
}
func (m *L3HWMappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_L3HWMappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_L3HWMappingKey proto.InternalMessageInfo

func (m *L3HWMappingKey) GetVPCId() uint32 {
	if m != nil {
		return m.VPCId
	}
	return 0
}

func (m *L3HWMappingKey) GetIPAddr() *IPAddress {
	if m != nil {
		return m.IPAddr
	}
	return nil
}

type L2HWMappingKey struct {
	SubnetId             uint32   `protobuf:"varint,1,opt,name=SubnetId,proto3" json:"SubnetId,omitempty"`
	MACAddr              uint64   `protobuf:"varint,2,opt,name=MACAddr,proto3" json:"MACAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L2HWMappingKey) Reset()         { *m = L2HWMappingKey{} }
func (m *L2HWMappingKey) String() string { return proto.CompactTextString(m) }
func (*L2HWMappingKey) ProtoMessage()    {}
func (*L2HWMappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{38}
}
func (m *L2HWMappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2HWMappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2HWMappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2HWMappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2HWMappingKey.Merge(m, src)
}
func (m *L2HWMappingKey) XXX_Size() int {
	return m.Size()
}
func (m *L2HWMappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_L2HWMappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_L2HWMappingKey proto.InternalMessageInfo

func (m *L2HWMappingKey) GetSubnetId() uint32 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *L2HWMappingKey) GetMACAddr() uint64 {
	if m != nil {
		return m.MACAddr
	}
	return 0
}

type HWMappingKey struct {
	// Types that are valid to be assigned to Keyinfo:
	//	*HWMappingKey_IPKey
	//	*HWMappingKey_MACKey
	Keyinfo              isHWMappingKey_Keyinfo `protobuf_oneof:"keyinfo"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *HWMappingKey) Reset()         { *m = HWMappingKey{} }
func (m *HWMappingKey) String() string { return proto.CompactTextString(m) }
func (*HWMappingKey) ProtoMessage()    {}
func (*HWMappingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{39}
}
func (m *HWMappingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HWMappingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HWMappingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HWMappingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HWMappingKey.Merge(m, src)
}
func (m *HWMappingKey) XXX_Size() int {
	return m.Size()
}
func (m *HWMappingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_HWMappingKey.DiscardUnknown(m)
}

var xxx_messageInfo_HWMappingKey proto.InternalMessageInfo

type isHWMappingKey_Keyinfo interface {
	isHWMappingKey_Keyinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HWMappingKey_IPKey struct {
	IPKey *L3HWMappingKey `protobuf:"bytes,1,opt,name=IPKey,proto3,oneof"`
}
type HWMappingKey_MACKey struct {
	MACKey *L2HWMappingKey `protobuf:"bytes,2,opt,name=MACKey,proto3,oneof"`
}

func (*HWMappingKey_IPKey) isHWMappingKey_Keyinfo()  {}
func (*HWMappingKey_MACKey) isHWMappingKey_Keyinfo() {}

func (m *HWMappingKey) GetKeyinfo() isHWMappingKey_Keyinfo {
	if m != nil {
		return m.Keyinfo
	}
	return nil
}

func (m *HWMappingKey) GetIPKey() *L3HWMappingKey {
	if x, ok := m.GetKeyinfo().(*HWMappingKey_IPKey); ok {
		return x.IPKey
	}
	return nil
}

func (m *HWMappingKey) GetMACKey() *L2HWMappingKey {
	if x, ok := m.GetKeyinfo().(*HWMappingKey_MACKey); ok {
		return x.MACKey
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HWMappingKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HWMappingKey_IPKey)(nil),
		(*HWMappingKey_MACKey)(nil),
	}
}

type MappingDumpFilter struct {
	Key                  *HWMappingKey   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Type                 MappingDumpType `protobuf:"varint,2,opt,name=Type,proto3,enum=pds.MappingDumpType" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MappingDumpFilter) Reset()         { *m = MappingDumpFilter{} }
func (m *MappingDumpFilter) String() string { return proto.CompactTextString(m) }
func (*MappingDumpFilter) ProtoMessage()    {}
func (*MappingDumpFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{40}
}
func (m *MappingDumpFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MappingDumpFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MappingDumpFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MappingDumpFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingDumpFilter.Merge(m, src)
}
func (m *MappingDumpFilter) XXX_Size() int {
	return m.Size()
}
func (m *MappingDumpFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingDumpFilter.DiscardUnknown(m)
}

var xxx_messageInfo_MappingDumpFilter proto.InternalMessageInfo

func (m *MappingDumpFilter) GetKey() *HWMappingKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MappingDumpFilter) GetType() MappingDumpType {
	if m != nil {
		return m.Type
	}
	return MappingDumpType_MAPPING_DUMP_LOCAL_L2
}

type CommandUUID struct {
	Id                   []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandUUID) Reset()         { *m = CommandUUID{} }
func (m *CommandUUID) String() string { return proto.CompactTextString(m) }
func (*CommandUUID) ProtoMessage()    {}
func (*CommandUUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{41}
}
func (m *CommandUUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandUUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandUUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandUUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandUUID.Merge(m, src)
}
func (m *CommandUUID) XXX_Size() int {
	return m.Size()
}
func (m *CommandUUID) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandUUID.DiscardUnknown(m)
}

var xxx_messageInfo_CommandUUID proto.InternalMessageInfo

func (m *CommandUUID) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type InterfaceDumpFilter struct {
	// Types that are valid to be assigned to Ifinfo:
	//	*InterfaceDumpFilter_Id
	//	*InterfaceDumpFilter_IfType
	Ifinfo               isInterfaceDumpFilter_Ifinfo `protobuf_oneof:"ifinfo"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *InterfaceDumpFilter) Reset()         { *m = InterfaceDumpFilter{} }
func (m *InterfaceDumpFilter) String() string { return proto.CompactTextString(m) }
func (*InterfaceDumpFilter) ProtoMessage()    {}
func (*InterfaceDumpFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{42}
}
func (m *InterfaceDumpFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDumpFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDumpFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDumpFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDumpFilter.Merge(m, src)
}
func (m *InterfaceDumpFilter) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDumpFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDumpFilter.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDumpFilter proto.InternalMessageInfo

type isInterfaceDumpFilter_Ifinfo interface {
	isInterfaceDumpFilter_Ifinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceDumpFilter_Id struct {
	Id *CommandUUID `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type InterfaceDumpFilter_IfType struct {
	IfType IfType `protobuf:"varint,2,opt,name=IfType,proto3,enum=pds.IfType,oneof"`
}

func (*InterfaceDumpFilter_Id) isInterfaceDumpFilter_Ifinfo()     {}
func (*InterfaceDumpFilter_IfType) isInterfaceDumpFilter_Ifinfo() {}

func (m *InterfaceDumpFilter) GetIfinfo() isInterfaceDumpFilter_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (m *InterfaceDumpFilter) GetId() *CommandUUID {
	if x, ok := m.GetIfinfo().(*InterfaceDumpFilter_Id); ok {
		return x.Id
	}
	return nil
}

func (m *InterfaceDumpFilter) GetIfType() IfType {
	if x, ok := m.GetIfinfo().(*InterfaceDumpFilter_IfType); ok {
		return x.IfType
	}
	return IfType_IF_TYPE_NONE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceDumpFilter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceDumpFilter_Id)(nil),
		(*InterfaceDumpFilter_IfType)(nil),
	}
}

type DatapathAssist struct {
	NumCores             uint32   `protobuf:"varint,1,opt,name=NumCores,proto3" json:"NumCores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatapathAssist) Reset()         { *m = DatapathAssist{} }
func (m *DatapathAssist) String() string { return proto.CompactTextString(m) }
func (*DatapathAssist) ProtoMessage()    {}
func (*DatapathAssist) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{43}
}
func (m *DatapathAssist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatapathAssist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatapathAssist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatapathAssist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatapathAssist.Merge(m, src)
}
func (m *DatapathAssist) XXX_Size() int {
	return m.Size()
}
func (m *DatapathAssist) XXX_DiscardUnknown() {
	xxx_messageInfo_DatapathAssist.DiscardUnknown(m)
}

var xxx_messageInfo_DatapathAssist proto.InternalMessageInfo

func (m *DatapathAssist) GetNumCores() uint32 {
	if m != nil {
		return m.NumCores
	}
	return 0
}

type CommandMessage struct {
	Command              Command    `protobuf:"varint,1,opt,name=Command,proto3,enum=pds.Command" json:"Command,omitempty"`
	CommandMsg           *types.Any `protobuf:"bytes,2,opt,name=CommandMsg,proto3" json:"CommandMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CommandMessage) Reset()         { *m = CommandMessage{} }
func (m *CommandMessage) String() string { return proto.CompactTextString(m) }
func (*CommandMessage) ProtoMessage()    {}
func (*CommandMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{44}
}
func (m *CommandMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandMessage.Merge(m, src)
}
func (m *CommandMessage) XXX_Size() int {
	return m.Size()
}
func (m *CommandMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CommandMessage proto.InternalMessageInfo

func (m *CommandMessage) GetCommand() Command {
	if m != nil {
		return m.Command
	}
	return Command_CMD_NONE
}

func (m *CommandMessage) GetCommandMsg() *types.Any {
	if m != nil {
		return m.CommandMsg
	}
	return nil
}

type AacsRequest struct {
	AacsServerPort       uint32   `protobuf:"varint,1,opt,name=AacsServerPort,proto3" json:"AacsServerPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AacsRequest) Reset()         { *m = AacsRequest{} }
func (m *AacsRequest) String() string { return proto.CompactTextString(m) }
func (*AacsRequest) ProtoMessage()    {}
func (*AacsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{45}
}
func (m *AacsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AacsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AacsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AacsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AacsRequest.Merge(m, src)
}
func (m *AacsRequest) XXX_Size() int {
	return m.Size()
}
func (m *AacsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AacsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AacsRequest proto.InternalMessageInfo

func (m *AacsRequest) GetAacsServerPort() uint32 {
	if m != nil {
		return m.AacsServerPort
	}
	return 0
}

type SlabSpec struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Id                   uint32   `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	ElementSize          uint32   `protobuf:"varint,3,opt,name=ElementSize,proto3" json:"ElementSize,omitempty"`
	ElementsPerBlock     uint32   `protobuf:"varint,4,opt,name=ElementsPerBlock,proto3" json:"ElementsPerBlock,omitempty"`
	ThreadSafe           bool     `protobuf:"varint,5,opt,name=ThreadSafe,proto3" json:"ThreadSafe,omitempty"`
	GrowOnDemand         bool     `protobuf:"varint,6,opt,name=GrowOnDemand,proto3" json:"GrowOnDemand,omitempty"`
	DelayDelete          bool     `protobuf:"varint,7,opt,name=DelayDelete,proto3" json:"DelayDelete,omitempty"`
	ZeroOnAllocation     bool     `protobuf:"varint,8,opt,name=ZeroOnAllocation,proto3" json:"ZeroOnAllocation,omitempty"`
	RawBlockSize         uint32   `protobuf:"varint,9,opt,name=RawBlockSize,proto3" json:"RawBlockSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SlabSpec) Reset()         { *m = SlabSpec{} }
func (m *SlabSpec) String() string { return proto.CompactTextString(m) }
func (*SlabSpec) ProtoMessage()    {}
func (*SlabSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{46}
}
func (m *SlabSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlabSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlabSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlabSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlabSpec.Merge(m, src)
}
func (m *SlabSpec) XXX_Size() int {
	return m.Size()
}
func (m *SlabSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SlabSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SlabSpec proto.InternalMessageInfo

func (m *SlabSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SlabSpec) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SlabSpec) GetElementSize() uint32 {
	if m != nil {
		return m.ElementSize
	}
	return 0
}

func (m *SlabSpec) GetElementsPerBlock() uint32 {
	if m != nil {
		return m.ElementsPerBlock
	}
	return 0
}

func (m *SlabSpec) GetThreadSafe() bool {
	if m != nil {
		return m.ThreadSafe
	}
	return false
}

func (m *SlabSpec) GetGrowOnDemand() bool {
	if m != nil {
		return m.GrowOnDemand
	}
	return false
}

func (m *SlabSpec) GetDelayDelete() bool {
	if m != nil {
		return m.DelayDelete
	}
	return false
}

func (m *SlabSpec) GetZeroOnAllocation() bool {
	if m != nil {
		return m.ZeroOnAllocation
	}
	return false
}

func (m *SlabSpec) GetRawBlockSize() uint32 {
	if m != nil {
		return m.RawBlockSize
	}
	return 0
}

type SlabStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SlabStatus) Reset()         { *m = SlabStatus{} }
func (m *SlabStatus) String() string { return proto.CompactTextString(m) }
func (*SlabStatus) ProtoMessage()    {}
func (*SlabStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{47}
}
func (m *SlabStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlabStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlabStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlabStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlabStatus.Merge(m, src)
}
func (m *SlabStatus) XXX_Size() int {
	return m.Size()
}
func (m *SlabStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SlabStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SlabStatus proto.InternalMessageInfo

type SlabStats struct {
	NumElementsInUse     uint32   `protobuf:"varint,1,opt,name=NumElementsInUse,proto3" json:"NumElementsInUse,omitempty"`
	NumAllocs            uint32   `protobuf:"varint,2,opt,name=NumAllocs,proto3" json:"NumAllocs,omitempty"`
	NumFrees             uint32   `protobuf:"varint,3,opt,name=NumFrees,proto3" json:"NumFrees,omitempty"`
	NumAllocErrors       uint32   `protobuf:"varint,4,opt,name=NumAllocErrors,proto3" json:"NumAllocErrors,omitempty"`
	NumBlocks            uint32   `protobuf:"varint,5,opt,name=NumBlocks,proto3" json:"NumBlocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SlabStats) Reset()         { *m = SlabStats{} }
func (m *SlabStats) String() string { return proto.CompactTextString(m) }
func (*SlabStats) ProtoMessage()    {}
func (*SlabStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{48}
}
func (m *SlabStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlabStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlabStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlabStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlabStats.Merge(m, src)
}
func (m *SlabStats) XXX_Size() int {
	return m.Size()
}
func (m *SlabStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SlabStats.DiscardUnknown(m)
}

var xxx_messageInfo_SlabStats proto.InternalMessageInfo

func (m *SlabStats) GetNumElementsInUse() uint32 {
	if m != nil {
		return m.NumElementsInUse
	}
	return 0
}

func (m *SlabStats) GetNumAllocs() uint32 {
	if m != nil {
		return m.NumAllocs
	}
	return 0
}

func (m *SlabStats) GetNumFrees() uint32 {
	if m != nil {
		return m.NumFrees
	}
	return 0
}

func (m *SlabStats) GetNumAllocErrors() uint32 {
	if m != nil {
		return m.NumAllocErrors
	}
	return 0
}

func (m *SlabStats) GetNumBlocks() uint32 {
	if m != nil {
		return m.NumBlocks
	}
	return 0
}

type Slab struct {
	Spec                 *SlabSpec   `protobuf:"bytes,1,opt,name=Spec,proto3" json:"Spec,omitempty"`
	Status               *SlabStatus `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
	Stats                *SlabStats  `protobuf:"bytes,3,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Slab) Reset()         { *m = Slab{} }
func (m *Slab) String() string { return proto.CompactTextString(m) }
func (*Slab) ProtoMessage()    {}
func (*Slab) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{49}
}
func (m *Slab) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slab) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slab.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slab) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slab.Merge(m, src)
}
func (m *Slab) XXX_Size() int {
	return m.Size()
}
func (m *Slab) XXX_DiscardUnknown() {
	xxx_messageInfo_Slab.DiscardUnknown(m)
}

var xxx_messageInfo_Slab proto.InternalMessageInfo

func (m *Slab) GetSpec() *SlabSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Slab) GetStatus() *SlabStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Slab) GetStats() *SlabStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type SlabGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Slab                 []*Slab   `protobuf:"bytes,2,rep,name=Slab,proto3" json:"Slab,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SlabGetResponse) Reset()         { *m = SlabGetResponse{} }
func (m *SlabGetResponse) String() string { return proto.CompactTextString(m) }
func (*SlabGetResponse) ProtoMessage()    {}
func (*SlabGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{50}
}
func (m *SlabGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlabGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlabGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlabGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlabGetResponse.Merge(m, src)
}
func (m *SlabGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SlabGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SlabGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SlabGetResponse proto.InternalMessageInfo

func (m *SlabGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SlabGetResponse) GetSlab() []*Slab {
	if m != nil {
		return m.Slab
	}
	return nil
}

// datapath memory usage of various memory segments
type DatapathMemoryGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// uncached lower memory used
	UncachedLowMemUsed uint64 `protobuf:"varint,2,opt,name=UncachedLowMemUsed,proto3" json:"UncachedLowMemUsed,omitempty"`
	// cached lower memory used
	CachedLowMemUsed uint64 `protobuf:"varint,3,opt,name=CachedLowMemUsed,proto3" json:"CachedLowMemUsed,omitempty"`
	// uncached lower high-mem used
	UncachedLowHighMemUsed uint64 `protobuf:"varint,4,opt,name=UncachedLowHighMemUsed,proto3" json:"UncachedLowHighMemUsed,omitempty"`
	// cached lower high-mem used
	CachedLowHighMemUsed uint64 `protobuf:"varint,5,opt,name=CachedLowHighMemUsed,proto3" json:"CachedLowHighMemUsed,omitempty"`
	// uncached higher high-mem used
	UncachedHighHighMemUsed uint64 `protobuf:"varint,6,opt,name=UncachedHighHighMemUsed,proto3" json:"UncachedHighHighMemUsed,omitempty"`
	// cached higher high-mem used
	CachedHighHighMemUsed uint64 `protobuf:"varint,7,opt,name=CachedHighHighMemUsed,proto3" json:"CachedHighHighMemUsed,omitempty"`
	// uncached memory reserved for ISSU
	UncachedISSUMemRsvd uint64 `protobuf:"varint,8,opt,name=UncachedISSUMemRsvd,proto3" json:"UncachedISSUMemRsvd,omitempty"`
	// cached memory reserved for ISSU
	CachedISSUMemRsvd uint64 `protobuf:"varint,9,opt,name=CachedISSUMemRsvd,proto3" json:"CachedISSUMemRsvd,omitempty"`
	// uncached memory needed for ISSU
	UncachedISSUMemNeeded uint64 `protobuf:"varint,10,opt,name=UncachedISSUMemNeeded,proto3" json:"UncachedISSUMemNeeded,omitempty"`
	// cached memory needed for ISSU
	CachedISSUMemNeeded uint64 `protobuf:"varint,11,opt,name=CachedISSUMemNeeded,proto3" json:"CachedISSUMemNeeded,omitempty"`
	// uncached low memory needed for ISSU
	UncachedISSULowMemNeeded uint64 `protobuf:"varint,12,opt,name=UncachedISSULowMemNeeded,proto3" json:"UncachedISSULowMemNeeded,omitempty"`
	// cached low memory needed for ISSU
	CachedISSULowMemNeeded uint64 `protobuf:"varint,13,opt,name=CachedISSULowMemNeeded,proto3" json:"CachedISSULowMemNeeded,omitempty"`
	// uncached hi memory needed for ISSU
	UncachedISSUHiMemNeeded uint64 `protobuf:"varint,14,opt,name=UncachedISSUHiMemNeeded,proto3" json:"UncachedISSUHiMemNeeded,omitempty"`
	// cached hi memory needed for ISSU
	CachedISSUHiMemNeeded uint64 `protobuf:"varint,15,opt,name=CachedISSUHiMemNeeded,proto3" json:"CachedISSUHiMemNeeded,omitempty"`
	// uncached low memory reserved for ISSU
	UncachedISSULowMemRsvd uint64 `protobuf:"varint,16,opt,name=UncachedISSULowMemRsvd,proto3" json:"UncachedISSULowMemRsvd,omitempty"`
	// cached low memory reserved for ISSU
	CachedISSULowMemRsvd uint64 `protobuf:"varint,17,opt,name=CachedISSULowMemRsvd,proto3" json:"CachedISSULowMemRsvd,omitempty"`
	// uncached hi memory reserved for ISSU
	UncachedISSUHiMemRsvd uint64 `protobuf:"varint,18,opt,name=UncachedISSUHiMemRsvd,proto3" json:"UncachedISSUHiMemRsvd,omitempty"`
	// cached hi memory reserved for ISSU
	CachedISSUHiMemRsvd  uint64   `protobuf:"varint,19,opt,name=CachedISSUHiMemRsvd,proto3" json:"CachedISSUHiMemRsvd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatapathMemoryGetResponse) Reset()         { *m = DatapathMemoryGetResponse{} }
func (m *DatapathMemoryGetResponse) String() string { return proto.CompactTextString(m) }
func (*DatapathMemoryGetResponse) ProtoMessage()    {}
func (*DatapathMemoryGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{51}
}
func (m *DatapathMemoryGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatapathMemoryGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatapathMemoryGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatapathMemoryGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatapathMemoryGetResponse.Merge(m, src)
}
func (m *DatapathMemoryGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *DatapathMemoryGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DatapathMemoryGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DatapathMemoryGetResponse proto.InternalMessageInfo

func (m *DatapathMemoryGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DatapathMemoryGetResponse) GetUncachedLowMemUsed() uint64 {
	if m != nil {
		return m.UncachedLowMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedLowMemUsed() uint64 {
	if m != nil {
		return m.CachedLowMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedLowHighMemUsed() uint64 {
	if m != nil {
		return m.UncachedLowHighMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedLowHighMemUsed() uint64 {
	if m != nil {
		return m.CachedLowHighMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedHighHighMemUsed() uint64 {
	if m != nil {
		return m.UncachedHighHighMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedHighHighMemUsed() uint64 {
	if m != nil {
		return m.CachedHighHighMemUsed
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSUMemRsvd() uint64 {
	if m != nil {
		return m.UncachedISSUMemRsvd
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSUMemRsvd() uint64 {
	if m != nil {
		return m.CachedISSUMemRsvd
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSUMemNeeded() uint64 {
	if m != nil {
		return m.UncachedISSUMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSUMemNeeded() uint64 {
	if m != nil {
		return m.CachedISSUMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSULowMemNeeded() uint64 {
	if m != nil {
		return m.UncachedISSULowMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSULowMemNeeded() uint64 {
	if m != nil {
		return m.CachedISSULowMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSUHiMemNeeded() uint64 {
	if m != nil {
		return m.UncachedISSUHiMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSUHiMemNeeded() uint64 {
	if m != nil {
		return m.CachedISSUHiMemNeeded
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSULowMemRsvd() uint64 {
	if m != nil {
		return m.UncachedISSULowMemRsvd
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSULowMemRsvd() uint64 {
	if m != nil {
		return m.CachedISSULowMemRsvd
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetUncachedISSUHiMemRsvd() uint64 {
	if m != nil {
		return m.UncachedISSUHiMemRsvd
	}
	return 0
}

func (m *DatapathMemoryGetResponse) GetCachedISSUHiMemRsvd() uint64 {
	if m != nil {
		return m.CachedISSUHiMemRsvd
	}
	return 0
}

type InternalPortStatus struct {
	PortStatus           IfStatus        `protobuf:"varint,1,opt,name=PortStatus,proto3,enum=pds.IfStatus" json:"PortStatus,omitempty"`
	PortSpeed            PortSpeed       `protobuf:"varint,2,opt,name=PortSpeed,proto3,enum=types.PortSpeed" json:"PortSpeed,omitempty"`
	PortMode             IntPortDplxMode `protobuf:"varint,3,opt,name=PortMode,proto3,enum=pds.IntPortDplxMode" json:"PortMode,omitempty"`
	PortTxPaused         bool            `protobuf:"varint,4,opt,name=PortTxPaused,proto3" json:"PortTxPaused,omitempty"`
	PortFlowCtrl         bool            `protobuf:"varint,5,opt,name=PortFlowCtrl,proto3" json:"PortFlowCtrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *InternalPortStatus) Reset()         { *m = InternalPortStatus{} }
func (m *InternalPortStatus) String() string { return proto.CompactTextString(m) }
func (*InternalPortStatus) ProtoMessage()    {}
func (*InternalPortStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{52}
}
func (m *InternalPortStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortStatus.Merge(m, src)
}
func (m *InternalPortStatus) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortStatus proto.InternalMessageInfo

func (m *InternalPortStatus) GetPortStatus() IfStatus {
	if m != nil {
		return m.PortStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InternalPortStatus) GetPortSpeed() PortSpeed {
	if m != nil {
		return m.PortSpeed
	}
	return PortSpeed_PORT_SPEED_NONE
}

func (m *InternalPortStatus) GetPortMode() IntPortDplxMode {
	if m != nil {
		return m.PortMode
	}
	return IntPortDplxMode_HALF_DUPLEX
}

func (m *InternalPortStatus) GetPortTxPaused() bool {
	if m != nil {
		return m.PortTxPaused
	}
	return false
}

func (m *InternalPortStatus) GetPortFlowCtrl() bool {
	if m != nil {
		return m.PortFlowCtrl
	}
	return false
}

type InternalPortStats struct {
	InGoodOctets         uint64   `protobuf:"varint,1,opt,name=InGoodOctets,proto3" json:"InGoodOctets,omitempty"`
	OutOctets            uint64   `protobuf:"varint,2,opt,name=OutOctets,proto3" json:"OutOctets,omitempty"`
	InBadOctets          uint32   `protobuf:"varint,3,opt,name=InBadOctets,proto3" json:"InBadOctets,omitempty"`
	InUnicast            uint32   `protobuf:"varint,4,opt,name=InUnicast,proto3" json:"InUnicast,omitempty"`
	Inbroadcast          uint32   `protobuf:"varint,5,opt,name=Inbroadcast,proto3" json:"Inbroadcast,omitempty"`
	Inmulticast          uint32   `protobuf:"varint,6,opt,name=Inmulticast,proto3" json:"Inmulticast,omitempty"`
	InPause              uint32   `protobuf:"varint,7,opt,name=InPause,proto3" json:"InPause,omitempty"`
	InUndersize          uint32   `protobuf:"varint,8,opt,name=InUndersize,proto3" json:"InUndersize,omitempty"`
	InFragments          uint32   `protobuf:"varint,9,opt,name=InFragments,proto3" json:"InFragments,omitempty"`
	InOversize           uint32   `protobuf:"varint,10,opt,name=InOversize,proto3" json:"InOversize,omitempty"`
	InJabber             uint32   `protobuf:"varint,11,opt,name=InJabber,proto3" json:"InJabber,omitempty"`
	InRxErr              uint32   `protobuf:"varint,12,opt,name=InRxErr,proto3" json:"InRxErr,omitempty"`
	InFcsErr             uint32   `protobuf:"varint,13,opt,name=InFcsErr,proto3" json:"InFcsErr,omitempty"`
	OutUnicast           uint32   `protobuf:"varint,14,opt,name=OutUnicast,proto3" json:"OutUnicast,omitempty"`
	OutBroadcast         uint32   `protobuf:"varint,15,opt,name=OutBroadcast,proto3" json:"OutBroadcast,omitempty"`
	OutMulticast         uint32   `protobuf:"varint,16,opt,name=OutMulticast,proto3" json:"OutMulticast,omitempty"`
	OutFcsErr            uint32   `protobuf:"varint,17,opt,name=OutFcsErr,proto3" json:"OutFcsErr,omitempty"`
	OutPause             uint32   `protobuf:"varint,18,opt,name=OutPause,proto3" json:"OutPause,omitempty"`
	OutCollisions        uint32   `protobuf:"varint,19,opt,name=OutCollisions,proto3" json:"OutCollisions,omitempty"`
	OutDeferred          uint32   `protobuf:"varint,20,opt,name=OutDeferred,proto3" json:"OutDeferred,omitempty"`
	OutSingle            uint32   `protobuf:"varint,21,opt,name=OutSingle,proto3" json:"OutSingle,omitempty"`
	OutMultiple          uint32   `protobuf:"varint,22,opt,name=OutMultiple,proto3" json:"OutMultiple,omitempty"`
	OutExcessive         uint32   `protobuf:"varint,23,opt,name=OutExcessive,proto3" json:"OutExcessive,omitempty"`
	OutLate              uint32   `protobuf:"varint,24,opt,name=OutLate,proto3" json:"OutLate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InternalPortStats) Reset()         { *m = InternalPortStats{} }
func (m *InternalPortStats) String() string { return proto.CompactTextString(m) }
func (*InternalPortStats) ProtoMessage()    {}
func (*InternalPortStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{53}
}
func (m *InternalPortStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortStats.Merge(m, src)
}
func (m *InternalPortStats) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortStats) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortStats.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortStats proto.InternalMessageInfo

func (m *InternalPortStats) GetInGoodOctets() uint64 {
	if m != nil {
		return m.InGoodOctets
	}
	return 0
}

func (m *InternalPortStats) GetOutOctets() uint64 {
	if m != nil {
		return m.OutOctets
	}
	return 0
}

func (m *InternalPortStats) GetInBadOctets() uint32 {
	if m != nil {
		return m.InBadOctets
	}
	return 0
}

func (m *InternalPortStats) GetInUnicast() uint32 {
	if m != nil {
		return m.InUnicast
	}
	return 0
}

func (m *InternalPortStats) GetInbroadcast() uint32 {
	if m != nil {
		return m.Inbroadcast
	}
	return 0
}

func (m *InternalPortStats) GetInmulticast() uint32 {
	if m != nil {
		return m.Inmulticast
	}
	return 0
}

func (m *InternalPortStats) GetInPause() uint32 {
	if m != nil {
		return m.InPause
	}
	return 0
}

func (m *InternalPortStats) GetInUndersize() uint32 {
	if m != nil {
		return m.InUndersize
	}
	return 0
}

func (m *InternalPortStats) GetInFragments() uint32 {
	if m != nil {
		return m.InFragments
	}
	return 0
}

func (m *InternalPortStats) GetInOversize() uint32 {
	if m != nil {
		return m.InOversize
	}
	return 0
}

func (m *InternalPortStats) GetInJabber() uint32 {
	if m != nil {
		return m.InJabber
	}
	return 0
}

func (m *InternalPortStats) GetInRxErr() uint32 {
	if m != nil {
		return m.InRxErr
	}
	return 0
}

func (m *InternalPortStats) GetInFcsErr() uint32 {
	if m != nil {
		return m.InFcsErr
	}
	return 0
}

func (m *InternalPortStats) GetOutUnicast() uint32 {
	if m != nil {
		return m.OutUnicast
	}
	return 0
}

func (m *InternalPortStats) GetOutBroadcast() uint32 {
	if m != nil {
		return m.OutBroadcast
	}
	return 0
}

func (m *InternalPortStats) GetOutMulticast() uint32 {
	if m != nil {
		return m.OutMulticast
	}
	return 0
}

func (m *InternalPortStats) GetOutFcsErr() uint32 {
	if m != nil {
		return m.OutFcsErr
	}
	return 0
}

func (m *InternalPortStats) GetOutPause() uint32 {
	if m != nil {
		return m.OutPause
	}
	return 0
}

func (m *InternalPortStats) GetOutCollisions() uint32 {
	if m != nil {
		return m.OutCollisions
	}
	return 0
}

func (m *InternalPortStats) GetOutDeferred() uint32 {
	if m != nil {
		return m.OutDeferred
	}
	return 0
}

func (m *InternalPortStats) GetOutSingle() uint32 {
	if m != nil {
		return m.OutSingle
	}
	return 0
}

func (m *InternalPortStats) GetOutMultiple() uint32 {
	if m != nil {
		return m.OutMultiple
	}
	return 0
}

func (m *InternalPortStats) GetOutExcessive() uint32 {
	if m != nil {
		return m.OutExcessive
	}
	return 0
}

func (m *InternalPortStats) GetOutLate() uint32 {
	if m != nil {
		return m.OutLate
	}
	return 0
}

type InternalPortResponse struct {
	PortNumber           uint32              `protobuf:"varint,1,opt,name=PortNumber,proto3" json:"PortNumber,omitempty"`
	PortDescr            string              `protobuf:"bytes,2,opt,name=PortDescr,proto3" json:"PortDescr,omitempty"`
	InternalStatus       *InternalPortStatus `protobuf:"bytes,3,opt,name=InternalStatus,proto3" json:"InternalStatus,omitempty"`
	Stats                *InternalPortStats  `protobuf:"bytes,4,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *InternalPortResponse) Reset()         { *m = InternalPortResponse{} }
func (m *InternalPortResponse) String() string { return proto.CompactTextString(m) }
func (*InternalPortResponse) ProtoMessage()    {}
func (*InternalPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{54}
}
func (m *InternalPortResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortResponse.Merge(m, src)
}
func (m *InternalPortResponse) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortResponse proto.InternalMessageInfo

func (m *InternalPortResponse) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *InternalPortResponse) GetPortDescr() string {
	if m != nil {
		return m.PortDescr
	}
	return ""
}

func (m *InternalPortResponse) GetInternalStatus() *InternalPortStatus {
	if m != nil {
		return m.InternalStatus
	}
	return nil
}

func (m *InternalPortResponse) GetStats() *InternalPortStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type InternalPortResponseMsg struct {
	Response             []*InternalPortResponse `protobuf:"bytes,1,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *InternalPortResponseMsg) Reset()         { *m = InternalPortResponseMsg{} }
func (m *InternalPortResponseMsg) String() string { return proto.CompactTextString(m) }
func (*InternalPortResponseMsg) ProtoMessage()    {}
func (*InternalPortResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{55}
}
func (m *InternalPortResponseMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortResponseMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortResponseMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortResponseMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortResponseMsg.Merge(m, src)
}
func (m *InternalPortResponseMsg) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortResponseMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortResponseMsg.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortResponseMsg proto.InternalMessageInfo

func (m *InternalPortResponseMsg) GetResponse() []*InternalPortResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type InternalPortRequest struct {
	PortNumber           uint32   `protobuf:"varint,1,opt,name=PortNumber,proto3" json:"PortNumber,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InternalPortRequest) Reset()         { *m = InternalPortRequest{} }
func (m *InternalPortRequest) String() string { return proto.CompactTextString(m) }
func (*InternalPortRequest) ProtoMessage()    {}
func (*InternalPortRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{56}
}
func (m *InternalPortRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortRequest.Merge(m, src)
}
func (m *InternalPortRequest) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortRequest proto.InternalMessageInfo

func (m *InternalPortRequest) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

type InternalPortRequestMsg struct {
	Request              []*InternalPortRequest `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *InternalPortRequestMsg) Reset()         { *m = InternalPortRequestMsg{} }
func (m *InternalPortRequestMsg) String() string { return proto.CompactTextString(m) }
func (*InternalPortRequestMsg) ProtoMessage()    {}
func (*InternalPortRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{57}
}
func (m *InternalPortRequestMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalPortRequestMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InternalPortRequestMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InternalPortRequestMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalPortRequestMsg.Merge(m, src)
}
func (m *InternalPortRequestMsg) XXX_Size() int {
	return m.Size()
}
func (m *InternalPortRequestMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalPortRequestMsg.DiscardUnknown(m)
}

var xxx_messageInfo_InternalPortRequestMsg proto.InternalMessageInfo

func (m *InternalPortRequestMsg) GetRequest() []*InternalPortRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type EepromAddress struct {
	PortId               []byte   `protobuf:"bytes,1,opt,name=PortId,proto3" json:"PortId,omitempty"`
	Page                 uint32   `protobuf:"varint,2,opt,name=Page,proto3" json:"Page,omitempty"`
	Offset               uint32   `protobuf:"varint,3,opt,name=Offset,proto3" json:"Offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EepromAddress) Reset()         { *m = EepromAddress{} }
func (m *EepromAddress) String() string { return proto.CompactTextString(m) }
func (*EepromAddress) ProtoMessage()    {}
func (*EepromAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{58}
}
func (m *EepromAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromAddress.Merge(m, src)
}
func (m *EepromAddress) XXX_Size() int {
	return m.Size()
}
func (m *EepromAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromAddress.DiscardUnknown(m)
}

var xxx_messageInfo_EepromAddress proto.InternalMessageInfo

func (m *EepromAddress) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *EepromAddress) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *EepromAddress) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type EepromPage struct {
	PageNumber           uint32   `protobuf:"varint,1,opt,name=PageNumber,proto3" json:"PageNumber,omitempty"`
	PageContent          []byte   `protobuf:"bytes,2,opt,name=PageContent,proto3" json:"PageContent,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EepromPage) Reset()         { *m = EepromPage{} }
func (m *EepromPage) String() string { return proto.CompactTextString(m) }
func (*EepromPage) ProtoMessage()    {}
func (*EepromPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{59}
}
func (m *EepromPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromPage.Merge(m, src)
}
func (m *EepromPage) XXX_Size() int {
	return m.Size()
}
func (m *EepromPage) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromPage.DiscardUnknown(m)
}

var xxx_messageInfo_EepromPage proto.InternalMessageInfo

func (m *EepromPage) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

func (m *EepromPage) GetPageContent() []byte {
	if m != nil {
		return m.PageContent
	}
	return nil
}

type EepromReadResponse struct {
	IfIndex              uint32        `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	Page                 []*EepromPage `protobuf:"bytes,2,rep,name=Page,proto3" json:"Page,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EepromReadResponse) Reset()         { *m = EepromReadResponse{} }
func (m *EepromReadResponse) String() string { return proto.CompactTextString(m) }
func (*EepromReadResponse) ProtoMessage()    {}
func (*EepromReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{60}
}
func (m *EepromReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromReadResponse.Merge(m, src)
}
func (m *EepromReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *EepromReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EepromReadResponse proto.InternalMessageInfo

func (m *EepromReadResponse) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *EepromReadResponse) GetPage() []*EepromPage {
	if m != nil {
		return m.Page
	}
	return nil
}

type EepromReadResponseMsg struct {
	ApiStatus            ApiStatus             `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*EepromReadResponse `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EepromReadResponseMsg) Reset()         { *m = EepromReadResponseMsg{} }
func (m *EepromReadResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EepromReadResponseMsg) ProtoMessage()    {}
func (*EepromReadResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{61}
}
func (m *EepromReadResponseMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromReadResponseMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromReadResponseMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromReadResponseMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromReadResponseMsg.Merge(m, src)
}
func (m *EepromReadResponseMsg) XXX_Size() int {
	return m.Size()
}
func (m *EepromReadResponseMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromReadResponseMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EepromReadResponseMsg proto.InternalMessageInfo

func (m *EepromReadResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EepromReadResponseMsg) GetResponse() []*EepromReadResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type EepromReadRequest struct {
	Address              *EepromAddress `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EepromReadRequest) Reset()         { *m = EepromReadRequest{} }
func (m *EepromReadRequest) String() string { return proto.CompactTextString(m) }
func (*EepromReadRequest) ProtoMessage()    {}
func (*EepromReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{62}
}
func (m *EepromReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromReadRequest.Merge(m, src)
}
func (m *EepromReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *EepromReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EepromReadRequest proto.InternalMessageInfo

func (m *EepromReadRequest) GetAddress() *EepromAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

type EepromReadRequestMsg struct {
	PortId               [][]byte `protobuf:"bytes,1,rep,name=PortId,proto3" json:"PortId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EepromReadRequestMsg) Reset()         { *m = EepromReadRequestMsg{} }
func (m *EepromReadRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EepromReadRequestMsg) ProtoMessage()    {}
func (*EepromReadRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{63}
}
func (m *EepromReadRequestMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromReadRequestMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromReadRequestMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromReadRequestMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromReadRequestMsg.Merge(m, src)
}
func (m *EepromReadRequestMsg) XXX_Size() int {
	return m.Size()
}
func (m *EepromReadRequestMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromReadRequestMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EepromReadRequestMsg proto.InternalMessageInfo

func (m *EepromReadRequestMsg) GetPortId() [][]byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

type EepromWriteResponseMsg struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EepromWriteResponseMsg) Reset()         { *m = EepromWriteResponseMsg{} }
func (m *EepromWriteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EepromWriteResponseMsg) ProtoMessage()    {}
func (*EepromWriteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{64}
}
func (m *EepromWriteResponseMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromWriteResponseMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromWriteResponseMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromWriteResponseMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromWriteResponseMsg.Merge(m, src)
}
func (m *EepromWriteResponseMsg) XXX_Size() int {
	return m.Size()
}
func (m *EepromWriteResponseMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromWriteResponseMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EepromWriteResponseMsg proto.InternalMessageInfo

func (m *EepromWriteResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type EepromWriteRequest struct {
	Address              *EepromAddress `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Value                uint32         `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EepromWriteRequest) Reset()         { *m = EepromWriteRequest{} }
func (m *EepromWriteRequest) String() string { return proto.CompactTextString(m) }
func (*EepromWriteRequest) ProtoMessage()    {}
func (*EepromWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{65}
}
func (m *EepromWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromWriteRequest.Merge(m, src)
}
func (m *EepromWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *EepromWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EepromWriteRequest proto.InternalMessageInfo

func (m *EepromWriteRequest) GetAddress() *EepromAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *EepromWriteRequest) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type EepromWriteRequestMsg struct {
	Request              []*EepromWriteRequest `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EepromWriteRequestMsg) Reset()         { *m = EepromWriteRequestMsg{} }
func (m *EepromWriteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EepromWriteRequestMsg) ProtoMessage()    {}
func (*EepromWriteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{66}
}
func (m *EepromWriteRequestMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EepromWriteRequestMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EepromWriteRequestMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EepromWriteRequestMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EepromWriteRequestMsg.Merge(m, src)
}
func (m *EepromWriteRequestMsg) XXX_Size() int {
	return m.Size()
}
func (m *EepromWriteRequestMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EepromWriteRequestMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EepromWriteRequestMsg proto.InternalMessageInfo

func (m *EepromWriteRequestMsg) GetRequest() []*EepromWriteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type LearnDedupIntervalRequest struct {
	DedupInterval        uint32   `protobuf:"varint,1,opt,name=DedupInterval,proto3" json:"DedupInterval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LearnDedupIntervalRequest) Reset()         { *m = LearnDedupIntervalRequest{} }
func (m *LearnDedupIntervalRequest) String() string { return proto.CompactTextString(m) }
func (*LearnDedupIntervalRequest) ProtoMessage()    {}
func (*LearnDedupIntervalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{67}
}
func (m *LearnDedupIntervalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnDedupIntervalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnDedupIntervalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnDedupIntervalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnDedupIntervalRequest.Merge(m, src)
}
func (m *LearnDedupIntervalRequest) XXX_Size() int {
	return m.Size()
}
func (m *LearnDedupIntervalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnDedupIntervalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LearnDedupIntervalRequest proto.InternalMessageInfo

func (m *LearnDedupIntervalRequest) GetDedupInterval() uint32 {
	if m != nil {
		return m.DedupInterval
	}
	return 0
}

type TcpProxySessionFilter struct {
	SrcIp                *IPAddress `protobuf:"bytes,1,opt,name=SrcIp,proto3" json:"SrcIp,omitempty"`
	DstIp                *IPAddress `protobuf:"bytes,2,opt,name=DstIp,proto3" json:"DstIp,omitempty"`
	SrcPort              uint32     `protobuf:"varint,3,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort              uint32     `protobuf:"varint,4,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	MatchAll             bool       `protobuf:"varint,5,opt,name=MatchAll,proto3" json:"MatchAll,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TcpProxySessionFilter) Reset()         { *m = TcpProxySessionFilter{} }
func (m *TcpProxySessionFilter) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionFilter) ProtoMessage()    {}
func (*TcpProxySessionFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{68}
}
func (m *TcpProxySessionFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxySessionFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxySessionFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxySessionFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxySessionFilter.Merge(m, src)
}
func (m *TcpProxySessionFilter) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxySessionFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxySessionFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxySessionFilter proto.InternalMessageInfo

func (m *TcpProxySessionFilter) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *TcpProxySessionFilter) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *TcpProxySessionFilter) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TcpProxySessionFilter) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TcpProxySessionFilter) GetMatchAll() bool {
	if m != nil {
		return m.MatchAll
	}
	return false
}

type TcpProxySessionReq struct {
	SessionFilter        *TcpProxySessionFilter `protobuf:"bytes,1,opt,name=SessionFilter,proto3" json:"SessionFilter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TcpProxySessionReq) Reset()         { *m = TcpProxySessionReq{} }
func (m *TcpProxySessionReq) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionReq) ProtoMessage()    {}
func (*TcpProxySessionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{69}
}
func (m *TcpProxySessionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxySessionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxySessionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxySessionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxySessionReq.Merge(m, src)
}
func (m *TcpProxySessionReq) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxySessionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxySessionReq.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxySessionReq proto.InternalMessageInfo

func (m *TcpProxySessionReq) GetSessionFilter() *TcpProxySessionFilter {
	if m != nil {
		return m.SessionFilter
	}
	return nil
}

type TcpProxyFlow struct {
	Qid1                 uint64     `protobuf:"varint,1,opt,name=Qid1,proto3" json:"Qid1,omitempty"`
	Qid2                 uint64     `protobuf:"varint,2,opt,name=Qid2,proto3" json:"Qid2,omitempty"`
	SrcIp                *IPAddress `protobuf:"bytes,3,opt,name=SrcIp,proto3" json:"SrcIp,omitempty"`
	DstIp                *IPAddress `protobuf:"bytes,4,opt,name=DstIp,proto3" json:"DstIp,omitempty"`
	SrcPort              uint32     `protobuf:"varint,5,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort              uint32     `protobuf:"varint,6,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TcpProxyFlow) Reset()         { *m = TcpProxyFlow{} }
func (m *TcpProxyFlow) String() string { return proto.CompactTextString(m) }
func (*TcpProxyFlow) ProtoMessage()    {}
func (*TcpProxyFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{70}
}
func (m *TcpProxyFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyFlow.Merge(m, src)
}
func (m *TcpProxyFlow) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyFlow.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyFlow proto.InternalMessageInfo

func (m *TcpProxyFlow) GetQid1() uint64 {
	if m != nil {
		return m.Qid1
	}
	return 0
}

func (m *TcpProxyFlow) GetQid2() uint64 {
	if m != nil {
		return m.Qid2
	}
	return 0
}

func (m *TcpProxyFlow) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *TcpProxyFlow) GetDstIp() *IPAddress {
	if m != nil {
		return m.DstIp
	}
	return nil
}

func (m *TcpProxyFlow) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TcpProxyFlow) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// TcpProxySessionGetRequest is batched get request
type TcpProxySessionGetRequest struct {
	Request              []*TcpProxySessionReq `protobuf:"bytes,1,rep,name=request,proto3" json:"request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TcpProxySessionGetRequest) Reset()         { *m = TcpProxySessionGetRequest{} }
func (m *TcpProxySessionGetRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetRequest) ProtoMessage()    {}
func (*TcpProxySessionGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{71}
}
func (m *TcpProxySessionGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxySessionGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxySessionGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxySessionGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxySessionGetRequest.Merge(m, src)
}
func (m *TcpProxySessionGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxySessionGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxySessionGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxySessionGetRequest proto.InternalMessageInfo

func (m *TcpProxySessionGetRequest) GetRequest() []*TcpProxySessionReq {
	if m != nil {
		return m.Request
	}
	return nil
}

type TcpProxySession struct {
	ApiStatus            ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Flow                 *TcpProxyFlow `protobuf:"bytes,2,opt,name=Flow,proto3" json:"Flow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TcpProxySession) Reset()         { *m = TcpProxySession{} }
func (m *TcpProxySession) String() string { return proto.CompactTextString(m) }
func (*TcpProxySession) ProtoMessage()    {}
func (*TcpProxySession) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{72}
}
func (m *TcpProxySession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxySession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxySession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxySession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxySession.Merge(m, src)
}
func (m *TcpProxySession) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxySession) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxySession.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxySession proto.InternalMessageInfo

func (m *TcpProxySession) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxySession) GetFlow() *TcpProxyFlow {
	if m != nil {
		return m.Flow
	}
	return nil
}

type TcpProxySessionGetResponse struct {
	ApiStatus            ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TcpProxySession `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TcpProxySessionGetResponse) Reset()         { *m = TcpProxySessionGetResponse{} }
func (m *TcpProxySessionGetResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxySessionGetResponse) ProtoMessage()    {}
func (*TcpProxySessionGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{73}
}
func (m *TcpProxySessionGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxySessionGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxySessionGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxySessionGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxySessionGetResponse.Merge(m, src)
}
func (m *TcpProxySessionGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxySessionGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxySessionGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxySessionGetResponse proto.InternalMessageInfo

func (m *TcpProxySessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxySessionGetResponse) GetResponse() []*TcpProxySession {
	if m != nil {
		return m.Response
	}
	return nil
}

// Only if ApiStatus indicates success, other fields are valid
type TcpProxyGlobalStatsGetResponse struct {
	ApiStatus            ApiStatus            `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	GlobalStats          *TcpProxyGlobalStats `protobuf:"bytes,2,opt,name=GlobalStats,proto3" json:"GlobalStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TcpProxyGlobalStatsGetResponse) Reset()         { *m = TcpProxyGlobalStatsGetResponse{} }
func (m *TcpProxyGlobalStatsGetResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStatsGetResponse) ProtoMessage()    {}
func (*TcpProxyGlobalStatsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{74}
}
func (m *TcpProxyGlobalStatsGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyGlobalStatsGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyGlobalStatsGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyGlobalStatsGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyGlobalStatsGetResponse.Merge(m, src)
}
func (m *TcpProxyGlobalStatsGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyGlobalStatsGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyGlobalStatsGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyGlobalStatsGetResponse proto.InternalMessageInfo

func (m *TcpProxyGlobalStatsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpProxyGlobalStatsGetResponse) GetGlobalStats() *TcpProxyGlobalStats {
	if m != nil {
		return m.GlobalStats
	}
	return nil
}

type TcpProxyGlobalStats struct {
	RxDescFull           uint64   `protobuf:"varint,1,opt,name=RxDescFull,proto3" json:"RxDescFull,omitempty"`
	InvalidTxDesc        uint64   `protobuf:"varint,2,opt,name=InvalidTxDesc,proto3" json:"InvalidTxDesc,omitempty"`
	InvalidRetxDesc      uint64   `protobuf:"varint,3,opt,name=InvalidRetxDesc,proto3" json:"InvalidRetxDesc,omitempty"`
	PartialPktAck        uint64   `protobuf:"varint,4,opt,name=PartialPktAck,proto3" json:"PartialPktAck,omitempty"`
	RetxNopSchedule      uint64   `protobuf:"varint,5,opt,name=RetxNopSchedule,proto3" json:"RetxNopSchedule,omitempty"`
	GcFull               uint64   `protobuf:"varint,6,opt,name=GcFull,proto3" json:"GcFull,omitempty"`
	TlsGcFull            uint64   `protobuf:"varint,7,opt,name=TlsGcFull,proto3" json:"TlsGcFull,omitempty"`
	OoqFull              uint64   `protobuf:"varint,8,opt,name=OoqFull,proto3" json:"OoqFull,omitempty"`
	InvalidRxDesc        uint64   `protobuf:"varint,9,opt,name=InvalidRxDesc,proto3" json:"InvalidRxDesc,omitempty"`
	RcvdCePkts           uint64   `protobuf:"varint,10,opt,name=RcvdCePkts,proto3" json:"RcvdCePkts,omitempty"`
	EcnReducedCongestion uint64   `protobuf:"varint,11,opt,name=EcnReducedCongestion,proto3" json:"EcnReducedCongestion,omitempty"`
	RetxPkts             uint64   `protobuf:"varint,12,opt,name=RetxPkts,proto3" json:"RetxPkts,omitempty"`
	OoqRx2TxFull         uint64   `protobuf:"varint,13,opt,name=OoqRx2txFull,proto3" json:"OoqRx2txFull,omitempty"`
	RxAckForUnsentData   uint64   `protobuf:"varint,14,opt,name=RxAckForUnsentData,proto3" json:"RxAckForUnsentData,omitempty"`
	FinSentCnt           uint64   `protobuf:"varint,15,opt,name=FinSentCnt,proto3" json:"FinSentCnt,omitempty"`
	RstSentCnt           uint64   `protobuf:"varint,16,opt,name=RstSentCnt,proto3" json:"RstSentCnt,omitempty"`
	RxWinProbe           uint64   `protobuf:"varint,17,opt,name=RxWinProbe,proto3" json:"RxWinProbe,omitempty"`
	RxKeepAlive          uint64   `protobuf:"varint,18,opt,name=RxKeepAlive,proto3" json:"RxKeepAlive,omitempty"`
	RxPktAfterWin        uint64   `protobuf:"varint,19,opt,name=RxPktAfterWin,proto3" json:"RxPktAfterWin,omitempty"`
	RxPureWinUpd         uint64   `protobuf:"varint,20,opt,name=RxPureWinUpd,proto3" json:"RxPureWinUpd,omitempty"`
	RxDescAvail          uint64   `protobuf:"varint,21,opt,name=RxDescAvail,proto3" json:"RxDescAvail,omitempty"`
	TxDescAvail          uint64   `protobuf:"varint,22,opt,name=TxDescAvail,proto3" json:"TxDescAvail,omitempty"`
	OoqAvail             uint64   `protobuf:"varint,23,opt,name=OoqAvail,proto3" json:"OoqAvail,omitempty"`
	TcpDebug1            uint64   `protobuf:"varint,1002,opt,name=TcpDebug1,proto3" json:"TcpDebug1,omitempty"`
	TcpDebug2            uint64   `protobuf:"varint,1003,opt,name=TcpDebug2,proto3" json:"TcpDebug2,omitempty"`
	TcpDebug3            uint64   `protobuf:"varint,1004,opt,name=TcpDebug3,proto3" json:"TcpDebug3,omitempty"`
	TcpDebug4            uint64   `protobuf:"varint,1005,opt,name=TcpDebug4,proto3" json:"TcpDebug4,omitempty"`
	TcpDebug5            uint64   `protobuf:"varint,1006,opt,name=TcpDebug5,proto3" json:"TcpDebug5,omitempty"`
	TcpDebug6            uint64   `protobuf:"varint,1007,opt,name=TcpDebug6,proto3" json:"TcpDebug6,omitempty"`
	TcpDebug7            uint64   `protobuf:"varint,1008,opt,name=TcpDebug7,proto3" json:"TcpDebug7,omitempty"`
	TcpDebug8            uint64   `protobuf:"varint,1009,opt,name=TcpDebug8,proto3" json:"TcpDebug8,omitempty"`
	TcpDebug9            uint64   `protobuf:"varint,1010,opt,name=TcpDebug9,proto3" json:"TcpDebug9,omitempty"`
	TcpDebug10           uint64   `protobuf:"varint,1011,opt,name=TcpDebug10,proto3" json:"TcpDebug10,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpProxyGlobalStats) Reset()         { *m = TcpProxyGlobalStats{} }
func (m *TcpProxyGlobalStats) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalStats) ProtoMessage()    {}
func (*TcpProxyGlobalStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{75}
}
func (m *TcpProxyGlobalStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyGlobalStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyGlobalStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyGlobalStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyGlobalStats.Merge(m, src)
}
func (m *TcpProxyGlobalStats) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyGlobalStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyGlobalStats.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyGlobalStats proto.InternalMessageInfo

func (m *TcpProxyGlobalStats) GetRxDescFull() uint64 {
	if m != nil {
		return m.RxDescFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetInvalidTxDesc() uint64 {
	if m != nil {
		return m.InvalidTxDesc
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetInvalidRetxDesc() uint64 {
	if m != nil {
		return m.InvalidRetxDesc
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetPartialPktAck() uint64 {
	if m != nil {
		return m.PartialPktAck
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRetxNopSchedule() uint64 {
	if m != nil {
		return m.RetxNopSchedule
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetGcFull() uint64 {
	if m != nil {
		return m.GcFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTlsGcFull() uint64 {
	if m != nil {
		return m.TlsGcFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetOoqFull() uint64 {
	if m != nil {
		return m.OoqFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetInvalidRxDesc() uint64 {
	if m != nil {
		return m.InvalidRxDesc
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRcvdCePkts() uint64 {
	if m != nil {
		return m.RcvdCePkts
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetEcnReducedCongestion() uint64 {
	if m != nil {
		return m.EcnReducedCongestion
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRetxPkts() uint64 {
	if m != nil {
		return m.RetxPkts
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetOoqRx2TxFull() uint64 {
	if m != nil {
		return m.OoqRx2TxFull
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxAckForUnsentData() uint64 {
	if m != nil {
		return m.RxAckForUnsentData
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetFinSentCnt() uint64 {
	if m != nil {
		return m.FinSentCnt
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRstSentCnt() uint64 {
	if m != nil {
		return m.RstSentCnt
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxWinProbe() uint64 {
	if m != nil {
		return m.RxWinProbe
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxKeepAlive() uint64 {
	if m != nil {
		return m.RxKeepAlive
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxPktAfterWin() uint64 {
	if m != nil {
		return m.RxPktAfterWin
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxPureWinUpd() uint64 {
	if m != nil {
		return m.RxPureWinUpd
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetRxDescAvail() uint64 {
	if m != nil {
		return m.RxDescAvail
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTxDescAvail() uint64 {
	if m != nil {
		return m.TxDescAvail
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetOoqAvail() uint64 {
	if m != nil {
		return m.OoqAvail
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug1() uint64 {
	if m != nil {
		return m.TcpDebug1
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug2() uint64 {
	if m != nil {
		return m.TcpDebug2
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug3() uint64 {
	if m != nil {
		return m.TcpDebug3
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug4() uint64 {
	if m != nil {
		return m.TcpDebug4
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug5() uint64 {
	if m != nil {
		return m.TcpDebug5
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug6() uint64 {
	if m != nil {
		return m.TcpDebug6
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug7() uint64 {
	if m != nil {
		return m.TcpDebug7
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug8() uint64 {
	if m != nil {
		return m.TcpDebug8
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug9() uint64 {
	if m != nil {
		return m.TcpDebug9
	}
	return 0
}

func (m *TcpProxyGlobalStats) GetTcpDebug10() uint64 {
	if m != nil {
		return m.TcpDebug10
	}
	return 0
}

// TcpProxyGlobalCfg captures global TCP configuration
type TcpProxyGlobalCfg struct {
	Mss                  uint32   `protobuf:"varint,1,opt,name=Mss,proto3" json:"Mss,omitempty"`
	CwndInitial          uint32   `protobuf:"varint,2,opt,name=CwndInitial,proto3" json:"CwndInitial,omitempty"`
	CwndIdle             uint32   `protobuf:"varint,3,opt,name=CwndIdle,proto3" json:"CwndIdle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpProxyGlobalCfg) Reset()         { *m = TcpProxyGlobalCfg{} }
func (m *TcpProxyGlobalCfg) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalCfg) ProtoMessage()    {}
func (*TcpProxyGlobalCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{76}
}
func (m *TcpProxyGlobalCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyGlobalCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyGlobalCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyGlobalCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyGlobalCfg.Merge(m, src)
}
func (m *TcpProxyGlobalCfg) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyGlobalCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyGlobalCfg.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyGlobalCfg proto.InternalMessageInfo

func (m *TcpProxyGlobalCfg) GetMss() uint32 {
	if m != nil {
		return m.Mss
	}
	return 0
}

func (m *TcpProxyGlobalCfg) GetCwndInitial() uint32 {
	if m != nil {
		return m.CwndInitial
	}
	return 0
}

func (m *TcpProxyGlobalCfg) GetCwndIdle() uint32 {
	if m != nil {
		return m.CwndIdle
	}
	return 0
}

// TcpProxyGlobalCfgRequest is batched GET requests for tcp global cfg
type TcpProxyGlobalCfgRequest struct {
	Request              []*TcpProxyGlobalCfg `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TcpProxyGlobalCfgRequest) Reset()         { *m = TcpProxyGlobalCfgRequest{} }
func (m *TcpProxyGlobalCfgRequest) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalCfgRequest) ProtoMessage()    {}
func (*TcpProxyGlobalCfgRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{77}
}
func (m *TcpProxyGlobalCfgRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyGlobalCfgRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyGlobalCfgRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyGlobalCfgRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyGlobalCfgRequest.Merge(m, src)
}
func (m *TcpProxyGlobalCfgRequest) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyGlobalCfgRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyGlobalCfgRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyGlobalCfgRequest proto.InternalMessageInfo

func (m *TcpProxyGlobalCfgRequest) GetRequest() []*TcpProxyGlobalCfg {
	if m != nil {
		return m.Request
	}
	return nil
}

// Only if ApiStatus indicates success, other fields are valid
type TcpProxyGlobalCfgResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TcpProxyGlobalCfgResponse) Reset()         { *m = TcpProxyGlobalCfgResponse{} }
func (m *TcpProxyGlobalCfgResponse) String() string { return proto.CompactTextString(m) }
func (*TcpProxyGlobalCfgResponse) ProtoMessage()    {}
func (*TcpProxyGlobalCfgResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{78}
}
func (m *TcpProxyGlobalCfgResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpProxyGlobalCfgResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpProxyGlobalCfgResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpProxyGlobalCfgResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpProxyGlobalCfgResponse.Merge(m, src)
}
func (m *TcpProxyGlobalCfgResponse) XXX_Size() int {
	return m.Size()
}
func (m *TcpProxyGlobalCfgResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpProxyGlobalCfgResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TcpProxyGlobalCfgResponse proto.InternalMessageInfo

func (m *TcpProxyGlobalCfgResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// TcpCbSpec captures all the tcp cb level configuration
type TcpCbSpec struct {
	TcpCbId              uint32   `protobuf:"varint,1,opt,name=TcpCbId,proto3" json:"TcpCbId,omitempty"`
	RcvNxt               uint32   `protobuf:"varint,2,opt,name=RcvNxt,proto3" json:"RcvNxt,omitempty"`
	SndNxt               uint32   `protobuf:"varint,3,opt,name=SndNxt,proto3" json:"SndNxt,omitempty"`
	SndUna               uint32   `protobuf:"varint,4,opt,name=SndUna,proto3" json:"SndUna,omitempty"`
	RcvTsval             uint32   `protobuf:"varint,5,opt,name=RcvTsval,proto3" json:"RcvTsval,omitempty"`
	TsRecent             uint32   `protobuf:"varint,6,opt,name=TsRecent,proto3" json:"TsRecent,omitempty"`
	SerqBase             uint64   `protobuf:"fixed64,7,opt,name=SerqBase,proto3" json:"SerqBase,omitempty"`
	DebugDol             uint32   `protobuf:"varint,8,opt,name=DebugDol,proto3" json:"DebugDol,omitempty"`
	SesqBase             uint64   `protobuf:"fixed64,9,opt,name=SesqBase,proto3" json:"SesqBase,omitempty"`
	SesqPi               uint32   `protobuf:"varint,10,opt,name=SesqPi,proto3" json:"SesqPi,omitempty"`
	SesqCi               uint32   `protobuf:"varint,11,opt,name=SesqCi,proto3" json:"SesqCi,omitempty"`
	SndWnd               uint32   `protobuf:"varint,12,opt,name=SndWnd,proto3" json:"SndWnd,omitempty"`
	SndCwnd              uint32   `protobuf:"varint,13,opt,name=SndCwnd,proto3" json:"SndCwnd,omitempty"`
	RcvMss               uint32   `protobuf:"varint,14,opt,name=RcvMss,proto3" json:"RcvMss,omitempty"`
	SourcePort           uint32   `protobuf:"varint,15,opt,name=SourcePort,proto3" json:"SourcePort,omitempty"`
	DestPort             uint32   `protobuf:"varint,16,opt,name=DestPort,proto3" json:"DestPort,omitempty"`
	HeaderTemplate       []byte   `protobuf:"bytes,17,opt,name=HeaderTemplate,proto3" json:"HeaderTemplate,omitempty"`
	State                uint32   `protobuf:"varint,18,opt,name=State,proto3" json:"State,omitempty"`
	SourceLif            uint32   `protobuf:"varint,19,opt,name=SourceLif,proto3" json:"SourceLif,omitempty"`
	AsesqBase            uint64   `protobuf:"fixed64,20,opt,name=AsesqBase,proto3" json:"AsesqBase,omitempty"`
	AsesqPi              uint32   `protobuf:"varint,21,opt,name=AsesqPi,proto3" json:"AsesqPi,omitempty"`
	AsesqCi              uint32   `protobuf:"varint,22,opt,name=AsesqCi,proto3" json:"AsesqCi,omitempty"`
	DebugDolTx           uint32   `protobuf:"varint,23,opt,name=DebugDolTx,proto3" json:"DebugDolTx,omitempty"`
	HeaderLen            uint32   `protobuf:"varint,24,opt,name=HeaderLen,proto3" json:"HeaderLen,omitempty"`
	PendingAckSend       bool     `protobuf:"varint,25,opt,name=PendingAckSend,proto3" json:"PendingAckSend,omitempty"`
	SesqRetxCi           uint32   `protobuf:"varint,27,opt,name=SesqRetxCi,proto3" json:"SesqRetxCi,omitempty"`
	RetxSndUna           uint64   `protobuf:"varint,28,opt,name=RetxSndUna,proto3" json:"RetxSndUna,omitempty"`
	RxTs                 uint64   `protobuf:"varint,29,opt,name=RxTs,proto3" json:"RxTs,omitempty"`
	Rto                  uint64   `protobuf:"varint,30,opt,name=Rto,proto3" json:"Rto,omitempty"`
	SndCwndCnt           uint32   `protobuf:"varint,31,opt,name=SndCwndCnt,proto3" json:"SndCwndCnt,omitempty"`
	DebugDolTblsetaddr   uint32   `protobuf:"varint,32,opt,name=DebugDolTblsetaddr,proto3" json:"DebugDolTblsetaddr,omitempty"`
	SerqPi               uint32   `protobuf:"varint,33,opt,name=SerqPi,proto3" json:"SerqPi,omitempty"`
	PredFlags            uint32   `protobuf:"varint,34,opt,name=PredFlags,proto3" json:"PredFlags,omitempty"`
	OtherQid             uint32   `protobuf:"varint,35,opt,name=OtherQid,proto3" json:"OtherQid,omitempty"`
	PacketsOut           uint32   `protobuf:"varint,36,opt,name=PacketsOut,proto3" json:"PacketsOut,omitempty"`
	SndSsthresh          uint32   `protobuf:"varint,37,opt,name=SndSsthresh,proto3" json:"SndSsthresh,omitempty"`
	CcAlgo               uint32   `protobuf:"varint,38,opt,name=CcAlgo,proto3" json:"CcAlgo,omitempty"`
	RtoBackoff           uint32   `protobuf:"varint,39,opt,name=RtoBackoff,proto3" json:"RtoBackoff,omitempty"`
	CpuId                uint32   `protobuf:"varint,40,opt,name=CpuId,proto3" json:"CpuId,omitempty"`
	SerqCi               uint32   `protobuf:"varint,41,opt,name=SerqCi,proto3" json:"SerqCi,omitempty"`
	RcvWnd               uint32   `protobuf:"varint,42,opt,name=RcvWnd,proto3" json:"RcvWnd,omitempty"`
	SndWscale            uint32   `protobuf:"varint,43,opt,name=SndWscale,proto3" json:"SndWscale,omitempty"`
	RcvWscale            uint32   `protobuf:"varint,44,opt,name=RcvWscale,proto3" json:"RcvWscale,omitempty"`
	SesqTxCi             uint32   `protobuf:"varint,45,opt,name=SesqTxCi,proto3" json:"SesqTxCi,omitempty"`
	DelayAck             bool     `protobuf:"varint,46,opt,name=DelayAck,proto3" json:"DelayAck,omitempty"`
	Ato                  uint32   `protobuf:"varint,47,opt,name=Ato,proto3" json:"Ato,omitempty"`
	SndRecover           uint32   `protobuf:"varint,48,opt,name=SndRecover,proto3" json:"SndRecover,omitempty"`
	Smss                 uint32   `protobuf:"varint,49,opt,name=Smss,proto3" json:"Smss,omitempty"`
	InitialWindow        uint32   `protobuf:"varint,50,opt,name=InitialWindow,proto3" json:"InitialWindow,omitempty"`
	AbcLVar              uint32   `protobuf:"varint,51,opt,name=AbcLVar,proto3" json:"AbcLVar,omitempty"`
	OooQueue             bool     `protobuf:"varint,52,opt,name=OooQueue,proto3" json:"OooQueue,omitempty"`
	OooRx2TxQbase        uint64   `protobuf:"varint,53,opt,name=OooRx2txQbase,proto3" json:"OooRx2txQbase,omitempty"`
	RcvWup               uint32   `protobuf:"varint,54,opt,name=RcvWup,proto3" json:"RcvWup,omitempty"`
	CbBase               uint64   `protobuf:"fixed64,55,opt,name=CbBase,proto3" json:"CbBase,omitempty"`
	ZeroWindowSent       uint32   `protobuf:"varint,56,opt,name=ZeroWindowSent,proto3" json:"ZeroWindowSent,omitempty"`
	CbBaseQtype1         uint64   `protobuf:"fixed64,57,opt,name=CbBaseQtype1,proto3" json:"CbBaseQtype1,omitempty"`
	SrttUs               uint32   `protobuf:"varint,58,opt,name=SrttUs,proto3" json:"SrttUs,omitempty"`
	SackPerm             bool     `protobuf:"varint,59,opt,name=SackPerm,proto3" json:"SackPerm,omitempty"`
	Timestamps           bool     `protobuf:"varint,60,opt,name=Timestamps,proto3" json:"Timestamps,omitempty"`
	RttSeqTsoffset       uint32   `protobuf:"varint,61,opt,name=RttSeqTsoffset,proto3" json:"RttSeqTsoffset,omitempty"`
	RttTime              uint32   `protobuf:"varint,62,opt,name=RttTime,proto3" json:"RttTime,omitempty"`
	TsLearned            uint32   `protobuf:"varint,63,opt,name=TsLearned,proto3" json:"TsLearned,omitempty"`
	TsOffset             uint32   `protobuf:"varint,64,opt,name=TsOffset,proto3" json:"TsOffset,omitempty"`
	TsTime               uint32   `protobuf:"varint,65,opt,name=TsTime,proto3" json:"TsTime,omitempty"`
	Keepalives           bool     `protobuf:"varint,66,opt,name=Keepalives,proto3" json:"Keepalives,omitempty"`
	RttVar               uint32   `protobuf:"varint,67,opt,name=RttVar,proto3" json:"RttVar,omitempty"`
	AppQid               uint32   `protobuf:"varint,68,opt,name=AppQid,proto3" json:"AppQid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpCbSpec) Reset()         { *m = TcpCbSpec{} }
func (m *TcpCbSpec) String() string { return proto.CompactTextString(m) }
func (*TcpCbSpec) ProtoMessage()    {}
func (*TcpCbSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{79}
}
func (m *TcpCbSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbSpec.Merge(m, src)
}
func (m *TcpCbSpec) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbSpec proto.InternalMessageInfo

func (m *TcpCbSpec) GetTcpCbId() uint32 {
	if m != nil {
		return m.TcpCbId
	}
	return 0
}

func (m *TcpCbSpec) GetRcvNxt() uint32 {
	if m != nil {
		return m.RcvNxt
	}
	return 0
}

func (m *TcpCbSpec) GetSndNxt() uint32 {
	if m != nil {
		return m.SndNxt
	}
	return 0
}

func (m *TcpCbSpec) GetSndUna() uint32 {
	if m != nil {
		return m.SndUna
	}
	return 0
}

func (m *TcpCbSpec) GetRcvTsval() uint32 {
	if m != nil {
		return m.RcvTsval
	}
	return 0
}

func (m *TcpCbSpec) GetTsRecent() uint32 {
	if m != nil {
		return m.TsRecent
	}
	return 0
}

func (m *TcpCbSpec) GetSerqBase() uint64 {
	if m != nil {
		return m.SerqBase
	}
	return 0
}

func (m *TcpCbSpec) GetDebugDol() uint32 {
	if m != nil {
		return m.DebugDol
	}
	return 0
}

func (m *TcpCbSpec) GetSesqBase() uint64 {
	if m != nil {
		return m.SesqBase
	}
	return 0
}

func (m *TcpCbSpec) GetSesqPi() uint32 {
	if m != nil {
		return m.SesqPi
	}
	return 0
}

func (m *TcpCbSpec) GetSesqCi() uint32 {
	if m != nil {
		return m.SesqCi
	}
	return 0
}

func (m *TcpCbSpec) GetSndWnd() uint32 {
	if m != nil {
		return m.SndWnd
	}
	return 0
}

func (m *TcpCbSpec) GetSndCwnd() uint32 {
	if m != nil {
		return m.SndCwnd
	}
	return 0
}

func (m *TcpCbSpec) GetRcvMss() uint32 {
	if m != nil {
		return m.RcvMss
	}
	return 0
}

func (m *TcpCbSpec) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *TcpCbSpec) GetDestPort() uint32 {
	if m != nil {
		return m.DestPort
	}
	return 0
}

func (m *TcpCbSpec) GetHeaderTemplate() []byte {
	if m != nil {
		return m.HeaderTemplate
	}
	return nil
}

func (m *TcpCbSpec) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TcpCbSpec) GetSourceLif() uint32 {
	if m != nil {
		return m.SourceLif
	}
	return 0
}

func (m *TcpCbSpec) GetAsesqBase() uint64 {
	if m != nil {
		return m.AsesqBase
	}
	return 0
}

func (m *TcpCbSpec) GetAsesqPi() uint32 {
	if m != nil {
		return m.AsesqPi
	}
	return 0
}

func (m *TcpCbSpec) GetAsesqCi() uint32 {
	if m != nil {
		return m.AsesqCi
	}
	return 0
}

func (m *TcpCbSpec) GetDebugDolTx() uint32 {
	if m != nil {
		return m.DebugDolTx
	}
	return 0
}

func (m *TcpCbSpec) GetHeaderLen() uint32 {
	if m != nil {
		return m.HeaderLen
	}
	return 0
}

func (m *TcpCbSpec) GetPendingAckSend() bool {
	if m != nil {
		return m.PendingAckSend
	}
	return false
}

func (m *TcpCbSpec) GetSesqRetxCi() uint32 {
	if m != nil {
		return m.SesqRetxCi
	}
	return 0
}

func (m *TcpCbSpec) GetRetxSndUna() uint64 {
	if m != nil {
		return m.RetxSndUna
	}
	return 0
}

func (m *TcpCbSpec) GetRxTs() uint64 {
	if m != nil {
		return m.RxTs
	}
	return 0
}

func (m *TcpCbSpec) GetRto() uint64 {
	if m != nil {
		return m.Rto
	}
	return 0
}

func (m *TcpCbSpec) GetSndCwndCnt() uint32 {
	if m != nil {
		return m.SndCwndCnt
	}
	return 0
}

func (m *TcpCbSpec) GetDebugDolTblsetaddr() uint32 {
	if m != nil {
		return m.DebugDolTblsetaddr
	}
	return 0
}

func (m *TcpCbSpec) GetSerqPi() uint32 {
	if m != nil {
		return m.SerqPi
	}
	return 0
}

func (m *TcpCbSpec) GetPredFlags() uint32 {
	if m != nil {
		return m.PredFlags
	}
	return 0
}

func (m *TcpCbSpec) GetOtherQid() uint32 {
	if m != nil {
		return m.OtherQid
	}
	return 0
}

func (m *TcpCbSpec) GetPacketsOut() uint32 {
	if m != nil {
		return m.PacketsOut
	}
	return 0
}

func (m *TcpCbSpec) GetSndSsthresh() uint32 {
	if m != nil {
		return m.SndSsthresh
	}
	return 0
}

func (m *TcpCbSpec) GetCcAlgo() uint32 {
	if m != nil {
		return m.CcAlgo
	}
	return 0
}

func (m *TcpCbSpec) GetRtoBackoff() uint32 {
	if m != nil {
		return m.RtoBackoff
	}
	return 0
}

func (m *TcpCbSpec) GetCpuId() uint32 {
	if m != nil {
		return m.CpuId
	}
	return 0
}

func (m *TcpCbSpec) GetSerqCi() uint32 {
	if m != nil {
		return m.SerqCi
	}
	return 0
}

func (m *TcpCbSpec) GetRcvWnd() uint32 {
	if m != nil {
		return m.RcvWnd
	}
	return 0
}

func (m *TcpCbSpec) GetSndWscale() uint32 {
	if m != nil {
		return m.SndWscale
	}
	return 0
}

func (m *TcpCbSpec) GetRcvWscale() uint32 {
	if m != nil {
		return m.RcvWscale
	}
	return 0
}

func (m *TcpCbSpec) GetSesqTxCi() uint32 {
	if m != nil {
		return m.SesqTxCi
	}
	return 0
}

func (m *TcpCbSpec) GetDelayAck() bool {
	if m != nil {
		return m.DelayAck
	}
	return false
}

func (m *TcpCbSpec) GetAto() uint32 {
	if m != nil {
		return m.Ato
	}
	return 0
}

func (m *TcpCbSpec) GetSndRecover() uint32 {
	if m != nil {
		return m.SndRecover
	}
	return 0
}

func (m *TcpCbSpec) GetSmss() uint32 {
	if m != nil {
		return m.Smss
	}
	return 0
}

func (m *TcpCbSpec) GetInitialWindow() uint32 {
	if m != nil {
		return m.InitialWindow
	}
	return 0
}

func (m *TcpCbSpec) GetAbcLVar() uint32 {
	if m != nil {
		return m.AbcLVar
	}
	return 0
}

func (m *TcpCbSpec) GetOooQueue() bool {
	if m != nil {
		return m.OooQueue
	}
	return false
}

func (m *TcpCbSpec) GetOooRx2TxQbase() uint64 {
	if m != nil {
		return m.OooRx2TxQbase
	}
	return 0
}

func (m *TcpCbSpec) GetRcvWup() uint32 {
	if m != nil {
		return m.RcvWup
	}
	return 0
}

func (m *TcpCbSpec) GetCbBase() uint64 {
	if m != nil {
		return m.CbBase
	}
	return 0
}

func (m *TcpCbSpec) GetZeroWindowSent() uint32 {
	if m != nil {
		return m.ZeroWindowSent
	}
	return 0
}

func (m *TcpCbSpec) GetCbBaseQtype1() uint64 {
	if m != nil {
		return m.CbBaseQtype1
	}
	return 0
}

func (m *TcpCbSpec) GetSrttUs() uint32 {
	if m != nil {
		return m.SrttUs
	}
	return 0
}

func (m *TcpCbSpec) GetSackPerm() bool {
	if m != nil {
		return m.SackPerm
	}
	return false
}

func (m *TcpCbSpec) GetTimestamps() bool {
	if m != nil {
		return m.Timestamps
	}
	return false
}

func (m *TcpCbSpec) GetRttSeqTsoffset() uint32 {
	if m != nil {
		return m.RttSeqTsoffset
	}
	return 0
}

func (m *TcpCbSpec) GetRttTime() uint32 {
	if m != nil {
		return m.RttTime
	}
	return 0
}

func (m *TcpCbSpec) GetTsLearned() uint32 {
	if m != nil {
		return m.TsLearned
	}
	return 0
}

func (m *TcpCbSpec) GetTsOffset() uint32 {
	if m != nil {
		return m.TsOffset
	}
	return 0
}

func (m *TcpCbSpec) GetTsTime() uint32 {
	if m != nil {
		return m.TsTime
	}
	return 0
}

func (m *TcpCbSpec) GetKeepalives() bool {
	if m != nil {
		return m.Keepalives
	}
	return false
}

func (m *TcpCbSpec) GetRttVar() uint32 {
	if m != nil {
		return m.RttVar
	}
	return 0
}

func (m *TcpCbSpec) GetAppQid() uint32 {
	if m != nil {
		return m.AppQid
	}
	return 0
}

type TcpCbOoqStatus struct {
	QueueAddr            uint64   `protobuf:"varint,1,opt,name=QueueAddr,proto3" json:"QueueAddr,omitempty"`
	StartSeq             uint32   `protobuf:"varint,2,opt,name=StartSeq,proto3" json:"StartSeq,omitempty"`
	EndSeq               uint32   `protobuf:"varint,3,opt,name=EndSeq,proto3" json:"EndSeq,omitempty"`
	NumEntries           uint32   `protobuf:"varint,4,opt,name=NumEntries,proto3" json:"NumEntries,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpCbOoqStatus) Reset()         { *m = TcpCbOoqStatus{} }
func (m *TcpCbOoqStatus) String() string { return proto.CompactTextString(m) }
func (*TcpCbOoqStatus) ProtoMessage()    {}
func (*TcpCbOoqStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{80}
}
func (m *TcpCbOoqStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbOoqStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbOoqStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbOoqStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbOoqStatus.Merge(m, src)
}
func (m *TcpCbOoqStatus) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbOoqStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbOoqStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbOoqStatus proto.InternalMessageInfo

func (m *TcpCbOoqStatus) GetQueueAddr() uint64 {
	if m != nil {
		return m.QueueAddr
	}
	return 0
}

func (m *TcpCbOoqStatus) GetStartSeq() uint32 {
	if m != nil {
		return m.StartSeq
	}
	return 0
}

func (m *TcpCbOoqStatus) GetEndSeq() uint32 {
	if m != nil {
		return m.EndSeq
	}
	return 0
}

func (m *TcpCbOoqStatus) GetNumEntries() uint32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

// TcpCbStatus is the operational status of a given tcpcb
type TcpCbStatus struct {
	TcpCbId              uint32            `protobuf:"varint,1,opt,name=TcpCbId,proto3" json:"TcpCbId,omitempty"`
	OoqNotEmpty          bool              `protobuf:"varint,2,opt,name=OoqNotEmpty,proto3" json:"OoqNotEmpty,omitempty"`
	OoqStatus            []*TcpCbOoqStatus `protobuf:"bytes,3,rep,name=OoqStatus,proto3" json:"OoqStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TcpCbStatus) Reset()         { *m = TcpCbStatus{} }
func (m *TcpCbStatus) String() string { return proto.CompactTextString(m) }
func (*TcpCbStatus) ProtoMessage()    {}
func (*TcpCbStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{81}
}
func (m *TcpCbStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbStatus.Merge(m, src)
}
func (m *TcpCbStatus) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbStatus proto.InternalMessageInfo

func (m *TcpCbStatus) GetTcpCbId() uint32 {
	if m != nil {
		return m.TcpCbId
	}
	return 0
}

func (m *TcpCbStatus) GetOoqNotEmpty() bool {
	if m != nil {
		return m.OoqNotEmpty
	}
	return false
}

func (m *TcpCbStatus) GetOoqStatus() []*TcpCbOoqStatus {
	if m != nil {
		return m.OoqStatus
	}
	return nil
}

// TcpCbGetRequest is used to get information about a tcpcb
type TcpCbRequest struct {
	TcpCbId              uint32   `protobuf:"varint,1,opt,name=TcpCbId,proto3" json:"TcpCbId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpCbRequest) Reset()         { *m = TcpCbRequest{} }
func (m *TcpCbRequest) String() string { return proto.CompactTextString(m) }
func (*TcpCbRequest) ProtoMessage()    {}
func (*TcpCbRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{82}
}
func (m *TcpCbRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbRequest.Merge(m, src)
}
func (m *TcpCbRequest) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbRequest proto.InternalMessageInfo

func (m *TcpCbRequest) GetTcpCbId() uint32 {
	if m != nil {
		return m.TcpCbId
	}
	return 0
}

// TcpCbGetRequest is batched GET requests for tcpcbs
type TcpCbGetRequest struct {
	Request              []*TcpCbRequest `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TcpCbGetRequest) Reset()         { *m = TcpCbGetRequest{} }
func (m *TcpCbGetRequest) String() string { return proto.CompactTextString(m) }
func (*TcpCbGetRequest) ProtoMessage()    {}
func (*TcpCbGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{83}
}
func (m *TcpCbGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbGetRequest.Merge(m, src)
}
func (m *TcpCbGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbGetRequest proto.InternalMessageInfo

func (m *TcpCbGetRequest) GetRequest() []*TcpCbRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// TcpCbStats is the statistics object for each tcpcb
type TcpCbStats struct {
	// rx stats
	BytesRcvd    uint64 `protobuf:"varint,1,opt,name=BytesRcvd,proto3" json:"BytesRcvd,omitempty"`
	PktsRcvd     uint64 `protobuf:"varint,2,opt,name=PktsRcvd,proto3" json:"PktsRcvd,omitempty"`
	BytesAcked   uint64 `protobuf:"varint,3,opt,name=BytesAcked,proto3" json:"BytesAcked,omitempty"`
	PureAcksRcvd uint64 `protobuf:"varint,4,opt,name=PureAcksRcvd,proto3" json:"PureAcksRcvd,omitempty"`
	DupAcksRcvd  uint64 `protobuf:"varint,5,opt,name=DupAcksRcvd,proto3" json:"DupAcksRcvd,omitempty"`
	SlowPathCnt  uint64 `protobuf:"varint,6,opt,name=SlowPathCnt,proto3" json:"SlowPathCnt,omitempty"`
	SerqFullCnt  uint64 `protobuf:"varint,7,opt,name=SerqFullCnt,proto3" json:"SerqFullCnt,omitempty"`
	OooCnt       uint64 `protobuf:"varint,8,opt,name=OooCnt,proto3" json:"OooCnt,omitempty"`
	RxDropCnt    uint64 `protobuf:"varint,9,opt,name=RxDropCnt,proto3" json:"RxDropCnt,omitempty"`
	PawsDropCnt  uint64 `protobuf:"varint,10,opt,name=PawsDropCnt,proto3" json:"PawsDropCnt,omitempty"`
	WinCheckFail uint64 `protobuf:"varint,11,opt,name=WinCheckFail,proto3" json:"WinCheckFail,omitempty"`
	OooDropCnt   uint64 `protobuf:"varint,12,opt,name=OooDropCnt,proto3" json:"OooDropCnt,omitempty"`
	SerqPi       uint64 `protobuf:"varint,13,opt,name=SerqPi,proto3" json:"SerqPi,omitempty"`
	SerqCi       uint64 `protobuf:"varint,14,opt,name=SerqCi,proto3" json:"SerqCi,omitempty"`
	// tx stats
	BytesSent            uint64   `protobuf:"varint,10001,opt,name=BytesSent,proto3" json:"BytesSent,omitempty"`
	PktsSent             uint64   `protobuf:"varint,10002,opt,name=PktsSent,proto3" json:"PktsSent,omitempty"`
	PureAcksSent         uint64   `protobuf:"varint,10003,opt,name=PureAcksSent,proto3" json:"PureAcksSent,omitempty"`
	SesqPi               uint32   `protobuf:"varint,10005,opt,name=SesqPi,proto3" json:"SesqPi,omitempty"`
	SesqCi               uint32   `protobuf:"varint,10006,opt,name=SesqCi,proto3" json:"SesqCi,omitempty"`
	SendAckPi            uint32   `protobuf:"varint,10007,opt,name=SendAckPi,proto3" json:"SendAckPi,omitempty"`
	SendAckCi            uint32   `protobuf:"varint,10008,opt,name=SendAckCi,proto3" json:"SendAckCi,omitempty"`
	FastTimerPi          uint32   `protobuf:"varint,10009,opt,name=FastTimerPi,proto3" json:"FastTimerPi,omitempty"`
	FastTimerCi          uint32   `protobuf:"varint,10010,opt,name=FastTimerCi,proto3" json:"FastTimerCi,omitempty"`
	DelAckPi             uint32   `protobuf:"varint,10011,opt,name=DelAckPi,proto3" json:"DelAckPi,omitempty"`
	DelAckCi             uint32   `protobuf:"varint,10012,opt,name=DelAckCi,proto3" json:"DelAckCi,omitempty"`
	OobRstPi             uint32   `protobuf:"varint,10013,opt,name=OobRstPi,proto3" json:"OobRstPi,omitempty"`
	OobRstCi             uint32   `protobuf:"varint,10014,opt,name=OobRstCi,proto3" json:"OobRstCi,omitempty"`
	PendingTxPi          uint32   `protobuf:"varint,10015,opt,name=PendingTxPi,proto3" json:"PendingTxPi,omitempty"`
	PendingTxCi          uint32   `protobuf:"varint,10016,opt,name=PendingTxCi,proto3" json:"PendingTxCi,omitempty"`
	FastRetransPi        uint32   `protobuf:"varint,10017,opt,name=FastRetransPi,proto3" json:"FastRetransPi,omitempty"`
	FastRetransCi        uint32   `protobuf:"varint,10018,opt,name=FastRetransCi,proto3" json:"FastRetransCi,omitempty"`
	CleanRetxPi          uint32   `protobuf:"varint,10019,opt,name=CleanRetxPi,proto3" json:"CleanRetxPi,omitempty"`
	CleanRetxCi          uint32   `protobuf:"varint,10020,opt,name=CleanRetxCi,proto3" json:"CleanRetxCi,omitempty"`
	PacketsOut           uint32   `protobuf:"varint,10021,opt,name=PacketsOut,proto3" json:"PacketsOut,omitempty"`
	SesqTxCi             uint32   `protobuf:"varint,10022,opt,name=SesqTxCi,proto3" json:"SesqTxCi,omitempty"`
	SesqRetxCi           uint32   `protobuf:"varint,10023,opt,name=SesqRetxCi,proto3" json:"SesqRetxCi,omitempty"`
	AsesqRetxCi          uint32   `protobuf:"varint,10024,opt,name=AsesqRetxCi,proto3" json:"AsesqRetxCi,omitempty"`
	TxRingPi             uint32   `protobuf:"varint,10025,opt,name=TxRingPi,proto3" json:"TxRingPi,omitempty"`
	PartialPktAckCnt     uint32   `protobuf:"varint,10026,opt,name=PartialPktAckCnt,proto3" json:"PartialPktAckCnt,omitempty"`
	AtoDeadline          uint32   `protobuf:"varint,10027,opt,name=AtoDeadline,proto3" json:"AtoDeadline,omitempty"`
	RtoDeadline          uint32   `protobuf:"varint,10028,opt,name=RtoDeadline,proto3" json:"RtoDeadline,omitempty"`
	CcFlags              uint32   `protobuf:"varint,10029,opt,name=CcFlags,proto3" json:"CcFlags,omitempty"`
	KeepaDeadline        uint32   `protobuf:"varint,10030,opt,name=KeepaDeadline,proto3" json:"KeepaDeadline,omitempty"`
	WindowFullCnt        uint32   `protobuf:"varint,10031,opt,name=WindowFullCnt,proto3" json:"WindowFullCnt,omitempty"`
	OoqRx2TxPi           uint32   `protobuf:"varint,10032,opt,name=OoqRx2txPi,proto3" json:"OoqRx2txPi,omitempty"`
	OoqRx2TxCi           uint32   `protobuf:"varint,10033,opt,name=OoqRx2txCi,proto3" json:"OoqRx2txCi,omitempty"`
	RetxCnt              uint32   `protobuf:"varint,10034,opt,name=RetxCnt,proto3" json:"RetxCnt,omitempty"`
	WindowUpdatePi       uint32   `protobuf:"varint,10035,opt,name=WindowUpdatePi,proto3" json:"WindowUpdatePi,omitempty"`
	WindowUpdateCi       uint32   `protobuf:"varint,10036,opt,name=WindowUpdateCi,proto3" json:"WindowUpdateCi,omitempty"`
	TxWindowUpdatePi     uint32   `protobuf:"varint,10037,opt,name=TxWindowUpdatePi,proto3" json:"TxWindowUpdatePi,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpCbStats) Reset()         { *m = TcpCbStats{} }
func (m *TcpCbStats) String() string { return proto.CompactTextString(m) }
func (*TcpCbStats) ProtoMessage()    {}
func (*TcpCbStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{84}
}
func (m *TcpCbStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbStats.Merge(m, src)
}
func (m *TcpCbStats) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbStats.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbStats proto.InternalMessageInfo

func (m *TcpCbStats) GetBytesRcvd() uint64 {
	if m != nil {
		return m.BytesRcvd
	}
	return 0
}

func (m *TcpCbStats) GetPktsRcvd() uint64 {
	if m != nil {
		return m.PktsRcvd
	}
	return 0
}

func (m *TcpCbStats) GetBytesAcked() uint64 {
	if m != nil {
		return m.BytesAcked
	}
	return 0
}

func (m *TcpCbStats) GetPureAcksRcvd() uint64 {
	if m != nil {
		return m.PureAcksRcvd
	}
	return 0
}

func (m *TcpCbStats) GetDupAcksRcvd() uint64 {
	if m != nil {
		return m.DupAcksRcvd
	}
	return 0
}

func (m *TcpCbStats) GetSlowPathCnt() uint64 {
	if m != nil {
		return m.SlowPathCnt
	}
	return 0
}

func (m *TcpCbStats) GetSerqFullCnt() uint64 {
	if m != nil {
		return m.SerqFullCnt
	}
	return 0
}

func (m *TcpCbStats) GetOooCnt() uint64 {
	if m != nil {
		return m.OooCnt
	}
	return 0
}

func (m *TcpCbStats) GetRxDropCnt() uint64 {
	if m != nil {
		return m.RxDropCnt
	}
	return 0
}

func (m *TcpCbStats) GetPawsDropCnt() uint64 {
	if m != nil {
		return m.PawsDropCnt
	}
	return 0
}

func (m *TcpCbStats) GetWinCheckFail() uint64 {
	if m != nil {
		return m.WinCheckFail
	}
	return 0
}

func (m *TcpCbStats) GetOooDropCnt() uint64 {
	if m != nil {
		return m.OooDropCnt
	}
	return 0
}

func (m *TcpCbStats) GetSerqPi() uint64 {
	if m != nil {
		return m.SerqPi
	}
	return 0
}

func (m *TcpCbStats) GetSerqCi() uint64 {
	if m != nil {
		return m.SerqCi
	}
	return 0
}

func (m *TcpCbStats) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *TcpCbStats) GetPktsSent() uint64 {
	if m != nil {
		return m.PktsSent
	}
	return 0
}

func (m *TcpCbStats) GetPureAcksSent() uint64 {
	if m != nil {
		return m.PureAcksSent
	}
	return 0
}

func (m *TcpCbStats) GetSesqPi() uint32 {
	if m != nil {
		return m.SesqPi
	}
	return 0
}

func (m *TcpCbStats) GetSesqCi() uint32 {
	if m != nil {
		return m.SesqCi
	}
	return 0
}

func (m *TcpCbStats) GetSendAckPi() uint32 {
	if m != nil {
		return m.SendAckPi
	}
	return 0
}

func (m *TcpCbStats) GetSendAckCi() uint32 {
	if m != nil {
		return m.SendAckCi
	}
	return 0
}

func (m *TcpCbStats) GetFastTimerPi() uint32 {
	if m != nil {
		return m.FastTimerPi
	}
	return 0
}

func (m *TcpCbStats) GetFastTimerCi() uint32 {
	if m != nil {
		return m.FastTimerCi
	}
	return 0
}

func (m *TcpCbStats) GetDelAckPi() uint32 {
	if m != nil {
		return m.DelAckPi
	}
	return 0
}

func (m *TcpCbStats) GetDelAckCi() uint32 {
	if m != nil {
		return m.DelAckCi
	}
	return 0
}

func (m *TcpCbStats) GetOobRstPi() uint32 {
	if m != nil {
		return m.OobRstPi
	}
	return 0
}

func (m *TcpCbStats) GetOobRstCi() uint32 {
	if m != nil {
		return m.OobRstCi
	}
	return 0
}

func (m *TcpCbStats) GetPendingTxPi() uint32 {
	if m != nil {
		return m.PendingTxPi
	}
	return 0
}

func (m *TcpCbStats) GetPendingTxCi() uint32 {
	if m != nil {
		return m.PendingTxCi
	}
	return 0
}

func (m *TcpCbStats) GetFastRetransPi() uint32 {
	if m != nil {
		return m.FastRetransPi
	}
	return 0
}

func (m *TcpCbStats) GetFastRetransCi() uint32 {
	if m != nil {
		return m.FastRetransCi
	}
	return 0
}

func (m *TcpCbStats) GetCleanRetxPi() uint32 {
	if m != nil {
		return m.CleanRetxPi
	}
	return 0
}

func (m *TcpCbStats) GetCleanRetxCi() uint32 {
	if m != nil {
		return m.CleanRetxCi
	}
	return 0
}

func (m *TcpCbStats) GetPacketsOut() uint32 {
	if m != nil {
		return m.PacketsOut
	}
	return 0
}

func (m *TcpCbStats) GetSesqTxCi() uint32 {
	if m != nil {
		return m.SesqTxCi
	}
	return 0
}

func (m *TcpCbStats) GetSesqRetxCi() uint32 {
	if m != nil {
		return m.SesqRetxCi
	}
	return 0
}

func (m *TcpCbStats) GetAsesqRetxCi() uint32 {
	if m != nil {
		return m.AsesqRetxCi
	}
	return 0
}

func (m *TcpCbStats) GetTxRingPi() uint32 {
	if m != nil {
		return m.TxRingPi
	}
	return 0
}

func (m *TcpCbStats) GetPartialPktAckCnt() uint32 {
	if m != nil {
		return m.PartialPktAckCnt
	}
	return 0
}

func (m *TcpCbStats) GetAtoDeadline() uint32 {
	if m != nil {
		return m.AtoDeadline
	}
	return 0
}

func (m *TcpCbStats) GetRtoDeadline() uint32 {
	if m != nil {
		return m.RtoDeadline
	}
	return 0
}

func (m *TcpCbStats) GetCcFlags() uint32 {
	if m != nil {
		return m.CcFlags
	}
	return 0
}

func (m *TcpCbStats) GetKeepaDeadline() uint32 {
	if m != nil {
		return m.KeepaDeadline
	}
	return 0
}

func (m *TcpCbStats) GetWindowFullCnt() uint32 {
	if m != nil {
		return m.WindowFullCnt
	}
	return 0
}

func (m *TcpCbStats) GetOoqRx2TxPi() uint32 {
	if m != nil {
		return m.OoqRx2TxPi
	}
	return 0
}

func (m *TcpCbStats) GetOoqRx2TxCi() uint32 {
	if m != nil {
		return m.OoqRx2TxCi
	}
	return 0
}

func (m *TcpCbStats) GetRetxCnt() uint32 {
	if m != nil {
		return m.RetxCnt
	}
	return 0
}

func (m *TcpCbStats) GetWindowUpdatePi() uint32 {
	if m != nil {
		return m.WindowUpdatePi
	}
	return 0
}

func (m *TcpCbStats) GetWindowUpdateCi() uint32 {
	if m != nil {
		return m.WindowUpdateCi
	}
	return 0
}

func (m *TcpCbStats) GetTxWindowUpdatePi() uint32 {
	if m != nil {
		return m.TxWindowUpdatePi
	}
	return 0
}

// TcpCbGetResponse captures all the information about a tcpcb
// only if ApiStatus indicates success, other fields are valid
type TcpCbResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Spec                 *TcpCbSpec   `protobuf:"bytes,2,opt,name=Spec,proto3" json:"Spec,omitempty"`
	Status               *TcpCbStatus `protobuf:"bytes,3,opt,name=Status,proto3" json:"Status,omitempty"`
	Stats                *TcpCbStats  `protobuf:"bytes,4,opt,name=Stats,proto3" json:"Stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TcpCbResponse) Reset()         { *m = TcpCbResponse{} }
func (m *TcpCbResponse) String() string { return proto.CompactTextString(m) }
func (*TcpCbResponse) ProtoMessage()    {}
func (*TcpCbResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{85}
}
func (m *TcpCbResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbResponse.Merge(m, src)
}
func (m *TcpCbResponse) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbResponse proto.InternalMessageInfo

func (m *TcpCbResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpCbResponse) GetSpec() *TcpCbSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TcpCbResponse) GetStatus() *TcpCbStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TcpCbResponse) GetStats() *TcpCbStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TcpCbGetResponse is batched response to TcpCbGetRequest
type TcpCbGetResponse struct {
	ApiStatus            ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*TcpCbResponse `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TcpCbGetResponse) Reset()         { *m = TcpCbGetResponse{} }
func (m *TcpCbGetResponse) String() string { return proto.CompactTextString(m) }
func (*TcpCbGetResponse) ProtoMessage()    {}
func (*TcpCbGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{86}
}
func (m *TcpCbGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpCbGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpCbGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpCbGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpCbGetResponse.Merge(m, src)
}
func (m *TcpCbGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *TcpCbGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpCbGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TcpCbGetResponse proto.InternalMessageInfo

func (m *TcpCbGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *TcpCbGetResponse) GetResponse() []*TcpCbResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type FlowTracerSpec struct {
	// unique key/identifier of VPC which is used to derive the VNI value in
	// the flowtracer packet
	VPC []byte `protobuf:"bytes,1,opt,name=VPC,proto3" json:"VPC,omitempty"`
	// VxLAN Network Identifier (VNI)
	// NOTE:
	// 1. VNI value of zero is considered invalid
	// 2. if both VPC and VNI values are valid then the VNI value takes precedence
	//    and will be used in the flowtracer packet
	VNI uint32 `protobuf:"varint,2,opt,name=VNI,proto3" json:"VNI,omitempty"`
	// overlay source IP address
	SrcAddr *IPAddress `protobuf:"bytes,3,opt,name=SrcAddr,proto3" json:"SrcAddr,omitempty"`
	// overlay destination address
	DstAddr *IPAddress `protobuf:"bytes,4,opt,name=DstAddr,proto3" json:"DstAddr,omitempty"`
	// source TEP address
	SrcTep *IPAddress `protobuf:"bytes,5,opt,name=SrcTep,proto3" json:"SrcTep,omitempty"`
	// IP protocol
	IPProto uint32 `protobuf:"varint,6,opt,name=IPProto,proto3" json:"IPProto,omitempty" meta:range:0-255`
	// L4 information
	L4Info *FlowL4Info `protobuf:"bytes,7,opt,name=L4Info,proto3" json:"L4Info,omitempty"`
	// overlay destination mac address
	OverlayDstMAC uint64 `protobuf:"varint,8,opt,name=OverlayDstMAC,proto3" json:"OverlayDstMAC,omitempty"`
	// overlay source mac address
	OverlaySrcMAC        uint64   `protobuf:"varint,9,opt,name=OverlaySrcMAC,proto3" json:"OverlaySrcMAC,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowTracerSpec) Reset()         { *m = FlowTracerSpec{} }
func (m *FlowTracerSpec) String() string { return proto.CompactTextString(m) }
func (*FlowTracerSpec) ProtoMessage()    {}
func (*FlowTracerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{87}
}
func (m *FlowTracerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTracerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTracerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTracerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTracerSpec.Merge(m, src)
}
func (m *FlowTracerSpec) XXX_Size() int {
	return m.Size()
}
func (m *FlowTracerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTracerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTracerSpec proto.InternalMessageInfo

func (m *FlowTracerSpec) GetVPC() []byte {
	if m != nil {
		return m.VPC
	}
	return nil
}

func (m *FlowTracerSpec) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *FlowTracerSpec) GetSrcAddr() *IPAddress {
	if m != nil {
		return m.SrcAddr
	}
	return nil
}

func (m *FlowTracerSpec) GetDstAddr() *IPAddress {
	if m != nil {
		return m.DstAddr
	}
	return nil
}

func (m *FlowTracerSpec) GetSrcTep() *IPAddress {
	if m != nil {
		return m.SrcTep
	}
	return nil
}

func (m *FlowTracerSpec) GetIPProto() uint32 {
	if m != nil {
		return m.IPProto
	}
	return 0
}

func (m *FlowTracerSpec) GetL4Info() *FlowL4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *FlowTracerSpec) GetOverlayDstMAC() uint64 {
	if m != nil {
		return m.OverlayDstMAC
	}
	return 0
}

func (m *FlowTracerSpec) GetOverlaySrcMAC() uint64 {
	if m != nil {
		return m.OverlaySrcMAC
	}
	return 0
}

type FlowTracerRequest struct {
	// multiple requests
	Request              []*FlowTracerSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FlowTracerRequest) Reset()         { *m = FlowTracerRequest{} }
func (m *FlowTracerRequest) String() string { return proto.CompactTextString(m) }
func (*FlowTracerRequest) ProtoMessage()    {}
func (*FlowTracerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{88}
}
func (m *FlowTracerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTracerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTracerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTracerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTracerRequest.Merge(m, src)
}
func (m *FlowTracerRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlowTracerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTracerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTracerRequest proto.InternalMessageInfo

func (m *FlowTracerRequest) GetRequest() []*FlowTracerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type FlowTracerStatus struct {
	// unique key/identifier of VPC
	VPC []byte `protobuf:"bytes,1,opt,name=VPC,proto3" json:"VPC,omitempty"`
	// unique key/identifier of Vnic
	Vnic []byte `protobuf:"bytes,2,opt,name=Vnic,proto3" json:"Vnic,omitempty"`
	// unique key/identifier of SecurityRule
	SecurityRule []byte `protobuf:"bytes,3,opt,name=SecurityRule,proto3" json:"SecurityRule,omitempty"`
	// unique key/identifier of SecurityPolicy
	SecurityPolicy []byte `protobuf:"bytes,4,opt,name=SecurityPolicy,proto3" json:"SecurityPolicy,omitempty"`
	// unique key/identifier of service mapping id
	SvcMapping []byte `protobuf:"bytes,5,opt,name=SvcMapping,proto3" json:"SvcMapping,omitempty"`
	// unique key/identifier of ingress subnet
	IngressSubnet []byte `protobuf:"bytes,6,opt,name=IngressSubnet,proto3" json:"IngressSubnet,omitempty"`
	// unique key/identifier of egress subnet
	EgressSubnet []byte `protobuf:"bytes,7,opt,name=EgressSubnet,proto3" json:"EgressSubnet,omitempty"`
	// meter class
	MeterClass uint32 `protobuf:"varint,8,opt,name=MeterClass,proto3" json:"MeterClass,omitempty"`
	// route class priority
	RouteClassPriority uint32 `protobuf:"varint,9,opt,name=RouteClassPriority,proto3" json:"RouteClassPriority,omitempty"`
	// security rule action
	Action SecurityRuleAction `protobuf:"varint,10,opt,name=Action,proto3,enum=types.SecurityRuleAction" json:"Action,omitempty"`
	// flow hit
	FlowHit bool `protobuf:"varint,11,opt,name=FlowHit,proto3" json:"FlowHit,omitempty"`
	// mapping hit
	MappingHit bool `protobuf:"varint,12,opt,name=MappingHit,proto3" json:"MappingHit,omitempty"`
	// default policy rule hit
	DefaultRuleHit bool `protobuf:"varint,13,opt,name=DefaultRuleHit,proto3" json:"DefaultRuleHit,omitempty"`
	// destination tunnel address (TEP)
	DstTep *IPAddress `protobuf:"bytes,14,opt,name=DstTep,proto3" json:"DstTep,omitempty"`
	// packet dropped in the pipeline
	Drop bool `protobuf:"varint,15,opt,name=Drop,proto3" json:"Drop,omitempty"`
	// drop reasons
	DropReason           []string `protobuf:"bytes,16,rep,name=DropReason,proto3" json:"DropReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowTracerStatus) Reset()         { *m = FlowTracerStatus{} }
func (m *FlowTracerStatus) String() string { return proto.CompactTextString(m) }
func (*FlowTracerStatus) ProtoMessage()    {}
func (*FlowTracerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{89}
}
func (m *FlowTracerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTracerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTracerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTracerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTracerStatus.Merge(m, src)
}
func (m *FlowTracerStatus) XXX_Size() int {
	return m.Size()
}
func (m *FlowTracerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTracerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTracerStatus proto.InternalMessageInfo

func (m *FlowTracerStatus) GetVPC() []byte {
	if m != nil {
		return m.VPC
	}
	return nil
}

func (m *FlowTracerStatus) GetVnic() []byte {
	if m != nil {
		return m.Vnic
	}
	return nil
}

func (m *FlowTracerStatus) GetSecurityRule() []byte {
	if m != nil {
		return m.SecurityRule
	}
	return nil
}

func (m *FlowTracerStatus) GetSecurityPolicy() []byte {
	if m != nil {
		return m.SecurityPolicy
	}
	return nil
}

func (m *FlowTracerStatus) GetSvcMapping() []byte {
	if m != nil {
		return m.SvcMapping
	}
	return nil
}

func (m *FlowTracerStatus) GetIngressSubnet() []byte {
	if m != nil {
		return m.IngressSubnet
	}
	return nil
}

func (m *FlowTracerStatus) GetEgressSubnet() []byte {
	if m != nil {
		return m.EgressSubnet
	}
	return nil
}

func (m *FlowTracerStatus) GetMeterClass() uint32 {
	if m != nil {
		return m.MeterClass
	}
	return 0
}

func (m *FlowTracerStatus) GetRouteClassPriority() uint32 {
	if m != nil {
		return m.RouteClassPriority
	}
	return 0
}

func (m *FlowTracerStatus) GetAction() SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return SecurityRuleAction_SECURITY_RULE_ACTION_NONE
}

func (m *FlowTracerStatus) GetFlowHit() bool {
	if m != nil {
		return m.FlowHit
	}
	return false
}

func (m *FlowTracerStatus) GetMappingHit() bool {
	if m != nil {
		return m.MappingHit
	}
	return false
}

func (m *FlowTracerStatus) GetDefaultRuleHit() bool {
	if m != nil {
		return m.DefaultRuleHit
	}
	return false
}

func (m *FlowTracerStatus) GetDstTep() *IPAddress {
	if m != nil {
		return m.DstTep
	}
	return nil
}

func (m *FlowTracerStatus) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

func (m *FlowTracerStatus) GetDropReason() []string {
	if m != nil {
		return m.DropReason
	}
	return nil
}

type FlowTracerResponse struct {
	ApiStatus            ApiStatus           `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*FlowTracerStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FlowTracerResponse) Reset()         { *m = FlowTracerResponse{} }
func (m *FlowTracerResponse) String() string { return proto.CompactTextString(m) }
func (*FlowTracerResponse) ProtoMessage()    {}
func (*FlowTracerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{90}
}
func (m *FlowTracerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTracerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTracerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTracerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTracerResponse.Merge(m, src)
}
func (m *FlowTracerResponse) XXX_Size() int {
	return m.Size()
}
func (m *FlowTracerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTracerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTracerResponse proto.InternalMessageInfo

func (m *FlowTracerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowTracerResponse) GetResponse() []*FlowTracerStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// MPU performance information
type MPUPerfInfo struct {
	// MPU utilization percentage
	Utilization uint32 `protobuf:"varint,1,opt,name=Utilization,proto3" json:"Utilization,omitempty"`
	// Cycles Per Instruction (CPI)
	CPI                  float32  `protobuf:"fixed32,2,opt,name=CPI,proto3" json:"CPI,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPUPerfInfo) Reset()         { *m = MPUPerfInfo{} }
func (m *MPUPerfInfo) String() string { return proto.CompactTextString(m) }
func (*MPUPerfInfo) ProtoMessage()    {}
func (*MPUPerfInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{91}
}
func (m *MPUPerfInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MPUPerfInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MPUPerfInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MPUPerfInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPUPerfInfo.Merge(m, src)
}
func (m *MPUPerfInfo) XXX_Size() int {
	return m.Size()
}
func (m *MPUPerfInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MPUPerfInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MPUPerfInfo proto.InternalMessageInfo

func (m *MPUPerfInfo) GetUtilization() uint32 {
	if m != nil {
		return m.Utilization
	}
	return 0
}

func (m *MPUPerfInfo) GetCPI() float32 {
	if m != nil {
		return m.CPI
	}
	return 0
}

// Pipeline stage performance information
type PipelineStagePerfInfo struct {
	// MPU performance data
	MPUPerf              []*MPUPerfInfo `protobuf:"bytes,1,rep,name=MPUPerf,proto3" json:"MPUPerf,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PipelineStagePerfInfo) Reset()         { *m = PipelineStagePerfInfo{} }
func (m *PipelineStagePerfInfo) String() string { return proto.CompactTextString(m) }
func (*PipelineStagePerfInfo) ProtoMessage()    {}
func (*PipelineStagePerfInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{92}
}
func (m *PipelineStagePerfInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineStagePerfInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineStagePerfInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineStagePerfInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineStagePerfInfo.Merge(m, src)
}
func (m *PipelineStagePerfInfo) XXX_Size() int {
	return m.Size()
}
func (m *PipelineStagePerfInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineStagePerfInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineStagePerfInfo proto.InternalMessageInfo

func (m *PipelineStagePerfInfo) GetMPUPerf() []*MPUPerfInfo {
	if m != nil {
		return m.MPUPerf
	}
	return nil
}

// Pipeline performance information
type PipelinePerfInfo struct {
	// pipeline type
	Pipeline Pipeline `protobuf:"varint,1,opt,name=Pipeline,proto3,enum=pds.Pipeline" json:"Pipeline,omitempty"`
	// no. of PHVs seen in the pipe
	PHVs uint64 `protobuf:"varint,2,opt,name=PHVs,proto3" json:"PHVs,omitempty"`
	// no. of drops in the pipe
	Drops uint64 `protobuf:"varint,3,opt,name=Drops,proto3" json:"Drops,omitempty"`
	// no. of recircs in the pipe
	Recircs uint64 `protobuf:"varint,4,opt,name=Recircs,proto3" json:"Recircs,omitempty"`
	// no. of packets received from PB
	PacketsFromPB uint64 `protobuf:"varint,5,opt,name=PacketsFromPB,proto3" json:"PacketsFromPB,omitempty"`
	// no. of parser drops, if applicable
	ParserDrops uint64 `protobuf:"varint,6,opt,name=ParserDrops,proto3" json:"ParserDrops,omitempty"`
	// per stage peformance information
	StagePerf            []*PipelineStagePerfInfo `protobuf:"bytes,7,rep,name=StagePerf,proto3" json:"StagePerf,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *PipelinePerfInfo) Reset()         { *m = PipelinePerfInfo{} }
func (m *PipelinePerfInfo) String() string { return proto.CompactTextString(m) }
func (*PipelinePerfInfo) ProtoMessage()    {}
func (*PipelinePerfInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{93}
}
func (m *PipelinePerfInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelinePerfInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelinePerfInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelinePerfInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelinePerfInfo.Merge(m, src)
}
func (m *PipelinePerfInfo) XXX_Size() int {
	return m.Size()
}
func (m *PipelinePerfInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelinePerfInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PipelinePerfInfo proto.InternalMessageInfo

func (m *PipelinePerfInfo) GetPipeline() Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return Pipeline_PIPELINE_NONE
}

func (m *PipelinePerfInfo) GetPHVs() uint64 {
	if m != nil {
		return m.PHVs
	}
	return 0
}

func (m *PipelinePerfInfo) GetDrops() uint64 {
	if m != nil {
		return m.Drops
	}
	return 0
}

func (m *PipelinePerfInfo) GetRecircs() uint64 {
	if m != nil {
		return m.Recircs
	}
	return 0
}

func (m *PipelinePerfInfo) GetPacketsFromPB() uint64 {
	if m != nil {
		return m.PacketsFromPB
	}
	return 0
}

func (m *PipelinePerfInfo) GetParserDrops() uint64 {
	if m != nil {
		return m.ParserDrops
	}
	return 0
}

func (m *PipelinePerfInfo) GetStagePerf() []*PipelineStagePerfInfo {
	if m != nil {
		return m.StagePerf
	}
	return nil
}

// DDR performance related information
type DDRPerfInfo struct {
	// number of read transactions
	Reads uint64 `protobuf:"varint,1,opt,name=Reads,proto3" json:"Reads,omitempty"`
	// maximum read latency
	ReadLatencyMax uint64 `protobuf:"varint,2,opt,name=ReadLatencyMax,proto3" json:"ReadLatencyMax,omitempty"`
	// average read latency
	ReadLatencyAvg uint64 `protobuf:"varint,3,opt,name=ReadLatencyAvg,proto3" json:"ReadLatencyAvg,omitempty"`
	// read Transactions Per Second (TPS) in Millions
	ReadMTPS float32 `protobuf:"fixed32,4,opt,name=ReadMTPS,proto3" json:"ReadMTPS,omitempty"`
	// read bandwidth in Gbps (MPTS * 64 * 8 * 1000000)/(1000000000)
	ReadBandwidth float32 `protobuf:"fixed32,5,opt,name=ReadBandwidth,proto3" json:"ReadBandwidth,omitempty"`
	// number of write transactions
	Writes uint64 `protobuf:"varint,6,opt,name=Writes,proto3" json:"Writes,omitempty"`
	// maximum write latency
	WriteLatencyMax uint64 `protobuf:"varint,7,opt,name=WriteLatencyMax,proto3" json:"WriteLatencyMax,omitempty"`
	// average write latency
	WriteLatencyAvg uint64 `protobuf:"varint,8,opt,name=WriteLatencyAvg,proto3" json:"WriteLatencyAvg,omitempty"`
	// write Transactions Per Second (TPS) in Millions
	WriteMTPS float32 `protobuf:"fixed32,9,opt,name=WriteMTPS,proto3" json:"WriteMTPS,omitempty"`
	// write bandwidth in Gbps (MPTS * 64 * 8 * 1000000)/(1000000000)
	WriteBandwidth       float32  `protobuf:"fixed32,10,opt,name=WriteBandwidth,proto3" json:"WriteBandwidth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DDRPerfInfo) Reset()         { *m = DDRPerfInfo{} }
func (m *DDRPerfInfo) String() string { return proto.CompactTextString(m) }
func (*DDRPerfInfo) ProtoMessage()    {}
func (*DDRPerfInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{94}
}
func (m *DDRPerfInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDRPerfInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDRPerfInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DDRPerfInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDRPerfInfo.Merge(m, src)
}
func (m *DDRPerfInfo) XXX_Size() int {
	return m.Size()
}
func (m *DDRPerfInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DDRPerfInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DDRPerfInfo proto.InternalMessageInfo

func (m *DDRPerfInfo) GetReads() uint64 {
	if m != nil {
		return m.Reads
	}
	return 0
}

func (m *DDRPerfInfo) GetReadLatencyMax() uint64 {
	if m != nil {
		return m.ReadLatencyMax
	}
	return 0
}

func (m *DDRPerfInfo) GetReadLatencyAvg() uint64 {
	if m != nil {
		return m.ReadLatencyAvg
	}
	return 0
}

func (m *DDRPerfInfo) GetReadMTPS() float32 {
	if m != nil {
		return m.ReadMTPS
	}
	return 0
}

func (m *DDRPerfInfo) GetReadBandwidth() float32 {
	if m != nil {
		return m.ReadBandwidth
	}
	return 0
}

func (m *DDRPerfInfo) GetWrites() uint64 {
	if m != nil {
		return m.Writes
	}
	return 0
}

func (m *DDRPerfInfo) GetWriteLatencyMax() uint64 {
	if m != nil {
		return m.WriteLatencyMax
	}
	return 0
}

func (m *DDRPerfInfo) GetWriteLatencyAvg() uint64 {
	if m != nil {
		return m.WriteLatencyAvg
	}
	return 0
}

func (m *DDRPerfInfo) GetWriteMTPS() float32 {
	if m != nil {
		return m.WriteMTPS
	}
	return 0
}

func (m *DDRPerfInfo) GetWriteBandwidth() float32 {
	if m != nil {
		return m.WriteBandwidth
	}
	return 0
}

// ASIC performance related status information
type AsicPerfGetResponse struct {
	// status reply
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// DDR related performance information
	DDRPerfInfo []*DDRPerfInfo `protobuf:"bytes,2,rep,name=DDRPerfInfo,proto3" json:"DDRPerfInfo,omitempty"`
	// per ASIC pipeline performance information
	PipelinePerfInfo     []*PipelinePerfInfo `protobuf:"bytes,3,rep,name=PipelinePerfInfo,proto3" json:"PipelinePerfInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AsicPerfGetResponse) Reset()         { *m = AsicPerfGetResponse{} }
func (m *AsicPerfGetResponse) String() string { return proto.CompactTextString(m) }
func (*AsicPerfGetResponse) ProtoMessage()    {}
func (*AsicPerfGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{95}
}
func (m *AsicPerfGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsicPerfGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AsicPerfGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AsicPerfGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsicPerfGetResponse.Merge(m, src)
}
func (m *AsicPerfGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *AsicPerfGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AsicPerfGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AsicPerfGetResponse proto.InternalMessageInfo

func (m *AsicPerfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AsicPerfGetResponse) GetDDRPerfInfo() []*DDRPerfInfo {
	if m != nil {
		return m.DDRPerfInfo
	}
	return nil
}

func (m *AsicPerfGetResponse) GetPipelinePerfInfo() []*PipelinePerfInfo {
	if m != nil {
		return m.PipelinePerfInfo
	}
	return nil
}

// NACL request message
type NaclRequest struct {
	// unique NACL id (used to delete the NACL later)
	Id uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// indicate whether to match tunneled (overlay) packets
	TunneledPacket bool `protobuf:"varint,2,opt,name=TunneledPacket,proto3" json:"TunneledPacket,omitempty"`
	// indicate whether to match packets that miss flow table lookup
	FlowMiss bool `protobuf:"varint,3,opt,name=FlowMiss,proto3" json:"FlowMiss,omitempty"`
	// indicate whether to match packets that are from/to unknown local mapping
	LocalMappingUnknown bool `protobuf:"varint,4,opt,name=LocalMappingUnknown,proto3" json:"LocalMappingUnknown,omitempty"`
	// indicate whether to match IP fragments
	IPFragment bool `protobuf:"varint,5,opt,name=IPFragment,proto3" json:"IPFragment,omitempty"`
	// packet direction (w.r.t vnic)
	Direction NaclRequest_PacketDir `protobuf:"varint,6,opt,name=Direction,proto3,enum=pds.NaclRequest_PacketDir" json:"Direction,omitempty"`
	// Types that are valid to be assigned to LifMatch:
	//	*NaclRequest_SrcLif
	//	*NaclRequest_SrcLifType
	LifMatch isNaclRequest_LifMatch `protobuf_oneof:"lif_match"`
	// Types that are valid to be assigned to MatchFields:
	//	*NaclRequest_L2Match
	//	*NaclRequest_IPMatch
	MatchFields isNaclRequest_MatchFields `protobuf_oneof:"match_fields"`
	// action indicates the action to be performed
	//
	// Types that are valid to be assigned to Action:
	//	*NaclRequest_Drop
	//	*NaclRequest_RedirectLifId
	Action               isNaclRequest_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NaclRequest) Reset()         { *m = NaclRequest{} }
func (m *NaclRequest) String() string { return proto.CompactTextString(m) }
func (*NaclRequest) ProtoMessage()    {}
func (*NaclRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96}
}
func (m *NaclRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest.Merge(m, src)
}
func (m *NaclRequest) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest proto.InternalMessageInfo

type isNaclRequest_LifMatch interface {
	isNaclRequest_LifMatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isNaclRequest_MatchFields interface {
	isNaclRequest_MatchFields()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isNaclRequest_Action interface {
	isNaclRequest_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NaclRequest_SrcLif struct {
	SrcLif []byte `protobuf:"bytes,7,opt,name=SrcLif,proto3,oneof"`
}
type NaclRequest_SrcLifType struct {
	SrcLifType LifType `protobuf:"varint,8,opt,name=SrcLifType,proto3,enum=types.LifType,oneof"`
}
type NaclRequest_L2Match struct {
	L2Match *NaclRequest_L2PacketMatch `protobuf:"bytes,9,opt,name=L2Match,proto3,oneof"`
}
type NaclRequest_IPMatch struct {
	IPMatch *NaclRequest_IPPacketMatch `protobuf:"bytes,10,opt,name=IPMatch,proto3,oneof"`
}
type NaclRequest_Drop struct {
	Drop bool `protobuf:"varint,11,opt,name=Drop,proto3,oneof"`
}
type NaclRequest_RedirectLifId struct {
	RedirectLifId []byte `protobuf:"bytes,12,opt,name=RedirectLifId,proto3,oneof"`
}

func (*NaclRequest_SrcLif) isNaclRequest_LifMatch()      {}
func (*NaclRequest_SrcLifType) isNaclRequest_LifMatch()  {}
func (*NaclRequest_L2Match) isNaclRequest_MatchFields()  {}
func (*NaclRequest_IPMatch) isNaclRequest_MatchFields()  {}
func (*NaclRequest_Drop) isNaclRequest_Action()          {}
func (*NaclRequest_RedirectLifId) isNaclRequest_Action() {}

func (m *NaclRequest) GetLifMatch() isNaclRequest_LifMatch {
	if m != nil {
		return m.LifMatch
	}
	return nil
}
func (m *NaclRequest) GetMatchFields() isNaclRequest_MatchFields {
	if m != nil {
		return m.MatchFields
	}
	return nil
}
func (m *NaclRequest) GetAction() isNaclRequest_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *NaclRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NaclRequest) GetTunneledPacket() bool {
	if m != nil {
		return m.TunneledPacket
	}
	return false
}

func (m *NaclRequest) GetFlowMiss() bool {
	if m != nil {
		return m.FlowMiss
	}
	return false
}

func (m *NaclRequest) GetLocalMappingUnknown() bool {
	if m != nil {
		return m.LocalMappingUnknown
	}
	return false
}

func (m *NaclRequest) GetIPFragment() bool {
	if m != nil {
		return m.IPFragment
	}
	return false
}

func (m *NaclRequest) GetDirection() NaclRequest_PacketDir {
	if m != nil {
		return m.Direction
	}
	return NaclRequest_PACKET_DIR_NONE
}

func (m *NaclRequest) GetSrcLif() []byte {
	if x, ok := m.GetLifMatch().(*NaclRequest_SrcLif); ok {
		return x.SrcLif
	}
	return nil
}

func (m *NaclRequest) GetSrcLifType() LifType {
	if x, ok := m.GetLifMatch().(*NaclRequest_SrcLifType); ok {
		return x.SrcLifType
	}
	return LifType_LIF_TYPE_NONE
}

func (m *NaclRequest) GetL2Match() *NaclRequest_L2PacketMatch {
	if x, ok := m.GetMatchFields().(*NaclRequest_L2Match); ok {
		return x.L2Match
	}
	return nil
}

func (m *NaclRequest) GetIPMatch() *NaclRequest_IPPacketMatch {
	if x, ok := m.GetMatchFields().(*NaclRequest_IPMatch); ok {
		return x.IPMatch
	}
	return nil
}

func (m *NaclRequest) GetDrop() bool {
	if x, ok := m.GetAction().(*NaclRequest_Drop); ok {
		return x.Drop
	}
	return false
}

func (m *NaclRequest) GetRedirectLifId() []byte {
	if x, ok := m.GetAction().(*NaclRequest_RedirectLifId); ok {
		return x.RedirectLifId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NaclRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NaclRequest_SrcLif)(nil),
		(*NaclRequest_SrcLifType)(nil),
		(*NaclRequest_L2Match)(nil),
		(*NaclRequest_IPMatch)(nil),
		(*NaclRequest_Drop)(nil),
		(*NaclRequest_RedirectLifId)(nil),
	}
}

// match condition for L2 packets (ARP, ARP etc.)
type NaclRequest_L2PacketMatch struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclRequest_L2PacketMatch) Reset()         { *m = NaclRequest_L2PacketMatch{} }
func (m *NaclRequest_L2PacketMatch) String() string { return proto.CompactTextString(m) }
func (*NaclRequest_L2PacketMatch) ProtoMessage()    {}
func (*NaclRequest_L2PacketMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 0}
}
func (m *NaclRequest_L2PacketMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_L2PacketMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_L2PacketMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_L2PacketMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_L2PacketMatch.Merge(m, src)
}
func (m *NaclRequest_L2PacketMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_L2PacketMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_L2PacketMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_L2PacketMatch proto.InternalMessageInfo

// IP protocol match condition
type NaclRequest_IPProtocolMatch struct {
	// IP Protocol number
	Protocol             uint32   `protobuf:"varint,1,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclRequest_IPProtocolMatch) Reset()         { *m = NaclRequest_IPProtocolMatch{} }
func (m *NaclRequest_IPProtocolMatch) String() string { return proto.CompactTextString(m) }
func (*NaclRequest_IPProtocolMatch) ProtoMessage()    {}
func (*NaclRequest_IPProtocolMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 1}
}
func (m *NaclRequest_IPProtocolMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPProtocolMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPProtocolMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPProtocolMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPProtocolMatch.Merge(m, src)
}
func (m *NaclRequest_IPProtocolMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPProtocolMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPProtocolMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPProtocolMatch proto.InternalMessageInfo

func (m *NaclRequest_IPProtocolMatch) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

type NaclRequest_IPPacketMatch struct {
	// source IP prefix
	SrcPrefix *IPPrefix `protobuf:"bytes,1,opt,name=SrcPrefix,proto3" json:"SrcPrefix,omitempty"`
	// destination IP prefix
	DstPrefix *IPPrefix                    `protobuf:"bytes,2,opt,name=DstPrefix,proto3" json:"DstPrefix,omitempty"`
	IPProto   *NaclRequest_IPProtocolMatch `protobuf:"bytes,3,opt,name=IPProto,proto3" json:"IPProto,omitempty"`
	// layer 4 match conditions
	//
	// Types that are valid to be assigned to L4Match:
	//	*NaclRequest_IPPacketMatch_TcpUdpMatch
	//	*NaclRequest_IPPacketMatch_IcmpMatch
	L4Match              isNaclRequest_IPPacketMatch_L4Match `protobuf_oneof:"l4_match"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *NaclRequest_IPPacketMatch) Reset()         { *m = NaclRequest_IPPacketMatch{} }
func (m *NaclRequest_IPPacketMatch) String() string { return proto.CompactTextString(m) }
func (*NaclRequest_IPPacketMatch) ProtoMessage()    {}
func (*NaclRequest_IPPacketMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2}
}
func (m *NaclRequest_IPPacketMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch proto.InternalMessageInfo

type isNaclRequest_IPPacketMatch_L4Match interface {
	isNaclRequest_IPPacketMatch_L4Match()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NaclRequest_IPPacketMatch_TcpUdpMatch struct {
	TcpUdpMatch *NaclRequest_IPPacketMatch_TCPUDPMatch `protobuf:"bytes,4,opt,name=TcpUdpMatch,proto3,oneof"`
}
type NaclRequest_IPPacketMatch_IcmpMatch struct {
	IcmpMatch *NaclRequest_IPPacketMatch_ICMPMatch `protobuf:"bytes,5,opt,name=IcmpMatch,proto3,oneof"`
}

func (*NaclRequest_IPPacketMatch_TcpUdpMatch) isNaclRequest_IPPacketMatch_L4Match() {}
func (*NaclRequest_IPPacketMatch_IcmpMatch) isNaclRequest_IPPacketMatch_L4Match()   {}

func (m *NaclRequest_IPPacketMatch) GetL4Match() isNaclRequest_IPPacketMatch_L4Match {
	if m != nil {
		return m.L4Match
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch) GetIPProto() *NaclRequest_IPProtocolMatch {
	if m != nil {
		return m.IPProto
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch) GetTcpUdpMatch() *NaclRequest_IPPacketMatch_TCPUDPMatch {
	if x, ok := m.GetL4Match().(*NaclRequest_IPPacketMatch_TcpUdpMatch); ok {
		return x.TcpUdpMatch
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch) GetIcmpMatch() *NaclRequest_IPPacketMatch_ICMPMatch {
	if x, ok := m.GetL4Match().(*NaclRequest_IPPacketMatch_IcmpMatch); ok {
		return x.IcmpMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NaclRequest_IPPacketMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NaclRequest_IPPacketMatch_TcpUdpMatch)(nil),
		(*NaclRequest_IPPacketMatch_IcmpMatch)(nil),
	}
}

// TCP or UDP match conditions
type NaclRequest_IPPacketMatch_TCPUDPMatch struct {
	// source port
	SrcPort *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch `protobuf:"bytes,1,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	// destination port
	DstPort              *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch `protobuf:"bytes,2,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) Reset()         { *m = NaclRequest_IPPacketMatch_TCPUDPMatch{} }
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) String() string { return proto.CompactTextString(m) }
func (*NaclRequest_IPPacketMatch_TCPUDPMatch) ProtoMessage()    {}
func (*NaclRequest_IPPacketMatch_TCPUDPMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2, 0}
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch proto.InternalMessageInfo

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) GetSrcPort() *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch {
	if m != nil {
		return m.SrcPort
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) GetDstPort() *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch {
	if m != nil {
		return m.DstPort
	}
	return nil
}

type NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch struct {
	Port                 uint32   `protobuf:"varint,1,opt,name=Port,proto3" json:"Port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) Reset() {
	*m = NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch{}
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) String() string {
	return proto.CompactTextString(m)
}
func (*NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) ProtoMessage() {}
func (*NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2, 0, 0}
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch proto.InternalMessageInfo

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// ICMP match conditions
type NaclRequest_IPPacketMatch_ICMPMatch struct {
	// ICMP type
	Type *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// ICMP code
	Code                 *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode `protobuf:"bytes,2,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) Reset()         { *m = NaclRequest_IPPacketMatch_ICMPMatch{} }
func (m *NaclRequest_IPPacketMatch_ICMPMatch) String() string { return proto.CompactTextString(m) }
func (*NaclRequest_IPPacketMatch_ICMPMatch) ProtoMessage()    {}
func (*NaclRequest_IPPacketMatch_ICMPMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2, 1}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch proto.InternalMessageInfo

func (m *NaclRequest_IPPacketMatch_ICMPMatch) GetType() *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) GetCode() *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode {
	if m != nil {
		return m.Code
	}
	return nil
}

type NaclRequest_IPPacketMatch_ICMPMatch_ICMPType struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) Reset() {
	*m = NaclRequest_IPPacketMatch_ICMPMatch_ICMPType{}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) String() string {
	return proto.CompactTextString(m)
}
func (*NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) ProtoMessage() {}
func (*NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2, 1, 0}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPType.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPType.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPType proto.InternalMessageInfo

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) Reset() {
	*m = NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode{}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) String() string {
	return proto.CompactTextString(m)
}
func (*NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) ProtoMessage() {}
func (*NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{96, 2, 1, 1}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode.Merge(m, src)
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) XXX_Size() int {
	return m.Size()
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode.DiscardUnknown(m)
}

var xxx_messageInfo_NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode proto.InternalMessageInfo

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// NACL response message
type NaclResponse struct {
	// response code
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NaclResponse) Reset()         { *m = NaclResponse{} }
func (m *NaclResponse) String() string { return proto.CompactTextString(m) }
func (*NaclResponse) ProtoMessage()    {}
func (*NaclResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{97}
}
func (m *NaclResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclResponse.Merge(m, src)
}
func (m *NaclResponse) XXX_Size() int {
	return m.Size()
}
func (m *NaclResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NaclResponse proto.InternalMessageInfo

func (m *NaclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NACL delete request
type NaclDeleteRequest struct {
	// unique NACL id
	Id                   uint32   `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NaclDeleteRequest) Reset()         { *m = NaclDeleteRequest{} }
func (m *NaclDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*NaclDeleteRequest) ProtoMessage()    {}
func (*NaclDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{98}
}
func (m *NaclDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclDeleteRequest.Merge(m, src)
}
func (m *NaclDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NaclDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NaclDeleteRequest proto.InternalMessageInfo

func (m *NaclDeleteRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// NACL delete response
type NaclDeleteResponse struct {
	// status code
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NaclDeleteResponse) Reset()         { *m = NaclDeleteResponse{} }
func (m *NaclDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*NaclDeleteResponse) ProtoMessage()    {}
func (*NaclDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{99}
}
func (m *NaclDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NaclDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NaclDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NaclDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NaclDeleteResponse.Merge(m, src)
}
func (m *NaclDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NaclDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NaclDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NaclDeleteResponse proto.InternalMessageInfo

func (m *NaclDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type ElamResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Output               string    `protobuf:"bytes,2,opt,name=Output,proto3" json:"Output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ElamResponse) Reset()         { *m = ElamResponse{} }
func (m *ElamResponse) String() string { return proto.CompactTextString(m) }
func (*ElamResponse) ProtoMessage()    {}
func (*ElamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{100}
}
func (m *ElamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElamResponse.Merge(m, src)
}
func (m *ElamResponse) XXX_Size() int {
	return m.Size()
}
func (m *ElamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ElamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ElamResponse proto.InternalMessageInfo

func (m *ElamResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ElamResponse) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// thread configuration
type ThreadSpec struct {
	// Internal unique thread id
	Id uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// pthread identifier
	PthreadId uint32 `protobuf:"varint,2,opt,name=PthreadId,proto3" json:"PthreadId,omitempty"`
	// Name of the thread
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	// thread priority
	Priority int32 `protobuf:"varint,4,opt,name=Priority,proto3" json:"Priority,omitempty"`
	// scheduling policy of the thread (SCHED_FIFO| SCHED_RR | SCHED_OTHER)
	SchedPolicy SchedPolicy `protobuf:"varint,5,opt,name=SchedPolicy,proto3,enum=pds.SchedPolicy" json:"SchedPolicy,omitempty"`
	// role of this thread (CONTROL or DATA)
	Role                 ThreadRole `protobuf:"varint,6,opt,name=Role,proto3,enum=pds.ThreadRole" json:"Role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ThreadSpec) Reset()         { *m = ThreadSpec{} }
func (m *ThreadSpec) String() string { return proto.CompactTextString(m) }
func (*ThreadSpec) ProtoMessage()    {}
func (*ThreadSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{101}
}
func (m *ThreadSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadSpec.Merge(m, src)
}
func (m *ThreadSpec) XXX_Size() int {
	return m.Size()
}
func (m *ThreadSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadSpec proto.InternalMessageInfo

func (m *ThreadSpec) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ThreadSpec) GetPthreadId() uint32 {
	if m != nil {
		return m.PthreadId
	}
	return 0
}

func (m *ThreadSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ThreadSpec) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *ThreadSpec) GetSchedPolicy() SchedPolicy {
	if m != nil {
		return m.SchedPolicy
	}
	return SchedPolicy_SCHED_POLICY_NONE
}

func (m *ThreadSpec) GetRole() ThreadRole {
	if m != nil {
		return m.Role
	}
	return ThreadRole_THREAD_ROLE_NONE
}

// operational status of the thread
type ThreadStatus struct {
	// Running is true if thread is in running state
	Running bool `protobuf:"varint,1,opt,name=Running,proto3" json:"Running,omitempty"`
	// time (in nanoseconds) since last heart beat
	LastHeartBeatTime    uint64   `protobuf:"varint,2,opt,name=LastHeartBeatTime,proto3" json:"LastHeartBeatTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThreadStatus) Reset()         { *m = ThreadStatus{} }
func (m *ThreadStatus) String() string { return proto.CompactTextString(m) }
func (*ThreadStatus) ProtoMessage()    {}
func (*ThreadStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{102}
}
func (m *ThreadStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadStatus.Merge(m, src)
}
func (m *ThreadStatus) XXX_Size() int {
	return m.Size()
}
func (m *ThreadStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadStatus proto.InternalMessageInfo

func (m *ThreadStatus) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

func (m *ThreadStatus) GetLastHeartBeatTime() uint64 {
	if m != nil {
		return m.LastHeartBeatTime
	}
	return 0
}

// per thread statistics
type ThreadStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThreadStats) Reset()         { *m = ThreadStats{} }
func (m *ThreadStats) String() string { return proto.CompactTextString(m) }
func (*ThreadStats) ProtoMessage()    {}
func (*ThreadStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{103}
}
func (m *ThreadStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadStats.Merge(m, src)
}
func (m *ThreadStats) XXX_Size() int {
	return m.Size()
}
func (m *ThreadStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadStats.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadStats proto.InternalMessageInfo

type Thread struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *ThreadSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *ThreadStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *ThreadStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Thread) Reset()         { *m = Thread{} }
func (m *Thread) String() string { return proto.CompactTextString(m) }
func (*Thread) ProtoMessage()    {}
func (*Thread) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{104}
}
func (m *Thread) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Thread) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Thread.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Thread) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Thread.Merge(m, src)
}
func (m *Thread) XXX_Size() int {
	return m.Size()
}
func (m *Thread) XXX_DiscardUnknown() {
	xxx_messageInfo_Thread.DiscardUnknown(m)
}

var xxx_messageInfo_Thread proto.InternalMessageInfo

func (m *Thread) GetSpec() *ThreadSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Thread) GetStatus() *ThreadStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Thread) GetStats() *ThreadStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type ThreadGetResponse struct {
	// response status code
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// per thread information
	Response             []*Thread `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ThreadGetResponse) Reset()         { *m = ThreadGetResponse{} }
func (m *ThreadGetResponse) String() string { return proto.CompactTextString(m) }
func (*ThreadGetResponse) ProtoMessage()    {}
func (*ThreadGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{105}
}
func (m *ThreadGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadGetResponse.Merge(m, src)
}
func (m *ThreadGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ThreadGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadGetResponse proto.InternalMessageInfo

func (m *ThreadGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ThreadGetResponse) GetResponse() []*Thread {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.TraceLevel", TraceLevel_name, TraceLevel_value)
	proto.RegisterEnum("pds.TableApiStatsType", TableApiStatsType_name, TableApiStatsType_value)
	proto.RegisterEnum("pds.TableStatsType", TableStatsType_name, TableStatsType_value)
	proto.RegisterEnum("pds.LlcCounterType", LlcCounterType_name, LlcCounterType_value)
	proto.RegisterEnum("pds.OflowFifoDropType", OflowFifoDropType_name, OflowFifoDropType_value)
	proto.RegisterEnum("pds.BufferDropReasons", BufferDropReasons_name, BufferDropReasons_value)
	proto.RegisterEnum("pds.PacketBufferPortType", PacketBufferPortType_name, PacketBufferPortType_value)
	proto.RegisterEnum("pds.MappingDumpType", MappingDumpType_name, MappingDumpType_value)
	proto.RegisterEnum("pds.Command", Command_name, Command_value)
	proto.RegisterEnum("pds.IntPortDplxMode", IntPortDplxMode_name, IntPortDplxMode_value)
	proto.RegisterEnum("pds.Pipeline", Pipeline_name, Pipeline_value)
	proto.RegisterEnum("pds.SchedPolicy", SchedPolicy_name, SchedPolicy_value)
	proto.RegisterEnum("pds.ThreadRole", ThreadRole_name, ThreadRole_value)
	proto.RegisterEnum("pds.NaclRequest_PacketDir", NaclRequest_PacketDir_name, NaclRequest_PacketDir_value)
	proto.RegisterType((*TraceRequest)(nil), "pds.TraceRequest")
	proto.RegisterType((*TraceResponse)(nil), "pds.TraceResponse")
	proto.RegisterType((*TraceLevelGetResponse)(nil), "pds.TraceLevelGetResponse")
	proto.RegisterType((*TableApiStatsEntry)(nil), "pds.TableApiStatsEntry")
	proto.RegisterType((*TableApiStats)(nil), "pds.TableApiStats")
	proto.RegisterType((*TableStatsEntry)(nil), "pds.TableStatsEntry")
	proto.RegisterType((*TableStats)(nil), "pds.TableStats")
	proto.RegisterType((*TableStatsResponse)(nil), "pds.TableStatsResponse")
	proto.RegisterType((*TableStatsGetResponse)(nil), "pds.TableStatsGetResponse")
	proto.RegisterType((*LlcSetupRequest)(nil), "pds.LlcSetupRequest")
	proto.RegisterType((*LlcSetupResponse)(nil), "pds.LlcSetupResponse")
	proto.RegisterType((*LlcStats)(nil), "pds.LlcStats")
	proto.RegisterType((*LlcStatsGetResponse)(nil), "pds.LlcStatsGetResponse")
	proto.RegisterType((*OflowFifoDropStatsEntry)(nil), "pds.OflowFifoDropStatsEntry")
	proto.RegisterType((*OflowFifoDropStats)(nil), "pds.OflowFifoDropStats")
	proto.RegisterType((*OflowFifoStats)(nil), "pds.OflowFifoStats")
	proto.RegisterType((*BufferDropStatsEntry)(nil), "pds.BufferDropStatsEntry")
	proto.RegisterType((*BufferDropStats)(nil), "pds.BufferDropStats")
	proto.RegisterType((*BufferStats)(nil), "pds.BufferStats")
	proto.RegisterType((*PacketBufferPort)(nil), "pds.PacketBufferPort")
	proto.RegisterType((*QosInputOflowQueueStats)(nil), "pds.QosInputOflowQueueStats")
	proto.RegisterType((*QosInputQueueStats)(nil), "pds.QosInputQueueStats")
	proto.RegisterType((*QosOutputQueueStats)(nil), "pds.QosOutputQueueStats")
	proto.RegisterType((*QosQueueStats)(nil), "pds.QosQueueStats")
	proto.RegisterType((*PacketBufferPortStats)(nil), "pds.PacketBufferPortStats")
	proto.RegisterType((*PacketBufferStats)(nil), "pds.PacketBufferStats")
	proto.RegisterType((*PbStatsGetResponse)(nil), "pds.PbStatsGetResponse")
	proto.RegisterType((*PbStatsSummary)(nil), "pds.PbStatsSummary")
	proto.RegisterType((*PbStatsSummaryGetResponse)(nil), "pds.PbStatsSummaryGetResponse")
	proto.RegisterType((*MemTrackSpec)(nil), "pds.MemTrackSpec")
	proto.RegisterType((*MemTrackStatus)(nil), "pds.MemTrackStatus")
	proto.RegisterType((*MemTrackStats)(nil), "pds.MemTrackStats")
	proto.RegisterType((*MemTrackGetRequest)(nil), "pds.MemTrackGetRequest")
	proto.RegisterType((*MemTrackGetResponse)(nil), "pds.MemTrackGetResponse")
	proto.RegisterType((*HeapStats)(nil), "pds.HeapStats")
	proto.RegisterType((*HeapGetRequest)(nil), "pds.HeapGetRequest")
	proto.RegisterType((*HeapGetResponse)(nil), "pds.HeapGetResponse")
	proto.RegisterType((*L3HWMappingKey)(nil), "pds.L3HWMappingKey")
	proto.RegisterType((*L2HWMappingKey)(nil), "pds.L2HWMappingKey")
	proto.RegisterType((*HWMappingKey)(nil), "pds.HWMappingKey")
	proto.RegisterType((*MappingDumpFilter)(nil), "pds.MappingDumpFilter")
	proto.RegisterType((*CommandUUID)(nil), "pds.CommandUUID")
	proto.RegisterType((*InterfaceDumpFilter)(nil), "pds.InterfaceDumpFilter")
	proto.RegisterType((*DatapathAssist)(nil), "pds.DatapathAssist")
	proto.RegisterType((*CommandMessage)(nil), "pds.CommandMessage")
	proto.RegisterType((*AacsRequest)(nil), "pds.AacsRequest")
	proto.RegisterType((*SlabSpec)(nil), "pds.SlabSpec")
	proto.RegisterType((*SlabStatus)(nil), "pds.SlabStatus")
	proto.RegisterType((*SlabStats)(nil), "pds.SlabStats")
	proto.RegisterType((*Slab)(nil), "pds.Slab")
	proto.RegisterType((*SlabGetResponse)(nil), "pds.SlabGetResponse")
	proto.RegisterType((*DatapathMemoryGetResponse)(nil), "pds.DatapathMemoryGetResponse")
	proto.RegisterType((*InternalPortStatus)(nil), "pds.InternalPortStatus")
	proto.RegisterType((*InternalPortStats)(nil), "pds.InternalPortStats")
	proto.RegisterType((*InternalPortResponse)(nil), "pds.InternalPortResponse")
	proto.RegisterType((*InternalPortResponseMsg)(nil), "pds.InternalPortResponseMsg")
	proto.RegisterType((*InternalPortRequest)(nil), "pds.InternalPortRequest")
	proto.RegisterType((*InternalPortRequestMsg)(nil), "pds.InternalPortRequestMsg")
	proto.RegisterType((*EepromAddress)(nil), "pds.EepromAddress")
	proto.RegisterType((*EepromPage)(nil), "pds.EepromPage")
	proto.RegisterType((*EepromReadResponse)(nil), "pds.EepromReadResponse")
	proto.RegisterType((*EepromReadResponseMsg)(nil), "pds.EepromReadResponseMsg")
	proto.RegisterType((*EepromReadRequest)(nil), "pds.EepromReadRequest")
	proto.RegisterType((*EepromReadRequestMsg)(nil), "pds.EepromReadRequestMsg")
	proto.RegisterType((*EepromWriteResponseMsg)(nil), "pds.EepromWriteResponseMsg")
	proto.RegisterType((*EepromWriteRequest)(nil), "pds.EepromWriteRequest")
	proto.RegisterType((*EepromWriteRequestMsg)(nil), "pds.EepromWriteRequestMsg")
	proto.RegisterType((*LearnDedupIntervalRequest)(nil), "pds.LearnDedupIntervalRequest")
	proto.RegisterType((*TcpProxySessionFilter)(nil), "pds.TcpProxySessionFilter")
	proto.RegisterType((*TcpProxySessionReq)(nil), "pds.TcpProxySessionReq")
	proto.RegisterType((*TcpProxyFlow)(nil), "pds.TcpProxyFlow")
	proto.RegisterType((*TcpProxySessionGetRequest)(nil), "pds.TcpProxySessionGetRequest")
	proto.RegisterType((*TcpProxySession)(nil), "pds.TcpProxySession")
	proto.RegisterType((*TcpProxySessionGetResponse)(nil), "pds.TcpProxySessionGetResponse")
	proto.RegisterType((*TcpProxyGlobalStatsGetResponse)(nil), "pds.TcpProxyGlobalStatsGetResponse")
	proto.RegisterType((*TcpProxyGlobalStats)(nil), "pds.TcpProxyGlobalStats")
	proto.RegisterType((*TcpProxyGlobalCfg)(nil), "pds.TcpProxyGlobalCfg")
	proto.RegisterType((*TcpProxyGlobalCfgRequest)(nil), "pds.TcpProxyGlobalCfgRequest")
	proto.RegisterType((*TcpProxyGlobalCfgResponse)(nil), "pds.TcpProxyGlobalCfgResponse")
	proto.RegisterType((*TcpCbSpec)(nil), "pds.TcpCbSpec")
	proto.RegisterType((*TcpCbOoqStatus)(nil), "pds.TcpCbOoqStatus")
	proto.RegisterType((*TcpCbStatus)(nil), "pds.TcpCbStatus")
	proto.RegisterType((*TcpCbRequest)(nil), "pds.TcpCbRequest")
	proto.RegisterType((*TcpCbGetRequest)(nil), "pds.TcpCbGetRequest")
	proto.RegisterType((*TcpCbStats)(nil), "pds.TcpCbStats")
	proto.RegisterType((*TcpCbResponse)(nil), "pds.TcpCbResponse")
	proto.RegisterType((*TcpCbGetResponse)(nil), "pds.TcpCbGetResponse")
	proto.RegisterType((*FlowTracerSpec)(nil), "pds.FlowTracerSpec")
	proto.RegisterType((*FlowTracerRequest)(nil), "pds.FlowTracerRequest")
	proto.RegisterType((*FlowTracerStatus)(nil), "pds.FlowTracerStatus")
	proto.RegisterType((*FlowTracerResponse)(nil), "pds.FlowTracerResponse")
	proto.RegisterType((*MPUPerfInfo)(nil), "pds.MPUPerfInfo")
	proto.RegisterType((*PipelineStagePerfInfo)(nil), "pds.PipelineStagePerfInfo")
	proto.RegisterType((*PipelinePerfInfo)(nil), "pds.PipelinePerfInfo")
	proto.RegisterType((*DDRPerfInfo)(nil), "pds.DDRPerfInfo")
	proto.RegisterType((*AsicPerfGetResponse)(nil), "pds.AsicPerfGetResponse")
	proto.RegisterType((*NaclRequest)(nil), "pds.NaclRequest")
	proto.RegisterType((*NaclRequest_L2PacketMatch)(nil), "pds.NaclRequest.L2PacketMatch")
	proto.RegisterType((*NaclRequest_IPProtocolMatch)(nil), "pds.NaclRequest.IPProtocolMatch")
	proto.RegisterType((*NaclRequest_IPPacketMatch)(nil), "pds.NaclRequest.IPPacketMatch")
	proto.RegisterType((*NaclRequest_IPPacketMatch_TCPUDPMatch)(nil), "pds.NaclRequest.IPPacketMatch.TCPUDPMatch")
	proto.RegisterType((*NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch)(nil), "pds.NaclRequest.IPPacketMatch.TCPUDPMatch.PortMatch")
	proto.RegisterType((*NaclRequest_IPPacketMatch_ICMPMatch)(nil), "pds.NaclRequest.IPPacketMatch.ICMPMatch")
	proto.RegisterType((*NaclRequest_IPPacketMatch_ICMPMatch_ICMPType)(nil), "pds.NaclRequest.IPPacketMatch.ICMPMatch.ICMPType")
	proto.RegisterType((*NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode)(nil), "pds.NaclRequest.IPPacketMatch.ICMPMatch.ICMPCode")
	proto.RegisterType((*NaclResponse)(nil), "pds.NaclResponse")
	proto.RegisterType((*NaclDeleteRequest)(nil), "pds.NaclDeleteRequest")
	proto.RegisterType((*NaclDeleteResponse)(nil), "pds.NaclDeleteResponse")
	proto.RegisterType((*ElamResponse)(nil), "pds.ElamResponse")
	proto.RegisterType((*ThreadSpec)(nil), "pds.ThreadSpec")
	proto.RegisterType((*ThreadStatus)(nil), "pds.ThreadStatus")
	proto.RegisterType((*ThreadStats)(nil), "pds.ThreadStats")
	proto.RegisterType((*Thread)(nil), "pds.Thread")
	proto.RegisterType((*ThreadGetResponse)(nil), "pds.ThreadGetResponse")
}

func init() { proto.RegisterFile("debug.proto", fileDescriptor_8d9d361be58531fb) }

var fileDescriptor_8d9d361be58531fb = []byte{
	// 8566 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0xbc, 0x59, 0x6c, 0x1c, 0x49,
	0x9a, 0x1f, 0xce, 0xe2, 0xcd, 0xe0, 0x95, 0x0c, 0x51, 0x64, 0x8a, 0x52, 0x4b, 0xea, 0xec, 0x4b,
	0xc3, 0x56, 0xab, 0x25, 0x4a, 0xea, 0xee, 0xe9, 0xfe, 0xef, 0xf4, 0x64, 0x65, 0x25, 0xc5, 0x9c,
	0xae, 0x23, 0x15, 0x55, 0x45, 0x4d, 0xcf, 0xff, 0xa1, 0x9c, 0xac, 0x0a, 0x52, 0xb9, 0xaa, 0xca,
	0x2c, 0x65, 0x66, 0x51, 0xe4, 0x62, 0xe0, 0x05, 0x76, 0x61, 0xc0, 0x30, 0xfc, 0xb2, 0xb6, 0xd7,
	0x5e, 0x9f, 0xeb, 0xfb, 0xbe, 0x66, 0xbd, 0x86, 0x01, 0x1f, 0x4f, 0x63, 0xc0, 0x36, 0x8c, 0x35,
	0x16, 0xb0, 0x5f, 0xfc, 0xe0, 0x86, 0x31, 0x2f, 0x06, 0xc6, 0x5e, 0x1f, 0xb3, 0x2f, 0x06, 0xec,
	0x07, 0xe3, 0x8b, 0x23, 0x33, 0x32, 0xab, 0xd8, 0xad, 0x95, 0xfc, 0xe0, 0x17, 0xb2, 0xe2, 0xf7,
	0x1d, 0xf1, 0xc5, 0x17, 0xd7, 0x17, 0x47, 0x06, 0x5a, 0xee, 0xd1, 0xa3, 0xd1, 0xc9, 0x9d, 0x61,
	0x14, 0x26, 0x21, 0x9e, 0x19, 0xf6, 0xe2, 0x1d, 0x74, 0x12, 0x9e, 0x84, 0x1c, 0xd8, 0x59, 0x1f,
	0xd0, 0xc4, 0xfb, 0x10, 0xfe, 0x08, 0x60, 0x39, 0x39, 0x1f, 0xd2, 0x58, 0x52, 0xfd, 0x20, 0xa1,
	0xd1, 0xb1, 0xd7, 0xa5, 0x02, 0xb8, 0x72, 0x12, 0x86, 0x27, 0x7d, 0xfa, 0x21, 0x4b, 0x1d, 0x8d,
	0x8e, 0x3f, 0xf4, 0x82, 0x73, 0x4e, 0x32, 0xbe, 0x8b, 0x56, 0x5a, 0x91, 0xd7, 0xa5, 0x84, 0x3e,
	0x1f, 0xd1, 0x38, 0xc1, 0x77, 0xd1, 0x72, 0x02, 0xe9, 0x4e, 0x9f, 0x9e, 0xd2, 0xbe, 0x5e, 0xba,
	0x59, 0xba, 0xb5, 0xb6, 0xb7, 0x7e, 0x67, 0xd8, 0x8b, 0xef, 0x30, 0xbe, 0x2a, 0xc0, 0x04, 0x25,
	0xe9, 0x6f, 0x63, 0x88, 0x56, 0x85, 0x86, 0x78, 0x18, 0x06, 0x31, 0xc5, 0x77, 0xd0, 0x92, 0x39,
	0xf4, 0x9b, 0x89, 0x97, 0x8c, 0x62, 0xa1, 0x40, 0xbb, 0xc3, 0xed, 0x4b, 0x71, 0x92, 0xb1, 0xe0,
	0x0f, 0x11, 0xca, 0x54, 0xeb, 0xd3, 0x17, 0xe4, 0x98, 0xfd, 0x36, 0x0e, 0xd0, 0xe5, 0x2c, 0xf5,
	0x88, 0x26, 0x69, 0xce, 0x79, 0x4d, 0xa5, 0x6f, 0xd6, 0x74, 0x88, 0x70, 0xcb, 0x3b, 0xea, 0x53,
	0x61, 0x4c, 0x6c, 0x07, 0x49, 0x74, 0x8e, 0x77, 0xd1, 0x6c, 0xeb, 0x7c, 0x48, 0x85, 0x82, 0x2d,
	0xae, 0x40, 0x65, 0x03, 0x2a, 0x61, 0x3c, 0x78, 0x13, 0xcd, 0x59, 0xe1, 0x28, 0x48, 0x98, 0xdd,
	0xab, 0x84, 0x27, 0x8c, 0xef, 0xa0, 0xd5, 0x9c, 0x00, 0xfe, 0x00, 0xcd, 0x31, 0xdd, 0x7a, 0xe9,
	0xe6, 0xcc, 0xad, 0xe5, 0xbd, 0xed, 0x71, 0x9d, 0x8c, 0x4c, 0x38, 0x97, 0xe1, 0xa2, 0x75, 0x46,
	0x54, 0x8c, 0x7a, 0x2f, 0x67, 0xd4, 0xa5, 0x4c, 0xc1, 0xcb, 0x59, 0xf4, 0x09, 0x42, 0x19, 0x37,
	0xde, 0xcd, 0x9b, 0xb3, 0x59, 0xd0, 0x96, 0xb3, 0xe5, 0x47, 0x25, 0xe1, 0x24, 0x46, 0x4a, 0x7d,
	0x7d, 0x0d, 0x2d, 0x31, 0xb4, 0xee, 0x0d, 0xb8, 0x51, 0x4b, 0x24, 0x03, 0xf0, 0x1d, 0xb4, 0x28,
	0x0b, 0xc6, 0xec, 0x58, 0xde, 0xc3, 0xe3, 0x45, 0x26, 0x29, 0x0f, 0xab, 0xb9, 0x34, 0x0f, 0x7d,
	0x86, 0x49, 0xac, 0x17, 0xac, 0x22, 0x6a, 0x09, 0x64, 0xf6, 0x4d, 0xff, 0x17, 0xa8, 0x3e, 0xcb,
	0x4a, 0x9a, 0x01, 0xc6, 0x0f, 0xd1, 0xe5, 0x8c, 0x57, 0x6d, 0x21, 0xbf, 0xd7, 0xb6, 0x79, 0x1f,
	0x2d, 0x4a, 0x59, 0x7d, 0xba, 0x58, 0x75, 0x39, 0x87, 0x90, 0x94, 0xd1, 0xf8, 0x14, 0xad, 0x57,
	0xfb, 0xdd, 0x26, 0x4d, 0x46, 0x43, 0xd9, 0xad, 0x26, 0xd5, 0x5e, 0xb5, 0xdf, 0x65, 0x75, 0x43,
	0xa3, 0xac, 0xf6, 0x8c, 0x32, 0xd2, 0x32, 0xd9, 0x57, 0x33, 0xda, 0x70, 0xd0, 0x22, 0xe8, 0x60,
	0x7e, 0x7a, 0xd9, 0x8c, 0xd5, 0x66, 0x33, 0x93, 0x35, 0x9b, 0x9f, 0x47, 0x97, 0xa4, 0xaa, 0xd7,
	0x71, 0xe3, 0x5b, 0x68, 0x4e, 0x6d, 0x0b, 0xab, 0xd2, 0x0c, 0xee, 0x41, 0x4e, 0x33, 0xfe, 0x7f,
	0xb4, 0xdd, 0x38, 0xee, 0x87, 0x2f, 0xf6, 0xfd, 0xe3, 0xb0, 0x12, 0x85, 0xc3, 0x6f, 0xe8, 0x91,
	0x39, 0xde, 0x6f, 0x6c, 0xff, 0x07, 0x08, 0x8f, 0x2b, 0xc7, 0x7b, 0xf9, 0x7e, 0x70, 0x6d, 0x5c,
	0xf1, 0x78, 0x7f, 0xf8, 0xad, 0x12, 0x5a, 0x4b, 0x59, 0xb8, 0x9a, 0xeb, 0x08, 0x35, 0xc3, 0x21,
	0xcb, 0xc8, 0x09, 0x98, 0x91, 0xab, 0x44, 0x41, 0x80, 0x6e, 0x67, 0x74, 0x6e, 0x97, 0x82, 0xe0,
	0x9b, 0x68, 0x59, 0x72, 0x37, 0x46, 0x09, 0x6b, 0xfe, 0xab, 0x44, 0x85, 0x80, 0xc3, 0x56, 0x38,
	0x78, 0x83, 0x57, 0x21, 0xfc, 0x31, 0x42, 0x60, 0x2f, 0x4b, 0xc7, 0xfa, 0x1c, 0xf3, 0xf3, 0xf6,
	0x05, 0xe5, 0x21, 0x0a, 0xab, 0x71, 0x8c, 0x36, 0xcb, 0xa3, 0xe3, 0x63, 0x1a, 0x15, 0x7c, 0x7e,
	0x17, 0x2d, 0x10, 0xea, 0xc5, 0x61, 0x10, 0xe7, 0xdc, 0x9e, 0xf1, 0x0a, 0x2a, 0x91, 0x6c, 0xd0,
	0x27, 0x53, 0xbd, 0xa2, 0x94, 0x19, 0x00, 0x63, 0x5a, 0x21, 0x1f, 0xfc, 0x73, 0x68, 0x25, 0xcd,
	0xd0, 0xa7, 0xb1, 0xa8, 0x85, 0x2b, 0x85, 0x7c, 0x94, 0x2a, 0xc8, 0xb1, 0x1b, 0xff, 0xa2, 0x84,
	0x96, 0x39, 0xdb, 0xff, 0x3b, 0xd5, 0xf0, 0x60, 0x42, 0x35, 0x6c, 0x4e, 0x2a, 0x50, 0xae, 0x0e,
	0xba, 0x48, 0x73, 0xbd, 0xee, 0x33, 0x9a, 0x70, 0x26, 0x37, 0x8c, 0x12, 0xfc, 0x10, 0x2d, 0xc2,
	0x7f, 0xa5, 0xdd, 0x73, 0xc7, 0x14, 0x19, 0x59, 0xd3, 0x4f, 0x59, 0xb1, 0x8e, 0x16, 0xe0, 0x77,
	0x7d, 0x34, 0x10, 0x25, 0x94, 0x49, 0xe3, 0xc7, 0x25, 0xb4, 0xfd, 0x38, 0x8c, 0x9d, 0x60, 0x38,
	0x4a, 0x58, 0x9b, 0x78, 0x3c, 0xa2, 0x23, 0x9a, 0xba, 0xee, 0x51, 0x18, 0xf6, 0xdc, 0x67, 0x49,
	0x2c, 0x5c, 0x37, 0x4b, 0x14, 0x04, 0x0a, 0x2e, 0x53, 0x50, 0xf0, 0x69, 0xc6, 0xa0, 0x42, 0xf8,
	0x6d, 0xb4, 0x6a, 0x47, 0x51, 0x18, 0x51, 0xa9, 0x64, 0x86, 0xf1, 0xe4, 0x41, 0x68, 0x22, 0xac,
	0x25, 0xd2, 0x61, 0xf2, 0x54, 0x0e, 0xdb, 0x29, 0x80, 0x0d, 0xb4, 0x52, 0xf3, 0xce, 0x32, 0x86,
	0x39, 0xc6, 0x90, 0xc3, 0x8c, 0x9f, 0x95, 0x10, 0x96, 0xa5, 0x50, 0x0a, 0xf0, 0x36, 0x5a, 0xcd,
	0x20, 0xa7, 0x77, 0x26, 0xaa, 0x3f, 0x0f, 0xe2, 0x4a, 0xb1, 0xeb, 0x8a, 0x01, 0x89, 0x77, 0xfc,
	0x0b, 0x9c, 0x43, 0x8a, 0xdd, 0xfd, 0x96, 0x6c, 0xc9, 0x8d, 0x6e, 0x77, 0x34, 0xf4, 0x82, 0xee,
	0xb9, 0x68, 0x2b, 0x45, 0x18, 0xac, 0x72, 0xa9, 0xf7, 0x2c, 0xe3, 0xe3, 0x45, 0xce, 0x83, 0xe0,
	0x5c, 0xa8, 0xa3, 0x5a, 0x18, 0xf8, 0x49, 0x18, 0xb1, 0x52, 0xcf, 0x12, 0x15, 0x32, 0x7e, 0x11,
	0x5d, 0x7a, 0x1c, 0x82, 0x9b, 0xf3, 0x85, 0x7e, 0x17, 0xad, 0x29, 0x58, 0x56, 0xea, 0x02, 0x0a,
	0xb5, 0xcb, 0x7e, 0x73, 0xaf, 0x8a, 0x86, 0x9f, 0x21, 0x45, 0x03, 0x66, 0xc6, 0x0d, 0xf8, 0xb5,
	0x12, 0x5a, 0x7d, 0x1c, 0xc6, 0x4a, 0xde, 0x26, 0x5a, 0x2f, 0xd4, 0x41, 0x2e, 0xb6, 0x19, 0xaf,
	0x22, 0x52, 0xe4, 0xc7, 0x15, 0xa4, 0x15, 0x8b, 0x24, 0x26, 0x59, 0x5d, 0xea, 0x28, 0xd2, 0xc9,
	0x98, 0x84, 0xf1, 0x07, 0xa6, 0xd1, 0xe5, 0x62, 0x9f, 0x90, 0x26, 0x8e, 0xf5, 0x2a, 0xe6, 0xa0,
	0xe5, 0xbd, 0xcb, 0x13, 0x7b, 0x12, 0x19, 0xef, 0x84, 0x7b, 0xb9, 0x11, 0x46, 0xb4, 0x16, 0x4d,
	0xe9, 0xcf, 0xdc, 0xaa, 0xdc, 0x30, 0xf4, 0xd9, 0x58, 0x23, 0xe3, 0xf1, 0xcc, 0xa5, 0xfc, 0x68,
	0x3c, 0xb9, 0x6d, 0x7d, 0x52, 0xf0, 0x33, 0x6b, 0x31, 0x32, 0x7a, 0xca, 0x51, 0x48, 0x9e, 0xd1,
	0xa8, 0xa1, 0x0d, 0xd5, 0x7c, 0xa9, 0x6e, 0x29, 0xf5, 0x87, 0xa8, 0x9f, 0x9d, 0x89, 0x65, 0xe7,
	0x2a, 0x33, 0x66, 0xe3, 0x14, 0x61, 0xf7, 0xe8, 0xb5, 0x27, 0xfe, 0xbb, 0x68, 0x41, 0x68, 0x11,
	0xbe, 0xdb, 0x1a, 0xcb, 0x9d, 0xe7, 0x2c, 0xd9, 0x8c, 0x5f, 0x9a, 0x46, 0x6b, 0xe2, 0x77, 0x73,
	0x34, 0x18, 0x78, 0xd1, 0x39, 0x34, 0xf3, 0x56, 0x98, 0x78, 0xfd, 0x9a, 0xd7, 0xcd, 0x0d, 0x50,
	0x05, 0x14, 0xfa, 0xa5, 0x8a, 0x64, 0x03, 0x55, 0x11, 0x4e, 0x39, 0x0f, 0xc2, 0x38, 0xc9, 0x0d,
	0x57, 0x45, 0x18, 0xef, 0x22, 0x2d, 0x07, 0xc9, 0x61, 0x7f, 0x96, 0x8c, 0xe1, 0x30, 0x7c, 0x31,
	0xcc, 0x2d, 0xc3, 0xd0, 0x1e, 0x8b, 0x8e, 0x9c, 0xc3, 0x60, 0x44, 0xe0, 0x69, 0x52, 0xe1, 0x4c,
	0xf3, 0x7c, 0x98, 0xcc, 0x81, 0xc6, 0x1f, 0x2c, 0xa1, 0x2b, 0x79, 0x27, 0xbc, 0x4e, 0x25, 0x7c,
	0x56, 0xf4, 0xa8, 0xa8, 0x0b, 0xde, 0x20, 0xf3, 0x24, 0x52, 0x60, 0x35, 0x6e, 0xa1, 0x95, 0x1a,
	0x1d, 0xc0, 0x9a, 0xe9, 0x59, 0x73, 0x48, 0xbb, 0x30, 0xbf, 0x98, 0xfd, 0x7e, 0xd8, 0x75, 0x7a,
	0x62, 0xb0, 0x91, 0x49, 0x43, 0x43, 0x6b, 0x29, 0xa7, 0x0c, 0x44, 0x57, 0x55, 0x84, 0x45, 0x08,
	0xf5, 0xd1, 0x80, 0x09, 0xc4, 0x42, 0x3c, 0x03, 0xf0, 0x0e, 0x5a, 0xac, 0x8f, 0x06, 0xfb, 0x11,
	0xa5, 0xb1, 0x18, 0xa4, 0xd2, 0xb4, 0xf1, 0x19, 0xc2, 0x52, 0x15, 0x73, 0x05, 0x0f, 0xab, 0xdf,
	0x41, 0xb3, 0x60, 0x94, 0xe8, 0xd5, 0x1b, 0xac, 0x3c, 0xaa, 0xb5, 0x84, 0x91, 0x61, 0xe6, 0xbb,
	0x94, 0x93, 0x7e, 0x45, 0x47, 0xca, 0xec, 0xa6, 0xbf, 0x36, 0x3b, 0xfc, 0x3e, 0x9a, 0x17, 0x3a,
	0xd5, 0x8e, 0x9f, 0xf7, 0x0d, 0x11, 0x2c, 0xf8, 0x96, 0x0c, 0x8d, 0xd5, 0x8e, 0x9e, 0xf3, 0x9a,
	0x8c, 0x8f, 0xff, 0xd5, 0x0c, 0x5a, 0x3a, 0xa0, 0x9e, 0x88, 0x9d, 0xee, 0x20, 0x0c, 0x9e, 0x8b,
	0x68, 0xe0, 0x95, 0xcf, 0x13, 0x1a, 0x33, 0x1f, 0x0a, 0x9f, 0x4e, 0xa0, 0x40, 0xc3, 0x13, 0xce,
	0x2c, 0xf7, 0xc3, 0xee, 0x33, 0xe9, 0xe1, 0x3c, 0x88, 0xf7, 0xd0, 0x26, 0x00, 0x5e, 0x9c, 0x94,
	0xfd, 0x40, 0x61, 0xe6, 0xf3, 0xdb, 0x44, 0x9a, 0xb0, 0xa4, 0x36, 0xf0, 0x86, 0x1c, 0xe0, 0x96,
	0xcc, 0xa6, 0x96, 0x14, 0x28, 0xf8, 0x36, 0xda, 0x90, 0x68, 0x66, 0x38, 0x9f, 0xea, 0xc7, 0x09,
	0xd0, 0xf9, 0x6b, 0xde, 0x99, 0xaa, 0x79, 0x9e, 0xcf, 0x71, 0x79, 0x14, 0xdf, 0x45, 0x97, 0x0a,
	0xd6, 0x81, 0x0e, 0x7d, 0x81, 0x31, 0x4f, 0x22, 0x09, 0x8f, 0x28, 0x36, 0x2c, 0xa6, 0x1e, 0x51,
	0xf2, 0x37, 0xd0, 0x8a, 0x74, 0x11, 0x53, 0xb8, 0xc4, 0x63, 0x12, 0x15, 0x83, 0xbc, 0x09, 0xed,
	0x53, 0x2f, 0x86, 0x55, 0x61, 0xc6, 0x8a, 0x78, 0xde, 0x13, 0x48, 0xd0, 0x57, 0xa0, 0x2a, 0xb3,
	0xa6, 0x6c, 0x9c, 0xa0, 0xf5, 0x14, 0x79, 0xc5, 0xe6, 0xf9, 0x76, 0x7e, 0x95, 0xb5, 0xc6, 0x9a,
	0x52, 0xda, 0x62, 0x64, 0x33, 0x72, 0xd1, 0x5a, 0xf5, 0xfe, 0xc1, 0x93, 0x9a, 0x37, 0x1c, 0xfa,
	0xc1, 0xc9, 0x17, 0xf4, 0x1c, 0x56, 0x4c, 0x87, 0xae, 0x95, 0x76, 0x68, 0x9e, 0xc0, 0xb7, 0xd0,
	0xbc, 0xe3, 0x9a, 0xbd, 0x5e, 0x94, 0xce, 0x7a, 0x3c, 0x6b, 0x0e, 0xd2, 0x38, 0x26, 0x82, 0x6e,
	0xec, 0xa3, 0xb5, 0xea, 0x5e, 0x4e, 0xe3, 0x0e, 0x5a, 0x6c, 0x8e, 0x8e, 0x02, 0x9a, 0xa4, 0x4a,
	0xd3, 0x34, 0x0c, 0x20, 0x35, 0xd3, 0x4a, 0x15, 0xcf, 0x12, 0x99, 0x34, 0x46, 0x68, 0x25, 0xa7,
	0xe5, 0x7d, 0x34, 0xe7, 0xb8, 0x5f, 0xd0, 0x73, 0xd1, 0xbd, 0xc5, 0xe2, 0x35, 0x67, 0xfb, 0xc1,
	0x14, 0xe1, 0x3c, 0xf8, 0x03, 0x34, 0x5f, 0x33, 0x2d, 0xe0, 0x56, 0x07, 0xb7, 0xbc, 0x5d, 0x07,
	0x53, 0x44, 0x30, 0x95, 0x97, 0xd0, 0xc2, 0x33, 0x7a, 0xee, 0x07, 0xc7, 0xa1, 0x71, 0x84, 0x36,
	0x04, 0x4b, 0x65, 0x34, 0x18, 0xee, 0xfb, 0xfd, 0x84, 0x46, 0xf8, 0x2d, 0x34, 0x93, 0xe5, 0xcc,
	0x7b, 0xba, 0xaa, 0x89, 0x00, 0x15, 0xdf, 0x12, 0xcb, 0x52, 0xbe, 0x67, 0xc5, 0xc3, 0x7c, 0x45,
	0x95, 0xb2, 0xac, 0x7f, 0x03, 0x2d, 0x5b, 0xe1, 0x60, 0xe0, 0x05, 0xbd, 0x76, 0xdb, 0xa9, 0xe0,
	0x35, 0x34, 0x2d, 0x3c, 0xb3, 0x42, 0xa6, 0x9d, 0x1e, 0x2c, 0xb3, 0x1d, 0xb9, 0x67, 0xa7, 0x18,
	0x61, 0xa4, 0x6c, 0x32, 0xe8, 0x50, 0x94, 0x1c, 0x4c, 0x81, 0x28, 0x7e, 0x07, 0xcd, 0x3b, 0xc7,
	0x8a, 0x15, 0xcb, 0x8c, 0x8f, 0x43, 0x50, 0x5e, 0xfe, 0xab, 0xbc, 0x88, 0xe6, 0xfd, 0x63, 0x56,
	0xdc, 0xdb, 0x68, 0xad, 0xe2, 0x25, 0xde, 0xd0, 0x4b, 0x9e, 0x9a, 0x71, 0xec, 0xc7, 0x89, 0x18,
	0x77, 0xad, 0x30, 0xa2, 0x72, 0x50, 0x4e, 0xd3, 0x46, 0x80, 0xd6, 0x44, 0x9e, 0x35, 0x1a, 0xc7,
	0xde, 0x09, 0xc5, 0xef, 0xa2, 0x05, 0x81, 0x88, 0x36, 0xb9, 0xa2, 0x5a, 0x46, 0x24, 0x11, 0x56,
	0x42, 0x52, 0x32, 0x3e, 0x11, 0x95, 0xb2, 0x79, 0x87, 0xef, 0x44, 0xde, 0x91, 0x3b, 0x91, 0x77,
	0xcc, 0xe0, 0x9c, 0x28, 0x7c, 0xc6, 0x43, 0xb4, 0x6c, 0x7a, 0xdd, 0x58, 0x0e, 0xf0, 0xef, 0xa2,
	0x35, 0x48, 0x36, 0x69, 0x74, 0xaa, 0x04, 0x70, 0xab, 0xa4, 0x80, 0x1a, 0xbf, 0x31, 0x8d, 0x16,
	0x9b, 0x7d, 0xef, 0x88, 0x8d, 0xbf, 0x18, 0xcd, 0x2a, 0xbb, 0x52, 0xec, 0xb7, 0xf0, 0x38, 0x1f,
	0xf3, 0xc0, 0x6d, 0xb0, 0x92, 0xeb, 0xd3, 0x01, 0x0d, 0x12, 0xb6, 0x83, 0x24, 0xd6, 0x7a, 0x0a,
	0x04, 0x33, 0xbf, 0x48, 0xc6, 0x2e, 0x8d, 0xd8, 0x50, 0x23, 0x06, 0xb5, 0x31, 0x1c, 0x02, 0xec,
	0xd6, 0xd3, 0x88, 0x7a, 0xbd, 0xa6, 0x77, 0x4c, 0xd9, 0x58, 0xb6, 0x48, 0x14, 0x04, 0x06, 0x91,
	0x47, 0x51, 0xf8, 0xa2, 0x11, 0x54, 0x28, 0x73, 0xdc, 0x3c, 0xe3, 0xc8, 0x61, 0x60, 0x51, 0x85,
	0xf6, 0xbd, 0xf3, 0x0a, 0xed, 0xd3, 0x84, 0xb2, 0x81, 0x6b, 0x91, 0xa8, 0x10, 0x58, 0xf4, 0x03,
	0x1a, 0x85, 0x8d, 0x80, 0x8d, 0x4c, 0x5e, 0xe2, 0x87, 0x01, 0x1b, 0xb3, 0x16, 0xc9, 0x18, 0x0e,
	0x39, 0x12, 0xef, 0x05, 0xb3, 0x8e, 0x15, 0x50, 0x0c, 0x5b, 0x2a, 0x66, 0xac, 0x20, 0xc4, 0x7c,
	0xc6, 0x27, 0xeb, 0x7f, 0x54, 0x42, 0x4b, 0x32, 0x19, 0x43, 0x5e, 0xf5, 0xd1, 0x40, 0x16, 0xd4,
	0x09, 0xda, 0x31, 0x15, 0xae, 0x1f, 0xc3, 0xf3, 0xb3, 0xfa, 0xf4, 0xd7, 0xcd, 0xea, 0x33, 0xf9,
	0x59, 0x1d, 0xaa, 0x57, 0x32, 0xb2, 0x75, 0x62, 0x2c, 0x3c, 0x5c, 0x40, 0x45, 0x0e, 0x62, 0x2e,
	0x9a, 0x4b, 0x73, 0xe0, 0x80, 0x71, 0x86, 0x66, 0xc1, 0x70, 0xfc, 0x66, 0x2e, 0x1a, 0xe0, 0x9b,
	0x4c, 0xb2, 0x51, 0x88, 0xa9, 0xf9, 0xbd, 0x74, 0x6a, 0x9e, 0x56, 0xf6, 0x18, 0x33, 0x2f, 0xa4,
	0xd3, 0x72, 0x3a, 0x96, 0xce, 0x28, 0x63, 0x69, 0xea, 0x1e, 0x39, 0x96, 0xfe, 0x3e, 0xb4, 0x0e,
	0xd8, 0xeb, 0x0c, 0xda, 0x6f, 0x70, 0xe3, 0xc5, 0xc2, 0x67, 0x29, 0xcd, 0x87, 0x30, 0xd8, 0xf8,
	0xe5, 0x45, 0x74, 0x45, 0x76, 0xd7, 0x1a, 0x1d, 0x84, 0xaf, 0x17, 0x09, 0xde, 0x41, 0xb8, 0x1d,
	0x74, 0xbd, 0xee, 0x53, 0xda, 0xab, 0x86, 0x2f, 0x6a, 0x74, 0xd0, 0x8e, 0x69, 0x4f, 0x0c, 0xc3,
	0x13, 0x28, 0xd0, 0x0a, 0xac, 0x22, 0x37, 0x0f, 0x94, 0xc7, 0x70, 0xfc, 0x11, 0xda, 0x52, 0x34,
	0x1c, 0xf8, 0x27, 0x4f, 0xa5, 0x04, 0x8f, 0x97, 0x2f, 0xa0, 0x42, 0xc8, 0x61, 0x4d, 0x92, 0xe2,
	0xd1, 0xf3, 0x44, 0x1a, 0xfe, 0x04, 0x6d, 0x4b, 0x6d, 0x00, 0xab, 0x62, 0x3c, 0x9e, 0xbe, 0x88,
	0x8c, 0x1f, 0xa0, 0xcb, 0xd6, 0x44, 0xb9, 0x05, 0x26, 0x37, 0x99, 0x08, 0x13, 0xbc, 0x54, 0xe8,
	0x34, 0x9b, 0xed, 0x1a, 0x1d, 0x90, 0xf8, 0xb4, 0xc7, 0x3a, 0xdf, 0x2c, 0x99, 0x44, 0x82, 0x20,
	0xc7, 0x1a, 0xe3, 0x5f, 0x62, 0xfc, 0xe3, 0x04, 0xb0, 0xaa, 0xa0, 0xa4, 0x4e, 0x69, 0x8f, 0xf6,
	0x58, 0x08, 0x31, 0x4b, 0x26, 0x13, 0xc1, 0x2a, 0x6b, 0x82, 0xcc, 0x32, 0xb7, 0x6a, 0x02, 0x09,
	0x7f, 0x8a, 0x74, 0x55, 0x15, 0xaf, 0x3d, 0x21, 0xb6, 0xc2, 0xc4, 0x2e, 0xa4, 0x43, 0xfd, 0x5a,
	0x93, 0x25, 0x57, 0x79, 0xfd, 0x4e, 0xa6, 0xaa, 0x75, 0x05, 0xb4, 0x03, 0x3f, 0x13, 0x5c, 0xcb,
	0xd7, 0x55, 0x81, 0x9c, 0xd5, 0x55, 0x51, 0x6e, 0x5d, 0xad, 0xab, 0xa2, 0x94, 0xd2, 0x0e, 0x33,
	0x5b, 0x98, 0xfb, 0xb5, 0x7c, 0x3b, 0xcc, 0x53, 0xb3, 0x76, 0x58, 0x90, 0xda, 0x50, 0xdb, 0x61,
	0x41, 0xa6, 0x50, 0x6f, 0xcc, 0x0c, 0x26, 0x84, 0xc7, 0xeb, 0x2d, 0x25, 0xe6, 0xeb, 0x2d, 0x93,
	0xb9, 0x54, 0xac, 0xb7, 0x94, 0x64, 0xfc, 0x4e, 0x09, 0x61, 0x16, 0x20, 0x04, 0x5e, 0x5f, 0x2e,
	0xd1, 0x47, 0x31, 0xfe, 0x00, 0xa1, 0x2c, 0x25, 0xfa, 0xff, 0xaa, 0x98, 0xff, 0x45, 0xe7, 0x57,
	0x18, 0x60, 0xb4, 0x60, 0xa9, 0x21, 0x15, 0x9d, 0x3e, 0x1b, 0x2d, 0x52, 0x9c, 0x64, 0x2c, 0xf8,
	0x2e, 0xdf, 0x81, 0xac, 0x85, 0x3d, 0x3e, 0x41, 0xca, 0x10, 0xc7, 0x09, 0x12, 0xc0, 0x2b, 0xc3,
	0xfe, 0x19, 0xd0, 0x48, 0xca, 0x05, 0xb3, 0x0e, 0xdb, 0x88, 0x3c, 0x73, 0xbd, 0x91, 0xec, 0xf9,
	0x8b, 0x24, 0x87, 0x49, 0x9e, 0xfd, 0x7e, 0xf8, 0xc2, 0x4a, 0xa2, 0xbe, 0x98, 0x2d, 0x73, 0x98,
	0xf1, 0x2b, 0xf3, 0x68, 0xa3, 0x58, 0xde, 0x18, 0x24, 0x9d, 0xe0, 0x51, 0x18, 0xf6, 0x1a, 0xdd,
	0x84, 0x26, 0xb1, 0xd8, 0x05, 0xc8, 0x61, 0x30, 0x53, 0x34, 0x46, 0x89, 0x60, 0xe0, 0x03, 0x5b,
	0x06, 0xc0, 0x1c, 0xeb, 0x04, 0x65, 0x4f, 0x2a, 0x10, 0xb3, 0xbe, 0x02, 0x81, 0xbc, 0x13, 0xb4,
	0x03, 0xbf, 0xeb, 0xc5, 0x72, 0x7f, 0x37, 0x03, 0xb8, 0xfc, 0x51, 0x14, 0x7a, 0x3d, 0x46, 0x9f,
	0x93, 0xf2, 0x29, 0xc4, 0x39, 0x06, 0xa3, 0x7e, 0xc2, 0x35, 0xcc, 0x4b, 0x8e, 0x14, 0x82, 0xf8,
	0xd7, 0x09, 0x98, 0x2f, 0xc4, 0xe2, 0x44, 0x26, 0xb9, 0x6c, 0x3b, 0xe8, 0xd1, 0x28, 0x86, 0x29,
	0x7b, 0x51, 0xca, 0xa6, 0x10, 0xe7, 0xd8, 0x8f, 0xbc, 0x13, 0x36, 0xfb, 0x8a, 0x49, 0x5d, 0x85,
	0x20, 0x12, 0x71, 0x82, 0xc6, 0xa9, 0x50, 0xc1, 0x57, 0x20, 0x0a, 0x02, 0xb3, 0xb1, 0x13, 0x7c,
	0xcf, 0x3b, 0x3a, 0xa2, 0x11, 0x1b, 0x28, 0x56, 0x49, 0x9a, 0xe6, 0x96, 0x91, 0x33, 0x3b, 0x8a,
	0xd8, 0x60, 0xc0, 0x2c, 0x63, 0x49, 0x2e, 0xb5, 0xdf, 0x8d, 0x81, 0xb4, 0x2a, 0xa5, 0x78, 0x1a,
	0x72, 0x6c, 0x8c, 0x12, 0xe9, 0xb2, 0x35, 0x9e, 0x63, 0x86, 0x40, 0xad, 0x35, 0x46, 0x49, 0x39,
	0x75, 0xda, 0x3a, 0x8f, 0x44, 0x54, 0x4c, 0xf0, 0xd4, 0x52, 0xb7, 0x69, 0x29, 0x4f, 0x8a, 0x89,
	0x9a, 0x15, 0x46, 0x6c, 0xf0, 0x9a, 0x49, 0x01, 0xb0, 0xb0, 0x31, 0x4a, 0xb8, 0x5b, 0x31, 0xb7,
	0x50, 0xa6, 0x61, 0xa1, 0xd7, 0x18, 0x25, 0x56, 0xd8, 0xef, 0xfb, 0xb1, 0x1f, 0x06, 0x31, 0xeb,
	0x69, 0xab, 0x24, 0x0f, 0x82, 0x6f, 0x1b, 0xa3, 0xa4, 0x42, 0x8f, 0x69, 0x14, 0xd1, 0x9e, 0xbe,
	0xc9, 0x7d, 0xab, 0x40, 0xc2, 0x82, 0xa6, 0x1f, 0x9c, 0xf4, 0xa9, 0x7e, 0x39, 0xb5, 0x80, 0x03,
	0x42, 0x9e, 0xd9, 0x3b, 0xec, 0x53, 0x7d, 0x2b, 0x95, 0x97, 0x90, 0x28, 0xa5, 0x7d, 0xd6, 0xa5,
	0x71, 0xec, 0x9f, 0x52, 0x7d, 0x3b, 0x2d, 0x65, 0x8a, 0x41, 0x1d, 0x34, 0x46, 0x49, 0xd5, 0x4b,
	0xa8, 0xae, 0xf3, 0x3a, 0x10, 0x49, 0xe3, 0xc7, 0x25, 0xb4, 0xa9, 0xf6, 0x89, 0x34, 0x08, 0xb8,
	0xce, 0x47, 0x81, 0xfa, 0x68, 0x00, 0x95, 0x2a, 0x8e, 0x3d, 0x32, 0x04, 0xcc, 0x66, 0xdd, 0x95,
	0xc6, 0x5d, 0xbe, 0xe4, 0x5a, 0x22, 0x19, 0x80, 0x3f, 0x47, 0x6b, 0x52, 0x6b, 0x6e, 0xd3, 0x62,
	0x5b, 0x76, 0xf5, 0xc2, 0xa0, 0x43, 0x0a, 0xec, 0xf8, 0x76, 0x7e, 0x03, 0x63, 0x6b, 0xa2, 0x9c,
	0xb2, 0xfa, 0xdc, 0x9e, 0x54, 0x88, 0x5a, 0x7c, 0x82, 0x1f, 0x2a, 0x67, 0xad, 0xea, 0x49, 0xd0,
	0x24, 0x7e, 0xe5, 0xb4, 0xf5, 0xa1, 0x58, 0x3b, 0xa5, 0x1c, 0x7c, 0xe5, 0xf0, 0x0d, 0x5e, 0x31,
	0xaa, 0x68, 0x6b, 0x82, 0x18, 0xd8, 0xb1, 0x87, 0x16, 0x44, 0x4a, 0x98, 0xa1, 0x4f, 0x30, 0x83,
	0xd1, 0x89, 0x64, 0x34, 0x9a, 0x68, 0xd5, 0xa6, 0xc3, 0x28, 0x1c, 0x88, 0xb5, 0x31, 0xde, 0x42,
	0xf3, 0xc0, 0x98, 0xae, 0xf2, 0x44, 0x0a, 0xd6, 0x26, 0xae, 0x77, 0x42, 0x45, 0x98, 0xcc, 0x7e,
	0x03, 0x6f, 0xe3, 0xf8, 0x38, 0xa6, 0xf2, 0xc8, 0x49, 0xa4, 0x8c, 0x3a, 0x42, 0x5c, 0x29, 0xe3,
	0x82, 0x02, 0x79, 0x27, 0xb4, 0x50, 0xa0, 0x14, 0x61, 0x9b, 0xf8, 0xde, 0x09, 0xb5, 0xc2, 0x20,
	0xa1, 0xe2, 0xfc, 0x6d, 0x85, 0xa8, 0x90, 0xd1, 0x44, 0x98, 0xeb, 0x23, 0xd4, 0xeb, 0xa5, 0xcd,
	0x07, 0x7a, 0xfd, 0xb1, 0x13, 0xf4, 0xa8, 0x3c, 0x3d, 0x90, 0x49, 0xfc, 0x56, 0x6a, 0xeb, 0x4c,
	0x1a, 0x2a, 0x67, 0x06, 0x71, 0xe3, 0x8d, 0x1f, 0xa2, 0xcb, 0xe3, 0x4a, 0xc1, 0x8d, 0xff, 0xb7,
	0x8e, 0xda, 0xc7, 0xb5, 0x2b, 0x95, 0x6f, 0xa2, 0x0d, 0x95, 0xce, 0xab, 0xfe, 0x36, 0x5a, 0x10,
	0xd5, 0x20, 0x96, 0x02, 0x58, 0x51, 0x24, 0x37, 0x2f, 0x24, 0x8b, 0x71, 0x07, 0x6d, 0x8e, 0xa9,
	0x00, 0xfb, 0xd5, 0x1a, 0x9c, 0xc9, 0x6a, 0xd0, 0x38, 0x40, 0x5b, 0x9c, 0xff, 0x49, 0xe4, 0x27,
	0xf4, 0x35, 0x4a, 0x6c, 0x7c, 0x5f, 0xd6, 0x87, 0xd0, 0xf4, 0x0a, 0xd6, 0xb3, 0xbd, 0x1b, 0xaf,
	0x3f, 0x92, 0x0d, 0x8a, 0x27, 0x8c, 0xef, 0xc9, 0x4a, 0x51, 0x35, 0x83, 0x89, 0xf7, 0x8a, 0x6d,
	0x5b, 0xf5, 0xb1, 0xca, 0x9c, 0x35, 0x6d, 0x13, 0x5d, 0xa9, 0x52, 0x2f, 0x0a, 0x2a, 0xb4, 0x37,
	0x1a, 0xb2, 0x4e, 0x70, 0xea, 0xf5, 0xa5, 0xb1, 0x6f, 0xa3, 0xd5, 0x1c, 0x2e, 0x8f, 0xdd, 0x72,
	0x20, 0x2c, 0x2d, 0x2f, 0xb7, 0xba, 0x43, 0x37, 0x0a, 0xcf, 0xce, 0x9b, 0x30, 0xd0, 0x85, 0x81,
	0xd8, 0xe1, 0x78, 0x17, 0xcd, 0x35, 0xa3, 0xae, 0x33, 0x4c, 0x37, 0x39, 0x8a, 0x7b, 0x4c, 0x9c,
	0x0c, 0x7c, 0x95, 0x38, 0x71, 0x86, 0x17, 0xee, 0x45, 0x71, 0x32, 0x34, 0xe6, 0x66, 0xd4, 0x65,
	0x1b, 0x05, 0xbc, 0x2f, 0xc9, 0x24, 0x50, 0x2a, 0x31, 0x8b, 0x5b, 0xc4, 0xb4, 0x2e, 0x93, 0x30,
	0x75, 0xd4, 0xbc, 0xa4, 0xfb, 0xd4, 0xec, 0xcb, 0x60, 0x24, 0x4d, 0xb3, 0x0b, 0x42, 0x79, 0xc3,
	0x09, 0x7d, 0x8e, 0xbf, 0x8b, 0x56, 0x73, 0xc5, 0x10, 0xd6, 0xf3, 0x93, 0x95, 0x89, 0x05, 0x25,
	0x79, 0x01, 0xe3, 0x1f, 0x97, 0xd0, 0x8a, 0x64, 0x84, 0xa8, 0x07, 0xc6, 0x85, 0xc7, 0x7e, 0xef,
	0x9e, 0x88, 0x69, 0xd8, 0x6f, 0x81, 0xed, 0x89, 0x30, 0x86, 0xfd, 0xce, 0x1c, 0x36, 0xf3, 0x92,
	0x0e, 0x9b, 0x7d, 0x69, 0x87, 0xcd, 0x5d, 0xe8, 0xb0, 0xf9, 0x9c, 0xc3, 0x8c, 0x3a, 0xba, 0x52,
	0x28, 0xa4, 0xb2, 0x25, 0x7f, 0x0f, 0x2d, 0x44, 0x13, 0x5a, 0xd8, 0xb8, 0x17, 0x89, 0xe4, 0x33,
	0x9e, 0xa2, 0xf5, 0x02, 0xf9, 0x55, 0x76, 0xe6, 0xc1, 0x8d, 0xb9, 0x9d, 0x79, 0xd5, 0xbf, 0x84,
	0x91, 0x8d, 0xdf, 0x8f, 0x76, 0x26, 0x59, 0xfe, 0xca, 0x87, 0x5b, 0xc5, 0x11, 0x6b, 0x73, 0x62,
	0x59, 0xb3, 0xe1, 0xea, 0x0f, 0x97, 0xd0, 0x75, 0x49, 0x7d, 0xd4, 0x0f, 0x8f, 0xf8, 0x24, 0xfa,
	0x5a, 0x27, 0x6c, 0x9f, 0xa2, 0x65, 0x45, 0x93, 0x70, 0x80, 0x9e, 0xb3, 0x43, 0xa1, 0x13, 0x95,
	0xd9, 0xf8, 0xdd, 0x45, 0x74, 0x69, 0x02, 0x13, 0x4c, 0x35, 0xe4, 0x0c, 0xc2, 0x83, 0xfd, 0x51,
	0xbf, 0x2f, 0x6f, 0x03, 0x64, 0x08, 0x3f, 0x6c, 0x3f, 0xf5, 0xfa, 0x7e, 0xaf, 0xc5, 0x40, 0xd1,
	0x42, 0xf3, 0x20, 0xbe, 0x85, 0xd6, 0x05, 0x40, 0x68, 0xc2, 0xf9, 0xc4, 0x21, 0x5b, 0x01, 0x66,
	0xc7, 0xe4, 0x5e, 0x94, 0xf8, 0x5e, 0xdf, 0x7d, 0x96, 0x98, 0x62, 0x9f, 0x6d, 0x96, 0xe4, 0x41,
	0xd0, 0x07, 0x12, 0xf5, 0x70, 0xd8, 0x84, 0x15, 0xd2, 0xa8, 0x4f, 0xc5, 0x1e, 0x41, 0x11, 0x86,
	0xa1, 0xfb, 0x11, 0xb7, 0x9d, 0xef, 0x06, 0x88, 0x14, 0xbb, 0x34, 0xd6, 0x8f, 0x05, 0x89, 0x2f,
	0xf8, 0x33, 0x80, 0x85, 0x5e, 0xe1, 0x73, 0x46, 0xe3, 0x0b, 0x7b, 0x99, 0x54, 0xca, 0xcb, 0x9d,
	0x20, 0x16, 0xf2, 0x79, 0x90, 0x79, 0xad, 0x7b, 0xda, 0xb3, 0xa8, 0xfb, 0x2c, 0x89, 0xc5, 0xca,
	0x5d, 0x41, 0x60, 0x81, 0x69, 0x77, 0x03, 0x42, 0x7b, 0xa3, 0x2e, 0xed, 0x59, 0x61, 0x70, 0x42,
	0x63, 0xb6, 0x85, 0xc7, 0xd7, 0xeb, 0x13, 0x69, 0x30, 0x36, 0x41, 0xe1, 0x98, 0x46, 0xbe, 0x40,
	0x4f, 0xd3, 0x2c, 0x9c, 0x0c, 0x9f, 0x93, 0xb3, 0xbd, 0xe4, 0x8c, 0x19, 0xcd, 0x97, 0xe1, 0x39,
	0x0c, 0xdf, 0x41, 0x98, 0x9c, 0x99, 0xdd, 0x67, 0xfb, 0x61, 0xd4, 0x0e, 0x62, 0x1a, 0x24, 0x15,
	0x2f, 0xf1, 0xc4, 0xba, 0x7b, 0x02, 0x05, 0xca, 0xb0, 0xef, 0x07, 0x4d, 0x1a, 0x24, 0x56, 0x90,
	0x88, 0x75, 0xb6, 0x82, 0xb0, 0x32, 0xc6, 0x89, 0xa4, 0x6b, 0xa2, 0x8c, 0x29, 0xc2, 0x5b, 0xce,
	0x13, 0x3f, 0x70, 0xa3, 0xf0, 0x88, 0x8a, 0xa5, 0xb3, 0x82, 0x40, 0x90, 0x42, 0xce, 0xbe, 0xa0,
	0x74, 0x68, 0xf6, 0x21, 0x02, 0xe6, 0xcb, 0x64, 0x15, 0x02, 0x5f, 0x13, 0x28, 0x9f, 0x79, 0x9c,
	0xd0, 0xe8, 0x89, 0x1f, 0x88, 0x65, 0x71, 0x1e, 0x64, 0xdb, 0x9b, 0x67, 0xee, 0x28, 0xa2, 0x4f,
	0xfc, 0xa0, 0x3d, 0xe4, 0xd1, 0xfa, 0x2c, 0xc9, 0x61, 0x3c, 0x2f, 0xa8, 0x19, 0xf3, 0xd4, 0xf3,
	0xfb, 0x2c, 0x60, 0x67, 0x79, 0xa5, 0x10, 0x70, 0xb4, 0x14, 0x8e, 0x2d, 0xce, 0xa1, 0x40, 0x6c,
	0x59, 0x11, 0x3e, 0xe7, 0xe4, 0x6d, 0xee, 0x7f, 0x99, 0xc6, 0x6f, 0xa0, 0xa5, 0x56, 0x77, 0x58,
	0xa1, 0x47, 0xa3, 0x93, 0x7b, 0xfa, 0x4f, 0x65, 0x73, 0x92, 0x88, 0x4a, 0xde, 0xd3, 0xff, 0x73,
	0x81, 0xbc, 0xa7, 0x92, 0xef, 0xeb, 0xff, 0xa5, 0x40, 0xbe, 0xaf, 0x92, 0x1f, 0xe8, 0xbf, 0x53,
	0x20, 0x3f, 0x50, 0xc9, 0x0f, 0xf5, 0xff, 0x5a, 0x20, 0x3f, 0x54, 0xc9, 0x1f, 0xe9, 0xff, 0xad,
	0x40, 0xfe, 0x48, 0x25, 0x7f, 0xac, 0xff, 0xf7, 0x02, 0xf9, 0x63, 0x95, 0xfc, 0x89, 0xfe, 0x3f,
	0x0a, 0xe4, 0x4f, 0x54, 0xf2, 0xb7, 0xf5, 0x9f, 0x15, 0xc8, 0xdf, 0xc6, 0x37, 0x10, 0x4a, 0x9d,
	0x70, 0x57, 0xff, 0x5d, 0x4e, 0x57, 0x20, 0xa3, 0x8b, 0x36, 0xf2, 0x83, 0x8e, 0x75, 0x7c, 0x82,
	0x35, 0x34, 0x53, 0x8b, 0xe5, 0xf1, 0x03, 0xfc, 0x84, 0xca, 0xb1, 0x5e, 0x04, 0x3d, 0x27, 0xf0,
	0x61, 0x0c, 0x10, 0xf1, 0x8d, 0x0a, 0x41, 0xe5, 0xb0, 0x64, 0xaf, 0x2f, 0x37, 0xf0, 0xd3, 0xb4,
	0x51, 0x45, 0xfa, 0x58, 0x26, 0xd9, 0x1d, 0xe7, 0x42, 0x10, 0xb4, 0x35, 0x61, 0xb8, 0x04, 0xfe,
	0x34, 0x06, 0xfa, 0x22, 0x9b, 0xf1, 0x14, 0x6d, 0xaf, 0x78, 0x3d, 0xf3, 0x7f, 0xad, 0x31, 0x07,
	0x5a, 0x47, 0xf2, 0x3c, 0x9d, 0x25, 0xb2, 0xf3, 0x74, 0x91, 0x84, 0x51, 0x8c, 0x74, 0x4f, 0xeb,
	0x67, 0xf2, 0x2e, 0x9d, 0x48, 0x01, 0xde, 0x0c, 0x7a, 0x80, 0x8b, 0xe5, 0x02, 0x4f, 0x09, 0xbc,
	0x1d, 0x78, 0x22, 0xc0, 0x11, 0x29, 0x36, 0x86, 0x74, 0x4f, 0x5b, 0x31, 0x84, 0x67, 0x7c, 0x8e,
	0x4f, 0xd3, 0x40, 0x6b, 0xc5, 0x84, 0x76, 0x61, 0xc5, 0xc0, 0x67, 0xf9, 0x34, 0xcd, 0x0e, 0xf1,
	0x68, 0xf4, 0xbc, 0xec, 0x89, 0x9d, 0x8a, 0x79, 0x92, 0xa6, 0x81, 0xc6, 0xaa, 0xb3, 0x12, 0xf6,
	0xc5, 0x3e, 0x45, 0x9a, 0xe6, 0x72, 0x31, 0x97, 0x5b, 0x92, 0x72, 0x3c, 0xcd, 0x6c, 0xa4, 0xf1,
	0x73, 0xd7, 0x17, 0x5b, 0x13, 0x22, 0x25, 0x71, 0xcb, 0x17, 0x9b, 0x12, 0x22, 0x25, 0xca, 0xf4,
	0x24, 0xe8, 0x89, 0x1d, 0x09, 0x91, 0x62, 0x61, 0x4b, 0xd0, 0x83, 0xda, 0x16, 0xfb, 0x11, 0x32,
	0x29, 0xbc, 0x06, 0x6d, 0x69, 0x2d, 0xf5, 0x1a, 0x34, 0x27, 0x76, 0x39, 0x70, 0x14, 0x75, 0x29,
	0x8b, 0x68, 0xd6, 0xe5, 0xe5, 0x40, 0x89, 0xf0, 0x12, 0x89, 0x78, 0x47, 0x93, 0x25, 0x12, 0x11,
	0xe2, 0xbb, 0xec, 0xb4, 0xb6, 0x47, 0xa3, 0x16, 0x1d, 0x0c, 0xfb, 0xb0, 0x36, 0xdf, 0x60, 0xab,
	0xab, 0x02, 0x0a, 0xc1, 0x38, 0xd4, 0xb1, 0xdc, 0x81, 0xe0, 0x09, 0x98, 0x75, 0x78, 0x3e, 0x55,
	0xff, 0x58, 0x6c, 0x3d, 0x64, 0x00, 0x50, 0xcd, 0x58, 0xba, 0x6b, 0x93, 0xb9, 0x2b, 0x03, 0xd8,
	0x6d, 0x8b, 0x98, 0x3b, 0xec, 0xb2, 0xb8, 0x6d, 0xc1, 0x93, 0x29, 0xc5, 0xf2, 0xc5, 0x56, 0x83,
	0x4c, 0x42, 0x49, 0x65, 0x5d, 0xb4, 0xce, 0xc4, 0x26, 0x83, 0x82, 0x40, 0x8e, 0xdc, 0xee, 0x2a,
	0x0d, 0xc4, 0x26, 0x43, 0x06, 0x40, 0x59, 0x5d, 0x1a, 0xf4, 0xfc, 0xe0, 0xc4, 0xec, 0x3e, 0x6b,
	0xd2, 0xa0, 0xa7, 0x5f, 0x61, 0x31, 0x71, 0x01, 0x65, 0xfe, 0xa4, 0xf1, 0x73, 0x98, 0x8d, 0x2c,
	0x5f, 0xbf, 0x2a, 0xfc, 0x99, 0x22, 0x6c, 0x26, 0xa0, 0xc9, 0x99, 0x68, 0x91, 0xd7, 0xc4, 0x4c,
	0x90, 0x22, 0x10, 0xdc, 0x92, 0xb3, 0x56, 0xac, 0xbf, 0xc1, 0x83, 0x5b, 0xf8, 0x0d, 0x83, 0x00,
	0x49, 0x42, 0xfd, 0x3a, 0x83, 0xe0, 0x27, 0xcb, 0x85, 0x57, 0x2c, 0xcc, 0x37, 0x37, 0x44, 0x2e,
	0x29, 0x02, 0xf3, 0x5b, 0x5a, 0xb2, 0xa3, 0x7e, 0x4c, 0x13, 0xaf, 0xd7, 0x8b, 0xf4, 0x9b, 0xfc,
	0xee, 0xc1, 0x38, 0x85, 0xb7, 0xb3, 0x08, 0xdc, 0xf9, 0xa6, 0x6c, 0x67, 0x90, 0x62, 0x7b, 0x24,
	0x11, 0xed, 0xed, 0xf7, 0xbd, 0x93, 0x58, 0x37, 0xb8, 0x4f, 0x52, 0x80, 0xcd, 0x02, 0xc9, 0x53,
	0x1a, 0x3d, 0xf6, 0x7b, 0xfa, 0x5b, 0x62, 0x73, 0x49, 0xa4, 0xf9, 0xb2, 0xbc, 0xfb, 0x8c, 0xf2,
	0xab, 0x41, 0x6f, 0xcb, 0x65, 0xb9, 0x44, 0xd8, 0xa5, 0xd2, 0xa0, 0xd7, 0x8c, 0x93, 0xa7, 0x11,
	0x8d, 0x9f, 0xea, 0xef, 0x88, 0x4b, 0xa5, 0x19, 0x04, 0x36, 0x59, 0x5d, 0xb3, 0x7f, 0x12, 0xea,
	0xef, 0x72, 0x9b, 0x78, 0x8a, 0x79, 0x30, 0x09, 0xcb, 0x5e, 0xf7, 0x59, 0x78, 0x7c, 0xac, 0xbf,
	0xc7, 0x35, 0x67, 0x08, 0xbb, 0xe8, 0x3c, 0x1c, 0x39, 0x3d, 0xfd, 0x96, 0xb8, 0xe8, 0x0c, 0x09,
	0x59, 0x42, 0xcb, 0xd7, 0xbf, 0x95, 0x95, 0x90, 0xf7, 0x24, 0xd2, 0x3d, 0x85, 0x9e, 0xb4, 0x9b,
	0xf6, 0x0b, 0xe8, 0x49, 0xd0, 0x3a, 0x83, 0xde, 0x93, 0xb8, 0xeb, 0xf5, 0xa9, 0xfe, 0xbe, 0x68,
	0x9d, 0x12, 0x00, 0x2a, 0xf0, 0x71, 0xea, 0x6d, 0x4e, 0x4d, 0x01, 0xd9, 0xd3, 0x5b, 0xd0, 0x02,
	0x3e, 0x10, 0xc7, 0xfc, 0x22, 0xcd, 0xfb, 0x53, 0xdf, 0x3b, 0x87, 0x70, 0xee, 0x0e, 0x5f, 0x55,
	0xc9, 0x34, 0xd4, 0xb3, 0x99, 0x84, 0xfa, 0x87, 0x7c, 0xb0, 0x37, 0xd3, 0x7a, 0x26, 0xb4, 0x1b,
	0x9e, 0xd2, 0x48, 0xbf, 0x9b, 0xd6, 0xb3, 0x40, 0xa0, 0xb5, 0x34, 0x07, 0x71, 0xac, 0xdf, 0xe3,
	0xdb, 0x26, 0xf0, 0x9b, 0x47, 0x65, 0x6c, 0x26, 0x78, 0xe2, 0x07, 0xbd, 0xf0, 0x85, 0xbe, 0x27,
	0xaf, 0x7c, 0x2a, 0x20, 0xeb, 0x27, 0x47, 0xdd, 0xea, 0xa1, 0x17, 0xe9, 0xf7, 0x45, 0x3f, 0xe1,
	0x49, 0x3e, 0xb7, 0x87, 0xec, 0x06, 0x9d, 0xfe, 0x80, 0x5b, 0x28, 0xd3, 0x6c, 0xcb, 0x30, 0x0c,
	0x59, 0x1c, 0xf5, 0xf8, 0x08, 0x7a, 0xe6, 0x43, 0x1e, 0x85, 0xe4, 0x40, 0xe9, 0xd3, 0xd1, 0x50,
	0xff, 0x28, 0xf3, 0xe9, 0x68, 0xc8, 0x6a, 0xf4, 0x88, 0x75, 0xe8, 0x8f, 0x59, 0x87, 0x16, 0x29,
	0xe8, 0x5b, 0x3f, 0xa0, 0x51, 0xc8, 0x2d, 0x83, 0x90, 0x49, 0xff, 0x84, 0x1f, 0x77, 0xe6, 0x51,
	0x88, 0x6e, 0xb8, 0xc4, 0x63, 0x98, 0x46, 0xee, 0xe9, 0xdf, 0x66, 0x5a, 0x72, 0x18, 0xab, 0xe7,
	0x28, 0x49, 0xda, 0xb1, 0xfe, 0xa9, 0xa8, 0x67, 0x96, 0x62, 0x75, 0xe2, 0x75, 0x9f, 0xb9, 0x34,
	0x1a, 0xe8, 0x9f, 0xf1, 0x52, 0xc9, 0x34, 0x3b, 0xa6, 0xf6, 0x07, 0x34, 0x4e, 0xbc, 0xc1, 0x30,
	0xd6, 0xff, 0x3f, 0x71, 0x4c, 0x9d, 0x22, 0x60, 0x1f, 0x49, 0x92, 0x26, 0x7d, 0xde, 0x8a, 0x43,
	0xbe, 0x21, 0xf5, 0x73, 0xdc, 0xbe, 0x3c, 0x0a, 0x3e, 0x25, 0x49, 0x02, 0x82, 0xfa, 0x77, 0xb8,
	0x4f, 0x45, 0x92, 0x45, 0xd8, 0x31, 0xdb, 0x2e, 0xa0, 0x3d, 0xfd, 0x73, 0xf1, 0x59, 0x86, 0x04,
	0xf8, 0x6c, 0x23, 0xb6, 0xba, 0xbe, 0x2b, 0x67, 0x1b, 0x9e, 0x86, 0xf2, 0xb4, 0x62, 0xa6, 0xd2,
	0xe4, 0xe5, 0xe1, 0x29, 0xb0, 0x19, 0x82, 0x43, 0x0f, 0x82, 0xc3, 0x58, 0x2f, 0x73, 0x9b, 0x33,
	0x84, 0xd5, 0x41, 0x92, 0x40, 0xf5, 0x5a, 0xa2, 0x0e, 0x58, 0x0a, 0x70, 0x73, 0x38, 0x84, 0x1e,
	0x5b, 0xe1, 0x38, 0x4f, 0x19, 0xbf, 0x54, 0x42, 0x6b, 0x6c, 0x86, 0x6d, 0x84, 0xcf, 0xc5, 0x12,
	0xea, 0x1a, 0x5a, 0x62, 0xb5, 0xce, 0xee, 0xa4, 0xf0, 0xd5, 0x4e, 0x06, 0x30, 0x87, 0x26, 0x5e,
	0x04, 0x0e, 0x90, 0xb7, 0xd2, 0x64, 0x1a, 0x32, 0xb1, 0x83, 0x1e, 0x50, 0xc4, 0x54, 0xcc, 0x53,
	0x60, 0x74, 0x7d, 0x34, 0x90, 0xd7, 0xda, 0xf9, 0x74, 0xac, 0x20, 0xc6, 0x0f, 0xd1, 0x32, 0x8f,
	0x00, 0xb8, 0x01, 0x17, 0xc7, 0x00, 0x37, 0xd1, 0x72, 0x23, 0x7c, 0x5e, 0x0f, 0x13, 0x7b, 0x30,
	0x4c, 0xf8, 0xd5, 0x96, 0x45, 0xa2, 0x42, 0xf8, 0x1e, 0x5a, 0x4a, 0x4b, 0xa2, 0xcf, 0xb0, 0x70,
	0xe6, 0x92, 0x0c, 0x67, 0x94, 0x42, 0x92, 0x8c, 0xcb, 0xb8, 0xc5, 0xf6, 0x1e, 0xac, 0x23, 0x19,
	0x0f, 0x5d, 0x98, 0xbd, 0xf1, 0x1d, 0xb6, 0x32, 0xb7, 0x8e, 0x94, 0xf5, 0xfd, 0xfb, 0xc5, 0xe0,
	0x69, 0x23, 0xcb, 0x6d, 0x6c, 0xef, 0xe8, 0x7f, 0xae, 0xb0, 0x60, 0xd0, 0x3a, 0x4a, 0xaf, 0xff,
	0xb1, 0xeb, 0x4f, 0xb0, 0x28, 0x92, 0x8e, 0x4e, 0x01, 0x70, 0x34, 0xac, 0x6b, 0x18, 0x91, 0x2f,
	0x28, 0xd3, 0x34, 0x38, 0x94, 0xdf, 0xc9, 0xea, 0x3e, 0x4b, 0x8f, 0xa0, 0x15, 0x84, 0x1d, 0x2a,
	0x8d, 0x22, 0x6a, 0x76, 0x9f, 0x71, 0x79, 0xbe, 0x80, 0xcc, 0x61, 0xec, 0x82, 0xc5, 0x68, 0x98,
	0xb2, 0x88, 0x6b, 0xd6, 0x0a, 0xc4, 0xc6, 0xea, 0x7e, 0xf8, 0xc2, 0xf5, 0x92, 0xa7, 0x96, 0x08,
	0x88, 0x66, 0x89, 0x0a, 0x31, 0x0e, 0x1a, 0xb1, 0x55, 0x21, 0x70, 0x2c, 0x08, 0x8e, 0x0c, 0x62,
	0x9b, 0xb9, 0x61, 0x08, 0x44, 0xbe, 0x88, 0x14, 0x29, 0x36, 0x92, 0x9e, 0xb1, 0x2b, 0xff, 0x41,
	0x22, 0xd6, 0x8f, 0x19, 0xc0, 0x37, 0x6f, 0x5f, 0xc4, 0x92, 0x8e, 0xc4, 0x0d, 0xec, 0x0c, 0x82,
	0x12, 0x3e, 0xf1, 0x03, 0xeb, 0x29, 0xed, 0x3e, 0xdb, 0x87, 0xd5, 0x08, 0x5f, 0x35, 0xe6, 0x30,
	0x76, 0x14, 0x13, 0x86, 0x52, 0x09, 0x5f, 0x2f, 0x2a, 0x88, 0x32, 0xfb, 0xf1, 0xb5, 0xa2, 0x9c,
	0xfd, 0xb2, 0x39, 0x63, 0x2d, 0xc3, 0x2d, 0x1f, 0x22, 0x7d, 0xe6, 0x63, 0x36, 0x54, 0xfd, 0x4a,
	0x5d, 0xa9, 0x30, 0x36, 0x4c, 0x5d, 0xe5, 0x15, 0xc6, 0xa8, 0x7f, 0xa4, 0x9e, 0xd5, 0x18, 0x23,
	0xbe, 0x95, 0xd5, 0x08, 0x63, 0xf8, 0xa3, 0xf5, 0x7c, 0x95, 0x30, 0xa6, 0xed, 0x34, 0x1c, 0xfc,
	0xd5, 0x7a, 0x2e, 0x1e, 0xdc, 0x4e, 0xe3, 0xc1, 0x3f, 0x5e, 0xcf, 0x05, 0x84, 0x6f, 0xa0, 0x25,
	0x08, 0x3f, 0xcc, 0xee, 0x33, 0xd7, 0xd7, 0xff, 0x44, 0x5d, 0xcc, 0x57, 0x12, 0x51, 0xc8, 0x96,
	0xaf, 0xff, 0x5a, 0x9e, 0x6c, 0xf9, 0xf8, 0x4d, 0xb4, 0xbc, 0xef, 0xc5, 0x6c, 0xa8, 0x8a, 0x5c,
	0x5f, 0xff, 0x93, 0x9c, 0x41, 0xc5, 0x72, 0x2c, 0x96, 0xaf, 0xff, 0xa9, 0x22, 0x8b, 0xe5, 0x43,
	0xb9, 0x2b, 0xb4, 0xcf, 0x4d, 0xf8, 0xd3, 0x75, 0x19, 0x2b, 0x72, 0x20, 0x23, 0x5a, 0xbe, 0xfe,
	0x67, 0x72, 0x44, 0x2e, 0xd9, 0x08, 0x8f, 0x48, 0x9c, 0xb8, 0xbe, 0xfe, 0x67, 0x05, 0x51, 0x02,
	0x19, 0xd1, 0xf2, 0xf5, 0x3f, 0x97, 0x23, 0x72, 0xcb, 0x45, 0x00, 0xd6, 0x3a, 0x73, 0x7d, 0xfd,
	0xd7, 0x85, 0x59, 0x0a, 0x96, 0x63, 0xb1, 0x7c, 0xfd, 0xcf, 0x17, 0x59, 0x2c, 0x1f, 0xbf, 0x83,
	0x56, 0xa1, 0x20, 0x84, 0x26, 0x91, 0x17, 0xc4, 0xae, 0xaf, 0xff, 0x05, 0xce, 0x94, 0x47, 0x0b,
	0x6c, 0x96, 0xaf, 0xff, 0xc5, 0x71, 0x36, 0x6e, 0x93, 0xd5, 0xa7, 0x5e, 0xc0, 0x76, 0x24, 0x7c,
	0xfd, 0x2f, 0x89, 0x0c, 0x15, 0x2c, 0xc7, 0x62, 0xf9, 0xfa, 0x5f, 0x2e, 0xb2, 0x58, 0x3e, 0xac,
	0x17, 0x95, 0x00, 0xea, 0xaf, 0xd4, 0xc7, 0x22, 0xa8, 0xab, 0x4a, 0x94, 0xf1, 0x57, 0xeb, 0x85,
	0x30, 0xe3, 0x46, 0x2e, 0x0c, 0xfd, 0x6b, 0xf5, 0xb1, 0x38, 0xf4, 0x4d, 0xb4, 0xcc, 0x02, 0x63,
	0xc1, 0xf1, 0xd7, 0x85, 0x05, 0x0a, 0x06, 0x19, 0xb4, 0xce, 0x88, 0x1f, 0x9c, 0xb8, 0xbe, 0xfe,
	0x37, 0x44, 0x06, 0x12, 0xc0, 0xef, 0x23, 0x2d, 0xb7, 0x0d, 0x05, 0x3d, 0xeb, 0x6f, 0x72, 0xa6,
	0x31, 0x02, 0xcb, 0x2c, 0x09, 0x2b, 0xd4, 0xeb, 0xf5, 0xfd, 0x80, 0xea, 0x7f, 0x4b, 0x66, 0x96,
	0x61, 0xc0, 0x42, 0x14, 0x96, 0xbf, 0x2d, 0x58, 0x14, 0x0c, 0x5f, 0x41, 0x0b, 0x56, 0x97, 0x87,
	0xa2, 0x7f, 0x87, 0x93, 0x65, 0x1a, 0x6a, 0x86, 0xcd, 0x7d, 0xa9, 0xfc, 0xdf, 0x15, 0x35, 0x93,
	0x43, 0x81, 0x8d, 0x87, 0x13, 0x72, 0xa0, 0xfa, 0x7b, 0x82, 0x2d, 0x87, 0x82, 0xf3, 0xe4, 0x6e,
	0x91, 0xeb, 0xeb, 0x7f, 0x5f, 0x38, 0x2f, 0x83, 0x54, 0x06, 0xcb, 0xd7, 0x7f, 0x54, 0x60, 0xb0,
	0x7c, 0x30, 0x95, 0x39, 0x31, 0x48, 0xf4, 0xdf, 0x10, 0xa6, 0x8a, 0x34, 0x7e, 0x0f, 0xad, 0xf1,
	0xdc, 0xda, 0xc3, 0x9e, 0x97, 0x50, 0xd7, 0xd7, 0xff, 0x01, 0xe7, 0x28, 0xc0, 0x45, 0x46, 0xcb,
	0xd7, 0x7f, 0x73, 0x02, 0xa3, 0xc5, 0xaa, 0xa2, 0x75, 0x56, 0xd0, 0xf9, 0x0f, 0x45, 0x55, 0x14,
	0x09, 0xc6, 0x6f, 0x96, 0xd0, 0xaa, 0x98, 0x94, 0x5e, 0x71, 0x67, 0xd5, 0xc8, 0xdd, 0xf6, 0x5e,
	0xcb, 0xa6, 0x39, 0xe5, 0x3e, 0xd9, 0xad, 0xc2, 0x55, 0x6f, 0x4d, 0xe1, 0xca, 0x5f, 0x28, 0x7b,
	0x27, 0x7f, 0x4c, 0xba, 0x9e, 0x67, 0x4c, 0xcf, 0x47, 0x23, 0xa4, 0x65, 0x33, 0xee, 0x2b, 0xdf,
	0xf2, 0x2a, 0xee, 0x4b, 0x63, 0x75, 0x8e, 0x1e, 0x3b, 0x44, 0xfb, 0x0f, 0xd3, 0x68, 0x6d, 0xbf,
	0x1f, 0xbe, 0x60, 0x1f, 0x46, 0x47, 0xac, 0x5c, 0x1a, 0x9a, 0x39, 0x74, 0x2d, 0x71, 0x76, 0x09,
	0x3f, 0x19, 0x52, 0x77, 0x44, 0x04, 0x04, 0x3f, 0xf1, 0x2e, 0x3b, 0x3a, 0x60, 0x41, 0xd3, 0x45,
	0x87, 0x11, 0x92, 0x01, 0x78, 0x2b, 0x71, 0xc2, 0x78, 0x2f, 0x3a, 0x90, 0x90, 0x0c, 0xcc, 0xa7,
	0x51, 0xb7, 0x45, 0x87, 0xe2, 0xf3, 0xb9, 0x09, 0x17, 0x8f, 0x39, 0x1d, 0xdf, 0x41, 0x0b, 0x8e,
	0xeb, 0x46, 0x61, 0x12, 0xf2, 0xcd, 0x8b, 0xf2, 0xe6, 0xcf, 0xbe, 0xba, 0xa1, 0x0d, 0x68, 0xe2,
	0x7d, 0x1a, 0x79, 0xc1, 0x09, 0xfd, 0xf4, 0xee, 0x07, 0x7b, 0x0f, 0x1f, 0x12, 0xc9, 0x84, 0xbf,
	0x85, 0xe6, 0xab, 0x0f, 0x9c, 0xe0, 0x38, 0x64, 0x13, 0x37, 0x84, 0x2e, 0x5c, 0x33, 0x14, 0x9e,
	0x13, 0x88, 0x60, 0x60, 0x0b, 0x80, 0x53, 0x1a, 0xf5, 0xbd, 0xf3, 0x4a, 0x9c, 0xd4, 0x4c, 0x4b,
	0xcc, 0xe6, 0x79, 0x50, 0xe1, 0x6a, 0x46, 0x5d, 0xe0, 0x5a, 0xca, 0x71, 0x71, 0xd0, 0x28, 0xa3,
	0x8d, 0xcc, 0xbd, 0x32, 0x8e, 0xfa, 0xa0, 0x18, 0x47, 0xf1, 0xa8, 0x2d, 0x5f, 0x0f, 0x59, 0x24,
	0xf5, 0xa3, 0x59, 0xa4, 0x29, 0x34, 0x5e, 0xd1, 0xe3, 0xb5, 0x84, 0xd1, 0xec, 0x61, 0xe0, 0x77,
	0xc5, 0xe9, 0x2f, 0xfb, 0x0d, 0x91, 0x43, 0x93, 0x76, 0x47, 0x91, 0x9f, 0x9c, 0x93, 0x91, 0xd8,
	0x2a, 0x5b, 0x21, 0x39, 0x0c, 0x22, 0x7f, 0x99, 0x76, 0xc3, 0xbe, 0x2f, 0xbe, 0x54, 0x5b, 0x21,
	0x05, 0x94, 0xad, 0xd3, 0x4e, 0xbb, 0xe2, 0x8e, 0x33, 0xab, 0x9f, 0x15, 0xa2, 0x20, 0x7c, 0x4d,
	0x76, 0x02, 0x95, 0xc4, 0xef, 0x7b, 0xb3, 0x7a, 0x59, 0x21, 0x79, 0x10, 0x2c, 0xb2, 0x55, 0xa6,
	0x05, 0x6e, 0x91, 0x8a, 0x41, 0x4e, 0x35, 0x9a, 0xd0, 0xc8, 0xea, 0x7b, 0x71, 0x2c, 0xf6, 0x98,
	0x14, 0x84, 0xed, 0x6c, 0x87, 0xa3, 0x84, 0xb2, 0x94, 0x1b, 0xf9, 0x21, 0x58, 0x29, 0x6e, 0xc4,
	0x4c, 0xa0, 0xe0, 0x7b, 0x68, 0xde, 0xec, 0xb2, 0xfd, 0x76, 0x24, 0x3e, 0xa6, 0xe4, 0x75, 0xaf,
	0xba, 0x81, 0x33, 0x10, 0xc1, 0x08, 0x71, 0x31, 0xb8, 0xfc, 0xc0, 0x4f, 0x58, 0xb4, 0xb5, 0x48,
	0x64, 0x92, 0x19, 0xc7, 0x4b, 0x0c, 0xc4, 0x15, 0xbe, 0x28, 0xc9, 0x10, 0x70, 0x67, 0x85, 0x1e,
	0x7b, 0xa3, 0x7e, 0x02, 0x6a, 0x81, 0x67, 0x95, 0x6f, 0xa2, 0xe4, 0x51, 0x68, 0xea, 0x95, 0x38,
	0x81, 0xa6, 0xbe, 0x76, 0x51, 0x53, 0xe7, 0x74, 0xa8, 0x58, 0x88, 0xe2, 0xd8, 0xc6, 0xd5, 0x22,
	0x61, 0xbf, 0xd9, 0x46, 0x4f, 0xfa, 0x1d, 0xae, 0xae, 0xdd, 0x9c, 0xb9, 0xb5, 0x44, 0x14, 0xc4,
	0x78, 0x81, 0xb0, 0xda, 0xee, 0x5e, 0x71, 0x34, 0xb9, 0x37, 0x36, 0x9a, 0x5c, 0x2e, 0xb6, 0x54,
	0x2e, 0xa3, 0x9e, 0xca, 0x2f, 0xd7, 0xdc, 0xb6, 0x4b, 0xa3, 0x63, 0xd6, 0x97, 0x6e, 0xa2, 0xe5,
	0x76, 0xe2, 0xf7, 0xfd, 0x5f, 0xe0, 0x57, 0x96, 0xf9, 0x1a, 0x43, 0x85, 0xa0, 0x21, 0x5b, 0x2e,
	0x1f, 0x5c, 0xa6, 0x09, 0xfc, 0x34, 0x2c, 0x74, 0xd9, 0xf5, 0x87, 0x14, 0x66, 0xb3, 0x66, 0xe2,
	0x9d, 0xd0, 0x54, 0xd9, 0x2e, 0x5a, 0x10, 0xba, 0x45, 0xbf, 0xe1, 0x43, 0xae, 0x92, 0x1f, 0x91,
	0x0c, 0xc6, 0x2f, 0x4f, 0x23, 0x4d, 0x6a, 0x49, 0x15, 0x7c, 0x0b, 0x2d, 0x4a, 0x2c, 0x77, 0x65,
	0x4e, 0x82, 0x24, 0x25, 0xb3, 0xcb, 0x1a, 0x07, 0x87, 0xf2, 0x1e, 0x19, 0xfb, 0x8d, 0x37, 0xd1,
	0x1c, 0xff, 0x70, 0x8b, 0x2f, 0x42, 0x78, 0x82, 0xad, 0x88, 0x69, 0xd7, 0x8f, 0xba, 0xb1, 0x58,
	0x7a, 0xc8, 0x24, 0x3f, 0xdb, 0x62, 0xb1, 0xcc, 0x7e, 0x14, 0x0e, 0xdc, 0xb2, 0x58, 0x77, 0xe4,
	0x41, 0x1e, 0xff, 0x47, 0x31, 0xff, 0x3e, 0x58, 0x7e, 0x14, 0xa6, 0x42, 0xf8, 0x13, 0xb4, 0x94,
	0x3a, 0x42, 0x5f, 0x50, 0xbf, 0xe4, 0x9b, 0xe4, 0x26, 0x92, 0x31, 0x1b, 0xff, 0x69, 0x1a, 0x2d,
	0x57, 0x2a, 0x24, 0x75, 0xc0, 0x26, 0x9a, 0x23, 0xd4, 0xeb, 0xc9, 0xfb, 0x73, 0x3c, 0xc1, 0xd6,
	0xfe, 0xd4, 0xeb, 0x55, 0xbd, 0x84, 0x06, 0xdd, 0xf3, 0x9a, 0x77, 0x26, 0x4a, 0x5d, 0x40, 0x0b,
	0x7c, 0xe6, 0xe9, 0x89, 0x70, 0x44, 0x01, 0xe5, 0x27, 0x57, 0x5e, 0xaf, 0xd6, 0x72, 0x9b, 0xcc,
	0x25, 0xd3, 0x24, 0x4d, 0xb3, 0x33, 0x1e, 0xea, 0xf5, 0xca, 0x5e, 0xd0, 0x7b, 0xe1, 0xf7, 0xc4,
	0x87, 0xbe, 0xd3, 0x24, 0x0f, 0xc2, 0xaa, 0x84, 0xdd, 0x48, 0x90, 0xee, 0x10, 0x29, 0x7c, 0x0b,
	0xad, 0xb3, 0x5f, 0x8a, 0xa9, 0x7c, 0x1d, 0x56, 0x84, 0x8b, 0x9c, 0x60, 0xec, 0xe2, 0x38, 0x27,
	0x58, 0x7b, 0x0d, 0x2d, 0x31, 0x88, 0x99, 0xbb, 0xc4, 0xac, 0xc9, 0x00, 0x28, 0x33, 0x4b, 0x64,
	0x06, 0x23, 0xc6, 0x52, 0x40, 0x8d, 0x7f, 0x5a, 0x42, 0x97, 0xcc, 0xd8, 0xef, 0x82, 0xab, 0x5f,
	0x67, 0x02, 0xdf, 0xcb, 0x55, 0x98, 0xe8, 0x75, 0xbc, 0x9d, 0x2b, 0x38, 0xc9, 0xd5, 0xaa, 0x39,
	0xde, 0xd4, 0xc5, 0x76, 0xc0, 0xe5, 0x5c, 0x33, 0x49, 0xa5, 0xc7, 0xd8, 0x8d, 0x7f, 0xbe, 0x8c,
	0x96, 0xeb, 0x5e, 0xb7, 0x9f, 0xdd, 0x44, 0x91, 0x9f, 0x9f, 0xac, 0x96, 0xaf, 0xfd, 0xec, 0xab,
	0x1b, 0x3a, 0x9b, 0x59, 0x07, 0x5e, 0xd0, 0xf3, 0x92, 0x30, 0x3a, 0xbf, 0xed, 0x0f, 0x06, 0xa3,
	0xc4, 0x3b, 0xea, 0x53, 0xf6, 0x45, 0xc5, 0xbb, 0x68, 0xad, 0x35, 0x0a, 0x02, 0xda, 0xa7, 0x3d,
	0xde, 0xb6, 0xc5, 0x6e, 0x45, 0x01, 0x85, 0x86, 0x01, 0x43, 0x47, 0xcd, 0x8f, 0x79, 0x1f, 0x5a,
	0x24, 0x69, 0x1a, 0xdf, 0x45, 0x97, 0xaa, 0x61, 0xd7, 0xeb, 0x8b, 0xa1, 0xb4, 0x1d, 0x3c, 0x0b,
	0xc2, 0x17, 0x81, 0xb8, 0x46, 0x3a, 0x89, 0xc4, 0xee, 0x3b, 0xba, 0xf2, 0xfa, 0xa3, 0xfc, 0xf2,
	0x22, 0x43, 0xa0, 0xdb, 0x54, 0xfc, 0x88, 0xf2, 0x91, 0x7f, 0x9e, 0xb9, 0x9e, 0x77, 0x1b, 0xa5,
	0xa0, 0xe2, 0x73, 0xd4, 0x8a, 0x1f, 0x91, 0x8c, 0x19, 0xeb, 0x2c, 0x0c, 0xa9, 0xfa, 0xc7, 0x7c,
	0x7a, 0x3a, 0x98, 0x22, 0x22, 0x8d, 0xef, 0x22, 0xc4, 0x7f, 0xb1, 0xcf, 0x6e, 0x16, 0x99, 0xd2,
	0x35, 0x51, 0x9f, 0x02, 0x3d, 0x98, 0x22, 0x0a, 0x0f, 0xfe, 0x14, 0x2d, 0x54, 0xf7, 0xd8, 0xa5,
	0x12, 0xd6, 0xb8, 0x96, 0xf7, 0xae, 0x8f, 0xd9, 0x50, 0xdd, 0xe3, 0x56, 0x30, 0xae, 0x83, 0x12,
	0x91, 0x02, 0x20, 0xeb, 0xb8, 0x5c, 0x16, 0x5d, 0x20, 0xeb, 0xb8, 0x05, 0x59, 0x21, 0x80, 0x37,
	0xc5, 0xac, 0xc1, 0xa6, 0xaf, 0x83, 0x69, 0x31, 0x6f, 0xbc, 0x0b, 0xdd, 0xaf, 0xc7, 0x0a, 0x5a,
	0xf5, 0x8f, 0x1d, 0x7e, 0xb6, 0xb2, 0x72, 0xc0, 0x3a, 0xa0, 0x02, 0xef, 0xac, 0xa3, 0xd5, 0x9c,
	0x55, 0x3b, 0x1f, 0xa0, 0x75, 0x11, 0x4a, 0x75, 0xc3, 0x3e, 0xcf, 0x61, 0x07, 0x2d, 0x4a, 0x40,
	0x7e, 0x3b, 0x24, 0xd3, 0x3b, 0xff, 0x7b, 0x0e, 0xad, 0xe6, 0x4c, 0xc3, 0x1f, 0xa0, 0xa5, 0x66,
	0xd4, 0x75, 0x23, 0x7a, 0xec, 0x9f, 0x89, 0x4b, 0x33, 0xeb, 0xe9, 0x94, 0xc7, 0x61, 0x92, 0x71,
	0x00, 0x7b, 0x25, 0x4e, 0x04, 0xfb, 0xf4, 0x05, 0xec, 0x29, 0x07, 0xf7, 0x14, 0x0f, 0x07, 0x79,
	0x40, 0x7a, 0x73, 0x92, 0xa7, 0x54, 0xf3, 0xb3, 0xd0, 0xb0, 0xce, 0x76, 0xe4, 0xda, 0xbd, 0x21,
	0xf7, 0x34, 0x0f, 0x52, 0x77, 0xbf, 0xde, 0xd3, 0x77, 0x5a, 0x96, 0xdb, 0xae, 0x70, 0x57, 0x1f,
	0x4c, 0x11, 0x55, 0x01, 0x3e, 0x40, 0x4b, 0x4e, 0x77, 0x20, 0xb4, 0xf1, 0x38, 0xf6, 0xd6, 0x37,
	0x68, 0x73, 0xac, 0x5a, 0xaa, 0x2b, 0x13, 0xde, 0xf9, 0x37, 0x25, 0xb4, 0xac, 0x64, 0x84, 0xeb,
	0xd9, 0x8d, 0x1d, 0xee, 0xc1, 0x07, 0x2f, 0x6f, 0x25, 0xbb, 0xe7, 0x2d, 0x4a, 0x2e, 0xef, 0xf9,
	0xd4, 0xb3, 0x7b, 0x3e, 0xd3, 0xaf, 0xa3, 0x4f, 0x28, 0xd9, 0xb9, 0xc1, 0xaf, 0x9b, 0x72, 0x63,
	0x61, 0x06, 0xcd, 0xbe, 0xda, 0x62, 0xbf, 0x77, 0xfe, 0x7d, 0x09, 0x2d, 0xa5, 0x65, 0xc5, 0xb6,
	0xf2, 0xb4, 0xcb, 0xf2, 0xde, 0xbd, 0x97, 0xf5, 0x11, 0xfb, 0xa5, 0xbc, 0xfa, 0x62, 0xa3, 0x59,
	0x2b, 0xec, 0x51, 0x51, 0x84, 0xdf, 0x9b, 0x1a, 0x10, 0x24, 0x4c, 0x7c, 0xe7, 0x3a, 0x5a, 0x94,
	0x8a, 0xc1, 0xf6, 0xd4, 0xb2, 0x55, 0x9e, 0x8d, 0xa4, 0x03, 0x2f, 0xd0, 0x59, 0x96, 0x82, 0x0e,
	0xbf, 0xcb, 0x08, 0x2d, 0xf6, 0x1f, 0x74, 0x06, 0xa0, 0xda, 0x68, 0xa0, 0xa5, 0x74, 0x60, 0xc1,
	0x97, 0xd0, 0xba, 0x6b, 0x5a, 0x5f, 0xd8, 0xad, 0x4e, 0xc5, 0x21, 0x9d, 0x7a, 0xa3, 0x6e, 0x6b,
	0x53, 0xf8, 0x32, 0xda, 0x50, 0x40, 0xfb, 0x11, 0xb1, 0x9b, 0x4d, 0xad, 0x84, 0xb7, 0x10, 0x56,
	0x60, 0xa7, 0xce, 0xf1, 0xe9, 0xf2, 0x32, 0x5a, 0xea, 0xfb, 0xc7, 0x5c, 0x7b, 0x79, 0x0d, 0xad,
	0xb0, 0x1f, 0x9d, 0x63, 0x9f, 0xf6, 0x7b, 0x71, 0x79, 0x11, 0xcd, 0x7b, 0x6c, 0xe0, 0x32, 0xbe,
	0x83, 0x56, 0x78, 0xc9, 0x5f, 0xf1, 0x7c, 0xda, 0x44, 0x1b, 0x20, 0xcf, 0x3f, 0x3a, 0x7b, 0xa5,
	0xb9, 0xc0, 0xa8, 0x20, 0xac, 0xaa, 0x78, 0x45, 0x43, 0x0e, 0xd1, 0x8a, 0xdd, 0xf7, 0x06, 0xaf,
	0x3c, 0x8d, 0x6e, 0xa1, 0x79, 0xfe, 0x5a, 0x84, 0xb8, 0xf5, 0x2c, 0x52, 0xc6, 0x8f, 0x4b, 0xe9,
	0xe7, 0x7a, 0xb0, 0xd6, 0xcd, 0x3e, 0xc6, 0xe4, 0x9f, 0x06, 0x5e, 0x43, 0x4b, 0x6e, 0xc2, 0xc8,
	0xe9, 0x17, 0x83, 0x19, 0x90, 0x7e, 0x5c, 0x38, 0xa3, 0x7c, 0x5c, 0xc8, 0x06, 0x41, 0xb1, 0x02,
	0x81, 0x91, 0x63, 0x8e, 0xa4, 0x69, 0x98, 0xcb, 0xd9, 0xbd, 0x24, 0xb1, 0xac, 0x9a, 0x13, 0x66,
	0xb3, 0xcf, 0xbc, 0x32, 0x9c, 0xa8, 0x4c, 0xf8, 0x2d, 0x34, 0x4b, 0xc2, 0x3e, 0x15, 0xf3, 0x95,
	0xd8, 0x2a, 0x60, 0x06, 0x00, 0x4c, 0x18, 0x11, 0xbc, 0x23, 0x0a, 0x91, 0x1e, 0x22, 0x90, 0x51,
	0x10, 0xc0, 0xba, 0xac, 0xc4, 0x57, 0x2b, 0x22, 0x89, 0x6f, 0xa3, 0x8d, 0xaa, 0x17, 0x27, 0x07,
	0xd4, 0x8b, 0x92, 0x32, 0xf5, 0xf8, 0xc1, 0x0d, 0x8f, 0xee, 0xc6, 0x09, 0xc6, 0x2a, 0x5a, 0xce,
	0xf4, 0xc6, 0xc6, 0x3f, 0x9b, 0x46, 0xf3, 0x3c, 0x8d, 0x3f, 0x43, 0x8b, 0xd0, 0x09, 0x6a, 0x34,
	0xf1, 0x44, 0x77, 0x5d, 0xbb, 0xc3, 0xde, 0xa0, 0x93, 0x68, 0x79, 0xfd, 0xb7, 0xbf, 0xba, 0x51,
	0xfa, 0xe9, 0x57, 0x37, 0x16, 0x6e, 0xfb, 0x01, 0x8f, 0xa5, 0x25, 0x09, 0x7f, 0x8e, 0x16, 0x1a,
	0x47, 0x3f, 0xcf, 0x64, 0xe5, 0x23, 0x50, 0x4c, 0x56, 0x80, 0xe5, 0x2d, 0x21, 0xba, 0x06, 0xe8,
	0xed, 0x70, 0xe0, 0x27, 0x74, 0x30, 0x4c, 0xce, 0x89, 0x94, 0xc2, 0x1f, 0x8b, 0xed, 0x98, 0xdc,
	0xe3, 0x60, 0x69, 0x2d, 0x96, 0x31, 0xc8, 0xc6, 0x43, 0xda, 0x55, 0x64, 0xf9, 0x1e, 0xcd, 0xe7,
	0xe9, 0x1e, 0xcd, 0xac, 0x7a, 0x3b, 0x50, 0xf1, 0x5d, 0x79, 0xf3, 0xa7, 0x5f, 0xdd, 0xd0, 0x62,
	0xf6, 0x5b, 0x11, 0x9f, 0x4f, 0xdf, 0x4f, 0x10, 0x5b, 0x37, 0x73, 0xea, 0x1e, 0x4f, 0xe6, 0xa3,
	0xf2, 0xa5, 0x9f, 0x7e, 0x75, 0x63, 0x1d, 0xc4, 0x55, 0x69, 0xb1, 0xa1, 0xd3, 0x47, 0x1b, 0x9c,
	0xf5, 0x75, 0x02, 0xc2, 0xf7, 0xc6, 0xd6, 0x60, 0xcb, 0x6a, 0xa3, 0x48, 0x89, 0xbb, 0xbf, 0x5a,
	0x52, 0x9f, 0xc0, 0xc3, 0x9b, 0x48, 0x6b, 0x11, 0xd3, 0xb2, 0x3b, 0x55, 0xfb, 0xd0, 0xae, 0x2a,
	0xc3, 0x8e, 0x8a, 0xda, 0x84, 0x34, 0x88, 0x56, 0x2a, 0xc2, 0x15, 0xbb, 0xdc, 0x7e, 0xa4, 0x4d,
	0x17, 0x75, 0x3c, 0x31, 0x49, 0x5d, 0x9b, 0x29, 0xa2, 0x4e, 0x7d, 0xbf, 0xa1, 0xcd, 0xe2, 0x6d,
	0x74, 0x49, 0x45, 0x0f, 0x6d, 0x52, 0x6e, 0x34, 0x6d, 0x6d, 0x6e, 0xf7, 0x5f, 0xcf, 0xa0, 0x8d,
	0xb1, 0x27, 0xf4, 0xf0, 0x0e, 0xda, 0x6a, 0x99, 0xe5, 0xaa, 0xdd, 0x31, 0x5d, 0xa7, 0xd3, 0x6c,
	0x99, 0xad, 0x66, 0xc7, 0xa9, 0x37, 0x6d, 0xd2, 0xd2, 0xa6, 0xf0, 0xdb, 0xe8, 0xe6, 0x64, 0x5a,
	0xa7, 0xd2, 0x76, 0xab, 0x8e, 0x65, 0xb6, 0x6c, 0xad, 0x84, 0x6f, 0xa0, 0xab, 0x17, 0x70, 0xed,
	0x9b, 0x4e, 0x55, 0x9b, 0x9e, 0x94, 0x05, 0xb1, 0x6b, 0x8d, 0x43, 0x5b, 0x9b, 0x99, 0x94, 0x05,
	0xa7, 0x75, 0xea, 0x8d, 0x56, 0x67, 0xbf, 0xd1, 0xae, 0x57, 0xb4, 0xd9, 0x49, 0x59, 0x08, 0x2e,
	0x96, 0xc5, 0xdc, 0xa4, 0x2c, 0xda, 0x6e, 0x05, 0xec, 0x9b, 0x9f, 0x24, 0xcc, 0x69, 0x5c, 0x78,
	0x81, 0x79, 0xac, 0xc0, 0xf0, 0xc8, 0x6e, 0x69, 0x8b, 0xf8, 0x1a, 0xd2, 0x27, 0x10, 0xb8, 0xd8,
	0x12, 0xbe, 0x8a, 0xb6, 0xc7, 0x8d, 0x6a, 0xda, 0xe4, 0xd0, 0xd6, 0x10, 0xbe, 0x89, 0xae, 0x5d,
	0x40, 0xe4, 0xe2, 0xcb, 0x93, 0xc5, 0xab, 0xb6, 0xd9, 0xb4, 0xb5, 0x95, 0xc9, 0xe2, 0x8c, 0xc8,
	0xc5, 0x57, 0x77, 0x6d, 0xb4, 0x96, 0x7f, 0x7a, 0x30, 0x2b, 0x06, 0xe7, 0xb7, 0xeb, 0x2d, 0xe2,
	0xd8, 0x4d, 0x6d, 0x2a, 0x73, 0x0e, 0x27, 0x58, 0x8d, 0x6a, 0xd5, 0x69, 0x3a, 0x8d, 0x7a, 0x53,
	0x2b, 0xed, 0xfe, 0xbb, 0x69, 0xb4, 0x96, 0x7f, 0x8b, 0x0e, 0xd8, 0xab, 0x55, 0xab, 0x63, 0x35,
	0xda, 0xf5, 0x96, 0x4d, 0x3a, 0x96, 0x69, 0x1d, 0xd8, 0xb2, 0xd9, 0x4e, 0xa4, 0x11, 0xdb, 0xac,
	0x68, 0x25, 0x28, 0xd0, 0x38, 0xed, 0x09, 0x71, 0x5a, 0xb6, 0x36, 0x8d, 0xdf, 0x44, 0x6f, 0xa8,
	0xc4, 0xa6, 0x45, 0xcc, 0x96, 0x75, 0xe0, 0x9a, 0x95, 0x8e, 0x69, 0x59, 0x30, 0xb5, 0xce, 0xe0,
	0x2b, 0xe8, 0xf2, 0xb8, 0xfc, 0x81, 0xd3, 0xd2, 0x66, 0x27, 0x67, 0x5b, 0x73, 0x9a, 0x4d, 0x6d,
	0x0e, 0xbf, 0x81, 0xae, 0xa8, 0x34, 0xd7, 0x24, 0x2d, 0xc7, 0xac, 0x8a, 0x8c, 0xe7, 0xf1, 0x75,
	0xb4, 0x33, 0x41, 0xd4, 0x74, 0xea, 0xad, 0x4e, 0xc3, 0xd5, 0x16, 0xb0, 0x8e, 0x36, 0x55, 0xba,
	0x7d, 0xe8, 0x58, 0x2d, 0xa7, 0x51, 0xe7, 0xb5, 0xaf, 0x52, 0x88, 0xdd, 0x22, 0x5f, 0x76, 0xea,
	0xb6, 0x5d, 0xb1, 0x2b, 0xda, 0xd2, 0x64, 0xaa, 0x28, 0x0b, 0xda, 0xfd, 0x27, 0x25, 0xb4, 0x31,
	0xf6, 0x38, 0x1e, 0xc6, 0x68, 0xad, 0x61, 0x59, 0x6d, 0xd7, 0xac, 0x5b, 0x5f, 0x76, 0x2a, 0xa4,
	0xe1, 0x6a, 0x53, 0x50, 0x6b, 0x76, 0xcd, 0x26, 0x8f, 0x6c, 0xc0, 0x9a, 0xad, 0x86, 0xcb, 0x09,
	0x25, 0xf0, 0x18, 0x2b, 0x43, 0xa7, 0xdc, 0xde, 0xdf, 0xb7, 0x49, 0xc7, 0xb4, 0xbe, 0xe8, 0xec,
	0x3b, 0xd5, 0x6a, 0xa7, 0x2d, 0x58, 0xa6, 0xa1, 0x6c, 0xe3, 0x2c, 0xed, 0x6a, 0x95, 0xd3, 0x67,
	0xc0, 0x6d, 0x39, 0x7a, 0x46, 0x63, 0x2e, 0xb5, 0x1a, 0xf5, 0x16, 0x69, 0x54, 0x3b, 0xfb, 0xce,
	0x7e, 0x43, 0xa1, 0xcd, 0xed, 0xfe, 0xdb, 0x69, 0xb4, 0x31, 0xf6, 0xc6, 0x1c, 0x58, 0xef, 0x40,
	0x9b, 0xaa, 0x37, 0x1d, 0x4b, 0x5a, 0xbf, 0x8a, 0x96, 0x2a, 0x4e, 0xd3, 0x32, 0x09, 0x38, 0xa5,
	0x84, 0x57, 0xd0, 0xa2, 0x59, 0xa9, 0x39, 0xad, 0x96, 0x5d, 0xd1, 0xa6, 0x61, 0x30, 0x6b, 0xb4,
	0x5b, 0x9d, 0xc6, 0x7e, 0xc7, 0xb2, 0xab, 0xd5, 0xa6, 0xb4, 0x6a, 0x1b, 0x5d, 0x1a, 0x83, 0x3b,
	0x7b, 0xda, 0x2c, 0xc4, 0x5c, 0x92, 0x40, 0xec, 0x8a, 0xd3, 0x12, 0xe6, 0x40, 0xdc, 0xd6, 0x22,
	0xed, 0xba, 0x65, 0x42, 0xc5, 0x70, 0x70, 0x9e, 0x05, 0x68, 0x0d, 0x18, 0x89, 0x9c, 0x26, 0xb4,
	0xed, 0x0a, 0xc7, 0x17, 0xa0, 0x15, 0x59, 0x0d, 0xf7, 0xcb, 0x4e, 0xab, 0xd1, 0xb1, 0xdc, 0x76,
	0xa7, 0x65, 0x3a, 0xa2, 0x58, 0x8b, 0x50, 0x80, 0xa6, 0x6b, 0xd6, 0x15, 0x8c, 0x75, 0xe2, 0x9a,
	0x53, 0xef, 0x34, 0x9d, 0x1f, 0xd8, 0x9d, 0x43, 0xa7, 0x51, 0x55, 0xf2, 0x40, 0x90, 0x87, 0x5d,
	0x7f, 0xdc, 0xb6, 0xdb, 0x36, 0x1f, 0xa0, 0x39, 0xbe, 0x0c, 0x05, 0x73, 0xea, 0x87, 0x66, 0xd5,
	0xa9, 0x74, 0xb8, 0x0d, 0x00, 0xaf, 0x40, 0x4b, 0x94, 0x70, 0xa3, 0xdd, 0x72, 0xdb, 0xad, 0x0e,
	0x97, 0x65, 0xe4, 0xd5, 0xdd, 0x5f, 0x2f, 0xa1, 0xcd, 0x49, 0x0f, 0xc7, 0xc1, 0x00, 0x25, 0x62,
	0x4d, 0x51, 0x4f, 0x4c, 0x69, 0xeb, 0x4b, 0xd7, 0xee, 0x54, 0x6a, 0xa6, 0x36, 0x05, 0xa3, 0xc1,
	0x45, 0x0c, 0xee, 0x03, 0xe7, 0x91, 0x56, 0xfa, 0x7a, 0x0e, 0x1b, 0xa6, 0x10, 0x03, 0x5d, 0xbf,
	0x88, 0x03, 0xc6, 0xf2, 0xfa, 0x17, 0xda, 0xcc, 0xee, 0x2f, 0xa2, 0xf5, 0xc2, 0xd3, 0x19, 0xe0,
	0xce, 0x9a, 0xe9, 0xba, 0x4e, 0xfd, 0x51, 0xa7, 0xd2, 0xae, 0xb9, 0x9d, 0x6a, 0xc3, 0x32, 0xab,
	0x9d, 0xea, 0x9e, 0x36, 0x75, 0x11, 0xe9, 0xbe, 0x56, 0x82, 0xc6, 0x95, 0x23, 0xc1, 0x60, 0xdd,
	0xb2, 0x41, 0x6c, 0xfa, 0x42, 0xda, 0x7d, 0x6d, 0x66, 0xf7, 0xb7, 0xe6, 0xd2, 0x87, 0x2d, 0xa0,
	0x2d, 0x59, 0xb5, 0x8a, 0x1c, 0x78, 0x36, 0x91, 0x06, 0x29, 0x55, 0x92, 0xe7, 0x03, 0x28, 0xf9,
	0x7e, 0xa5, 0x66, 0xe6, 0x69, 0xd3, 0x78, 0x03, 0xad, 0x02, 0x0d, 0x9a, 0x2c, 0x87, 0x66, 0xa0,
	0x01, 0xa4, 0x90, 0x55, 0xb5, 0x4d, 0xa2, 0xcd, 0x42, 0xa5, 0x01, 0x06, 0xe3, 0xac, 0x5d, 0x7f,
	0xe4, 0xd4, 0xe5, 0x28, 0xc9, 0x44, 0xe6, 0xa4, 0x96, 0xfd, 0x6a, 0xe3, 0x09, 0x87, 0xe6, 0x61,
	0xc4, 0x00, 0xa8, 0xd9, 0x6a, 0x90, 0x1c, 0xf3, 0x02, 0xb4, 0x0b, 0x66, 0xb2, 0xd9, 0x52, 0x04,
	0x16, 0xa5, 0x8e, 0xba, 0x69, 0x55, 0x39, 0xb4, 0x24, 0x39, 0x59, 0x1d, 0xec, 0x37, 0x6b, 0x1c,
	0x46, 0x52, 0x35, 0x28, 0x78, 0x54, 0x6d, 0x94, 0xcd, 0x2a, 0xd7, 0xaf, 0x2d, 0x43, 0x53, 0x04,
	0x4a, 0xd5, 0xd9, 0x57, 0xb3, 0x5c, 0x91, 0x8a, 0xf2, 0xf0, 0xaa, 0x2c, 0x29, 0xb3, 0x82, 0x45,
	0x03, 0xda, 0x9a, 0x74, 0x56, 0xcd, 0x61, 0x4d, 0xd9, 0x6d, 0x54, 0x1d, 0x18, 0x85, 0x80, 0x7f,
	0x5d, 0xaa, 0x01, 0xf5, 0x87, 0x55, 0xb3, 0xce, 0x61, 0x0d, 0x6b, 0x68, 0x05, 0xe0, 0xc3, 0xba,
	0xc3, 0x91, 0x0d, 0xe8, 0x8b, 0xac, 0xf0, 0x87, 0x56, 0xa7, 0x52, 0xe6, 0x20, 0x96, 0xc6, 0x1d,
	0xd6, 0x1d, 0xab, 0xd3, 0xb2, 0x4c, 0x51, 0x9c, 0x4b, 0x30, 0xb9, 0x33, 0xe6, 0x2f, 0x9b, 0x2d,
	0xbb, 0xd6, 0x21, 0xb6, 0xd5, 0x38, 0xb4, 0x89, 0x59, 0x76, 0xaa, 0x4e, 0xeb, 0xcb, 0x8e, 0x5d,
	0x87, 0x7e, 0xab, 0x6d, 0xe2, 0x77, 0xd0, 0x9b, 0x17, 0x73, 0x89, 0xee, 0xad, 0x5d, 0x86, 0xf1,
	0x90, 0xb7, 0x80, 0x7a, 0x7b, 0xdf, 0xb4, 0x5a, 0x6d, 0x02, 0x75, 0x5d, 0x6b, 0x54, 0x6c, 0xa9,
	0x69, 0x0b, 0xda, 0xf8, 0x05, 0x2c, 0x52, 0xcd, 0x36, 0x8c, 0x3e, 0xc0, 0x53, 0x31, 0x5b, 0xa6,
	0x6b, 0xb6, 0x0e, 0x3a, 0x66, 0xb3, 0xe9, 0x34, 0x5b, 0x9a, 0x9e, 0x7a, 0x12, 0x1a, 0x87, 0x59,
	0x15, 0x35, 0x75, 0x05, 0xc6, 0x79, 0x80, 0xed, 0xef, 0xb7, 0x6c, 0x52, 0x37, 0xab, 0x9d, 0x47,
	0xc4, 0xb5, 0x64, 0x8e, 0x3b, 0xb2, 0xf5, 0xe4, 0xa9, 0x32, 0xb3, 0xab, 0xbb, 0xf7, 0xd1, 0x7a,
	0xe1, 0x43, 0x6d, 0xbc, 0x8e, 0x96, 0x0f, 0xcc, 0xea, 0x3e, 0x8b, 0xa0, 0xec, 0xef, 0x6b, 0x53,
	0x00, 0xf0, 0xb1, 0x97, 0x03, 0xa5, 0xdd, 0x3f, 0x54, 0xca, 0x76, 0xc7, 0xa1, 0xed, 0xb8, 0x8e,
	0x6b, 0x57, 0xa1, 0x61, 0x8a, 0xae, 0x80, 0xd1, 0x5a, 0x0a, 0xb5, 0xa0, 0xe5, 0x6b, 0xa5, 0x1c,
	0xc6, 0x7a, 0x83, 0x36, 0x0d, 0x25, 0x4d, 0x31, 0xf7, 0x41, 0xba, 0x86, 0x9d, 0x61, 0x43, 0xa7,
	0x42, 0x10, 0x6b, 0xde, 0xd9, 0x9c, 0x92, 0x26, 0x53, 0x32, 0xb7, 0xfb, 0x34, 0xb7, 0x74, 0x02,
	0x27, 0x35, 0xad, 0x03, 0xbb, 0x22, 0x9b, 0x8f, 0x30, 0x69, 0x0b, 0xe1, 0x1c, 0xdc, 0x68, 0x1d,
	0xd8, 0x22, 0x9c, 0xcd, 0xe1, 0x30, 0xd3, 0x68, 0xd3, 0xd0, 0x88, 0x72, 0x30, 0x21, 0xda, 0xcc,
	0xee, 0x63, 0xb9, 0x20, 0x84, 0x95, 0x15, 0x8b, 0x6d, 0x0f, 0x20, 0xb0, 0xe8, 0x90, 0x46, 0x35,
	0x2d, 0x3a, 0x84, 0x38, 0x0a, 0x2a, 0x26, 0x30, 0xad, 0x54, 0x64, 0x87, 0xda, 0xd5, 0xa6, 0xf7,
	0xfe, 0xd8, 0x86, 0xb8, 0x22, 0xdd, 0x3c, 0xed, 0xe2, 0x8f, 0xd0, 0x32, 0x8b, 0xca, 0xf9, 0xe9,
	0x34, 0xde, 0xc8, 0xde, 0xa4, 0x16, 0xeb, 0xeb, 0x1d, 0xac, 0x42, 0xe2, 0x18, 0x65, 0x0a, 0xef,
	0x8a, 0x68, 0x7e, 0xbf, 0x3f, 0x8a, 0x9f, 0xe2, 0x15, 0xb1, 0x44, 0x60, 0x17, 0xbf, 0x76, 0x72,
	0x29, 0x63, 0x0a, 0x7f, 0x26, 0xde, 0xe1, 0x96, 0xaf, 0x62, 0x17, 0xd8, 0x77, 0x0a, 0xef, 0x60,
	0x2b, 0xcb, 0x11, 0x21, 0xac, 0x3e, 0x98, 0x3c, 0x59, 0x78, 0xd2, 0x93, 0xca, 0xc6, 0x14, 0xfe,
	0x36, 0x7f, 0x6f, 0x98, 0x26, 0xa3, 0x21, 0xde, 0x4c, 0x9f, 0xf6, 0x55, 0x9e, 0x3f, 0xde, 0xb9,
	0x5c, 0x40, 0x53, 0xd1, 0x8f, 0xd1, 0xb2, 0xf2, 0xbe, 0x70, 0x21, 0x57, 0x3d, 0xf7, 0x4c, 0x70,
	0x3e, 0xcf, 0x87, 0x08, 0x65, 0xcf, 0x13, 0x16, 0xe4, 0xb6, 0xd5, 0x77, 0xed, 0xf2, 0x62, 0xb7,
	0xd1, 0x8a, 0xc0, 0x09, 0x8d, 0xc7, 0x04, 0x8b, 0x2e, 0xbd, 0x8b, 0x34, 0xf7, 0x28, 0x7b, 0xb1,
	0xf5, 0x25, 0x24, 0x2c, 0xb4, 0x31, 0xf6, 0x6e, 0x5f, 0x41, 0xe4, 0xfa, 0x84, 0x57, 0xf7, 0xf2,
	0x46, 0xde, 0x47, 0x97, 0x0a, 0x8f, 0xf2, 0xbd, 0x44, 0xce, 0x65, 0xb4, 0xac, 0x3c, 0x71, 0x87,
	0xb7, 0x73, 0xef, 0xc8, 0x65, 0xf7, 0xf7, 0x84, 0x53, 0x27, 0xbc, 0x86, 0x67, 0x4c, 0xe1, 0x0f,
	0xd1, 0x82, 0x78, 0xce, 0xa6, 0x90, 0xd9, 0x66, 0xfa, 0x2c, 0x4d, 0x5e, 0xe0, 0x23, 0xb4, 0x20,
	0x1e, 0x2d, 0xc3, 0x97, 0xd2, 0xd7, 0xc6, 0x94, 0xcc, 0x36, 0xf3, 0xa0, 0xda, 0xae, 0xf9, 0x63,
	0x36, 0xad, 0xc8, 0x1f, 0x7c, 0x43, 0xc1, 0xee, 0xa3, 0x75, 0x76, 0xdf, 0x32, 0x7b, 0xf1, 0x09,
	0xf3, 0x15, 0xb8, 0xf2, 0x4e, 0xd4, 0x98, 0xd0, 0x1d, 0xb4, 0xd6, 0x4c, 0xc2, 0xa1, 0x22, 0xf3,
	0xf5, 0x99, 0xd4, 0xd9, 0x60, 0x99, 0x7e, 0xdf, 0x0d, 0x05, 0xba, 0x7a, 0xd1, 0x57, 0xdf, 0xb5,
	0xf8, 0x64, 0xe7, 0xda, 0x85, 0x5f, 0xa6, 0xd7, 0xe2, 0x13, 0x63, 0x0a, 0x7f, 0x8a, 0x76, 0xd2,
	0x07, 0xbd, 0xdc, 0x61, 0xcc, 0x7c, 0xed, 0x07, 0x27, 0x76, 0x00, 0x5d, 0xe8, 0x1b, 0x3b, 0xf2,
	0xd5, 0x49, 0xb2, 0x15, 0x3f, 0x7e, 0x09, 0xe1, 0xef, 0x21, 0x7d, 0xfc, 0x6b, 0x5d, 0x31, 0xec,
	0xf0, 0x96, 0x77, 0xe1, 0xc7, 0xbc, 0x63, 0xba, 0x9e, 0x8c, 0x7d, 0xfc, 0x0a, 0x7e, 0xb9, 0x3e,
	0xe9, 0x1b, 0x47, 0xa5, 0xce, 0x6f, 0x5c, 0x48, 0x57, 0x07, 0x0c, 0x79, 0xc9, 0x05, 0x6f, 0x66,
	0x57, 0x53, 0x14, 0x25, 0x97, 0x0b, 0x68, 0x2a, 0x5a, 0x43, 0x5b, 0x93, 0x3f, 0xa0, 0x2c, 0xf8,
	0xe5, 0xad, 0x8b, 0xbe, 0x80, 0xcc, 0xab, 0xfb, 0x01, 0xda, 0x1e, 0xfb, 0xb0, 0xc7, 0x8a, 0x28,
	0x78, 0xeb, 0x8d, 0x0b, 0x3e, 0x0a, 0x12, 0x16, 0x5e, 0xbf, 0x88, 0x9c, 0xea, 0xbe, 0x8b, 0x34,
	0x68, 0x7b, 0x3e, 0xfb, 0xce, 0xe3, 0xa5, 0x6a, 0xfe, 0x1e, 0xda, 0xc8, 0x24, 0x5e, 0xae, 0xbe,
	0x3f, 0x47, 0x28, 0x3b, 0x88, 0xc7, 0x5b, 0x85, 0x93, 0x79, 0x69, 0xec, 0xf6, 0x18, 0xae, 0x8e,
	0xc0, 0xca, 0x91, 0xe5, 0xc4, 0x11, 0x78, 0xc2, 0x91, 0x26, 0xeb, 0x97, 0xa8, 0xee, 0x75, 0xfb,
	0xc2, 0x5b, 0x5a, 0x71, 0xc7, 0x7d, 0x67, 0x43, 0x41, 0x52, 0xa1, 0xcf, 0xb9, 0x90, 0x78, 0xd0,
	0x6c, 0x2b, 0x65, 0xc9, 0x6d, 0x36, 0x0b, 0x73, 0xc7, 0x77, 0x90, 0x8d, 0x29, 0x6c, 0xcb, 0x37,
	0x11, 0x08, 0xf5, 0x7a, 0xf8, 0xca, 0xd8, 0x0b, 0x01, 0x69, 0x0f, 0xdd, 0xb9, 0xe0, 0xf1, 0x00,
	0xde, 0x3f, 0x0f, 0xd0, 0xb2, 0xf2, 0xcd, 0x3b, 0xde, 0xb9, 0xe0, 0x2b, 0x78, 0x50, 0x74, 0x75,
	0x9c, 0xa6, 0x6a, 0xba, 0x8f, 0xd6, 0xec, 0xbe, 0x37, 0xb0, 0xbc, 0x61, 0x32, 0x8a, 0xe8, 0xb8,
	0x0b, 0xb9, 0x1b, 0xd4, 0x7d, 0x6c, 0x26, 0xb4, 0x94, 0x6e, 0x0a, 0x16, 0xf8, 0xb7, 0x94, 0x8d,
	0xbd, 0xbc, 0xc3, 0x2d, 0xb4, 0x31, 0xf6, 0x12, 0xd8, 0xc4, 0xb9, 0xe5, 0xc2, 0xf7, 0xc2, 0x8c,
	0xa9, 0xf2, 0xca, 0xbf, 0xfc, 0xc9, 0xf5, 0xd2, 0x6f, 0xff, 0xe4, 0x7a, 0xe9, 0x3f, 0xfe, 0xe4,
	0x7a, 0xe9, 0x68, 0x9e, 0xbd, 0xc3, 0x77, 0xff, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x20, 0xe0,
	0x77, 0xbc, 0x6e, 0x64, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DebugSvcClient is the client API for DebugSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DebugSvcClient interface {
	TraceUpdate(ctx context.Context, in *TraceRequest, opts ...grpc.CallOption) (*TraceResponse, error)
	TraceFlush(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	TraceLevelGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TraceLevelGetResponse, error)
	TableStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TableStatsGetResponse, error)
	LlcSetup(ctx context.Context, in *LlcSetupRequest, opts ...grpc.CallOption) (*LlcSetupResponse, error)
	LlcStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LlcStatsGetResponse, error)
	PbStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PbStatsGetResponse, error)
	PbStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	PbDropStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	PbStatsSummaryGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PbStatsSummaryGetResponse, error)
	PbStatsSummaryReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	MemTrackGet(ctx context.Context, in *MemTrackGetRequest, opts ...grpc.CallOption) (*MemTrackGetResponse, error)
	SlabGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SlabGetResponse, error)
	HeapGet(ctx context.Context, in *HeapGetRequest, opts ...grpc.CallOption) (*HeapGetResponse, error)
	MemoryTrim(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	StartAacsServer(ctx context.Context, in *AacsRequest, opts ...grpc.CallOption) (*Empty, error)
	StopAacsServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	InternalPortGet(ctx context.Context, in *InternalPortRequestMsg, opts ...grpc.CallOption) (*InternalPortResponseMsg, error)
	InterfacePpsTrackingEnable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	InterfacePpsTrackingDisable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	LearnDedupIntervalUpdate(ctx context.Context, in *LearnDedupIntervalRequest, opts ...grpc.CallOption) (*Empty, error)
	TcpProxySessionGet(ctx context.Context, in *TcpProxySessionGetRequest, opts ...grpc.CallOption) (*TcpProxySessionGetResponse, error)
	TcpCbGet(ctx context.Context, in *TcpCbGetRequest, opts ...grpc.CallOption) (*TcpCbGetResponse, error)
	TcpProxyGlobalStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TcpProxyGlobalStatsGetResponse, error)
	TcpProxyGlobalCfgCreate(ctx context.Context, in *TcpProxyGlobalCfgRequest, opts ...grpc.CallOption) (*TcpProxyGlobalCfgResponse, error)
	ServiceLifEnable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	ServiceLifDisable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	FlowTracer(ctx context.Context, in *FlowTracerRequest, opts ...grpc.CallOption) (*FlowTracerResponse, error)
	AsicPerfGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AsicPerfGetResponse, error)
	NaclCreate(ctx context.Context, in *NaclRequest, opts ...grpc.CallOption) (*NaclResponse, error)
	NaclDelete(ctx context.Context, in *NaclDeleteRequest, opts ...grpc.CallOption) (*NaclDeleteResponse, error)
	EepromRead(ctx context.Context, in *EepromReadRequestMsg, opts ...grpc.CallOption) (*EepromReadResponseMsg, error)
	EepromWrite(ctx context.Context, in *EepromWriteRequestMsg, opts ...grpc.CallOption) (*EepromWriteResponseMsg, error)
	ElamCaptureGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ElamResponse, error)
	ThreadGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ThreadGetResponse, error)
	DatapathMemoryGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DatapathMemoryGetResponse, error)
}

type debugSvcClient struct {
	cc *grpc.ClientConn
}

func NewDebugSvcClient(cc *grpc.ClientConn) DebugSvcClient {
	return &debugSvcClient{cc}
}

func (c *debugSvcClient) TraceUpdate(ctx context.Context, in *TraceRequest, opts ...grpc.CallOption) (*TraceResponse, error) {
	out := new(TraceResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TraceUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TraceFlush(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TraceFlush", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TraceLevelGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TraceLevelGetResponse, error) {
	out := new(TraceLevelGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TraceLevelGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TableStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TableStatsGetResponse, error) {
	out := new(TableStatsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TableStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) LlcSetup(ctx context.Context, in *LlcSetupRequest, opts ...grpc.CallOption) (*LlcSetupResponse, error) {
	out := new(LlcSetupResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/LlcSetup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) LlcStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LlcStatsGetResponse, error) {
	out := new(LlcStatsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/LlcStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) PbStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PbStatsGetResponse, error) {
	out := new(PbStatsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/PbStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) PbStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/PbStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) PbDropStatsReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/PbDropStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) PbStatsSummaryGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PbStatsSummaryGetResponse, error) {
	out := new(PbStatsSummaryGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/PbStatsSummaryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) PbStatsSummaryReset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/PbStatsSummaryReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) MemTrackGet(ctx context.Context, in *MemTrackGetRequest, opts ...grpc.CallOption) (*MemTrackGetResponse, error) {
	out := new(MemTrackGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/MemTrackGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) SlabGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SlabGetResponse, error) {
	out := new(SlabGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/SlabGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) HeapGet(ctx context.Context, in *HeapGetRequest, opts ...grpc.CallOption) (*HeapGetResponse, error) {
	out := new(HeapGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/HeapGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) MemoryTrim(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/MemoryTrim", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) StartAacsServer(ctx context.Context, in *AacsRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/StartAacsServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) StopAacsServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/StopAacsServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) InternalPortGet(ctx context.Context, in *InternalPortRequestMsg, opts ...grpc.CallOption) (*InternalPortResponseMsg, error) {
	out := new(InternalPortResponseMsg)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/InternalPortGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) InterfacePpsTrackingEnable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/InterfacePpsTrackingEnable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) InterfacePpsTrackingDisable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/InterfacePpsTrackingDisable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) LearnDedupIntervalUpdate(ctx context.Context, in *LearnDedupIntervalRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/LearnDedupIntervalUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TcpProxySessionGet(ctx context.Context, in *TcpProxySessionGetRequest, opts ...grpc.CallOption) (*TcpProxySessionGetResponse, error) {
	out := new(TcpProxySessionGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TcpProxySessionGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TcpCbGet(ctx context.Context, in *TcpCbGetRequest, opts ...grpc.CallOption) (*TcpCbGetResponse, error) {
	out := new(TcpCbGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TcpCbGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TcpProxyGlobalStatsGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TcpProxyGlobalStatsGetResponse, error) {
	out := new(TcpProxyGlobalStatsGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TcpProxyGlobalStatsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) TcpProxyGlobalCfgCreate(ctx context.Context, in *TcpProxyGlobalCfgRequest, opts ...grpc.CallOption) (*TcpProxyGlobalCfgResponse, error) {
	out := new(TcpProxyGlobalCfgResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/TcpProxyGlobalCfgCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) ServiceLifEnable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/ServiceLifEnable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) ServiceLifDisable(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/ServiceLifDisable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) FlowTracer(ctx context.Context, in *FlowTracerRequest, opts ...grpc.CallOption) (*FlowTracerResponse, error) {
	out := new(FlowTracerResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/FlowTracer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) AsicPerfGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AsicPerfGetResponse, error) {
	out := new(AsicPerfGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/AsicPerfGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) NaclCreate(ctx context.Context, in *NaclRequest, opts ...grpc.CallOption) (*NaclResponse, error) {
	out := new(NaclResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/NaclCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) NaclDelete(ctx context.Context, in *NaclDeleteRequest, opts ...grpc.CallOption) (*NaclDeleteResponse, error) {
	out := new(NaclDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/NaclDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) EepromRead(ctx context.Context, in *EepromReadRequestMsg, opts ...grpc.CallOption) (*EepromReadResponseMsg, error) {
	out := new(EepromReadResponseMsg)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/EepromRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) EepromWrite(ctx context.Context, in *EepromWriteRequestMsg, opts ...grpc.CallOption) (*EepromWriteResponseMsg, error) {
	out := new(EepromWriteResponseMsg)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/EepromWrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) ElamCaptureGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ElamResponse, error) {
	out := new(ElamResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/ElamCaptureGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) ThreadGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ThreadGetResponse, error) {
	out := new(ThreadGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/ThreadGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugSvcClient) DatapathMemoryGet(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DatapathMemoryGetResponse, error) {
	out := new(DatapathMemoryGetResponse)
	err := c.cc.Invoke(ctx, "/pds.DebugSvc/DatapathMemoryGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugSvcServer is the server API for DebugSvc service.
type DebugSvcServer interface {
	TraceUpdate(context.Context, *TraceRequest) (*TraceResponse, error)
	TraceFlush(context.Context, *Empty) (*Empty, error)
	TraceLevelGet(context.Context, *Empty) (*TraceLevelGetResponse, error)
	TableStatsGet(context.Context, *Empty) (*TableStatsGetResponse, error)
	LlcSetup(context.Context, *LlcSetupRequest) (*LlcSetupResponse, error)
	LlcStatsGet(context.Context, *Empty) (*LlcStatsGetResponse, error)
	PbStatsGet(context.Context, *Empty) (*PbStatsGetResponse, error)
	PbStatsReset(context.Context, *Empty) (*Empty, error)
	PbDropStatsReset(context.Context, *Empty) (*Empty, error)
	PbStatsSummaryGet(context.Context, *Empty) (*PbStatsSummaryGetResponse, error)
	PbStatsSummaryReset(context.Context, *Empty) (*Empty, error)
	MemTrackGet(context.Context, *MemTrackGetRequest) (*MemTrackGetResponse, error)
	SlabGet(context.Context, *Empty) (*SlabGetResponse, error)
	HeapGet(context.Context, *HeapGetRequest) (*HeapGetResponse, error)
	MemoryTrim(context.Context, *Empty) (*Empty, error)
	StartAacsServer(context.Context, *AacsRequest) (*Empty, error)
	StopAacsServer(context.Context, *Empty) (*Empty, error)
	InternalPortGet(context.Context, *InternalPortRequestMsg) (*InternalPortResponseMsg, error)
	InterfacePpsTrackingEnable(context.Context, *Empty) (*Empty, error)
	InterfacePpsTrackingDisable(context.Context, *Empty) (*Empty, error)
	LearnDedupIntervalUpdate(context.Context, *LearnDedupIntervalRequest) (*Empty, error)
	TcpProxySessionGet(context.Context, *TcpProxySessionGetRequest) (*TcpProxySessionGetResponse, error)
	TcpCbGet(context.Context, *TcpCbGetRequest) (*TcpCbGetResponse, error)
	TcpProxyGlobalStatsGet(context.Context, *Empty) (*TcpProxyGlobalStatsGetResponse, error)
	TcpProxyGlobalCfgCreate(context.Context, *TcpProxyGlobalCfgRequest) (*TcpProxyGlobalCfgResponse, error)
	ServiceLifEnable(context.Context, *Empty) (*Empty, error)
	ServiceLifDisable(context.Context, *Empty) (*Empty, error)
	FlowTracer(context.Context, *FlowTracerRequest) (*FlowTracerResponse, error)
	AsicPerfGet(context.Context, *Empty) (*AsicPerfGetResponse, error)
	NaclCreate(context.Context, *NaclRequest) (*NaclResponse, error)
	NaclDelete(context.Context, *NaclDeleteRequest) (*NaclDeleteResponse, error)
	EepromRead(context.Context, *EepromReadRequestMsg) (*EepromReadResponseMsg, error)
	EepromWrite(context.Context, *EepromWriteRequestMsg) (*EepromWriteResponseMsg, error)
	ElamCaptureGet(context.Context, *Empty) (*ElamResponse, error)
	ThreadGet(context.Context, *Empty) (*ThreadGetResponse, error)
	DatapathMemoryGet(context.Context, *Empty) (*DatapathMemoryGetResponse, error)
}

// UnimplementedDebugSvcServer can be embedded to have forward compatible implementations.
type UnimplementedDebugSvcServer struct {
}

func (*UnimplementedDebugSvcServer) TraceUpdate(ctx context.Context, req *TraceRequest) (*TraceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TraceUpdate not implemented")
}
func (*UnimplementedDebugSvcServer) TraceFlush(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TraceFlush not implemented")
}
func (*UnimplementedDebugSvcServer) TraceLevelGet(ctx context.Context, req *Empty) (*TraceLevelGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TraceLevelGet not implemented")
}
func (*UnimplementedDebugSvcServer) TableStatsGet(ctx context.Context, req *Empty) (*TableStatsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableStatsGet not implemented")
}
func (*UnimplementedDebugSvcServer) LlcSetup(ctx context.Context, req *LlcSetupRequest) (*LlcSetupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LlcSetup not implemented")
}
func (*UnimplementedDebugSvcServer) LlcStatsGet(ctx context.Context, req *Empty) (*LlcStatsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LlcStatsGet not implemented")
}
func (*UnimplementedDebugSvcServer) PbStatsGet(ctx context.Context, req *Empty) (*PbStatsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PbStatsGet not implemented")
}
func (*UnimplementedDebugSvcServer) PbStatsReset(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PbStatsReset not implemented")
}
func (*UnimplementedDebugSvcServer) PbDropStatsReset(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PbDropStatsReset not implemented")
}
func (*UnimplementedDebugSvcServer) PbStatsSummaryGet(ctx context.Context, req *Empty) (*PbStatsSummaryGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PbStatsSummaryGet not implemented")
}
func (*UnimplementedDebugSvcServer) PbStatsSummaryReset(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PbStatsSummaryReset not implemented")
}
func (*UnimplementedDebugSvcServer) MemTrackGet(ctx context.Context, req *MemTrackGetRequest) (*MemTrackGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemTrackGet not implemented")
}
func (*UnimplementedDebugSvcServer) SlabGet(ctx context.Context, req *Empty) (*SlabGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SlabGet not implemented")
}
func (*UnimplementedDebugSvcServer) HeapGet(ctx context.Context, req *HeapGetRequest) (*HeapGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeapGet not implemented")
}
func (*UnimplementedDebugSvcServer) MemoryTrim(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemoryTrim not implemented")
}
func (*UnimplementedDebugSvcServer) StartAacsServer(ctx context.Context, req *AacsRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAacsServer not implemented")
}
func (*UnimplementedDebugSvcServer) StopAacsServer(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAacsServer not implemented")
}
func (*UnimplementedDebugSvcServer) InternalPortGet(ctx context.Context, req *InternalPortRequestMsg) (*InternalPortResponseMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalPortGet not implemented")
}
func (*UnimplementedDebugSvcServer) InterfacePpsTrackingEnable(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfacePpsTrackingEnable not implemented")
}
func (*UnimplementedDebugSvcServer) InterfacePpsTrackingDisable(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfacePpsTrackingDisable not implemented")
}
func (*UnimplementedDebugSvcServer) LearnDedupIntervalUpdate(ctx context.Context, req *LearnDedupIntervalRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LearnDedupIntervalUpdate not implemented")
}
func (*UnimplementedDebugSvcServer) TcpProxySessionGet(ctx context.Context, req *TcpProxySessionGetRequest) (*TcpProxySessionGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TcpProxySessionGet not implemented")
}
func (*UnimplementedDebugSvcServer) TcpCbGet(ctx context.Context, req *TcpCbGetRequest) (*TcpCbGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TcpCbGet not implemented")
}
func (*UnimplementedDebugSvcServer) TcpProxyGlobalStatsGet(ctx context.Context, req *Empty) (*TcpProxyGlobalStatsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TcpProxyGlobalStatsGet not implemented")
}
func (*UnimplementedDebugSvcServer) TcpProxyGlobalCfgCreate(ctx context.Context, req *TcpProxyGlobalCfgRequest) (*TcpProxyGlobalCfgResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TcpProxyGlobalCfgCreate not implemented")
}
func (*UnimplementedDebugSvcServer) ServiceLifEnable(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServiceLifEnable not implemented")
}
func (*UnimplementedDebugSvcServer) ServiceLifDisable(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServiceLifDisable not implemented")
}
func (*UnimplementedDebugSvcServer) FlowTracer(ctx context.Context, req *FlowTracerRequest) (*FlowTracerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlowTracer not implemented")
}
func (*UnimplementedDebugSvcServer) AsicPerfGet(ctx context.Context, req *Empty) (*AsicPerfGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AsicPerfGet not implemented")
}
func (*UnimplementedDebugSvcServer) NaclCreate(ctx context.Context, req *NaclRequest) (*NaclResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NaclCreate not implemented")
}
func (*UnimplementedDebugSvcServer) NaclDelete(ctx context.Context, req *NaclDeleteRequest) (*NaclDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NaclDelete not implemented")
}
func (*UnimplementedDebugSvcServer) EepromRead(ctx context.Context, req *EepromReadRequestMsg) (*EepromReadResponseMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EepromRead not implemented")
}
func (*UnimplementedDebugSvcServer) EepromWrite(ctx context.Context, req *EepromWriteRequestMsg) (*EepromWriteResponseMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EepromWrite not implemented")
}
func (*UnimplementedDebugSvcServer) ElamCaptureGet(ctx context.Context, req *Empty) (*ElamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ElamCaptureGet not implemented")
}
func (*UnimplementedDebugSvcServer) ThreadGet(ctx context.Context, req *Empty) (*ThreadGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThreadGet not implemented")
}
func (*UnimplementedDebugSvcServer) DatapathMemoryGet(ctx context.Context, req *Empty) (*DatapathMemoryGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatapathMemoryGet not implemented")
}

func RegisterDebugSvcServer(s *grpc.Server, srv DebugSvcServer) {
	s.RegisterService(&_DebugSvc_serviceDesc, srv)
}

func _DebugSvc_TraceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TraceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TraceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TraceUpdate(ctx, req.(*TraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TraceFlush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TraceFlush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TraceFlush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TraceFlush(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TraceLevelGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TraceLevelGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TraceLevelGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TraceLevelGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TableStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TableStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TableStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TableStatsGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_LlcSetup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LlcSetupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).LlcSetup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/LlcSetup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).LlcSetup(ctx, req.(*LlcSetupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_LlcStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).LlcStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/LlcStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).LlcStatsGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_PbStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).PbStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/PbStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).PbStatsGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_PbStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).PbStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/PbStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).PbStatsReset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_PbDropStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).PbDropStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/PbDropStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).PbDropStatsReset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_PbStatsSummaryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).PbStatsSummaryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/PbStatsSummaryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).PbStatsSummaryGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_PbStatsSummaryReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).PbStatsSummaryReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/PbStatsSummaryReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).PbStatsSummaryReset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_MemTrackGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemTrackGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).MemTrackGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/MemTrackGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).MemTrackGet(ctx, req.(*MemTrackGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_SlabGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).SlabGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/SlabGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).SlabGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_HeapGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeapGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).HeapGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/HeapGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).HeapGet(ctx, req.(*HeapGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_MemoryTrim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).MemoryTrim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/MemoryTrim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).MemoryTrim(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_StartAacsServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AacsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).StartAacsServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/StartAacsServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).StartAacsServer(ctx, req.(*AacsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_StopAacsServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).StopAacsServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/StopAacsServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).StopAacsServer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_InternalPortGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalPortRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).InternalPortGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/InternalPortGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).InternalPortGet(ctx, req.(*InternalPortRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_InterfacePpsTrackingEnable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).InterfacePpsTrackingEnable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/InterfacePpsTrackingEnable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).InterfacePpsTrackingEnable(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_InterfacePpsTrackingDisable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).InterfacePpsTrackingDisable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/InterfacePpsTrackingDisable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).InterfacePpsTrackingDisable(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_LearnDedupIntervalUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnDedupIntervalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).LearnDedupIntervalUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/LearnDedupIntervalUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).LearnDedupIntervalUpdate(ctx, req.(*LearnDedupIntervalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TcpProxySessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxySessionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TcpProxySessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TcpProxySessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TcpProxySessionGet(ctx, req.(*TcpProxySessionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TcpCbGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpCbGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TcpCbGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TcpCbGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TcpCbGet(ctx, req.(*TcpCbGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TcpProxyGlobalStatsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TcpProxyGlobalStatsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TcpProxyGlobalStatsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TcpProxyGlobalStatsGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_TcpProxyGlobalCfgCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcpProxyGlobalCfgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).TcpProxyGlobalCfgCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/TcpProxyGlobalCfgCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).TcpProxyGlobalCfgCreate(ctx, req.(*TcpProxyGlobalCfgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_ServiceLifEnable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).ServiceLifEnable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/ServiceLifEnable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).ServiceLifEnable(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_ServiceLifDisable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).ServiceLifDisable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/ServiceLifDisable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).ServiceLifDisable(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_FlowTracer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowTracerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).FlowTracer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/FlowTracer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).FlowTracer(ctx, req.(*FlowTracerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_AsicPerfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).AsicPerfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/AsicPerfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).AsicPerfGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_NaclCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NaclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).NaclCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/NaclCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).NaclCreate(ctx, req.(*NaclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_NaclDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NaclDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).NaclDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/NaclDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).NaclDelete(ctx, req.(*NaclDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_EepromRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EepromReadRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).EepromRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/EepromRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).EepromRead(ctx, req.(*EepromReadRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_EepromWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EepromWriteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).EepromWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/EepromWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).EepromWrite(ctx, req.(*EepromWriteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_ElamCaptureGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).ElamCaptureGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/ElamCaptureGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).ElamCaptureGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_ThreadGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).ThreadGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/ThreadGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).ThreadGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugSvc_DatapathMemoryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugSvcServer).DatapathMemoryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.DebugSvc/DatapathMemoryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugSvcServer).DatapathMemoryGet(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _DebugSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.DebugSvc",
	HandlerType: (*DebugSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TraceUpdate",
			Handler:    _DebugSvc_TraceUpdate_Handler,
		},
		{
			MethodName: "TraceFlush",
			Handler:    _DebugSvc_TraceFlush_Handler,
		},
		{
			MethodName: "TraceLevelGet",
			Handler:    _DebugSvc_TraceLevelGet_Handler,
		},
		{
			MethodName: "TableStatsGet",
			Handler:    _DebugSvc_TableStatsGet_Handler,
		},
		{
			MethodName: "LlcSetup",
			Handler:    _DebugSvc_LlcSetup_Handler,
		},
		{
			MethodName: "LlcStatsGet",
			Handler:    _DebugSvc_LlcStatsGet_Handler,
		},
		{
			MethodName: "PbStatsGet",
			Handler:    _DebugSvc_PbStatsGet_Handler,
		},
		{
			MethodName: "PbStatsReset",
			Handler:    _DebugSvc_PbStatsReset_Handler,
		},
		{
			MethodName: "PbDropStatsReset",
			Handler:    _DebugSvc_PbDropStatsReset_Handler,
		},
		{
			MethodName: "PbStatsSummaryGet",
			Handler:    _DebugSvc_PbStatsSummaryGet_Handler,
		},
		{
			MethodName: "PbStatsSummaryReset",
			Handler:    _DebugSvc_PbStatsSummaryReset_Handler,
		},
		{
			MethodName: "MemTrackGet",
			Handler:    _DebugSvc_MemTrackGet_Handler,
		},
		{
			MethodName: "SlabGet",
			Handler:    _DebugSvc_SlabGet_Handler,
		},
		{
			MethodName: "HeapGet",
			Handler:    _DebugSvc_HeapGet_Handler,
		},
		{
			MethodName: "MemoryTrim",
			Handler:    _DebugSvc_MemoryTrim_Handler,
		},
		{
			MethodName: "StartAacsServer",
			Handler:    _DebugSvc_StartAacsServer_Handler,
		},
		{
			MethodName: "StopAacsServer",
			Handler:    _DebugSvc_StopAacsServer_Handler,
		},
		{
			MethodName: "InternalPortGet",
			Handler:    _DebugSvc_InternalPortGet_Handler,
		},
		{
			MethodName: "InterfacePpsTrackingEnable",
			Handler:    _DebugSvc_InterfacePpsTrackingEnable_Handler,
		},
		{
			MethodName: "InterfacePpsTrackingDisable",
			Handler:    _DebugSvc_InterfacePpsTrackingDisable_Handler,
		},
		{
			MethodName: "LearnDedupIntervalUpdate",
			Handler:    _DebugSvc_LearnDedupIntervalUpdate_Handler,
		},
		{
			MethodName: "TcpProxySessionGet",
			Handler:    _DebugSvc_TcpProxySessionGet_Handler,
		},
		{
			MethodName: "TcpCbGet",
			Handler:    _DebugSvc_TcpCbGet_Handler,
		},
		{
			MethodName: "TcpProxyGlobalStatsGet",
			Handler:    _DebugSvc_TcpProxyGlobalStatsGet_Handler,
		},
		{
			MethodName: "TcpProxyGlobalCfgCreate",
			Handler:    _DebugSvc_TcpProxyGlobalCfgCreate_Handler,
		},
		{
			MethodName: "ServiceLifEnable",
			Handler:    _DebugSvc_ServiceLifEnable_Handler,
		},
		{
			MethodName: "ServiceLifDisable",
			Handler:    _DebugSvc_ServiceLifDisable_Handler,
		},
		{
			MethodName: "FlowTracer",
			Handler:    _DebugSvc_FlowTracer_Handler,
		},
		{
			MethodName: "AsicPerfGet",
			Handler:    _DebugSvc_AsicPerfGet_Handler,
		},
		{
			MethodName: "NaclCreate",
			Handler:    _DebugSvc_NaclCreate_Handler,
		},
		{
			MethodName: "NaclDelete",
			Handler:    _DebugSvc_NaclDelete_Handler,
		},
		{
			MethodName: "EepromRead",
			Handler:    _DebugSvc_EepromRead_Handler,
		},
		{
			MethodName: "EepromWrite",
			Handler:    _DebugSvc_EepromWrite_Handler,
		},
		{
			MethodName: "ElamCaptureGet",
			Handler:    _DebugSvc_ElamCaptureGet_Handler,
		},
		{
			MethodName: "ThreadGet",
			Handler:    _DebugSvc_ThreadGet_Handler,
		},
		{
			MethodName: "DatapathMemoryGet",
			Handler:    _DebugSvc_DatapathMemoryGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "debug.proto",
}

func (m *TraceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TraceLevel != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TraceLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TraceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TraceLevel != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TraceLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TraceLevelGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceLevelGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceLevelGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TraceLevel != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TraceLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableApiStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableApiStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableApiStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableApiStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableApiStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableApiStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entry) > 0 {
		for iNdEx := len(m.Entry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entry) > 0 {
		for iNdEx := len(m.Entry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableSize != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TableSize))
		i--
		dAtA[i] = 0x20
	}
	if m.TableStats != nil {
		{
			size, err := m.TableStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ApiStats != nil {
		{
			size, err := m.ApiStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableStatsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LlcSetupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LlcSetupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LlcSetupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LlcSetupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LlcSetupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LlcSetupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LlcStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LlcStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LlcStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Count) > 0 {
		dAtA4 := make([]byte, len(m.Count)*10)
		var j3 int
		for _, num := range m.Count {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintDebug(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LlcStatsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LlcStatsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LlcStatsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OflowFifoDropStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OflowFifoDropStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OflowFifoDropStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OflowFifoDropStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OflowFifoDropStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OflowFifoDropStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entry) > 0 {
		for iNdEx := len(m.Entry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OflowFifoStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OflowFifoStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OflowFifoStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DropCounts != nil {
		{
			size, err := m.DropCounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EopCountOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EopCountOut))
		i--
		dAtA[i] = 0x20
	}
	if m.SopCountOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SopCountOut))
		i--
		dAtA[i] = 0x18
	}
	if m.EopCountIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EopCountIn))
		i--
		dAtA[i] = 0x10
	}
	if m.SopCountIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SopCountIn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BufferDropStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferDropStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferDropStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DropCount != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DropCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Reasons != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Reasons))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BufferDropStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferDropStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferDropStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatsEntries) > 0 {
		for iNdEx := len(m.StatsEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StatsEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BufferStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DropCounts != nil {
		{
			size, err := m.DropCounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EopCountOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EopCountOut))
		i--
		dAtA[i] = 0x20
	}
	if m.SopCountOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SopCountOut))
		i--
		dAtA[i] = 0x18
	}
	if m.EopCountIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EopCountIn))
		i--
		dAtA[i] = 0x10
	}
	if m.SopCountIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SopCountIn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PacketBufferPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketBufferPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketBufferPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortNum != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortNum))
		i--
		dAtA[i] = 0x10
	}
	if m.PortType != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosInputOflowQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosInputOflowQueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosInputOflowQueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxFifoDepth != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.MaxFifoDepth))
		i--
		dAtA[i] = 0x28
	}
	if m.FifoDepth != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FifoDepth))
		i--
		dAtA[i] = 0x20
	}
	if m.ErroredPktsIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ErroredPktsIn))
		i--
		dAtA[i] = 0x18
	}
	if m.GoodPktsOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.GoodPktsOut))
		i--
		dAtA[i] = 0x10
	}
	if m.GoodPktsIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.GoodPktsIn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosInputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosInputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosInputQueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortMonitor != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortMonitor))
		i--
		dAtA[i] = 0x28
	}
	if m.PeakOccupancy != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PeakOccupancy))
		i--
		dAtA[i] = 0x20
	}
	if m.BufferOccupancy != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.BufferOccupancy))
		i--
		dAtA[i] = 0x18
	}
	if m.OflowFifoStats != nil {
		{
			size, err := m.OflowFifoStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.InputQueueIdx != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InputQueueIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosOutputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosOutputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosOutputQueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortMonitor != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortMonitor))
		i--
		dAtA[i] = 0x18
	}
	if m.QueueDepth != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.QueueDepth))
		i--
		dAtA[i] = 0x10
	}
	if m.OutputQueueIdx != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutputQueueIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosQueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosQueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OutputQueueStats) > 0 {
		for iNdEx := len(m.OutputQueueStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutputQueueStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.InputQueueStats) > 0 {
		for iNdEx := len(m.InputQueueStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputQueueStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PacketBufferPortStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketBufferPortStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketBufferPortStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.QosQueueStats != nil {
		{
			size, err := m.QosQueueStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OflowFifoStats != nil {
		{
			size, err := m.OflowFifoStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BufferStats != nil {
		{
			size, err := m.BufferStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PacketBufferPort != nil {
		{
			size, err := m.PacketBufferPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PacketBufferStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketBufferStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketBufferStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PortStats) > 0 {
		for iNdEx := len(m.PortStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PortStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PbStatsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbStatsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbStatsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PbStats != nil {
		{
			size, err := m.PbStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PbStatsSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbStatsSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbStatsSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalPRDDrops != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalPRDDrops))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalPBDrops != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalPBDrops))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalHostPktsOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalHostPktsOut))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalHostPktsIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalHostPktsIn))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalMacPktsOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalMacPktsOut))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalMacPktsIn != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TotalMacPktsIn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PbStatsSummaryGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PbStatsSummaryGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PbStatsSummaryGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PbStatsSummary != nil {
		{
			size, err := m.PbStatsSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemTrackSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemTrackSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemTrackSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllocId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AllocId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemTrackStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemTrackStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemTrackStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MemTrackStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemTrackStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemTrackStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumFrees != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFrees))
		i--
		dAtA[i] = 0x10
	}
	if m.NumAllocs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumAllocs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemTrackGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemTrackGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemTrackGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemTrackGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemTrackGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemTrackGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeapStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeapStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeapStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReleasableFreeBytes != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ReleasableFreeBytes))
		i--
		dAtA[i] = 0x50
	}
	if m.NumFreeBytes != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFreeBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.NumBytesAlloc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumBytesAlloc))
		i--
		dAtA[i] = 0x40
	}
	if m.NumFastBinFreeBytes != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFastBinFreeBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxBlocksAlloc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.MaxBlocksAlloc))
		i--
		dAtA[i] = 0x30
	}
	if m.NumMmapBytesAlloc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumMmapBytesAlloc))
		i--
		dAtA[i] = 0x28
	}
	if m.NumMmapBlocksAlloc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumMmapBlocksAlloc))
		i--
		dAtA[i] = 0x20
	}
	if m.NumFastBinFreeBlocks != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFastBinFreeBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.NumFreeBlocks != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFreeBlocks))
		i--
		dAtA[i] = 0x10
	}
	if m.NumArenaBytesAlloc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumArenaBytesAlloc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeapGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeapGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeapGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HeapGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeapGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeapGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L3HWMappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3HWMappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3HWMappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IPAddr != nil {
		{
			size, err := m.IPAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VPCId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.VPCId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2HWMappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2HWMappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2HWMappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.MACAddr))
		i--
		dAtA[i] = 0x10
	}
	if m.SubnetId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HWMappingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HWMappingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HWMappingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Keyinfo != nil {
		{
			size := m.Keyinfo.Size()
			i -= size
			if _, err := m.Keyinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HWMappingKey_IPKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HWMappingKey_IPKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPKey != nil {
		{
			size, err := m.IPKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *HWMappingKey_MACKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HWMappingKey_MACKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MACKey != nil {
		{
			size, err := m.MACKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MappingDumpFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MappingDumpFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MappingDumpFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandUUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandUUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandUUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDumpFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDumpFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDumpFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ifinfo != nil {
		{
			size := m.Ifinfo.Size()
			i -= size
			if _, err := m.Ifinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDumpFilter_Id) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceDumpFilter_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceDumpFilter_IfType) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceDumpFilter_IfType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDebug(dAtA, i, uint64(m.IfType))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *DatapathAssist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatapathAssist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatapathAssist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumCores != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommandMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommandMsg != nil {
		{
			size, err := m.CommandMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Command != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AacsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AacsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AacsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AacsServerPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AacsServerPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlabSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlabSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlabSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RawBlockSize != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RawBlockSize))
		i--
		dAtA[i] = 0x48
	}
	if m.ZeroOnAllocation {
		i--
		if m.ZeroOnAllocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.DelayDelete {
		i--
		if m.DelayDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.GrowOnDemand {
		i--
		if m.GrowOnDemand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ThreadSafe {
		i--
		if m.ThreadSafe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ElementsPerBlock != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ElementsPerBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.ElementSize != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ElementSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlabStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlabStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlabStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SlabStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlabStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlabStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumBlocks != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumBlocks))
		i--
		dAtA[i] = 0x28
	}
	if m.NumAllocErrors != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumAllocErrors))
		i--
		dAtA[i] = 0x20
	}
	if m.NumFrees != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumFrees))
		i--
		dAtA[i] = 0x18
	}
	if m.NumAllocs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumAllocs))
		i--
		dAtA[i] = 0x10
	}
	if m.NumElementsInUse != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumElementsInUse))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Slab) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlabGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlabGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlabGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Slab) > 0 {
		for iNdEx := len(m.Slab) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Slab[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatapathMemoryGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatapathMemoryGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatapathMemoryGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CachedISSUHiMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSUHiMemRsvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UncachedISSUHiMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSUHiMemRsvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CachedISSULowMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSULowMemRsvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.UncachedISSULowMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSULowMemRsvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CachedISSUHiMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSUHiMemNeeded))
		i--
		dAtA[i] = 0x78
	}
	if m.UncachedISSUHiMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSUHiMemNeeded))
		i--
		dAtA[i] = 0x70
	}
	if m.CachedISSULowMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSULowMemNeeded))
		i--
		dAtA[i] = 0x68
	}
	if m.UncachedISSULowMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSULowMemNeeded))
		i--
		dAtA[i] = 0x60
	}
	if m.CachedISSUMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSUMemNeeded))
		i--
		dAtA[i] = 0x58
	}
	if m.UncachedISSUMemNeeded != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSUMemNeeded))
		i--
		dAtA[i] = 0x50
	}
	if m.CachedISSUMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedISSUMemRsvd))
		i--
		dAtA[i] = 0x48
	}
	if m.UncachedISSUMemRsvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedISSUMemRsvd))
		i--
		dAtA[i] = 0x40
	}
	if m.CachedHighHighMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedHighHighMemUsed))
		i--
		dAtA[i] = 0x38
	}
	if m.UncachedHighHighMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedHighHighMemUsed))
		i--
		dAtA[i] = 0x30
	}
	if m.CachedLowHighMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedLowHighMemUsed))
		i--
		dAtA[i] = 0x28
	}
	if m.UncachedLowHighMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedLowHighMemUsed))
		i--
		dAtA[i] = 0x20
	}
	if m.CachedLowMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CachedLowMemUsed))
		i--
		dAtA[i] = 0x18
	}
	if m.UncachedLowMemUsed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UncachedLowMemUsed))
		i--
		dAtA[i] = 0x10
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortFlowCtrl {
		i--
		if m.PortFlowCtrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PortTxPaused {
		i--
		if m.PortTxPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PortMode != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortMode))
		i--
		dAtA[i] = 0x18
	}
	if m.PortSpeed != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortSpeed))
		i--
		dAtA[i] = 0x10
	}
	if m.PortStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutLate != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutLate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.OutExcessive != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutExcessive))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.OutMultiple != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutMultiple))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OutSingle != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutSingle))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OutDeferred != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutDeferred))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.OutCollisions != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutCollisions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.OutPause != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutPause))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.OutFcsErr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutFcsErr))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.OutMulticast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutMulticast))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.OutBroadcast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutBroadcast))
		i--
		dAtA[i] = 0x78
	}
	if m.OutUnicast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutUnicast))
		i--
		dAtA[i] = 0x70
	}
	if m.InFcsErr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InFcsErr))
		i--
		dAtA[i] = 0x68
	}
	if m.InRxErr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InRxErr))
		i--
		dAtA[i] = 0x60
	}
	if m.InJabber != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InJabber))
		i--
		dAtA[i] = 0x58
	}
	if m.InOversize != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InOversize))
		i--
		dAtA[i] = 0x50
	}
	if m.InFragments != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InFragments))
		i--
		dAtA[i] = 0x48
	}
	if m.InUndersize != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InUndersize))
		i--
		dAtA[i] = 0x40
	}
	if m.InPause != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InPause))
		i--
		dAtA[i] = 0x38
	}
	if m.Inmulticast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Inmulticast))
		i--
		dAtA[i] = 0x30
	}
	if m.Inbroadcast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Inbroadcast))
		i--
		dAtA[i] = 0x28
	}
	if m.InUnicast != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InUnicast))
		i--
		dAtA[i] = 0x20
	}
	if m.InBadOctets != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InBadOctets))
		i--
		dAtA[i] = 0x18
	}
	if m.OutOctets != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OutOctets))
		i--
		dAtA[i] = 0x10
	}
	if m.InGoodOctets != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InGoodOctets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InternalStatus != nil {
		{
			size, err := m.InternalStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PortDescr) > 0 {
		i -= len(m.PortDescr)
		copy(dAtA[i:], m.PortDescr)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.PortDescr)))
		i--
		dAtA[i] = 0x12
	}
	if m.PortNumber != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortResponseMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortNumber != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternalPortRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPortRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalPortRequestMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EepromAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Page != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EepromPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PageContent) > 0 {
		i -= len(m.PageContent)
		copy(dAtA[i:], m.PageContent)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.PageContent)))
		i--
		dAtA[i] = 0x12
	}
	if m.PageNumber != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PageNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EepromReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Page) > 0 {
		for iNdEx := len(m.Page) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Page[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IfIndex != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EepromReadResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromReadResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromReadResponseMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EepromReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EepromReadRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromReadRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromReadRequestMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PortId) > 0 {
		for iNdEx := len(m.PortId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PortId[iNdEx])
			copy(dAtA[i:], m.PortId[iNdEx])
			i = encodeVarintDebug(dAtA, i, uint64(len(m.PortId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EepromWriteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromWriteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromWriteResponseMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EepromWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EepromWriteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EepromWriteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EepromWriteRequestMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LearnDedupIntervalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnDedupIntervalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnDedupIntervalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DedupInterval != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DedupInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxySessionFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxySessionFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchAll {
		i--
		if m.MatchAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DstPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x18
	}
	if m.DstIp != nil {
		{
			size, err := m.DstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcIp != nil {
		{
			size, err := m.SrcIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxySessionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxySessionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SessionFilter != nil {
		{
			size, err := m.SessionFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyFlow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyFlow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x30
	}
	if m.SrcPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x28
	}
	if m.DstIp != nil {
		{
			size, err := m.DstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SrcIp != nil {
		{
			size, err := m.SrcIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Qid2 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Qid2))
		i--
		dAtA[i] = 0x10
	}
	if m.Qid1 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Qid1))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxySessionGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxySessionGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxySession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxySession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flow != nil {
		{
			size, err := m.Flow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxySessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxySessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxySessionGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyGlobalStatsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStatsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyGlobalStatsGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GlobalStats != nil {
		{
			size, err := m.GlobalStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyGlobalStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyGlobalStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpDebug10 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug10))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x98
	}
	if m.TcpDebug9 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug9))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x90
	}
	if m.TcpDebug8 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug8))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x88
	}
	if m.TcpDebug7 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug7))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x80
	}
	if m.TcpDebug6 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug6))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpDebug5 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug5))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpDebug4 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug4))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpDebug3 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug3))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpDebug2 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug2))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpDebug1 != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpDebug1))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd0
	}
	if m.OoqAvail != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OoqAvail))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.TxDescAvail != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TxDescAvail))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RxDescAvail != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxDescAvail))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RxPureWinUpd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxPureWinUpd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RxPktAfterWin != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxPktAfterWin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RxKeepAlive != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxKeepAlive))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RxWinProbe != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxWinProbe))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.RstSentCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RstSentCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FinSentCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FinSentCnt))
		i--
		dAtA[i] = 0x78
	}
	if m.RxAckForUnsentData != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxAckForUnsentData))
		i--
		dAtA[i] = 0x70
	}
	if m.OoqRx2TxFull != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OoqRx2TxFull))
		i--
		dAtA[i] = 0x68
	}
	if m.RetxPkts != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RetxPkts))
		i--
		dAtA[i] = 0x60
	}
	if m.EcnReducedCongestion != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EcnReducedCongestion))
		i--
		dAtA[i] = 0x58
	}
	if m.RcvdCePkts != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvdCePkts))
		i--
		dAtA[i] = 0x50
	}
	if m.InvalidRxDesc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InvalidRxDesc))
		i--
		dAtA[i] = 0x48
	}
	if m.OoqFull != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OoqFull))
		i--
		dAtA[i] = 0x40
	}
	if m.TlsGcFull != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TlsGcFull))
		i--
		dAtA[i] = 0x38
	}
	if m.GcFull != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.GcFull))
		i--
		dAtA[i] = 0x30
	}
	if m.RetxNopSchedule != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RetxNopSchedule))
		i--
		dAtA[i] = 0x28
	}
	if m.PartialPktAck != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PartialPktAck))
		i--
		dAtA[i] = 0x20
	}
	if m.InvalidRetxDesc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InvalidRetxDesc))
		i--
		dAtA[i] = 0x18
	}
	if m.InvalidTxDesc != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InvalidTxDesc))
		i--
		dAtA[i] = 0x10
	}
	if m.RxDescFull != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxDescFull))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyGlobalCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyGlobalCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CwndIdle != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CwndIdle))
		i--
		dAtA[i] = 0x18
	}
	if m.CwndInitial != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CwndInitial))
		i--
		dAtA[i] = 0x10
	}
	if m.Mss != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Mss))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyGlobalCfgRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalCfgRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyGlobalCfgRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TcpProxyGlobalCfgResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpProxyGlobalCfgResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpProxyGlobalCfgResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppQid != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AppQid))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.RttVar != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RttVar))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.Keepalives {
		i--
		if m.Keepalives {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.TsTime != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TsTime))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.TsOffset != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TsOffset))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.TsLearned != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TsLearned))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.RttTime != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RttTime))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.RttSeqTsoffset != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RttSeqTsoffset))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.Timestamps {
		i--
		if m.Timestamps {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.SackPerm {
		i--
		if m.SackPerm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.SrttUs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SrttUs))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.CbBaseQtype1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CbBaseQtype1))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc9
	}
	if m.ZeroWindowSent != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ZeroWindowSent))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.CbBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CbBase))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb9
	}
	if m.RcvWup != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvWup))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.OooRx2TxQbase != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OooRx2TxQbase))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.OooQueue {
		i--
		if m.OooQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.AbcLVar != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AbcLVar))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.InitialWindow != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.InitialWindow))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.Smss != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Smss))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.SndRecover != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndRecover))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.Ato != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Ato))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.DelayAck {
		i--
		if m.DelayAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.SesqTxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqTxCi))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.RcvWscale != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvWscale))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.SndWscale != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndWscale))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.RcvWnd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvWnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.SerqCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SerqCi))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.CpuId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CpuId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.RtoBackoff != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RtoBackoff))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.CcAlgo != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CcAlgo))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.SndSsthresh != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndSsthresh))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.PacketsOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PacketsOut))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.OtherQid != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OtherQid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.PredFlags != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PredFlags))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.SerqPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SerqPi))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.DebugDolTblsetaddr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DebugDolTblsetaddr))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SndCwndCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndCwndCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Rto != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Rto))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RxTs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxTs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.RetxSndUna != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RetxSndUna))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SesqRetxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqRetxCi))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.PendingAckSend {
		i--
		if m.PendingAckSend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.HeaderLen != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.HeaderLen))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.DebugDolTx != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DebugDolTx))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.AsesqCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AsesqCi))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.AsesqPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AsesqPi))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AsesqBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AsesqBase))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.SourceLif != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SourceLif))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.State != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.HeaderTemplate) > 0 {
		i -= len(m.HeaderTemplate)
		copy(dAtA[i:], m.HeaderTemplate)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.HeaderTemplate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DestPort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DestPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SourcePort != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SourcePort))
		i--
		dAtA[i] = 0x78
	}
	if m.RcvMss != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvMss))
		i--
		dAtA[i] = 0x70
	}
	if m.SndCwnd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndCwnd))
		i--
		dAtA[i] = 0x68
	}
	if m.SndWnd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndWnd))
		i--
		dAtA[i] = 0x60
	}
	if m.SesqCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqCi))
		i--
		dAtA[i] = 0x58
	}
	if m.SesqPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqPi))
		i--
		dAtA[i] = 0x50
	}
	if m.SesqBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SesqBase))
		i--
		dAtA[i] = 0x49
	}
	if m.DebugDol != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DebugDol))
		i--
		dAtA[i] = 0x40
	}
	if m.SerqBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SerqBase))
		i--
		dAtA[i] = 0x39
	}
	if m.TsRecent != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TsRecent))
		i--
		dAtA[i] = 0x30
	}
	if m.RcvTsval != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvTsval))
		i--
		dAtA[i] = 0x28
	}
	if m.SndUna != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndUna))
		i--
		dAtA[i] = 0x20
	}
	if m.SndNxt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SndNxt))
		i--
		dAtA[i] = 0x18
	}
	if m.RcvNxt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RcvNxt))
		i--
		dAtA[i] = 0x10
	}
	if m.TcpCbId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpCbId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbOoqStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbOoqStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbOoqStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumEntries != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.NumEntries))
		i--
		dAtA[i] = 0x20
	}
	if m.EndSeq != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EndSeq))
		i--
		dAtA[i] = 0x18
	}
	if m.StartSeq != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.StartSeq))
		i--
		dAtA[i] = 0x10
	}
	if m.QueueAddr != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.QueueAddr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OoqStatus) > 0 {
		for iNdEx := len(m.OoqStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OoqStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.OoqNotEmpty {
		i--
		if m.OoqNotEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TcpCbId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpCbId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpCbId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TcpCbId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxWindowUpdatePi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TxWindowUpdatePi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0xa8
	}
	if m.WindowUpdateCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WindowUpdateCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0xa0
	}
	if m.WindowUpdatePi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WindowUpdatePi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0x98
	}
	if m.RetxCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RetxCnt))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0x90
	}
	if m.OoqRx2TxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OoqRx2TxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0x88
	}
	if m.OoqRx2TxPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OoqRx2TxPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf3
		i--
		dAtA[i] = 0x80
	}
	if m.WindowFullCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WindowFullCnt))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xf8
	}
	if m.KeepaDeadline != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.KeepaDeadline))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xf0
	}
	if m.CcFlags != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CcFlags))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xe8
	}
	if m.RtoDeadline != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RtoDeadline))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xe0
	}
	if m.AtoDeadline != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AtoDeadline))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xd8
	}
	if m.PartialPktAckCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PartialPktAckCnt))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xd0
	}
	if m.TxRingPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.TxRingPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xc8
	}
	if m.AsesqRetxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.AsesqRetxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xc0
	}
	if m.SesqRetxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqRetxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xb8
	}
	if m.SesqTxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqTxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xb0
	}
	if m.PacketsOut != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PacketsOut))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xa8
	}
	if m.CleanRetxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CleanRetxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0xa0
	}
	if m.CleanRetxPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.CleanRetxPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0x98
	}
	if m.FastRetransCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FastRetransCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0x90
	}
	if m.FastRetransPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FastRetransPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0x88
	}
	if m.PendingTxCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PendingTxCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
		i--
		dAtA[i] = 0x80
	}
	if m.PendingTxPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PendingTxPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xf8
	}
	if m.OobRstCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OobRstCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xf0
	}
	if m.OobRstPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OobRstPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xe8
	}
	if m.DelAckCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DelAckCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xe0
	}
	if m.DelAckPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DelAckPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xd8
	}
	if m.FastTimerCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FastTimerCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xd0
	}
	if m.FastTimerPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.FastTimerPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xc8
	}
	if m.SendAckCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SendAckCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xc0
	}
	if m.SendAckPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SendAckPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xb8
	}
	if m.SesqCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqCi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xb0
	}
	if m.SesqPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SesqPi))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0xa8
	}
	if m.PureAcksSent != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PureAcksSent))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0x98
	}
	if m.PktsSent != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PktsSent))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0x90
	}
	if m.BytesSent != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.BytesSent))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0x88
	}
	if m.SerqCi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SerqCi))
		i--
		dAtA[i] = 0x70
	}
	if m.SerqPi != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SerqPi))
		i--
		dAtA[i] = 0x68
	}
	if m.OooDropCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OooDropCnt))
		i--
		dAtA[i] = 0x60
	}
	if m.WinCheckFail != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WinCheckFail))
		i--
		dAtA[i] = 0x58
	}
	if m.PawsDropCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PawsDropCnt))
		i--
		dAtA[i] = 0x50
	}
	if m.RxDropCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RxDropCnt))
		i--
		dAtA[i] = 0x48
	}
	if m.OooCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OooCnt))
		i--
		dAtA[i] = 0x40
	}
	if m.SerqFullCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SerqFullCnt))
		i--
		dAtA[i] = 0x38
	}
	if m.SlowPathCnt != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SlowPathCnt))
		i--
		dAtA[i] = 0x30
	}
	if m.DupAcksRcvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DupAcksRcvd))
		i--
		dAtA[i] = 0x28
	}
	if m.PureAcksRcvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PureAcksRcvd))
		i--
		dAtA[i] = 0x20
	}
	if m.BytesAcked != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.BytesAcked))
		i--
		dAtA[i] = 0x18
	}
	if m.PktsRcvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PktsRcvd))
		i--
		dAtA[i] = 0x10
	}
	if m.BytesRcvd != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.BytesRcvd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpCbGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpCbGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpCbGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowTracerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTracerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTracerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OverlaySrcMAC != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OverlaySrcMAC))
		i--
		dAtA[i] = 0x48
	}
	if m.OverlayDstMAC != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.OverlayDstMAC))
		i--
		dAtA[i] = 0x40
	}
	if m.L4Info != nil {
		{
			size, err := m.L4Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.IPProto != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.IPProto))
		i--
		dAtA[i] = 0x30
	}
	if m.SrcTep != nil {
		{
			size, err := m.SrcTep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DstAddr != nil {
		{
			size, err := m.DstAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SrcAddr != nil {
		{
			size, err := m.SrcAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.VNI != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.VNI))
		i--
		dAtA[i] = 0x10
	}
	if len(m.VPC) > 0 {
		i -= len(m.VPC)
		copy(dAtA[i:], m.VPC)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.VPC)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowTracerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTracerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTracerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowTracerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTracerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTracerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DropReason) > 0 {
		for iNdEx := len(m.DropReason) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DropReason[iNdEx])
			copy(dAtA[i:], m.DropReason[iNdEx])
			i = encodeVarintDebug(dAtA, i, uint64(len(m.DropReason[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Drop {
		i--
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.DstTep != nil {
		{
			size, err := m.DstTep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.DefaultRuleHit {
		i--
		if m.DefaultRuleHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MappingHit {
		i--
		if m.MappingHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.FlowHit {
		i--
		if m.FlowHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Action != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x50
	}
	if m.RouteClassPriority != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.RouteClassPriority))
		i--
		dAtA[i] = 0x48
	}
	if m.MeterClass != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.MeterClass))
		i--
		dAtA[i] = 0x40
	}
	if len(m.EgressSubnet) > 0 {
		i -= len(m.EgressSubnet)
		copy(dAtA[i:], m.EgressSubnet)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.EgressSubnet)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IngressSubnet) > 0 {
		i -= len(m.IngressSubnet)
		copy(dAtA[i:], m.IngressSubnet)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.IngressSubnet)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SvcMapping) > 0 {
		i -= len(m.SvcMapping)
		copy(dAtA[i:], m.SvcMapping)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.SvcMapping)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SecurityPolicy) > 0 {
		i -= len(m.SecurityPolicy)
		copy(dAtA[i:], m.SecurityPolicy)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.SecurityPolicy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SecurityRule) > 0 {
		i -= len(m.SecurityRule)
		copy(dAtA[i:], m.SecurityRule)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.SecurityRule)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vnic) > 0 {
		i -= len(m.Vnic)
		copy(dAtA[i:], m.Vnic)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Vnic)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPC) > 0 {
		i -= len(m.VPC)
		copy(dAtA[i:], m.VPC)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.VPC)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowTracerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTracerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTracerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MPUPerfInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MPUPerfInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MPUPerfInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CPI != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CPI))))
		i--
		dAtA[i] = 0x15
	}
	if m.Utilization != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Utilization))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PipelineStagePerfInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineStagePerfInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineStagePerfInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MPUPerf) > 0 {
		for iNdEx := len(m.MPUPerf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MPUPerf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PipelinePerfInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelinePerfInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelinePerfInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StagePerf) > 0 {
		for iNdEx := len(m.StagePerf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StagePerf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ParserDrops != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ParserDrops))
		i--
		dAtA[i] = 0x30
	}
	if m.PacketsFromPB != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PacketsFromPB))
		i--
		dAtA[i] = 0x28
	}
	if m.Recircs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Recircs))
		i--
		dAtA[i] = 0x20
	}
	if m.Drops != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Drops))
		i--
		dAtA[i] = 0x18
	}
	if m.PHVs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PHVs))
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Pipeline))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DDRPerfInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDRPerfInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DDRPerfInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WriteBandwidth != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WriteBandwidth))))
		i--
		dAtA[i] = 0x55
	}
	if m.WriteMTPS != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WriteMTPS))))
		i--
		dAtA[i] = 0x4d
	}
	if m.WriteLatencyAvg != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WriteLatencyAvg))
		i--
		dAtA[i] = 0x40
	}
	if m.WriteLatencyMax != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.WriteLatencyMax))
		i--
		dAtA[i] = 0x38
	}
	if m.Writes != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Writes))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadBandwidth != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReadBandwidth))))
		i--
		dAtA[i] = 0x2d
	}
	if m.ReadMTPS != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReadMTPS))))
		i--
		dAtA[i] = 0x25
	}
	if m.ReadLatencyAvg != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ReadLatencyAvg))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadLatencyMax != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ReadLatencyMax))
		i--
		dAtA[i] = 0x10
	}
	if m.Reads != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Reads))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AsicPerfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsicPerfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsicPerfGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PipelinePerfInfo) > 0 {
		for iNdEx := len(m.PipelinePerfInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PipelinePerfInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DDRPerfInfo) > 0 {
		for iNdEx := len(m.DDRPerfInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DDRPerfInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MatchFields != nil {
		{
			size := m.MatchFields.Size()
			i -= size
			if _, err := m.MatchFields.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LifMatch != nil {
		{
			size := m.LifMatch.Size()
			i -= size
			if _, err := m.LifMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Direction != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x30
	}
	if m.IPFragment {
		i--
		if m.IPFragment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LocalMappingUnknown {
		i--
		if m.LocalMappingUnknown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.FlowMiss {
		i--
		if m.FlowMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TunneledPacket {
		i--
		if m.TunneledPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_SrcLif) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_SrcLif) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrcLif != nil {
		i -= len(m.SrcLif)
		copy(dAtA[i:], m.SrcLif)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.SrcLif)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_SrcLifType) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_SrcLifType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDebug(dAtA, i, uint64(m.SrcLifType))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *NaclRequest_L2Match) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_L2Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L2Match != nil {
		{
			size, err := m.L2Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_IPMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_IPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPMatch != nil {
		{
			size, err := m.IPMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_Drop) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_Drop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Drop {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	return len(dAtA) - i, nil
}
func (m *NaclRequest_RedirectLifId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_RedirectLifId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RedirectLifId != nil {
		i -= len(m.RedirectLifId)
		copy(dAtA[i:], m.RedirectLifId)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.RedirectLifId)))
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_L2PacketMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_L2PacketMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_L2PacketMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPProtocolMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPProtocolMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPProtocolMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Protocol != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4Match != nil {
		{
			size := m.L4Match.Size()
			i -= size
			if _, err := m.L4Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IPProto != nil {
		{
			size, err := m.IPProto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DstPrefix != nil {
		{
			size, err := m.DstPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPrefix != nil {
		{
			size, err := m.SrcPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch_TcpUdpMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_IPPacketMatch_TcpUdpMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpUdpMatch != nil {
		{
			size, err := m.TcpUdpMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_IPPacketMatch_IcmpMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NaclRequest_IPPacketMatch_IcmpMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IcmpMatch != nil {
		{
			size, err := m.IcmpMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstPort != nil {
		{
			size, err := m.DstPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPort != nil {
		{
			size, err := m.SrcPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != nil {
		{
			size, err := m.Code.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NaclDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NaclDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NaclDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ElamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThreadSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Role != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x30
	}
	if m.SchedPolicy != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.SchedPolicy))
		i--
		dAtA[i] = 0x28
	}
	if m.Priority != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PthreadId != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.PthreadId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThreadStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastHeartBeatTime != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.LastHeartBeatTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Running {
		i--
		if m.Running {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThreadStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Thread) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Thread) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Thread) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThreadGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDebug(dAtA []byte, offset int, v uint64) int {
	offset -= sovDebug(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TraceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TraceLevel != 0 {
		n += 1 + sovDebug(uint64(m.TraceLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TraceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.TraceLevel != 0 {
		n += 1 + sovDebug(uint64(m.TraceLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TraceLevelGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TraceLevel != 0 {
		n += 1 + sovDebug(uint64(m.TraceLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableApiStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.Count != 0 {
		n += 1 + sovDebug(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableApiStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, e := range m.Entry {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.Count != 0 {
		n += 1 + sovDebug(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, e := range m.Entry {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.ApiStats != nil {
		l = m.ApiStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.TableStats != nil {
		l = m.TableStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.TableSize != 0 {
		n += 1 + sovDebug(uint64(m.TableSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableStatsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LlcSetupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LlcSetupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LlcStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if len(m.Count) > 0 {
		l = 0
		for _, e := range m.Count {
			l += sovDebug(uint64(e))
		}
		n += 1 + sovDebug(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LlcStatsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OflowFifoDropStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.Count != 0 {
		n += 1 + sovDebug(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OflowFifoDropStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, e := range m.Entry {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OflowFifoStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SopCountIn != 0 {
		n += 1 + sovDebug(uint64(m.SopCountIn))
	}
	if m.EopCountIn != 0 {
		n += 1 + sovDebug(uint64(m.EopCountIn))
	}
	if m.SopCountOut != 0 {
		n += 1 + sovDebug(uint64(m.SopCountOut))
	}
	if m.EopCountOut != 0 {
		n += 1 + sovDebug(uint64(m.EopCountOut))
	}
	if m.DropCounts != nil {
		l = m.DropCounts.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BufferDropStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reasons != 0 {
		n += 1 + sovDebug(uint64(m.Reasons))
	}
	if m.DropCount != 0 {
		n += 1 + sovDebug(uint64(m.DropCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BufferDropStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StatsEntries) > 0 {
		for _, e := range m.StatsEntries {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BufferStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SopCountIn != 0 {
		n += 1 + sovDebug(uint64(m.SopCountIn))
	}
	if m.EopCountIn != 0 {
		n += 1 + sovDebug(uint64(m.EopCountIn))
	}
	if m.SopCountOut != 0 {
		n += 1 + sovDebug(uint64(m.SopCountOut))
	}
	if m.EopCountOut != 0 {
		n += 1 + sovDebug(uint64(m.EopCountOut))
	}
	if m.DropCounts != nil {
		l = m.DropCounts.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PacketBufferPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortType != 0 {
		n += 1 + sovDebug(uint64(m.PortType))
	}
	if m.PortNum != 0 {
		n += 1 + sovDebug(uint64(m.PortNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosInputOflowQueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GoodPktsIn != 0 {
		n += 1 + sovDebug(uint64(m.GoodPktsIn))
	}
	if m.GoodPktsOut != 0 {
		n += 1 + sovDebug(uint64(m.GoodPktsOut))
	}
	if m.ErroredPktsIn != 0 {
		n += 1 + sovDebug(uint64(m.ErroredPktsIn))
	}
	if m.FifoDepth != 0 {
		n += 1 + sovDebug(uint64(m.FifoDepth))
	}
	if m.MaxFifoDepth != 0 {
		n += 1 + sovDebug(uint64(m.MaxFifoDepth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosInputQueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputQueueIdx != 0 {
		n += 1 + sovDebug(uint64(m.InputQueueIdx))
	}
	if m.OflowFifoStats != nil {
		l = m.OflowFifoStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.BufferOccupancy != 0 {
		n += 1 + sovDebug(uint64(m.BufferOccupancy))
	}
	if m.PeakOccupancy != 0 {
		n += 1 + sovDebug(uint64(m.PeakOccupancy))
	}
	if m.PortMonitor != 0 {
		n += 1 + sovDebug(uint64(m.PortMonitor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosOutputQueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputQueueIdx != 0 {
		n += 1 + sovDebug(uint64(m.OutputQueueIdx))
	}
	if m.QueueDepth != 0 {
		n += 1 + sovDebug(uint64(m.QueueDepth))
	}
	if m.PortMonitor != 0 {
		n += 1 + sovDebug(uint64(m.PortMonitor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosQueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InputQueueStats) > 0 {
		for _, e := range m.InputQueueStats {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if len(m.OutputQueueStats) > 0 {
		for _, e := range m.OutputQueueStats {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PacketBufferPortStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketBufferPort != nil {
		l = m.PacketBufferPort.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.BufferStats != nil {
		l = m.BufferStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.OflowFifoStats != nil {
		l = m.OflowFifoStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.QosQueueStats != nil {
		l = m.QosQueueStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PacketBufferStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PortStats) > 0 {
		for _, e := range m.PortStats {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PbStatsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.PbStats != nil {
		l = m.PbStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PbStatsSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalMacPktsIn != 0 {
		n += 1 + sovDebug(uint64(m.TotalMacPktsIn))
	}
	if m.TotalMacPktsOut != 0 {
		n += 1 + sovDebug(uint64(m.TotalMacPktsOut))
	}
	if m.TotalHostPktsIn != 0 {
		n += 1 + sovDebug(uint64(m.TotalHostPktsIn))
	}
	if m.TotalHostPktsOut != 0 {
		n += 1 + sovDebug(uint64(m.TotalHostPktsOut))
	}
	if m.TotalPBDrops != 0 {
		n += 1 + sovDebug(uint64(m.TotalPBDrops))
	}
	if m.TotalPRDDrops != 0 {
		n += 1 + sovDebug(uint64(m.TotalPRDDrops))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PbStatsSummaryGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.PbStatsSummary != nil {
		l = m.PbStatsSummary.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemTrackSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllocId != 0 {
		n += 1 + sovDebug(uint64(m.AllocId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemTrackStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemTrackStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumAllocs != 0 {
		n += 1 + sovDebug(uint64(m.NumAllocs))
	}
	if m.NumFrees != 0 {
		n += 1 + sovDebug(uint64(m.NumFrees))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemTrackGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemTrackGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeapStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumArenaBytesAlloc != 0 {
		n += 1 + sovDebug(uint64(m.NumArenaBytesAlloc))
	}
	if m.NumFreeBlocks != 0 {
		n += 1 + sovDebug(uint64(m.NumFreeBlocks))
	}
	if m.NumFastBinFreeBlocks != 0 {
		n += 1 + sovDebug(uint64(m.NumFastBinFreeBlocks))
	}
	if m.NumMmapBlocksAlloc != 0 {
		n += 1 + sovDebug(uint64(m.NumMmapBlocksAlloc))
	}
	if m.NumMmapBytesAlloc != 0 {
		n += 1 + sovDebug(uint64(m.NumMmapBytesAlloc))
	}
	if m.MaxBlocksAlloc != 0 {
		n += 1 + sovDebug(uint64(m.MaxBlocksAlloc))
	}
	if m.NumFastBinFreeBytes != 0 {
		n += 1 + sovDebug(uint64(m.NumFastBinFreeBytes))
	}
	if m.NumBytesAlloc != 0 {
		n += 1 + sovDebug(uint64(m.NumBytesAlloc))
	}
	if m.NumFreeBytes != 0 {
		n += 1 + sovDebug(uint64(m.NumFreeBytes))
	}
	if m.ReleasableFreeBytes != 0 {
		n += 1 + sovDebug(uint64(m.ReleasableFreeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeapGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeapGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L3HWMappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VPCId != 0 {
		n += 1 + sovDebug(uint64(m.VPCId))
	}
	if m.IPAddr != nil {
		l = m.IPAddr.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L2HWMappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetId != 0 {
		n += 1 + sovDebug(uint64(m.SubnetId))
	}
	if m.MACAddr != 0 {
		n += 1 + sovDebug(uint64(m.MACAddr))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HWMappingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Keyinfo != nil {
		n += m.Keyinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HWMappingKey_IPKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPKey != nil {
		l = m.IPKey.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *HWMappingKey_MACKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MACKey != nil {
		l = m.MACKey.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *MappingDumpFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandUUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceDumpFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ifinfo != nil {
		n += m.Ifinfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceDumpFilter_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *InterfaceDumpFilter_IfType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDebug(uint64(m.IfType))
	return n
}
func (m *DatapathAssist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumCores != 0 {
		n += 1 + sovDebug(uint64(m.NumCores))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovDebug(uint64(m.Command))
	}
	if m.CommandMsg != nil {
		l = m.CommandMsg.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AacsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AacsServerPort != 0 {
		n += 1 + sovDebug(uint64(m.AacsServerPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlabSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	if m.ElementSize != 0 {
		n += 1 + sovDebug(uint64(m.ElementSize))
	}
	if m.ElementsPerBlock != 0 {
		n += 1 + sovDebug(uint64(m.ElementsPerBlock))
	}
	if m.ThreadSafe {
		n += 2
	}
	if m.GrowOnDemand {
		n += 2
	}
	if m.DelayDelete {
		n += 2
	}
	if m.ZeroOnAllocation {
		n += 2
	}
	if m.RawBlockSize != 0 {
		n += 1 + sovDebug(uint64(m.RawBlockSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlabStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlabStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumElementsInUse != 0 {
		n += 1 + sovDebug(uint64(m.NumElementsInUse))
	}
	if m.NumAllocs != 0 {
		n += 1 + sovDebug(uint64(m.NumAllocs))
	}
	if m.NumFrees != 0 {
		n += 1 + sovDebug(uint64(m.NumFrees))
	}
	if m.NumAllocErrors != 0 {
		n += 1 + sovDebug(uint64(m.NumAllocErrors))
	}
	if m.NumBlocks != 0 {
		n += 1 + sovDebug(uint64(m.NumBlocks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Slab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlabGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Slab) > 0 {
		for _, e := range m.Slab {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatapathMemoryGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.UncachedLowMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.UncachedLowMemUsed))
	}
	if m.CachedLowMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.CachedLowMemUsed))
	}
	if m.UncachedLowHighMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.UncachedLowHighMemUsed))
	}
	if m.CachedLowHighMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.CachedLowHighMemUsed))
	}
	if m.UncachedHighHighMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.UncachedHighHighMemUsed))
	}
	if m.CachedHighHighMemUsed != 0 {
		n += 1 + sovDebug(uint64(m.CachedHighHighMemUsed))
	}
	if m.UncachedISSUMemRsvd != 0 {
		n += 1 + sovDebug(uint64(m.UncachedISSUMemRsvd))
	}
	if m.CachedISSUMemRsvd != 0 {
		n += 1 + sovDebug(uint64(m.CachedISSUMemRsvd))
	}
	if m.UncachedISSUMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.UncachedISSUMemNeeded))
	}
	if m.CachedISSUMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.CachedISSUMemNeeded))
	}
	if m.UncachedISSULowMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.UncachedISSULowMemNeeded))
	}
	if m.CachedISSULowMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.CachedISSULowMemNeeded))
	}
	if m.UncachedISSUHiMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.UncachedISSUHiMemNeeded))
	}
	if m.CachedISSUHiMemNeeded != 0 {
		n += 1 + sovDebug(uint64(m.CachedISSUHiMemNeeded))
	}
	if m.UncachedISSULowMemRsvd != 0 {
		n += 2 + sovDebug(uint64(m.UncachedISSULowMemRsvd))
	}
	if m.CachedISSULowMemRsvd != 0 {
		n += 2 + sovDebug(uint64(m.CachedISSULowMemRsvd))
	}
	if m.UncachedISSUHiMemRsvd != 0 {
		n += 2 + sovDebug(uint64(m.UncachedISSUHiMemRsvd))
	}
	if m.CachedISSUHiMemRsvd != 0 {
		n += 2 + sovDebug(uint64(m.CachedISSUHiMemRsvd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortStatus != 0 {
		n += 1 + sovDebug(uint64(m.PortStatus))
	}
	if m.PortSpeed != 0 {
		n += 1 + sovDebug(uint64(m.PortSpeed))
	}
	if m.PortMode != 0 {
		n += 1 + sovDebug(uint64(m.PortMode))
	}
	if m.PortTxPaused {
		n += 2
	}
	if m.PortFlowCtrl {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InGoodOctets != 0 {
		n += 1 + sovDebug(uint64(m.InGoodOctets))
	}
	if m.OutOctets != 0 {
		n += 1 + sovDebug(uint64(m.OutOctets))
	}
	if m.InBadOctets != 0 {
		n += 1 + sovDebug(uint64(m.InBadOctets))
	}
	if m.InUnicast != 0 {
		n += 1 + sovDebug(uint64(m.InUnicast))
	}
	if m.Inbroadcast != 0 {
		n += 1 + sovDebug(uint64(m.Inbroadcast))
	}
	if m.Inmulticast != 0 {
		n += 1 + sovDebug(uint64(m.Inmulticast))
	}
	if m.InPause != 0 {
		n += 1 + sovDebug(uint64(m.InPause))
	}
	if m.InUndersize != 0 {
		n += 1 + sovDebug(uint64(m.InUndersize))
	}
	if m.InFragments != 0 {
		n += 1 + sovDebug(uint64(m.InFragments))
	}
	if m.InOversize != 0 {
		n += 1 + sovDebug(uint64(m.InOversize))
	}
	if m.InJabber != 0 {
		n += 1 + sovDebug(uint64(m.InJabber))
	}
	if m.InRxErr != 0 {
		n += 1 + sovDebug(uint64(m.InRxErr))
	}
	if m.InFcsErr != 0 {
		n += 1 + sovDebug(uint64(m.InFcsErr))
	}
	if m.OutUnicast != 0 {
		n += 1 + sovDebug(uint64(m.OutUnicast))
	}
	if m.OutBroadcast != 0 {
		n += 1 + sovDebug(uint64(m.OutBroadcast))
	}
	if m.OutMulticast != 0 {
		n += 2 + sovDebug(uint64(m.OutMulticast))
	}
	if m.OutFcsErr != 0 {
		n += 2 + sovDebug(uint64(m.OutFcsErr))
	}
	if m.OutPause != 0 {
		n += 2 + sovDebug(uint64(m.OutPause))
	}
	if m.OutCollisions != 0 {
		n += 2 + sovDebug(uint64(m.OutCollisions))
	}
	if m.OutDeferred != 0 {
		n += 2 + sovDebug(uint64(m.OutDeferred))
	}
	if m.OutSingle != 0 {
		n += 2 + sovDebug(uint64(m.OutSingle))
	}
	if m.OutMultiple != 0 {
		n += 2 + sovDebug(uint64(m.OutMultiple))
	}
	if m.OutExcessive != 0 {
		n += 2 + sovDebug(uint64(m.OutExcessive))
	}
	if m.OutLate != 0 {
		n += 2 + sovDebug(uint64(m.OutLate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovDebug(uint64(m.PortNumber))
	}
	l = len(m.PortDescr)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.InternalStatus != nil {
		l = m.InternalStatus.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortResponseMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovDebug(uint64(m.PortNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPortRequestMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovDebug(uint64(m.Page))
	}
	if m.Offset != 0 {
		n += 1 + sovDebug(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageNumber != 0 {
		n += 1 + sovDebug(uint64(m.PageNumber))
	}
	l = len(m.PageContent)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovDebug(uint64(m.IfIndex))
	}
	if len(m.Page) > 0 {
		for _, e := range m.Page {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromReadResponseMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromReadRequestMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PortId) > 0 {
		for _, b := range m.PortId {
			l = len(b)
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromWriteResponseMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovDebug(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EepromWriteRequestMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnDedupIntervalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedupInterval != 0 {
		n += 1 + sovDebug(uint64(m.DedupInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxySessionFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovDebug(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovDebug(uint64(m.DstPort))
	}
	if m.MatchAll {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxySessionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionFilter != nil {
		l = m.SessionFilter.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Qid1 != 0 {
		n += 1 + sovDebug(uint64(m.Qid1))
	}
	if m.Qid2 != 0 {
		n += 1 + sovDebug(uint64(m.Qid2))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.DstIp != nil {
		l = m.DstIp.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovDebug(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovDebug(uint64(m.DstPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxySessionGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxySession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxySessionGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyGlobalStatsGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.GlobalStats != nil {
		l = m.GlobalStats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyGlobalStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RxDescFull != 0 {
		n += 1 + sovDebug(uint64(m.RxDescFull))
	}
	if m.InvalidTxDesc != 0 {
		n += 1 + sovDebug(uint64(m.InvalidTxDesc))
	}
	if m.InvalidRetxDesc != 0 {
		n += 1 + sovDebug(uint64(m.InvalidRetxDesc))
	}
	if m.PartialPktAck != 0 {
		n += 1 + sovDebug(uint64(m.PartialPktAck))
	}
	if m.RetxNopSchedule != 0 {
		n += 1 + sovDebug(uint64(m.RetxNopSchedule))
	}
	if m.GcFull != 0 {
		n += 1 + sovDebug(uint64(m.GcFull))
	}
	if m.TlsGcFull != 0 {
		n += 1 + sovDebug(uint64(m.TlsGcFull))
	}
	if m.OoqFull != 0 {
		n += 1 + sovDebug(uint64(m.OoqFull))
	}
	if m.InvalidRxDesc != 0 {
		n += 1 + sovDebug(uint64(m.InvalidRxDesc))
	}
	if m.RcvdCePkts != 0 {
		n += 1 + sovDebug(uint64(m.RcvdCePkts))
	}
	if m.EcnReducedCongestion != 0 {
		n += 1 + sovDebug(uint64(m.EcnReducedCongestion))
	}
	if m.RetxPkts != 0 {
		n += 1 + sovDebug(uint64(m.RetxPkts))
	}
	if m.OoqRx2TxFull != 0 {
		n += 1 + sovDebug(uint64(m.OoqRx2TxFull))
	}
	if m.RxAckForUnsentData != 0 {
		n += 1 + sovDebug(uint64(m.RxAckForUnsentData))
	}
	if m.FinSentCnt != 0 {
		n += 1 + sovDebug(uint64(m.FinSentCnt))
	}
	if m.RstSentCnt != 0 {
		n += 2 + sovDebug(uint64(m.RstSentCnt))
	}
	if m.RxWinProbe != 0 {
		n += 2 + sovDebug(uint64(m.RxWinProbe))
	}
	if m.RxKeepAlive != 0 {
		n += 2 + sovDebug(uint64(m.RxKeepAlive))
	}
	if m.RxPktAfterWin != 0 {
		n += 2 + sovDebug(uint64(m.RxPktAfterWin))
	}
	if m.RxPureWinUpd != 0 {
		n += 2 + sovDebug(uint64(m.RxPureWinUpd))
	}
	if m.RxDescAvail != 0 {
		n += 2 + sovDebug(uint64(m.RxDescAvail))
	}
	if m.TxDescAvail != 0 {
		n += 2 + sovDebug(uint64(m.TxDescAvail))
	}
	if m.OoqAvail != 0 {
		n += 2 + sovDebug(uint64(m.OoqAvail))
	}
	if m.TcpDebug1 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug1))
	}
	if m.TcpDebug2 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug2))
	}
	if m.TcpDebug3 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug3))
	}
	if m.TcpDebug4 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug4))
	}
	if m.TcpDebug5 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug5))
	}
	if m.TcpDebug6 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug6))
	}
	if m.TcpDebug7 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug7))
	}
	if m.TcpDebug8 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug8))
	}
	if m.TcpDebug9 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug9))
	}
	if m.TcpDebug10 != 0 {
		n += 2 + sovDebug(uint64(m.TcpDebug10))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyGlobalCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mss != 0 {
		n += 1 + sovDebug(uint64(m.Mss))
	}
	if m.CwndInitial != 0 {
		n += 1 + sovDebug(uint64(m.CwndInitial))
	}
	if m.CwndIdle != 0 {
		n += 1 + sovDebug(uint64(m.CwndIdle))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyGlobalCfgRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpProxyGlobalCfgResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpCbId != 0 {
		n += 1 + sovDebug(uint64(m.TcpCbId))
	}
	if m.RcvNxt != 0 {
		n += 1 + sovDebug(uint64(m.RcvNxt))
	}
	if m.SndNxt != 0 {
		n += 1 + sovDebug(uint64(m.SndNxt))
	}
	if m.SndUna != 0 {
		n += 1 + sovDebug(uint64(m.SndUna))
	}
	if m.RcvTsval != 0 {
		n += 1 + sovDebug(uint64(m.RcvTsval))
	}
	if m.TsRecent != 0 {
		n += 1 + sovDebug(uint64(m.TsRecent))
	}
	if m.SerqBase != 0 {
		n += 9
	}
	if m.DebugDol != 0 {
		n += 1 + sovDebug(uint64(m.DebugDol))
	}
	if m.SesqBase != 0 {
		n += 9
	}
	if m.SesqPi != 0 {
		n += 1 + sovDebug(uint64(m.SesqPi))
	}
	if m.SesqCi != 0 {
		n += 1 + sovDebug(uint64(m.SesqCi))
	}
	if m.SndWnd != 0 {
		n += 1 + sovDebug(uint64(m.SndWnd))
	}
	if m.SndCwnd != 0 {
		n += 1 + sovDebug(uint64(m.SndCwnd))
	}
	if m.RcvMss != 0 {
		n += 1 + sovDebug(uint64(m.RcvMss))
	}
	if m.SourcePort != 0 {
		n += 1 + sovDebug(uint64(m.SourcePort))
	}
	if m.DestPort != 0 {
		n += 2 + sovDebug(uint64(m.DestPort))
	}
	l = len(m.HeaderTemplate)
	if l > 0 {
		n += 2 + l + sovDebug(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovDebug(uint64(m.State))
	}
	if m.SourceLif != 0 {
		n += 2 + sovDebug(uint64(m.SourceLif))
	}
	if m.AsesqBase != 0 {
		n += 10
	}
	if m.AsesqPi != 0 {
		n += 2 + sovDebug(uint64(m.AsesqPi))
	}
	if m.AsesqCi != 0 {
		n += 2 + sovDebug(uint64(m.AsesqCi))
	}
	if m.DebugDolTx != 0 {
		n += 2 + sovDebug(uint64(m.DebugDolTx))
	}
	if m.HeaderLen != 0 {
		n += 2 + sovDebug(uint64(m.HeaderLen))
	}
	if m.PendingAckSend {
		n += 3
	}
	if m.SesqRetxCi != 0 {
		n += 2 + sovDebug(uint64(m.SesqRetxCi))
	}
	if m.RetxSndUna != 0 {
		n += 2 + sovDebug(uint64(m.RetxSndUna))
	}
	if m.RxTs != 0 {
		n += 2 + sovDebug(uint64(m.RxTs))
	}
	if m.Rto != 0 {
		n += 2 + sovDebug(uint64(m.Rto))
	}
	if m.SndCwndCnt != 0 {
		n += 2 + sovDebug(uint64(m.SndCwndCnt))
	}
	if m.DebugDolTblsetaddr != 0 {
		n += 2 + sovDebug(uint64(m.DebugDolTblsetaddr))
	}
	if m.SerqPi != 0 {
		n += 2 + sovDebug(uint64(m.SerqPi))
	}
	if m.PredFlags != 0 {
		n += 2 + sovDebug(uint64(m.PredFlags))
	}
	if m.OtherQid != 0 {
		n += 2 + sovDebug(uint64(m.OtherQid))
	}
	if m.PacketsOut != 0 {
		n += 2 + sovDebug(uint64(m.PacketsOut))
	}
	if m.SndSsthresh != 0 {
		n += 2 + sovDebug(uint64(m.SndSsthresh))
	}
	if m.CcAlgo != 0 {
		n += 2 + sovDebug(uint64(m.CcAlgo))
	}
	if m.RtoBackoff != 0 {
		n += 2 + sovDebug(uint64(m.RtoBackoff))
	}
	if m.CpuId != 0 {
		n += 2 + sovDebug(uint64(m.CpuId))
	}
	if m.SerqCi != 0 {
		n += 2 + sovDebug(uint64(m.SerqCi))
	}
	if m.RcvWnd != 0 {
		n += 2 + sovDebug(uint64(m.RcvWnd))
	}
	if m.SndWscale != 0 {
		n += 2 + sovDebug(uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		n += 2 + sovDebug(uint64(m.RcvWscale))
	}
	if m.SesqTxCi != 0 {
		n += 2 + sovDebug(uint64(m.SesqTxCi))
	}
	if m.DelayAck {
		n += 3
	}
	if m.Ato != 0 {
		n += 2 + sovDebug(uint64(m.Ato))
	}
	if m.SndRecover != 0 {
		n += 2 + sovDebug(uint64(m.SndRecover))
	}
	if m.Smss != 0 {
		n += 2 + sovDebug(uint64(m.Smss))
	}
	if m.InitialWindow != 0 {
		n += 2 + sovDebug(uint64(m.InitialWindow))
	}
	if m.AbcLVar != 0 {
		n += 2 + sovDebug(uint64(m.AbcLVar))
	}
	if m.OooQueue {
		n += 3
	}
	if m.OooRx2TxQbase != 0 {
		n += 2 + sovDebug(uint64(m.OooRx2TxQbase))
	}
	if m.RcvWup != 0 {
		n += 2 + sovDebug(uint64(m.RcvWup))
	}
	if m.CbBase != 0 {
		n += 10
	}
	if m.ZeroWindowSent != 0 {
		n += 2 + sovDebug(uint64(m.ZeroWindowSent))
	}
	if m.CbBaseQtype1 != 0 {
		n += 10
	}
	if m.SrttUs != 0 {
		n += 2 + sovDebug(uint64(m.SrttUs))
	}
	if m.SackPerm {
		n += 3
	}
	if m.Timestamps {
		n += 3
	}
	if m.RttSeqTsoffset != 0 {
		n += 2 + sovDebug(uint64(m.RttSeqTsoffset))
	}
	if m.RttTime != 0 {
		n += 2 + sovDebug(uint64(m.RttTime))
	}
	if m.TsLearned != 0 {
		n += 2 + sovDebug(uint64(m.TsLearned))
	}
	if m.TsOffset != 0 {
		n += 2 + sovDebug(uint64(m.TsOffset))
	}
	if m.TsTime != 0 {
		n += 2 + sovDebug(uint64(m.TsTime))
	}
	if m.Keepalives {
		n += 3
	}
	if m.RttVar != 0 {
		n += 2 + sovDebug(uint64(m.RttVar))
	}
	if m.AppQid != 0 {
		n += 2 + sovDebug(uint64(m.AppQid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbOoqStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueAddr != 0 {
		n += 1 + sovDebug(uint64(m.QueueAddr))
	}
	if m.StartSeq != 0 {
		n += 1 + sovDebug(uint64(m.StartSeq))
	}
	if m.EndSeq != 0 {
		n += 1 + sovDebug(uint64(m.EndSeq))
	}
	if m.NumEntries != 0 {
		n += 1 + sovDebug(uint64(m.NumEntries))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpCbId != 0 {
		n += 1 + sovDebug(uint64(m.TcpCbId))
	}
	if m.OoqNotEmpty {
		n += 2
	}
	if len(m.OoqStatus) > 0 {
		for _, e := range m.OoqStatus {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpCbId != 0 {
		n += 1 + sovDebug(uint64(m.TcpCbId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesRcvd != 0 {
		n += 1 + sovDebug(uint64(m.BytesRcvd))
	}
	if m.PktsRcvd != 0 {
		n += 1 + sovDebug(uint64(m.PktsRcvd))
	}
	if m.BytesAcked != 0 {
		n += 1 + sovDebug(uint64(m.BytesAcked))
	}
	if m.PureAcksRcvd != 0 {
		n += 1 + sovDebug(uint64(m.PureAcksRcvd))
	}
	if m.DupAcksRcvd != 0 {
		n += 1 + sovDebug(uint64(m.DupAcksRcvd))
	}
	if m.SlowPathCnt != 0 {
		n += 1 + sovDebug(uint64(m.SlowPathCnt))
	}
	if m.SerqFullCnt != 0 {
		n += 1 + sovDebug(uint64(m.SerqFullCnt))
	}
	if m.OooCnt != 0 {
		n += 1 + sovDebug(uint64(m.OooCnt))
	}
	if m.RxDropCnt != 0 {
		n += 1 + sovDebug(uint64(m.RxDropCnt))
	}
	if m.PawsDropCnt != 0 {
		n += 1 + sovDebug(uint64(m.PawsDropCnt))
	}
	if m.WinCheckFail != 0 {
		n += 1 + sovDebug(uint64(m.WinCheckFail))
	}
	if m.OooDropCnt != 0 {
		n += 1 + sovDebug(uint64(m.OooDropCnt))
	}
	if m.SerqPi != 0 {
		n += 1 + sovDebug(uint64(m.SerqPi))
	}
	if m.SerqCi != 0 {
		n += 1 + sovDebug(uint64(m.SerqCi))
	}
	if m.BytesSent != 0 {
		n += 3 + sovDebug(uint64(m.BytesSent))
	}
	if m.PktsSent != 0 {
		n += 3 + sovDebug(uint64(m.PktsSent))
	}
	if m.PureAcksSent != 0 {
		n += 3 + sovDebug(uint64(m.PureAcksSent))
	}
	if m.SesqPi != 0 {
		n += 3 + sovDebug(uint64(m.SesqPi))
	}
	if m.SesqCi != 0 {
		n += 3 + sovDebug(uint64(m.SesqCi))
	}
	if m.SendAckPi != 0 {
		n += 3 + sovDebug(uint64(m.SendAckPi))
	}
	if m.SendAckCi != 0 {
		n += 3 + sovDebug(uint64(m.SendAckCi))
	}
	if m.FastTimerPi != 0 {
		n += 3 + sovDebug(uint64(m.FastTimerPi))
	}
	if m.FastTimerCi != 0 {
		n += 3 + sovDebug(uint64(m.FastTimerCi))
	}
	if m.DelAckPi != 0 {
		n += 3 + sovDebug(uint64(m.DelAckPi))
	}
	if m.DelAckCi != 0 {
		n += 3 + sovDebug(uint64(m.DelAckCi))
	}
	if m.OobRstPi != 0 {
		n += 3 + sovDebug(uint64(m.OobRstPi))
	}
	if m.OobRstCi != 0 {
		n += 3 + sovDebug(uint64(m.OobRstCi))
	}
	if m.PendingTxPi != 0 {
		n += 3 + sovDebug(uint64(m.PendingTxPi))
	}
	if m.PendingTxCi != 0 {
		n += 3 + sovDebug(uint64(m.PendingTxCi))
	}
	if m.FastRetransPi != 0 {
		n += 3 + sovDebug(uint64(m.FastRetransPi))
	}
	if m.FastRetransCi != 0 {
		n += 3 + sovDebug(uint64(m.FastRetransCi))
	}
	if m.CleanRetxPi != 0 {
		n += 3 + sovDebug(uint64(m.CleanRetxPi))
	}
	if m.CleanRetxCi != 0 {
		n += 3 + sovDebug(uint64(m.CleanRetxCi))
	}
	if m.PacketsOut != 0 {
		n += 3 + sovDebug(uint64(m.PacketsOut))
	}
	if m.SesqTxCi != 0 {
		n += 3 + sovDebug(uint64(m.SesqTxCi))
	}
	if m.SesqRetxCi != 0 {
		n += 3 + sovDebug(uint64(m.SesqRetxCi))
	}
	if m.AsesqRetxCi != 0 {
		n += 3 + sovDebug(uint64(m.AsesqRetxCi))
	}
	if m.TxRingPi != 0 {
		n += 3 + sovDebug(uint64(m.TxRingPi))
	}
	if m.PartialPktAckCnt != 0 {
		n += 3 + sovDebug(uint64(m.PartialPktAckCnt))
	}
	if m.AtoDeadline != 0 {
		n += 3 + sovDebug(uint64(m.AtoDeadline))
	}
	if m.RtoDeadline != 0 {
		n += 3 + sovDebug(uint64(m.RtoDeadline))
	}
	if m.CcFlags != 0 {
		n += 3 + sovDebug(uint64(m.CcFlags))
	}
	if m.KeepaDeadline != 0 {
		n += 3 + sovDebug(uint64(m.KeepaDeadline))
	}
	if m.WindowFullCnt != 0 {
		n += 3 + sovDebug(uint64(m.WindowFullCnt))
	}
	if m.OoqRx2TxPi != 0 {
		n += 3 + sovDebug(uint64(m.OoqRx2TxPi))
	}
	if m.OoqRx2TxCi != 0 {
		n += 3 + sovDebug(uint64(m.OoqRx2TxCi))
	}
	if m.RetxCnt != 0 {
		n += 3 + sovDebug(uint64(m.RetxCnt))
	}
	if m.WindowUpdatePi != 0 {
		n += 3 + sovDebug(uint64(m.WindowUpdatePi))
	}
	if m.WindowUpdateCi != 0 {
		n += 3 + sovDebug(uint64(m.WindowUpdateCi))
	}
	if m.TxWindowUpdatePi != 0 {
		n += 3 + sovDebug(uint64(m.TxWindowUpdatePi))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpCbGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTracerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPC)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.VNI != 0 {
		n += 1 + sovDebug(uint64(m.VNI))
	}
	if m.SrcAddr != nil {
		l = m.SrcAddr.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.DstAddr != nil {
		l = m.DstAddr.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.SrcTep != nil {
		l = m.SrcTep.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.IPProto != 0 {
		n += 1 + sovDebug(uint64(m.IPProto))
	}
	if m.L4Info != nil {
		l = m.L4Info.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.OverlayDstMAC != 0 {
		n += 1 + sovDebug(uint64(m.OverlayDstMAC))
	}
	if m.OverlaySrcMAC != 0 {
		n += 1 + sovDebug(uint64(m.OverlaySrcMAC))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTracerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTracerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPC)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.Vnic)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.SecurityRule)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.SecurityPolicy)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.SvcMapping)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.IngressSubnet)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.EgressSubnet)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.MeterClass != 0 {
		n += 1 + sovDebug(uint64(m.MeterClass))
	}
	if m.RouteClassPriority != 0 {
		n += 1 + sovDebug(uint64(m.RouteClassPriority))
	}
	if m.Action != 0 {
		n += 1 + sovDebug(uint64(m.Action))
	}
	if m.FlowHit {
		n += 2
	}
	if m.MappingHit {
		n += 2
	}
	if m.DefaultRuleHit {
		n += 2
	}
	if m.DstTep != nil {
		l = m.DstTep.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Drop {
		n += 2
	}
	if len(m.DropReason) > 0 {
		for _, s := range m.DropReason {
			l = len(s)
			n += 2 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTracerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MPUPerfInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Utilization != 0 {
		n += 1 + sovDebug(uint64(m.Utilization))
	}
	if m.CPI != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineStagePerfInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MPUPerf) > 0 {
		for _, e := range m.MPUPerf {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelinePerfInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != 0 {
		n += 1 + sovDebug(uint64(m.Pipeline))
	}
	if m.PHVs != 0 {
		n += 1 + sovDebug(uint64(m.PHVs))
	}
	if m.Drops != 0 {
		n += 1 + sovDebug(uint64(m.Drops))
	}
	if m.Recircs != 0 {
		n += 1 + sovDebug(uint64(m.Recircs))
	}
	if m.PacketsFromPB != 0 {
		n += 1 + sovDebug(uint64(m.PacketsFromPB))
	}
	if m.ParserDrops != 0 {
		n += 1 + sovDebug(uint64(m.ParserDrops))
	}
	if len(m.StagePerf) > 0 {
		for _, e := range m.StagePerf {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DDRPerfInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reads != 0 {
		n += 1 + sovDebug(uint64(m.Reads))
	}
	if m.ReadLatencyMax != 0 {
		n += 1 + sovDebug(uint64(m.ReadLatencyMax))
	}
	if m.ReadLatencyAvg != 0 {
		n += 1 + sovDebug(uint64(m.ReadLatencyAvg))
	}
	if m.ReadMTPS != 0 {
		n += 5
	}
	if m.ReadBandwidth != 0 {
		n += 5
	}
	if m.Writes != 0 {
		n += 1 + sovDebug(uint64(m.Writes))
	}
	if m.WriteLatencyMax != 0 {
		n += 1 + sovDebug(uint64(m.WriteLatencyMax))
	}
	if m.WriteLatencyAvg != 0 {
		n += 1 + sovDebug(uint64(m.WriteLatencyAvg))
	}
	if m.WriteMTPS != 0 {
		n += 5
	}
	if m.WriteBandwidth != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AsicPerfGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.DDRPerfInfo) > 0 {
		for _, e := range m.DDRPerfInfo {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if len(m.PipelinePerfInfo) > 0 {
		for _, e := range m.PipelinePerfInfo {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	if m.TunneledPacket {
		n += 2
	}
	if m.FlowMiss {
		n += 2
	}
	if m.LocalMappingUnknown {
		n += 2
	}
	if m.IPFragment {
		n += 2
	}
	if m.Direction != 0 {
		n += 1 + sovDebug(uint64(m.Direction))
	}
	if m.LifMatch != nil {
		n += m.LifMatch.Size()
	}
	if m.MatchFields != nil {
		n += m.MatchFields.Size()
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_SrcLif) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcLif != nil {
		l = len(m.SrcLif)
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_SrcLifType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDebug(uint64(m.SrcLifType))
	return n
}
func (m *NaclRequest_L2Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2Match != nil {
		l = m.L2Match.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_IPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPMatch != nil {
		l = m.IPMatch.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_Drop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *NaclRequest_RedirectLifId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedirectLifId != nil {
		l = len(m.RedirectLifId)
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_L2PacketMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPProtocolMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovDebug(uint64(m.Protocol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.IPProto != nil {
		l = m.IPProto.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.L4Match != nil {
		n += m.L4Match.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch_TcpUdpMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpUdpMatch != nil {
		l = m.TcpUdpMatch.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_IPPacketMatch_IcmpMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IcmpMatch != nil {
		l = m.IcmpMatch.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPort != nil {
		l = m.SrcPort.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.DstPort != nil {
		l = m.DstPort.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovDebug(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Code != nil {
		l = m.Code.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDebug(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDebug(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NaclDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ElamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThreadSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDebug(uint64(m.Id))
	}
	if m.PthreadId != 0 {
		n += 1 + sovDebug(uint64(m.PthreadId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovDebug(uint64(m.Priority))
	}
	if m.SchedPolicy != 0 {
		n += 1 + sovDebug(uint64(m.SchedPolicy))
	}
	if m.Role != 0 {
		n += 1 + sovDebug(uint64(m.Role))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThreadStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Running {
		n += 2
	}
	if m.LastHeartBeatTime != 0 {
		n += 1 + sovDebug(uint64(m.LastHeartBeatTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThreadStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Thread) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThreadGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDebug(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDebug(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDebug(x uint64) (n int) {
	return sovDebug(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TraceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= TraceLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= TraceLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceLevelGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceLevelGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceLevelGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= TraceLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableApiStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableApiStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableApiStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TableApiStatsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableApiStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableApiStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableApiStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entry = append(m.Entry, &TableApiStatsEntry{})
			if err := m.Entry[len(m.Entry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TableStatsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entry = append(m.Entry, &TableStatsEntry{})
			if err := m.Entry[len(m.Entry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiStats == nil {
				m.ApiStats = &TableApiStats{}
			}
			if err := m.ApiStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableStats == nil {
				m.TableStats = &TableStats{}
			}
			if err := m.TableStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableSize", wireType)
			}
			m.TableSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TableStatsResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LlcSetupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LlcSetupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LlcSetupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LlcCounterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LlcSetupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LlcSetupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LlcSetupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LlcStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LlcStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LlcStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LlcCounterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Count = append(m.Count, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebug
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebug
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Count) == 0 {
					m.Count = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebug
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Count = append(m.Count, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LlcStatsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LlcStatsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LlcStatsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &LlcStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OflowFifoDropStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OflowFifoDropStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OflowFifoDropStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OflowFifoDropType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OflowFifoDropStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OflowFifoDropStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OflowFifoDropStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entry = append(m.Entry, &OflowFifoDropStatsEntry{})
			if err := m.Entry[len(m.Entry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OflowFifoStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OflowFifoStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OflowFifoStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SopCountIn", wireType)
			}
			m.SopCountIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SopCountIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EopCountIn", wireType)
			}
			m.EopCountIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EopCountIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SopCountOut", wireType)
			}
			m.SopCountOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SopCountOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EopCountOut", wireType)
			}
			m.EopCountOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EopCountOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropCounts == nil {
				m.DropCounts = &OflowFifoDropStats{}
			}
			if err := m.DropCounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferDropStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferDropStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferDropStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reasons", wireType)
			}
			m.Reasons = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reasons |= BufferDropReasons(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCount", wireType)
			}
			m.DropCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferDropStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferDropStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferDropStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsEntries = append(m.StatsEntries, &BufferDropStatsEntry{})
			if err := m.StatsEntries[len(m.StatsEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SopCountIn", wireType)
			}
			m.SopCountIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SopCountIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EopCountIn", wireType)
			}
			m.EopCountIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EopCountIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SopCountOut", wireType)
			}
			m.SopCountOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SopCountOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EopCountOut", wireType)
			}
			m.EopCountOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EopCountOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropCounts == nil {
				m.DropCounts = &BufferDropStats{}
			}
			if err := m.DropCounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketBufferPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketBufferPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketBufferPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortType", wireType)
			}
			m.PortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortType |= PacketBufferPortType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosInputOflowQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosInputOflowQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosInputOflowQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsIn", wireType)
			}
			m.GoodPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsOut", wireType)
			}
			m.GoodPktsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErroredPktsIn", wireType)
			}
			m.ErroredPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErroredPktsIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifoDepth", wireType)
			}
			m.FifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FifoDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFifoDepth", wireType)
			}
			m.MaxFifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFifoDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosInputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosInputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosInputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueIdx", wireType)
			}
			m.InputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputQueueIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OflowFifoStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OflowFifoStats == nil {
				m.OflowFifoStats = &QosInputOflowQueueStats{}
			}
			if err := m.OflowFifoStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferOccupancy", wireType)
			}
			m.BufferOccupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferOccupancy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakOccupancy", wireType)
			}
			m.PeakOccupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakOccupancy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMonitor", wireType)
			}
			m.PortMonitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMonitor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosOutputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosOutputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosOutputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueIdx", wireType)
			}
			m.OutputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputQueueIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueDepth", wireType)
			}
			m.QueueDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMonitor", wireType)
			}
			m.PortMonitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMonitor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputQueueStats = append(m.InputQueueStats, &QosInputQueueStats{})
			if err := m.InputQueueStats[len(m.InputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputQueueStats = append(m.OutputQueueStats, &QosOutputQueueStats{})
			if err := m.OutputQueueStats[len(m.OutputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketBufferPortStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketBufferPortStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketBufferPortStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketBufferPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PacketBufferPort == nil {
				m.PacketBufferPort = &PacketBufferPort{}
			}
			if err := m.PacketBufferPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferStats == nil {
				m.BufferStats = &BufferStats{}
			}
			if err := m.BufferStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OflowFifoStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OflowFifoStats == nil {
				m.OflowFifoStats = &OflowFifoStats{}
			}
			if err := m.OflowFifoStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QosQueueStats == nil {
				m.QosQueueStats = &QosQueueStats{}
			}
			if err := m.QosQueueStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketBufferStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketBufferStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketBufferStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortStats = append(m.PortStats, &PacketBufferPortStats{})
			if err := m.PortStats[len(m.PortStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbStatsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbStatsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbStatsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PbStats == nil {
				m.PbStats = &PacketBufferStats{}
			}
			if err := m.PbStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbStatsSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbStatsSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbStatsSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMacPktsIn", wireType)
			}
			m.TotalMacPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMacPktsIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMacPktsOut", wireType)
			}
			m.TotalMacPktsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMacPktsOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHostPktsIn", wireType)
			}
			m.TotalHostPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHostPktsIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHostPktsOut", wireType)
			}
			m.TotalHostPktsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHostPktsOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPBDrops", wireType)
			}
			m.TotalPBDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPBDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPRDDrops", wireType)
			}
			m.TotalPRDDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPRDDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PbStatsSummaryGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PbStatsSummaryGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PbStatsSummaryGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbStatsSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PbStatsSummary == nil {
				m.PbStatsSummary = &PbStatsSummary{}
			}
			if err := m.PbStatsSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemTrackSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemTrackSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemTrackSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			m.AllocId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemTrackStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemTrackStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemTrackStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemTrackStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemTrackStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemTrackStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAllocs", wireType)
			}
			m.NumAllocs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAllocs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFrees", wireType)
			}
			m.NumFrees = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFrees |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemTrackGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemTrackGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemTrackGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MemTrackSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemTrackGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemTrackGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemTrackGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MemTrackSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MemTrackStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MemTrackStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeapStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeapStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeapStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumArenaBytesAlloc", wireType)
			}
			m.NumArenaBytesAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumArenaBytesAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFreeBlocks", wireType)
			}
			m.NumFreeBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFreeBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFastBinFreeBlocks", wireType)
			}
			m.NumFastBinFreeBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFastBinFreeBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMmapBlocksAlloc", wireType)
			}
			m.NumMmapBlocksAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumMmapBlocksAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMmapBytesAlloc", wireType)
			}
			m.NumMmapBytesAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumMmapBytesAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBlocksAlloc", wireType)
			}
			m.MaxBlocksAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBlocksAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFastBinFreeBytes", wireType)
			}
			m.NumFastBinFreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFastBinFreeBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytesAlloc", wireType)
			}
			m.NumBytesAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytesAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFreeBytes", wireType)
			}
			m.NumFreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFreeBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasableFreeBytes", wireType)
			}
			m.ReleasableFreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleasableFreeBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeapGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeapGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeapGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeapGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeapGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeapGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &HeapStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3HWMappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3HWMappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3HWMappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			m.VPCId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VPCId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAddr == nil {
				m.IPAddr = &IPAddress{}
			}
			if err := m.IPAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2HWMappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2HWMappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2HWMappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddr", wireType)
			}
			m.MACAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HWMappingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HWMappingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HWMappingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3HWMappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &HWMappingKey_IPKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2HWMappingKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Keyinfo = &HWMappingKey_MACKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MappingDumpFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MappingDumpFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MappingDumpFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &HWMappingKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MappingDumpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandUUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandUUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandUUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDumpFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDumpFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDumpFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandUUID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceDumpFilter_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfType", wireType)
			}
			var v IfType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= IfType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ifinfo = &InterfaceDumpFilter_IfType{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatapathAssist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatapathAssist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatapathAssist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCores", wireType)
			}
			m.NumCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCores |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= Command(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommandMsg == nil {
				m.CommandMsg = &types.Any{}
			}
			if err := m.CommandMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AacsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AacsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AacsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AacsServerPort", wireType)
			}
			m.AacsServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AacsServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlabSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlabSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlabSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementSize", wireType)
			}
			m.ElementSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElementSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementsPerBlock", wireType)
			}
			m.ElementsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElementsPerBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadSafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThreadSafe = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowOnDemand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GrowOnDemand = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayDelete = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroOnAllocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZeroOnAllocation = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBlockSize", wireType)
			}
			m.RawBlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawBlockSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlabStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlabStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlabStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlabStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlabStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlabStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumElementsInUse", wireType)
			}
			m.NumElementsInUse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumElementsInUse |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAllocs", wireType)
			}
			m.NumAllocs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAllocs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFrees", wireType)
			}
			m.NumFrees = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFrees |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAllocErrors", wireType)
			}
			m.NumAllocErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAllocErrors |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBlocks", wireType)
			}
			m.NumBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Slab) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slab: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slab: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SlabSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SlabStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &SlabStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlabGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlabGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlabGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slab = append(m.Slab, &Slab{})
			if err := m.Slab[len(m.Slab)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatapathMemoryGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatapathMemoryGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatapathMemoryGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedLowMemUsed", wireType)
			}
			m.UncachedLowMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedLowMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedLowMemUsed", wireType)
			}
			m.CachedLowMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedLowMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedLowHighMemUsed", wireType)
			}
			m.UncachedLowHighMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedLowHighMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedLowHighMemUsed", wireType)
			}
			m.CachedLowHighMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedLowHighMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedHighHighMemUsed", wireType)
			}
			m.UncachedHighHighMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedHighHighMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedHighHighMemUsed", wireType)
			}
			m.CachedHighHighMemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedHighHighMemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSUMemRsvd", wireType)
			}
			m.UncachedISSUMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSUMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSUMemRsvd", wireType)
			}
			m.CachedISSUMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSUMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSUMemNeeded", wireType)
			}
			m.UncachedISSUMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSUMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSUMemNeeded", wireType)
			}
			m.CachedISSUMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSUMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSULowMemNeeded", wireType)
			}
			m.UncachedISSULowMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSULowMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSULowMemNeeded", wireType)
			}
			m.CachedISSULowMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSULowMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSUHiMemNeeded", wireType)
			}
			m.UncachedISSUHiMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSUHiMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSUHiMemNeeded", wireType)
			}
			m.CachedISSUHiMemNeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSUHiMemNeeded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSULowMemRsvd", wireType)
			}
			m.UncachedISSULowMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSULowMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSULowMemRsvd", wireType)
			}
			m.CachedISSULowMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSULowMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncachedISSUHiMemRsvd", wireType)
			}
			m.UncachedISSUHiMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncachedISSUHiMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedISSUHiMemRsvd", wireType)
			}
			m.CachedISSUHiMemRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedISSUHiMemRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortStatus", wireType)
			}
			m.PortStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortStatus |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSpeed", wireType)
			}
			m.PortSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortSpeed |= PortSpeed(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMode", wireType)
			}
			m.PortMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMode |= IntPortDplxMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortTxPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortTxPaused = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortFlowCtrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortFlowCtrl = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InGoodOctets", wireType)
			}
			m.InGoodOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InGoodOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutOctets", wireType)
			}
			m.OutOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBadOctets", wireType)
			}
			m.InBadOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InBadOctets |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUnicast", wireType)
			}
			m.InUnicast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUnicast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbroadcast", wireType)
			}
			m.Inbroadcast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inbroadcast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inmulticast", wireType)
			}
			m.Inmulticast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inmulticast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPause", wireType)
			}
			m.InPause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPause |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUndersize", wireType)
			}
			m.InUndersize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUndersize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFragments", wireType)
			}
			m.InFragments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InFragments |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOversize", wireType)
			}
			m.InOversize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InOversize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InJabber", wireType)
			}
			m.InJabber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InJabber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRxErr", wireType)
			}
			m.InRxErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InRxErr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFcsErr", wireType)
			}
			m.InFcsErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InFcsErr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUnicast", wireType)
			}
			m.OutUnicast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUnicast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutBroadcast", wireType)
			}
			m.OutBroadcast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutBroadcast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMulticast", wireType)
			}
			m.OutMulticast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutMulticast |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutFcsErr", wireType)
			}
			m.OutFcsErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutFcsErr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPause", wireType)
			}
			m.OutPause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPause |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutCollisions", wireType)
			}
			m.OutCollisions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutCollisions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDeferred", wireType)
			}
			m.OutDeferred = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutDeferred |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutSingle", wireType)
			}
			m.OutSingle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutSingle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMultiple", wireType)
			}
			m.OutMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutMultiple |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutExcessive", wireType)
			}
			m.OutExcessive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutExcessive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutLate", wireType)
			}
			m.OutLate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutLate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDescr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortDescr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalStatus == nil {
				m.InternalStatus = &InternalPortStatus{}
			}
			if err := m.InternalStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &InternalPortStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &InternalPortResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPortRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPortRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPortRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &InternalPortRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNumber", wireType)
			}
			m.PageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageContent = append(m.PageContent[:0], dAtA[iNdEx:postIndex]...)
			if m.PageContent == nil {
				m.PageContent = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Page = append(m.Page, &EepromPage{})
			if err := m.Page[len(m.Page)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromReadResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromReadResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromReadResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EepromReadResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &EepromAddress{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromReadRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromReadRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromReadRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId, make([]byte, postIndex-iNdEx))
			copy(m.PortId[len(m.PortId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromWriteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromWriteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromWriteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &EepromAddress{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EepromWriteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EepromWriteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EepromWriteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EepromWriteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnDedupIntervalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnDedupIntervalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnDedupIntervalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedupInterval", wireType)
			}
			m.DedupInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DedupInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionFilter == nil {
				m.SessionFilter = &TcpProxySessionFilter{}
			}
			if err := m.SessionFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qid1", wireType)
			}
			m.Qid1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qid1 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qid2", wireType)
			}
			m.Qid2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qid2 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIp == nil {
				m.DstIp = &IPAddress{}
			}
			if err := m.DstIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxySessionReq{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &TcpProxyFlow{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxySessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxySessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxySessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpProxySession{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStatsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStatsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalStats == nil {
				m.GlobalStats = &TcpProxyGlobalStats{}
			}
			if err := m.GlobalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDescFull", wireType)
			}
			m.RxDescFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDescFull |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidTxDesc", wireType)
			}
			m.InvalidTxDesc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidTxDesc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidRetxDesc", wireType)
			}
			m.InvalidRetxDesc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidRetxDesc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialPktAck", wireType)
			}
			m.PartialPktAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialPktAck |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxNopSchedule", wireType)
			}
			m.RetxNopSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxNopSchedule |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcFull", wireType)
			}
			m.GcFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcFull |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsGcFull", wireType)
			}
			m.TlsGcFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TlsGcFull |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqFull", wireType)
			}
			m.OoqFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OoqFull |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidRxDesc", wireType)
			}
			m.InvalidRxDesc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidRxDesc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvdCePkts", wireType)
			}
			m.RcvdCePkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvdCePkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcnReducedCongestion", wireType)
			}
			m.EcnReducedCongestion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EcnReducedCongestion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxPkts", wireType)
			}
			m.RetxPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqRx2TxFull", wireType)
			}
			m.OoqRx2TxFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OoqRx2TxFull |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxAckForUnsentData", wireType)
			}
			m.RxAckForUnsentData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxAckForUnsentData |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinSentCnt", wireType)
			}
			m.FinSentCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinSentCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RstSentCnt", wireType)
			}
			m.RstSentCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RstSentCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxWinProbe", wireType)
			}
			m.RxWinProbe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxWinProbe |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxKeepAlive", wireType)
			}
			m.RxKeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxKeepAlive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPktAfterWin", wireType)
			}
			m.RxPktAfterWin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPktAfterWin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPureWinUpd", wireType)
			}
			m.RxPureWinUpd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPureWinUpd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDescAvail", wireType)
			}
			m.RxDescAvail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDescAvail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDescAvail", wireType)
			}
			m.TxDescAvail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDescAvail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqAvail", wireType)
			}
			m.OoqAvail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OoqAvail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug1", wireType)
			}
			m.TcpDebug1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug1 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug2", wireType)
			}
			m.TcpDebug2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug2 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug3", wireType)
			}
			m.TcpDebug3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug3 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1005:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug4", wireType)
			}
			m.TcpDebug4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug4 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug5", wireType)
			}
			m.TcpDebug5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug5 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1007:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug6", wireType)
			}
			m.TcpDebug6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug6 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1008:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug7", wireType)
			}
			m.TcpDebug7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug7 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1009:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug8", wireType)
			}
			m.TcpDebug8 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug8 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug9", wireType)
			}
			m.TcpDebug9 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug9 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1011:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDebug10", wireType)
			}
			m.TcpDebug10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDebug10 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mss", wireType)
			}
			m.Mss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CwndInitial", wireType)
			}
			m.CwndInitial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CwndInitial |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CwndIdle", wireType)
			}
			m.CwndIdle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CwndIdle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalCfgRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalCfgRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalCfgRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpProxyGlobalCfg{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpProxyGlobalCfgResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpProxyGlobalCfgResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpProxyGlobalCfgResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCbId", wireType)
			}
			m.TcpCbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCbId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvNxt", wireType)
			}
			m.RcvNxt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvNxt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndNxt", wireType)
			}
			m.SndNxt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndNxt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndUna", wireType)
			}
			m.SndUna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndUna |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvTsval", wireType)
			}
			m.RcvTsval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvTsval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsRecent", wireType)
			}
			m.TsRecent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsRecent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqBase", wireType)
			}
			m.SerqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SerqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDol", wireType)
			}
			m.DebugDol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqBase", wireType)
			}
			m.SesqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SesqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqPi", wireType)
			}
			m.SesqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqCi", wireType)
			}
			m.SesqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWnd", wireType)
			}
			m.SndWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndCwnd", wireType)
			}
			m.SndCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndCwnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvMss", wireType)
			}
			m.RcvMss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvMss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			m.SourcePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourcePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPort", wireType)
			}
			m.DestPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderTemplate = append(m.HeaderTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderTemplate == nil {
				m.HeaderTemplate = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLif", wireType)
			}
			m.SourceLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceLif |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqBase", wireType)
			}
			m.AsesqBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AsesqBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqPi", wireType)
			}
			m.AsesqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsesqPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqCi", wireType)
			}
			m.AsesqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsesqCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDolTx", wireType)
			}
			m.DebugDolTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDolTx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderLen", wireType)
			}
			m.HeaderLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingAckSend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PendingAckSend = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqRetxCi", wireType)
			}
			m.SesqRetxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqRetxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxSndUna", wireType)
			}
			m.RetxSndUna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxSndUna |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxTs", wireType)
			}
			m.RxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rto", wireType)
			}
			m.Rto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rto |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndCwndCnt", wireType)
			}
			m.SndCwndCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndCwndCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugDolTblsetaddr", wireType)
			}
			m.DebugDolTblsetaddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugDolTblsetaddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqPi", wireType)
			}
			m.SerqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredFlags", wireType)
			}
			m.PredFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherQid", wireType)
			}
			m.OtherQid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherQid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsOut", wireType)
			}
			m.PacketsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndSsthresh", wireType)
			}
			m.SndSsthresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndSsthresh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcAlgo", wireType)
			}
			m.CcAlgo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CcAlgo |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoBackoff", wireType)
			}
			m.RtoBackoff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtoBackoff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuId", wireType)
			}
			m.CpuId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqCi", wireType)
			}
			m.SerqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWnd", wireType)
			}
			m.RcvWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWscale", wireType)
			}
			m.SndWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWscale", wireType)
			}
			m.RcvWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqTxCi", wireType)
			}
			m.SesqTxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqTxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayAck = bool(v != 0)
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ato", wireType)
			}
			m.Ato = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ato |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndRecover", wireType)
			}
			m.SndRecover = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndRecover |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smss", wireType)
			}
			m.Smss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Smss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialWindow", wireType)
			}
			m.InitialWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialWindow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbcLVar", wireType)
			}
			m.AbcLVar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbcLVar |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OooQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OooQueue = bool(v != 0)
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OooRx2TxQbase", wireType)
			}
			m.OooRx2TxQbase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OooRx2TxQbase |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWup", wireType)
			}
			m.RcvWup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWup |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbBase", wireType)
			}
			m.CbBase = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CbBase = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWindowSent", wireType)
			}
			m.ZeroWindowSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroWindowSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbBaseQtype1", wireType)
			}
			m.CbBaseQtype1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CbBaseQtype1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrttUs", wireType)
			}
			m.SrttUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrttUs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SackPerm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SackPerm = bool(v != 0)
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamps = bool(v != 0)
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttSeqTsoffset", wireType)
			}
			m.RttSeqTsoffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttSeqTsoffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttTime", wireType)
			}
			m.RttTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsLearned", wireType)
			}
			m.TsLearned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsLearned |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsOffset", wireType)
			}
			m.TsOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsTime", wireType)
			}
			m.TsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keepalives", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Keepalives = bool(v != 0)
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttVar", wireType)
			}
			m.RttVar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttVar |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppQid", wireType)
			}
			m.AppQid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppQid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbOoqStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbOoqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbOoqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueAddr", wireType)
			}
			m.QueueAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueAddr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartSeq", wireType)
			}
			m.StartSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSeq", wireType)
			}
			m.EndSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCbId", wireType)
			}
			m.TcpCbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCbId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqNotEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OoqNotEmpty = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OoqStatus = append(m.OoqStatus, &TcpCbOoqStatus{})
			if err := m.OoqStatus[len(m.OoqStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCbId", wireType)
			}
			m.TcpCbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCbId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &TcpCbRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRcvd", wireType)
			}
			m.BytesRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRcvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsRcvd", wireType)
			}
			m.PktsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsRcvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesAcked", wireType)
			}
			m.BytesAcked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesAcked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureAcksRcvd", wireType)
			}
			m.PureAcksRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PureAcksRcvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DupAcksRcvd", wireType)
			}
			m.DupAcksRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DupAcksRcvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowPathCnt", wireType)
			}
			m.SlowPathCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlowPathCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqFullCnt", wireType)
			}
			m.SerqFullCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqFullCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OooCnt", wireType)
			}
			m.OooCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OooCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDropCnt", wireType)
			}
			m.RxDropCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDropCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PawsDropCnt", wireType)
			}
			m.PawsDropCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PawsDropCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCheckFail", wireType)
			}
			m.WinCheckFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinCheckFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OooDropCnt", wireType)
			}
			m.OooDropCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OooDropCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqPi", wireType)
			}
			m.SerqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqPi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerqCi", wireType)
			}
			m.SerqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerqCi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsSent", wireType)
			}
			m.PktsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PktsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureAcksSent", wireType)
			}
			m.PureAcksSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PureAcksSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10005:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqPi", wireType)
			}
			m.SesqPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqCi", wireType)
			}
			m.SesqCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10007:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendAckPi", wireType)
			}
			m.SendAckPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendAckPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10008:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendAckCi", wireType)
			}
			m.SendAckCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendAckCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10009:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastTimerPi", wireType)
			}
			m.FastTimerPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FastTimerPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10010:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastTimerCi", wireType)
			}
			m.FastTimerCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FastTimerCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10011:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAckPi", wireType)
			}
			m.DelAckPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelAckPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10012:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAckCi", wireType)
			}
			m.DelAckCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelAckCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10013:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OobRstPi", wireType)
			}
			m.OobRstPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OobRstPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10014:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OobRstCi", wireType)
			}
			m.OobRstCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OobRstCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10015:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTxPi", wireType)
			}
			m.PendingTxPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingTxPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10016:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTxCi", wireType)
			}
			m.PendingTxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingTxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10017:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastRetransPi", wireType)
			}
			m.FastRetransPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FastRetransPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10018:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastRetransCi", wireType)
			}
			m.FastRetransCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FastRetransCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10019:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanRetxPi", wireType)
			}
			m.CleanRetxPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CleanRetxPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10020:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanRetxCi", wireType)
			}
			m.CleanRetxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CleanRetxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10021:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsOut", wireType)
			}
			m.PacketsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10022:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqTxCi", wireType)
			}
			m.SesqTxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqTxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10023:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SesqRetxCi", wireType)
			}
			m.SesqRetxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SesqRetxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10024:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsesqRetxCi", wireType)
			}
			m.AsesqRetxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsesqRetxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10025:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxRingPi", wireType)
			}
			m.TxRingPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxRingPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10026:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialPktAckCnt", wireType)
			}
			m.PartialPktAckCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialPktAckCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10027:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtoDeadline", wireType)
			}
			m.AtoDeadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtoDeadline |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10028:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoDeadline", wireType)
			}
			m.RtoDeadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtoDeadline |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10029:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcFlags", wireType)
			}
			m.CcFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CcFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10030:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaDeadline", wireType)
			}
			m.KeepaDeadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaDeadline |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10031:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFullCnt", wireType)
			}
			m.WindowFullCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowFullCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10032:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqRx2TxPi", wireType)
			}
			m.OoqRx2TxPi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OoqRx2TxPi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10033:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OoqRx2TxCi", wireType)
			}
			m.OoqRx2TxCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OoqRx2TxCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10034:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetxCnt", wireType)
			}
			m.RetxCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetxCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10035:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowUpdatePi", wireType)
			}
			m.WindowUpdatePi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowUpdatePi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10036:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowUpdateCi", wireType)
			}
			m.WindowUpdateCi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowUpdateCi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10037:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxWindowUpdatePi", wireType)
			}
			m.TxWindowUpdatePi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxWindowUpdatePi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TcpCbSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TcpCbStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TcpCbStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpCbGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpCbGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpCbGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &TcpCbResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTracerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTracerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTracerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPC = append(m.VPC[:0], dAtA[iNdEx:postIndex]...)
			if m.VPC == nil {
				m.VPC = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcAddr == nil {
				m.SrcAddr = &IPAddress{}
			}
			if err := m.SrcAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAddr == nil {
				m.DstAddr = &IPAddress{}
			}
			if err := m.DstAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcTep == nil {
				m.SrcTep = &IPAddress{}
			}
			if err := m.SrcTep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProto", wireType)
			}
			m.IPProto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProto |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4Info == nil {
				m.L4Info = &FlowL4Info{}
			}
			if err := m.L4Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayDstMAC", wireType)
			}
			m.OverlayDstMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlayDstMAC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlaySrcMAC", wireType)
			}
			m.OverlaySrcMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlaySrcMAC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTracerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTracerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTracerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FlowTracerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTracerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTracerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTracerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPC = append(m.VPC[:0], dAtA[iNdEx:postIndex]...)
			if m.VPC == nil {
				m.VPC = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vnic = append(m.Vnic[:0], dAtA[iNdEx:postIndex]...)
			if m.Vnic == nil {
				m.Vnic = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityRule", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityRule = append(m.SecurityRule[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityRule == nil {
				m.SecurityRule = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityPolicy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityPolicy = append(m.SecurityPolicy[:0], dAtA[iNdEx:postIndex]...)
			if m.SecurityPolicy == nil {
				m.SecurityPolicy = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcMapping", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SvcMapping = append(m.SvcMapping[:0], dAtA[iNdEx:postIndex]...)
			if m.SvcMapping == nil {
				m.SvcMapping = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressSubnet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressSubnet = append(m.IngressSubnet[:0], dAtA[iNdEx:postIndex]...)
			if m.IngressSubnet == nil {
				m.IngressSubnet = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressSubnet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressSubnet = append(m.EgressSubnet[:0], dAtA[iNdEx:postIndex]...)
			if m.EgressSubnet == nil {
				m.EgressSubnet = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterClass", wireType)
			}
			m.MeterClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterClass |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteClassPriority", wireType)
			}
			m.RouteClassPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteClassPriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= SecurityRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowHit = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MappingHit = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRuleHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultRuleHit = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstTep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstTep == nil {
				m.DstTep = &IPAddress{}
			}
			if err := m.DstTep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropReason = append(m.DropReason, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTracerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTracerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTracerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FlowTracerStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MPUPerfInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MPUPerfInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MPUPerfInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Utilization", wireType)
			}
			m.Utilization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Utilization |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CPI = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineStagePerfInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineStagePerfInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineStagePerfInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPUPerf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MPUPerf = append(m.MPUPerf, &MPUPerfInfo{})
			if err := m.MPUPerf[len(m.MPUPerf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelinePerfInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelinePerfInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelinePerfInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			m.Pipeline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pipeline |= Pipeline(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PHVs", wireType)
			}
			m.PHVs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PHVs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drops", wireType)
			}
			m.Drops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Drops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recircs", wireType)
			}
			m.Recircs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recircs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsFromPB", wireType)
			}
			m.PacketsFromPB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsFromPB |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserDrops", wireType)
			}
			m.ParserDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParserDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StagePerf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StagePerf = append(m.StagePerf, &PipelineStagePerfInfo{})
			if err := m.StagePerf[len(m.StagePerf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DDRPerfInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDRPerfInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDRPerfInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reads", wireType)
			}
			m.Reads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reads |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadLatencyMax", wireType)
			}
			m.ReadLatencyMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadLatencyMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadLatencyAvg", wireType)
			}
			m.ReadLatencyAvg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadLatencyAvg |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMTPS", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReadMTPS = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBandwidth", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReadBandwidth = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writes", wireType)
			}
			m.Writes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Writes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteLatencyMax", wireType)
			}
			m.WriteLatencyMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteLatencyMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteLatencyAvg", wireType)
			}
			m.WriteLatencyAvg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteLatencyAvg |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMTPS", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WriteMTPS = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBandwidth", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WriteBandwidth = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsicPerfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsicPerfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsicPerfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDRPerfInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DDRPerfInfo = append(m.DDRPerfInfo, &DDRPerfInfo{})
			if err := m.DDRPerfInfo[len(m.DDRPerfInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelinePerfInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelinePerfInfo = append(m.PipelinePerfInfo, &PipelinePerfInfo{})
			if err := m.PipelinePerfInfo[len(m.PipelinePerfInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaclRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaclRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunneledPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunneledPacket = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowMiss = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalMappingUnknown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalMappingUnknown = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPFragment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IPFragment = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= NaclRequest_PacketDir(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcLif", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.LifMatch = &NaclRequest_SrcLif{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcLifType", wireType)
			}
			var v LifType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= LifType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LifMatch = &NaclRequest_SrcLifType{v}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaclRequest_L2PacketMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchFields = &NaclRequest_L2Match{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaclRequest_IPPacketMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchFields = &NaclRequest_IPMatch{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Action = &NaclRequest_Drop{b}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectLifId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Action = &NaclRequest_RedirectLifId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_L2PacketMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2PacketMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2PacketMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPProtocolMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPProtocolMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPProtocolMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPPacketMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPPacketMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPrefix == nil {
				m.SrcPrefix = &IPPrefix{}
			}
			if err := m.SrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPrefix == nil {
				m.DstPrefix = &IPPrefix{}
			}
			if err := m.DstPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPProto == nil {
				m.IPProto = &NaclRequest_IPProtocolMatch{}
			}
			if err := m.IPProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUdpMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaclRequest_IPPacketMatch_TCPUDPMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Match = &NaclRequest_IPPacketMatch_TcpUdpMatch{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NaclRequest_IPPacketMatch_ICMPMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Match = &NaclRequest_IPPacketMatch_IcmpMatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPUDPMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPUDPMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPort == nil {
				m.SrcPort = &NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch{}
			}
			if err := m.SrcPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPort == nil {
				m.DstPort = &NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch{}
			}
			if err := m.DstPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch_TCPUDPMatch_PortMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &NaclRequest_IPPacketMatch_ICMPMatch_ICMPType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Code == nil {
				m.Code = &NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode{}
			}
			if err := m.Code.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclRequest_IPPacketMatch_ICMPMatch_ICMPCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaclResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaclResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaclDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaclDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NaclDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NaclDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NaclDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PthreadId", wireType)
			}
			m.PthreadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PthreadId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedPolicy", wireType)
			}
			m.SchedPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedPolicy |= SchedPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ThreadRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Running", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Running = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartBeatTime", wireType)
			}
			m.LastHeartBeatTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartBeatTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Thread) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Thread: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Thread: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ThreadSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ThreadStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ThreadStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Thread{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebug(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDebug
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDebug
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDebug(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDebug
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDebug = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebug   = fmt.Errorf("proto: integer overflow")
)
