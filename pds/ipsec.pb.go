// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipsec.proto

package pds

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IPSec protocols
type IpsecProtocol int32

const (
	IpsecProtocol_IPSEC_PROTOCOL_NONE IpsecProtocol = 0
	IpsecProtocol_IPSEC_PROTOCOL_AH   IpsecProtocol = 1
	IpsecProtocol_IPSEC_PROTOCOL_ESP  IpsecProtocol = 2
)

var IpsecProtocol_name = map[int32]string{
	0: "IPSEC_PROTOCOL_NONE",
	1: "IPSEC_PROTOCOL_AH",
	2: "IPSEC_PROTOCOL_ESP",
}

var IpsecProtocol_value = map[string]int32{
	"IPSEC_PROTOCOL_NONE": 0,
	"IPSEC_PROTOCOL_AH":   1,
	"IPSEC_PROTOCOL_ESP":  2,
}

func (x IpsecProtocol) String() string {
	return proto.EnumName(IpsecProtocol_name, int32(x))
}

func (IpsecProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{0}
}

// Encryption algorithms
type EncryptionAlgorithm int32

const (
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE        EncryptionAlgorithm = 0
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_GCM_128 EncryptionAlgorithm = 1
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_GCM_256 EncryptionAlgorithm = 2
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_128 EncryptionAlgorithm = 3
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_192 EncryptionAlgorithm = 4
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CCM_256 EncryptionAlgorithm = 5
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_128 EncryptionAlgorithm = 6
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_192 EncryptionAlgorithm = 7
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_AES_CBC_256 EncryptionAlgorithm = 8
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_DES3        EncryptionAlgorithm = 9
	EncryptionAlgorithm_ENCRYPTION_ALGORITHM_CHA_CHA     EncryptionAlgorithm = 10
)

var EncryptionAlgorithm_name = map[int32]string{
	0:  "ENCRYPTION_ALGORITHM_NONE",
	1:  "ENCRYPTION_ALGORITHM_AES_GCM_128",
	2:  "ENCRYPTION_ALGORITHM_AES_GCM_256",
	3:  "ENCRYPTION_ALGORITHM_AES_CCM_128",
	4:  "ENCRYPTION_ALGORITHM_AES_CCM_192",
	5:  "ENCRYPTION_ALGORITHM_AES_CCM_256",
	6:  "ENCRYPTION_ALGORITHM_AES_CBC_128",
	7:  "ENCRYPTION_ALGORITHM_AES_CBC_192",
	8:  "ENCRYPTION_ALGORITHM_AES_CBC_256",
	9:  "ENCRYPTION_ALGORITHM_DES3",
	10: "ENCRYPTION_ALGORITHM_CHA_CHA",
}

var EncryptionAlgorithm_value = map[string]int32{
	"ENCRYPTION_ALGORITHM_NONE":        0,
	"ENCRYPTION_ALGORITHM_AES_GCM_128": 1,
	"ENCRYPTION_ALGORITHM_AES_GCM_256": 2,
	"ENCRYPTION_ALGORITHM_AES_CCM_128": 3,
	"ENCRYPTION_ALGORITHM_AES_CCM_192": 4,
	"ENCRYPTION_ALGORITHM_AES_CCM_256": 5,
	"ENCRYPTION_ALGORITHM_AES_CBC_128": 6,
	"ENCRYPTION_ALGORITHM_AES_CBC_192": 7,
	"ENCRYPTION_ALGORITHM_AES_CBC_256": 8,
	"ENCRYPTION_ALGORITHM_DES3":        9,
	"ENCRYPTION_ALGORITHM_CHA_CHA":     10,
}

func (x EncryptionAlgorithm) String() string {
	return proto.EnumName(EncryptionAlgorithm_name, int32(x))
}

func (EncryptionAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{1}
}

// Authentication algorithms
type AuthenticationAlgorithm int32

const (
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE        AuthenticationAlgorithm = 0
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_AES_GCM     AuthenticationAlgorithm = 1
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_AES_CCM     AuthenticationAlgorithm = 2
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_HMAC        AuthenticationAlgorithm = 3
	AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_AES_CBC_SHA AuthenticationAlgorithm = 4
)

var AuthenticationAlgorithm_name = map[int32]string{
	0: "AUTHENTICATION_ALGORITHM_NONE",
	1: "AUTHENTICATION_ALGORITHM_AES_GCM",
	2: "AUTHENTICATION_ALGORITHM_AES_CCM",
	3: "AUTHENTICATION_ALGORITHM_HMAC",
	4: "AUTHENTICATION_ALGORITHM_AES_CBC_SHA",
}

var AuthenticationAlgorithm_value = map[string]int32{
	"AUTHENTICATION_ALGORITHM_NONE":        0,
	"AUTHENTICATION_ALGORITHM_AES_GCM":     1,
	"AUTHENTICATION_ALGORITHM_AES_CCM":     2,
	"AUTHENTICATION_ALGORITHM_HMAC":        3,
	"AUTHENTICATION_ALGORITHM_AES_CBC_SHA": 4,
}

func (x AuthenticationAlgorithm) String() string {
	return proto.EnumName(AuthenticationAlgorithm_name, int32(x))
}

func (AuthenticationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{2}
}

// Key object
type SymmetricKey struct {
	// Types that are valid to be assigned to KeyInfo:
	//	*SymmetricKey_Key
	//	*SymmetricKey_KeyLocation
	KeyInfo              isSymmetricKey_KeyInfo `protobuf_oneof:"key_info"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SymmetricKey) Reset()         { *m = SymmetricKey{} }
func (m *SymmetricKey) String() string { return proto.CompactTextString(m) }
func (*SymmetricKey) ProtoMessage()    {}
func (*SymmetricKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{0}
}
func (m *SymmetricKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SymmetricKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SymmetricKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SymmetricKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymmetricKey.Merge(m, src)
}
func (m *SymmetricKey) XXX_Size() int {
	return m.Size()
}
func (m *SymmetricKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SymmetricKey.DiscardUnknown(m)
}

var xxx_messageInfo_SymmetricKey proto.InternalMessageInfo

type isSymmetricKey_KeyInfo interface {
	isSymmetricKey_KeyInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SymmetricKey_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=Key,proto3,oneof"`
}
type SymmetricKey_KeyLocation struct {
	KeyLocation uint32 `protobuf:"varint,2,opt,name=KeyLocation,proto3,oneof"`
}

func (*SymmetricKey_Key) isSymmetricKey_KeyInfo()         {}
func (*SymmetricKey_KeyLocation) isSymmetricKey_KeyInfo() {}

func (m *SymmetricKey) GetKeyInfo() isSymmetricKey_KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *SymmetricKey) GetKey() []byte {
	if x, ok := m.GetKeyInfo().(*SymmetricKey_Key); ok {
		return x.Key
	}
	return nil
}

func (m *SymmetricKey) GetKeyLocation() uint32 {
	if x, ok := m.GetKeyInfo().(*SymmetricKey_KeyLocation); ok {
		return x.KeyLocation
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SymmetricKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SymmetricKey_Key)(nil),
		(*SymmetricKey_KeyLocation)(nil),
	}
}

// IPSec Security Association object
type IpsecSAEncryptSpec struct {
	// unique identifier of SA
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// ESP or AH
	Protocol IpsecProtocol `protobuf:"varint,2,opt,name=Protocol,proto3,enum=pds.IpsecProtocol" json:"Protocol,omitempty"`
	// authentication algorithm
	AuthenticationAlgorithm AuthenticationAlgorithm `protobuf:"varint,3,opt,name=AuthenticationAlgorithm,proto3,enum=pds.AuthenticationAlgorithm" json:"AuthenticationAlgorithm,omitempty"`
	// authenticaion key
	AuthenticationKey *SymmetricKey `protobuf:"bytes,4,opt,name=AuthenticationKey,proto3" json:"AuthenticationKey,omitempty"`
	// encryption algorithm
	EncryptionAlgorithm EncryptionAlgorithm `protobuf:"varint,5,opt,name=EncryptionAlgorithm,proto3,enum=pds.EncryptionAlgorithm" json:"EncryptionAlgorithm,omitempty"`
	// encryption key
	EncryptionKey *SymmetricKey `protobuf:"bytes,6,opt,name=EncryptionKey,proto3" json:"EncryptionKey,omitempty"`
	// security parameters index
	Spi uint32 `protobuf:"varint,7,opt,name=Spi,proto3" json:"Spi,omitempty"`
	// NAT-T port, if non-zero - NAT-T header is added.
	NatTraversalPort uint32 `protobuf:"varint,8,opt,name=NatTraversalPort,proto3" json:"NatTraversalPort,omitempty"`
	// Initial Random number - 32 bits (need to be same on peer)
	Salt uint32 `protobuf:"varint,9,opt,name=Salt,proto3" json:"Salt,omitempty"`
	// Initial Random number that goes in packet - can be assigned from top or generated locally
	Iv                   uint64   `protobuf:"varint,10,opt,name=Iv,proto3" json:"Iv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSAEncryptSpec) Reset()         { *m = IpsecSAEncryptSpec{} }
func (m *IpsecSAEncryptSpec) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptSpec) ProtoMessage()    {}
func (*IpsecSAEncryptSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{1}
}
func (m *IpsecSAEncryptSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptSpec.Merge(m, src)
}
func (m *IpsecSAEncryptSpec) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptSpec proto.InternalMessageInfo

func (m *IpsecSAEncryptSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *IpsecSAEncryptSpec) GetProtocol() IpsecProtocol {
	if m != nil {
		return m.Protocol
	}
	return IpsecProtocol_IPSEC_PROTOCOL_NONE
}

func (m *IpsecSAEncryptSpec) GetAuthenticationAlgorithm() AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgorithm
	}
	return AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE
}

func (m *IpsecSAEncryptSpec) GetAuthenticationKey() *SymmetricKey {
	if m != nil {
		return m.AuthenticationKey
	}
	return nil
}

func (m *IpsecSAEncryptSpec) GetEncryptionAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSAEncryptSpec) GetEncryptionKey() *SymmetricKey {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *IpsecSAEncryptSpec) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *IpsecSAEncryptSpec) GetNatTraversalPort() uint32 {
	if m != nil {
		return m.NatTraversalPort
	}
	return 0
}

func (m *IpsecSAEncryptSpec) GetSalt() uint32 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *IpsecSAEncryptSpec) GetIv() uint64 {
	if m != nil {
		return m.Iv
	}
	return 0
}

// operational status of IPSec Encrypt SA, if any
type IpsecSAEncryptStatus struct {
	KeyIndex             uint32   `protobuf:"varint,1,opt,name=KeyIndex,proto3" json:"KeyIndex,omitempty"`
	SeqNo                uint64   `protobuf:"varint,2,opt,name=SeqNo,proto3" json:"SeqNo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSAEncryptStatus) Reset()         { *m = IpsecSAEncryptStatus{} }
func (m *IpsecSAEncryptStatus) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptStatus) ProtoMessage()    {}
func (*IpsecSAEncryptStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{2}
}
func (m *IpsecSAEncryptStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptStatus.Merge(m, src)
}
func (m *IpsecSAEncryptStatus) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptStatus.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptStatus proto.InternalMessageInfo

func (m *IpsecSAEncryptStatus) GetKeyIndex() uint32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

func (m *IpsecSAEncryptStatus) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

// stats of IPSec Encrypt SA, if any
type IpsecSAEncryptStats struct {
	RxPkts               uint64   `protobuf:"varint,1,opt,name=RxPkts,proto3" json:"RxPkts,omitempty"`
	RxBytes              uint64   `protobuf:"varint,2,opt,name=RxBytes,proto3" json:"RxBytes,omitempty"`
	TxPkts               uint64   `protobuf:"varint,3,opt,name=TxPkts,proto3" json:"TxPkts,omitempty"`
	TxBytes              uint64   `protobuf:"varint,4,opt,name=TxBytes,proto3" json:"TxBytes,omitempty"`
	RxDrops              uint64   `protobuf:"varint,5,opt,name=RxDrops,proto3" json:"RxDrops,omitempty"`
	TxDrops              uint64   `protobuf:"varint,6,opt,name=TxDrops,proto3" json:"TxDrops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSAEncryptStats) Reset()         { *m = IpsecSAEncryptStats{} }
func (m *IpsecSAEncryptStats) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptStats) ProtoMessage()    {}
func (*IpsecSAEncryptStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{3}
}
func (m *IpsecSAEncryptStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptStats.Merge(m, src)
}
func (m *IpsecSAEncryptStats) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptStats) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptStats.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptStats proto.InternalMessageInfo

func (m *IpsecSAEncryptStats) GetRxPkts() uint64 {
	if m != nil {
		return m.RxPkts
	}
	return 0
}

func (m *IpsecSAEncryptStats) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *IpsecSAEncryptStats) GetTxPkts() uint64 {
	if m != nil {
		return m.TxPkts
	}
	return 0
}

func (m *IpsecSAEncryptStats) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *IpsecSAEncryptStats) GetRxDrops() uint64 {
	if m != nil {
		return m.RxDrops
	}
	return 0
}

func (m *IpsecSAEncryptStats) GetTxDrops() uint64 {
	if m != nil {
		return m.TxDrops
	}
	return 0
}

// IPSec Encrypt SA object
type IpsecSAEncrypt struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *IpsecSAEncryptSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *IpsecSAEncryptStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *IpsecSAEncryptStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IpsecSAEncrypt) Reset()         { *m = IpsecSAEncrypt{} }
func (m *IpsecSAEncrypt) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncrypt) ProtoMessage()    {}
func (*IpsecSAEncrypt) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{4}
}
func (m *IpsecSAEncrypt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncrypt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncrypt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncrypt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncrypt.Merge(m, src)
}
func (m *IpsecSAEncrypt) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncrypt) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncrypt.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncrypt proto.InternalMessageInfo

func (m *IpsecSAEncrypt) GetSpec() *IpsecSAEncryptSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IpsecSAEncrypt) GetStatus() *IpsecSAEncryptStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *IpsecSAEncrypt) GetStats() *IpsecSAEncryptStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// IPSec SA Encrypt create and update request
type IpsecSAEncryptRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt            `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*IpsecSAEncryptSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IpsecSAEncryptRequest) Reset()         { *m = IpsecSAEncryptRequest{} }
func (m *IpsecSAEncryptRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptRequest) ProtoMessage()    {}
func (*IpsecSAEncryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{5}
}
func (m *IpsecSAEncryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptRequest.Merge(m, src)
}
func (m *IpsecSAEncryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptRequest proto.InternalMessageInfo

func (m *IpsecSAEncryptRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *IpsecSAEncryptRequest) GetRequest() []*IpsecSAEncryptSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// IPSec SA Encrypt create and update response
type IpsecSAEncryptResponse struct {
	ApiStatus            ApiStatus               `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*IpsecSAEncryptStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *IpsecSAEncryptResponse) Reset()         { *m = IpsecSAEncryptResponse{} }
func (m *IpsecSAEncryptResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptResponse) ProtoMessage()    {}
func (*IpsecSAEncryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{6}
}
func (m *IpsecSAEncryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptResponse.Merge(m, src)
}
func (m *IpsecSAEncryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptResponse proto.InternalMessageInfo

func (m *IpsecSAEncryptResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSAEncryptResponse) GetResponse() []*IpsecSAEncryptStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// IPSec SA Encrypt get request
type IpsecSAEncryptGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSAEncryptGetRequest) Reset()         { *m = IpsecSAEncryptGetRequest{} }
func (m *IpsecSAEncryptGetRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptGetRequest) ProtoMessage()    {}
func (*IpsecSAEncryptGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{7}
}
func (m *IpsecSAEncryptGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptGetRequest.Merge(m, src)
}
func (m *IpsecSAEncryptGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptGetRequest proto.InternalMessageInfo

func (m *IpsecSAEncryptGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// IPSec SA Encrypt get response
type IpsecSAEncryptGetResponse struct {
	ApiStatus            ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*IpsecSAEncrypt `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IpsecSAEncryptGetResponse) Reset()         { *m = IpsecSAEncryptGetResponse{} }
func (m *IpsecSAEncryptGetResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptGetResponse) ProtoMessage()    {}
func (*IpsecSAEncryptGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{8}
}
func (m *IpsecSAEncryptGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptGetResponse.Merge(m, src)
}
func (m *IpsecSAEncryptGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptGetResponse proto.InternalMessageInfo

func (m *IpsecSAEncryptGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSAEncryptGetResponse) GetResponse() []*IpsecSAEncrypt {
	if m != nil {
		return m.Response
	}
	return nil
}

// IPSec SA Encrypt delete request
type IpsecSAEncryptDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IpsecSAEncryptDeleteRequest) Reset()         { *m = IpsecSAEncryptDeleteRequest{} }
func (m *IpsecSAEncryptDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptDeleteRequest) ProtoMessage()    {}
func (*IpsecSAEncryptDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{9}
}
func (m *IpsecSAEncryptDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptDeleteRequest.Merge(m, src)
}
func (m *IpsecSAEncryptDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptDeleteRequest proto.InternalMessageInfo

func (m *IpsecSAEncryptDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *IpsecSAEncryptDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// IPSec SA Encrypt delete response
type IpsecSAEncryptDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IpsecSAEncryptDeleteResponse) Reset()         { *m = IpsecSAEncryptDeleteResponse{} }
func (m *IpsecSAEncryptDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSAEncryptDeleteResponse) ProtoMessage()    {}
func (*IpsecSAEncryptDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{10}
}
func (m *IpsecSAEncryptDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSAEncryptDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSAEncryptDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSAEncryptDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSAEncryptDeleteResponse.Merge(m, src)
}
func (m *IpsecSAEncryptDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSAEncryptDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSAEncryptDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSAEncryptDeleteResponse proto.InternalMessageInfo

func (m *IpsecSAEncryptDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// IPSec Security Association object
type IpsecSADecryptSpec struct {
	// unique identifier of SA
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// ESP or AH
	Protocol IpsecProtocol `protobuf:"varint,2,opt,name=Protocol,proto3,enum=pds.IpsecProtocol" json:"Protocol,omitempty"`
	// authentication algorithm
	AuthenticationAlgorithm AuthenticationAlgorithm `protobuf:"varint,3,opt,name=AuthenticationAlgorithm,proto3,enum=pds.AuthenticationAlgorithm" json:"AuthenticationAlgorithm,omitempty"`
	// authenticaion key
	AuthenticationKey *SymmetricKey `protobuf:"bytes,4,opt,name=AuthenticationKey,proto3" json:"AuthenticationKey,omitempty"`
	// encryption algorithm
	DecryptionAlgorithm EncryptionAlgorithm `protobuf:"varint,5,opt,name=DecryptionAlgorithm,proto3,enum=pds.EncryptionAlgorithm" json:"DecryptionAlgorithm,omitempty"`
	// encryption algorithm
	RekeyDecAlgorithm EncryptionAlgorithm `protobuf:"varint,6,opt,name=RekeyDecAlgorithm,proto3,enum=pds.EncryptionAlgorithm" json:"RekeyDecAlgorithm,omitempty"`
	// encryption key
	DecryptionKey *SymmetricKey `protobuf:"bytes,7,opt,name=DecryptionKey,proto3" json:"DecryptionKey,omitempty"`
	// authentication key
	RekeyAuthenticationKey *SymmetricKey `protobuf:"bytes,8,opt,name=RekeyAuthenticationKey,proto3" json:"RekeyAuthenticationKey,omitempty"`
	// encryption key
	RekeyDecryptionKey *SymmetricKey `protobuf:"bytes,9,opt,name=RekeyDecryptionKey,proto3" json:"RekeyDecryptionKey,omitempty"`
	// security parameters index
	Spi uint32 `protobuf:"varint,10,opt,name=Spi,proto3" json:"Spi,omitempty"`
	// valid when rekey is active, part of update
	RekeySpi uint32 `protobuf:"varint,11,opt,name=RekeySpi,proto3" json:"RekeySpi,omitempty"`
	// initial Random number - 32 bits (need to be same on peer)
	Salt                 uint32   `protobuf:"varint,12,opt,name=Salt,proto3" json:"Salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSADecryptSpec) Reset()         { *m = IpsecSADecryptSpec{} }
func (m *IpsecSADecryptSpec) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptSpec) ProtoMessage()    {}
func (*IpsecSADecryptSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{11}
}
func (m *IpsecSADecryptSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptSpec.Merge(m, src)
}
func (m *IpsecSADecryptSpec) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptSpec proto.InternalMessageInfo

func (m *IpsecSADecryptSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *IpsecSADecryptSpec) GetProtocol() IpsecProtocol {
	if m != nil {
		return m.Protocol
	}
	return IpsecProtocol_IPSEC_PROTOCOL_NONE
}

func (m *IpsecSADecryptSpec) GetAuthenticationAlgorithm() AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgorithm
	}
	return AuthenticationAlgorithm_AUTHENTICATION_ALGORITHM_NONE
}

func (m *IpsecSADecryptSpec) GetAuthenticationKey() *SymmetricKey {
	if m != nil {
		return m.AuthenticationKey
	}
	return nil
}

func (m *IpsecSADecryptSpec) GetDecryptionAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.DecryptionAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSADecryptSpec) GetRekeyDecAlgorithm() EncryptionAlgorithm {
	if m != nil {
		return m.RekeyDecAlgorithm
	}
	return EncryptionAlgorithm_ENCRYPTION_ALGORITHM_NONE
}

func (m *IpsecSADecryptSpec) GetDecryptionKey() *SymmetricKey {
	if m != nil {
		return m.DecryptionKey
	}
	return nil
}

func (m *IpsecSADecryptSpec) GetRekeyAuthenticationKey() *SymmetricKey {
	if m != nil {
		return m.RekeyAuthenticationKey
	}
	return nil
}

func (m *IpsecSADecryptSpec) GetRekeyDecryptionKey() *SymmetricKey {
	if m != nil {
		return m.RekeyDecryptionKey
	}
	return nil
}

func (m *IpsecSADecryptSpec) GetSpi() uint32 {
	if m != nil {
		return m.Spi
	}
	return 0
}

func (m *IpsecSADecryptSpec) GetRekeySpi() uint32 {
	if m != nil {
		return m.RekeySpi
	}
	return 0
}

func (m *IpsecSADecryptSpec) GetSalt() uint32 {
	if m != nil {
		return m.Salt
	}
	return 0
}

// operational status of IPSec Decrypt SA, if any
type IpsecSADecryptStatus struct {
	KeyIndex             uint32   `protobuf:"varint,1,opt,name=KeyIndex,proto3" json:"KeyIndex,omitempty"`
	NewKeyIndex          uint32   `protobuf:"varint,2,opt,name=NewKeyIndex,proto3" json:"NewKeyIndex,omitempty"`
	RekeyActive          uint32   `protobuf:"varint,3,opt,name=RekeyActive,proto3" json:"RekeyActive,omitempty"`
	SeqNo                uint64   `protobuf:"varint,4,opt,name=SeqNo,proto3" json:"SeqNo,omitempty"`
	SeqNoBmp             uint64   `protobuf:"varint,5,opt,name=SeqNoBmp,proto3" json:"SeqNoBmp,omitempty"`
	LastReplaySeqNo      uint64   `protobuf:"varint,6,opt,name=LastReplaySeqNo,proto3" json:"LastReplaySeqNo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSADecryptStatus) Reset()         { *m = IpsecSADecryptStatus{} }
func (m *IpsecSADecryptStatus) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptStatus) ProtoMessage()    {}
func (*IpsecSADecryptStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{12}
}
func (m *IpsecSADecryptStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptStatus.Merge(m, src)
}
func (m *IpsecSADecryptStatus) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptStatus.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptStatus proto.InternalMessageInfo

func (m *IpsecSADecryptStatus) GetKeyIndex() uint32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

func (m *IpsecSADecryptStatus) GetNewKeyIndex() uint32 {
	if m != nil {
		return m.NewKeyIndex
	}
	return 0
}

func (m *IpsecSADecryptStatus) GetRekeyActive() uint32 {
	if m != nil {
		return m.RekeyActive
	}
	return 0
}

func (m *IpsecSADecryptStatus) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *IpsecSADecryptStatus) GetSeqNoBmp() uint64 {
	if m != nil {
		return m.SeqNoBmp
	}
	return 0
}

func (m *IpsecSADecryptStatus) GetLastReplaySeqNo() uint64 {
	if m != nil {
		return m.LastReplaySeqNo
	}
	return 0
}

// stats of IPSec Decrypt SA, if any
type IpsecSADecryptStats struct {
	RxPkts               uint64   `protobuf:"varint,1,opt,name=RxPkts,proto3" json:"RxPkts,omitempty"`
	RxBytes              uint64   `protobuf:"varint,2,opt,name=RxBytes,proto3" json:"RxBytes,omitempty"`
	TxPkts               uint64   `protobuf:"varint,3,opt,name=TxPkts,proto3" json:"TxPkts,omitempty"`
	TxBytes              uint64   `protobuf:"varint,4,opt,name=TxBytes,proto3" json:"TxBytes,omitempty"`
	RxDrops              uint64   `protobuf:"varint,5,opt,name=RxDrops,proto3" json:"RxDrops,omitempty"`
	TxDrops              uint64   `protobuf:"varint,6,opt,name=TxDrops,proto3" json:"TxDrops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSADecryptStats) Reset()         { *m = IpsecSADecryptStats{} }
func (m *IpsecSADecryptStats) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptStats) ProtoMessage()    {}
func (*IpsecSADecryptStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{13}
}
func (m *IpsecSADecryptStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptStats.Merge(m, src)
}
func (m *IpsecSADecryptStats) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptStats) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptStats.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptStats proto.InternalMessageInfo

func (m *IpsecSADecryptStats) GetRxPkts() uint64 {
	if m != nil {
		return m.RxPkts
	}
	return 0
}

func (m *IpsecSADecryptStats) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *IpsecSADecryptStats) GetTxPkts() uint64 {
	if m != nil {
		return m.TxPkts
	}
	return 0
}

func (m *IpsecSADecryptStats) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *IpsecSADecryptStats) GetRxDrops() uint64 {
	if m != nil {
		return m.RxDrops
	}
	return 0
}

func (m *IpsecSADecryptStats) GetTxDrops() uint64 {
	if m != nil {
		return m.TxDrops
	}
	return 0
}

// IPSec Decrypt SA object
type IpsecSADecrypt struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *IpsecSADecryptSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *IpsecSADecryptStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *IpsecSADecryptStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IpsecSADecrypt) Reset()         { *m = IpsecSADecrypt{} }
func (m *IpsecSADecrypt) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecrypt) ProtoMessage()    {}
func (*IpsecSADecrypt) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{14}
}
func (m *IpsecSADecrypt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecrypt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecrypt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecrypt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecrypt.Merge(m, src)
}
func (m *IpsecSADecrypt) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecrypt) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecrypt.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecrypt proto.InternalMessageInfo

func (m *IpsecSADecrypt) GetSpec() *IpsecSADecryptSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IpsecSADecrypt) GetStatus() *IpsecSADecryptStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *IpsecSADecrypt) GetStats() *IpsecSADecryptStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// IPSec SA Decrypt create and update request
type IpsecSADecryptRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt            `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Request              []*IpsecSADecryptSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IpsecSADecryptRequest) Reset()         { *m = IpsecSADecryptRequest{} }
func (m *IpsecSADecryptRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptRequest) ProtoMessage()    {}
func (*IpsecSADecryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{15}
}
func (m *IpsecSADecryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptRequest.Merge(m, src)
}
func (m *IpsecSADecryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptRequest proto.InternalMessageInfo

func (m *IpsecSADecryptRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *IpsecSADecryptRequest) GetRequest() []*IpsecSADecryptSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// IPSec SA Decrypt create and update response
type IpsecSADecryptResponse struct {
	ApiStatus            ApiStatus               `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*IpsecSADecryptStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *IpsecSADecryptResponse) Reset()         { *m = IpsecSADecryptResponse{} }
func (m *IpsecSADecryptResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptResponse) ProtoMessage()    {}
func (*IpsecSADecryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{16}
}
func (m *IpsecSADecryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptResponse.Merge(m, src)
}
func (m *IpsecSADecryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptResponse proto.InternalMessageInfo

func (m *IpsecSADecryptResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSADecryptResponse) GetResponse() []*IpsecSADecryptStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// IPSec SA Decrypt get request
type IpsecSADecryptGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpsecSADecryptGetRequest) Reset()         { *m = IpsecSADecryptGetRequest{} }
func (m *IpsecSADecryptGetRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptGetRequest) ProtoMessage()    {}
func (*IpsecSADecryptGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{17}
}
func (m *IpsecSADecryptGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptGetRequest.Merge(m, src)
}
func (m *IpsecSADecryptGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptGetRequest proto.InternalMessageInfo

func (m *IpsecSADecryptGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// IPSec SA Decrypt get response
type IpsecSADecryptGetResponse struct {
	ApiStatus            ApiStatus         `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*IpsecSADecrypt `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IpsecSADecryptGetResponse) Reset()         { *m = IpsecSADecryptGetResponse{} }
func (m *IpsecSADecryptGetResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptGetResponse) ProtoMessage()    {}
func (*IpsecSADecryptGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{18}
}
func (m *IpsecSADecryptGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptGetResponse.Merge(m, src)
}
func (m *IpsecSADecryptGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptGetResponse proto.InternalMessageInfo

func (m *IpsecSADecryptGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *IpsecSADecryptGetResponse) GetResponse() []*IpsecSADecrypt {
	if m != nil {
		return m.Response
	}
	return nil
}

// IPSec SA Decrypt delete request
type IpsecSADecryptDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IpsecSADecryptDeleteRequest) Reset()         { *m = IpsecSADecryptDeleteRequest{} }
func (m *IpsecSADecryptDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptDeleteRequest) ProtoMessage()    {}
func (*IpsecSADecryptDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{19}
}
func (m *IpsecSADecryptDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptDeleteRequest.Merge(m, src)
}
func (m *IpsecSADecryptDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptDeleteRequest proto.InternalMessageInfo

func (m *IpsecSADecryptDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *IpsecSADecryptDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// IPSec SA Decrypt delete response
type IpsecSADecryptDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IpsecSADecryptDeleteResponse) Reset()         { *m = IpsecSADecryptDeleteResponse{} }
func (m *IpsecSADecryptDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*IpsecSADecryptDeleteResponse) ProtoMessage()    {}
func (*IpsecSADecryptDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a27ac5c58e1b0f, []int{20}
}
func (m *IpsecSADecryptDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecSADecryptDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpsecSADecryptDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpsecSADecryptDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecSADecryptDeleteResponse.Merge(m, src)
}
func (m *IpsecSADecryptDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *IpsecSADecryptDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecSADecryptDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecSADecryptDeleteResponse proto.InternalMessageInfo

func (m *IpsecSADecryptDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.IpsecProtocol", IpsecProtocol_name, IpsecProtocol_value)
	proto.RegisterEnum("pds.EncryptionAlgorithm", EncryptionAlgorithm_name, EncryptionAlgorithm_value)
	proto.RegisterEnum("pds.AuthenticationAlgorithm", AuthenticationAlgorithm_name, AuthenticationAlgorithm_value)
	proto.RegisterType((*SymmetricKey)(nil), "pds.SymmetricKey")
	proto.RegisterType((*IpsecSAEncryptSpec)(nil), "pds.IpsecSAEncryptSpec")
	proto.RegisterType((*IpsecSAEncryptStatus)(nil), "pds.IpsecSAEncryptStatus")
	proto.RegisterType((*IpsecSAEncryptStats)(nil), "pds.IpsecSAEncryptStats")
	proto.RegisterType((*IpsecSAEncrypt)(nil), "pds.IpsecSAEncrypt")
	proto.RegisterType((*IpsecSAEncryptRequest)(nil), "pds.IpsecSAEncryptRequest")
	proto.RegisterType((*IpsecSAEncryptResponse)(nil), "pds.IpsecSAEncryptResponse")
	proto.RegisterType((*IpsecSAEncryptGetRequest)(nil), "pds.IpsecSAEncryptGetRequest")
	proto.RegisterType((*IpsecSAEncryptGetResponse)(nil), "pds.IpsecSAEncryptGetResponse")
	proto.RegisterType((*IpsecSAEncryptDeleteRequest)(nil), "pds.IpsecSAEncryptDeleteRequest")
	proto.RegisterType((*IpsecSAEncryptDeleteResponse)(nil), "pds.IpsecSAEncryptDeleteResponse")
	proto.RegisterType((*IpsecSADecryptSpec)(nil), "pds.IpsecSADecryptSpec")
	proto.RegisterType((*IpsecSADecryptStatus)(nil), "pds.IpsecSADecryptStatus")
	proto.RegisterType((*IpsecSADecryptStats)(nil), "pds.IpsecSADecryptStats")
	proto.RegisterType((*IpsecSADecrypt)(nil), "pds.IpsecSADecrypt")
	proto.RegisterType((*IpsecSADecryptRequest)(nil), "pds.IpsecSADecryptRequest")
	proto.RegisterType((*IpsecSADecryptResponse)(nil), "pds.IpsecSADecryptResponse")
	proto.RegisterType((*IpsecSADecryptGetRequest)(nil), "pds.IpsecSADecryptGetRequest")
	proto.RegisterType((*IpsecSADecryptGetResponse)(nil), "pds.IpsecSADecryptGetResponse")
	proto.RegisterType((*IpsecSADecryptDeleteRequest)(nil), "pds.IpsecSADecryptDeleteRequest")
	proto.RegisterType((*IpsecSADecryptDeleteResponse)(nil), "pds.IpsecSADecryptDeleteResponse")
}

func init() { proto.RegisterFile("ipsec.proto", fileDescriptor_c3a27ac5c58e1b0f) }

var fileDescriptor_c3a27ac5c58e1b0f = []byte{
	// 1371 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4f, 0x6f, 0x1a, 0xc7,
	0x1b, 0xf6, 0x02, 0x06, 0xfc, 0xe2, 0x3f, 0xeb, 0x71, 0xe2, 0x10, 0x92, 0xd8, 0x64, 0x95, 0x03,
	0xb2, 0x22, 0xa2, 0x10, 0xe5, 0xf7, 0x6b, 0xda, 0x43, 0xc4, 0xae, 0xa9, 0xa1, 0xb6, 0x81, 0x0e,
	0xa4, 0x55, 0x0f, 0x11, 0xda, 0xc0, 0xb4, 0xa1, 0x06, 0x76, 0xc3, 0x4e, 0x5c, 0x6f, 0x55, 0xa9,
	0xdf, 0xa4, 0xb7, 0x1e, 0xfb, 0x1d, 0x7a, 0xec, 0x31, 0xaa, 0xd4, 0x63, 0xad, 0x2a, 0xa7, 0x2a,
	0xc7, 0x7e, 0x82, 0x6a, 0x67, 0x67, 0x97, 0x5d, 0x98, 0x85, 0xc4, 0x91, 0xa5, 0x56, 0x3d, 0x24,
	0xda, 0x99, 0xf7, 0x79, 0x9e, 0x79, 0xe7, 0x7d, 0x77, 0xe6, 0x61, 0x0d, 0x99, 0xbe, 0x69, 0x91,
	0x6e, 0xd1, 0x1c, 0x1b, 0xd4, 0x40, 0x71, 0xb3, 0x67, 0xe5, 0x36, 0x86, 0x84, 0xea, 0xf7, 0x9c,
	0xff, 0xdc, 0xd9, 0x5c, 0x86, 0xda, 0x26, 0xb1, 0xdc, 0x81, 0x82, 0x61, 0xb5, 0x65, 0x0f, 0x87,
	0x84, 0x8e, 0xfb, 0xdd, 0x43, 0x62, 0x23, 0x04, 0xf1, 0x43, 0x62, 0x67, 0xa5, 0xbc, 0x54, 0x58,
	0xad, 0x2e, 0x61, 0x67, 0x80, 0x14, 0xc8, 0x1c, 0x12, 0xfb, 0xc8, 0xe8, 0xea, 0xb4, 0x6f, 0x8c,
	0xb2, 0xb1, 0xbc, 0x54, 0x58, 0xab, 0x2e, 0xe1, 0xe0, 0xa4, 0x0a, 0x90, 0x3e, 0x21, 0x76, 0xa7,
	0x3f, 0xfa, 0xd2, 0x50, 0xfe, 0x8c, 0x03, 0xaa, 0x39, 0x69, 0xb4, 0xca, 0x95, 0x51, 0x77, 0x6c,
	0x9b, 0xb4, 0x65, 0x92, 0x2e, 0x52, 0x20, 0x56, 0xeb, 0xb9, 0xca, 0x2a, 0xfa, 0xeb, 0x7c, 0x77,
	0xdd, 0xc9, 0xe9, 0xc3, 0xa1, 0x3e, 0xea, 0xe9, 0xd4, 0x18, 0xdb, 0x38, 0x56, 0xeb, 0xa1, 0x22,
	0xa4, 0x9b, 0x4e, 0x5e, 0x5d, 0x63, 0xc0, 0xd6, 0x59, 0x2f, 0xa1, 0xa2, 0xd9, 0xb3, 0x8a, 0x4c,
	0xce, 0x8b, 0x60, 0x1f, 0x83, 0x3e, 0x83, 0x6b, 0xe5, 0x97, 0xf4, 0x39, 0x19, 0xd1, 0xbe, 0x9b,
	0x48, 0x79, 0xf0, 0x95, 0x31, 0xee, 0xd3, 0xe7, 0xc3, 0x6c, 0x9c, 0xd1, 0x6f, 0x32, 0x7a, 0x04,
	0x06, 0x47, 0x91, 0xd1, 0x63, 0xd8, 0x0c, 0x87, 0x9c, 0xa2, 0x24, 0xf2, 0x52, 0x21, 0x53, 0xda,
	0x64, 0x8a, 0xc1, 0xa2, 0xe1, 0x59, 0x2c, 0xfa, 0x04, 0xb6, 0xf8, 0xde, 0x43, 0x49, 0x2d, 0xb3,
	0xa4, 0xb2, 0x4c, 0x42, 0x10, 0xc7, 0x22, 0x12, 0xfa, 0x3f, 0xac, 0x4d, 0xa6, 0x9d, 0x44, 0x92,
	0x51, 0x89, 0x84, 0x71, 0x48, 0x86, 0x78, 0xcb, 0xec, 0x67, 0x53, 0x4e, 0xc3, 0xb0, 0xf3, 0x88,
	0xf6, 0x40, 0xae, 0xeb, 0xb4, 0x3d, 0xd6, 0x4f, 0xc9, 0xd8, 0xd2, 0x07, 0x4d, 0x63, 0x4c, 0xb3,
	0x69, 0x16, 0x9e, 0x99, 0x47, 0x08, 0x12, 0x2d, 0x7d, 0x40, 0xb3, 0x2b, 0x2c, 0xce, 0x9e, 0xd1,
	0x3a, 0xc4, 0x6a, 0xa7, 0x59, 0xc8, 0x4b, 0x85, 0x04, 0x8e, 0xd5, 0x4e, 0x95, 0x2a, 0x5c, 0x99,
	0xea, 0x34, 0xd5, 0xe9, 0x4b, 0x0b, 0xe5, 0x20, 0x7d, 0x48, 0xec, 0xda, 0xa8, 0x47, 0xce, 0x58,
	0xc7, 0xd7, 0xb0, 0x3f, 0x46, 0x57, 0x60, 0xb9, 0x45, 0x5e, 0xd4, 0x0d, 0xd6, 0xe0, 0x04, 0x76,
	0x07, 0xca, 0x4f, 0x12, 0x6c, 0xcd, 0x4a, 0x59, 0x68, 0x1b, 0x92, 0xf8, 0xac, 0x79, 0x42, 0x2d,
	0xa6, 0x93, 0xc0, 0x7c, 0x84, 0xb2, 0x90, 0xc2, 0x67, 0xaa, 0x4d, 0x89, 0xc5, 0x75, 0xbc, 0xa1,
	0xc3, 0x68, 0xbb, 0x8c, 0xb8, 0xcb, 0x68, 0xfb, 0x8c, 0x36, 0x67, 0x24, 0x5c, 0x06, 0x1f, 0xba,
	0x5a, 0xfb, 0x63, 0xc3, 0xb4, 0x58, 0x83, 0x98, 0x16, 0x1b, 0xba, 0x1c, 0x37, 0x92, 0xf4, 0x38,
	0x6c, 0xa8, 0xfc, 0x1e, 0x83, 0xf5, 0x70, 0xbe, 0xe8, 0x23, 0x48, 0xb7, 0x6d, 0x93, 0x1c, 0x13,
	0xaa, 0xb3, 0x64, 0x33, 0xa5, 0xf5, 0x22, 0x3b, 0x77, 0xde, 0xac, 0xba, 0xf1, 0xea, 0x7c, 0x57,
	0x7a, 0x73, 0xbe, 0x9b, 0xba, 0xdb, 0x1f, 0x0d, 0xfa, 0x23, 0x82, 0x7d, 0x02, 0x7a, 0x0c, 0xa9,
	0xc6, 0xb3, 0xaf, 0x19, 0x37, 0xc6, 0xb8, 0x6b, 0x2e, 0x97, 0x4f, 0xaa, 0xdb, 0x9c, 0xca, 0x4e,
	0xcd, 0x5d, 0x63, 0xd8, 0xa7, 0x64, 0x68, 0x52, 0x1b, 0x7b, 0x2c, 0xf4, 0x18, 0x12, 0xce, 0x31,
	0x63, 0x9b, 0xce, 0x94, 0xae, 0x4d, 0x8e, 0x4d, 0xe8, 0x14, 0xaa, 0xc8, 0xd1, 0xb0, 0x4c, 0xd2,
	0x0d, 0x68, 0x30, 0x22, 0x3a, 0x80, 0xa4, 0xdb, 0x3d, 0xfe, 0xa2, 0x5f, 0x17, 0x49, 0x30, 0x80,
	0x7a, 0xe5, 0xcd, 0xf9, 0xae, 0x6c, 0xb1, 0xe7, 0x80, 0x0c, 0xa7, 0x23, 0x0d, 0x96, 0x59, 0xef,
	0x58, 0x31, 0x33, 0xfc, 0x6d, 0x17, 0xf4, 0x56, 0xdd, 0x7a, 0x73, 0xbe, 0xbb, 0xe1, 0xc8, 0x04,
	0x55, 0x5c, 0xae, 0xf2, 0x2d, 0x5c, 0x0d, 0x53, 0x30, 0x79, 0xf1, 0x92, 0x58, 0x14, 0x15, 0x61,
	0x45, 0xd5, 0x69, 0xf7, 0xb9, 0x46, 0xcf, 0x28, 0x2f, 0xb3, 0x5c, 0x74, 0xaf, 0x34, 0x7f, 0x1e,
	0x4f, 0x20, 0xe8, 0x3e, 0xa4, 0x38, 0x35, 0x1b, 0xcb, 0xc7, 0xe7, 0x94, 0x06, 0x7b, 0x38, 0xe5,
	0x7b, 0xd8, 0x9e, 0x5e, 0xdb, 0x32, 0x8d, 0x91, 0x45, 0x9c, 0xc5, 0xcb, 0x66, 0x9f, 0x97, 0x49,
	0x62, 0x87, 0xd9, 0x5b, 0xdc, 0x9f, 0xc7, 0x13, 0x08, 0x7a, 0x08, 0x69, 0x8f, 0xcb, 0x57, 0x8f,
	0xae, 0x2a, 0xf6, 0xa1, 0xca, 0x1e, 0x64, 0xc3, 0x88, 0x03, 0xe2, 0xef, 0x7f, 0x9d, 0x5f, 0xa3,
	0xf1, 0xc2, 0xaa, 0x73, 0x65, 0x2a, 0xdf, 0xc1, 0x75, 0x01, 0xf6, 0x82, 0xf9, 0xde, 0x9b, 0xc9,
	0x77, 0x4b, 0x90, 0x6f, 0x20, 0xd3, 0xa7, 0x70, 0x23, 0x1c, 0xdb, 0x27, 0x03, 0x42, 0xc9, 0x45,
	0x9b, 0xe5, 0x6e, 0x2e, 0xe6, 0x6f, 0xae, 0x0e, 0x37, 0xc5, 0xf2, 0xe2, 0xfd, 0xc5, 0x17, 0xec,
	0x4f, 0xf9, 0x61, 0xd9, 0xb7, 0xa6, 0x7d, 0xf2, 0xdf, 0xb5, 0x26, 0xbe, 0xf7, 0x77, 0xb3, 0x26,
	0x01, 0x09, 0x7d, 0x0c, 0x9b, 0x98, 0x9c, 0x10, 0x7b, 0x9f, 0x74, 0x27, 0x4a, 0xc9, 0x05, 0x4a,
	0xb3, 0x14, 0xc7, 0xe2, 0x26, 0xf2, 0xce, 0x86, 0x52, 0x91, 0x16, 0x17, 0xc2, 0xa1, 0x1a, 0x6c,
	0x33, 0xb5, 0xd9, 0x92, 0xa4, 0xa3, 0x14, 0x22, 0x08, 0xa8, 0x0c, 0xc8, 0x4b, 0x2c, 0x90, 0xc8,
	0x4a, 0x94, 0x8c, 0x00, 0xec, 0x19, 0x2e, 0x4c, 0x0c, 0x37, 0xe7, 0x1c, 0xa8, 0x13, 0x62, 0x3b,
	0xd3, 0x19, 0xd7, 0x08, 0xbd, 0xb1, 0x6f, 0xb0, 0xab, 0x13, 0x83, 0x55, 0x7e, 0x95, 0x7c, 0x47,
	0xf5, 0x5e, 0xd0, 0xc5, 0x8e, 0x9a, 0x87, 0x4c, 0x9d, 0x7c, 0xe3, 0x87, 0xd9, 0x0f, 0x34, 0x1c,
	0x9c, 0x72, 0x10, 0xee, 0xae, 0xbb, 0xb4, 0x7f, 0x4a, 0xd8, 0x0b, 0xb8, 0x86, 0x83, 0x53, 0x13,
	0x57, 0x4e, 0x04, 0x5c, 0xd9, 0x59, 0x95, 0x3d, 0xa8, 0x43, 0x93, 0x5b, 0xa3, 0x3f, 0x46, 0x05,
	0xd8, 0x38, 0xd2, 0x2d, 0x8a, 0x89, 0x39, 0xd0, 0x6d, 0x97, 0xeb, 0x7a, 0xe4, 0xf4, 0x74, 0xd0,
	0xdb, 0x03, 0x9b, 0xfa, 0x57, 0x78, 0x3b, 0xcf, 0xf7, 0x9f, 0xeb, 0xed, 0x81, 0x6b, 0xec, 0xa2,
	0xde, 0x1e, 0x7a, 0xd1, 0xde, 0xc3, 0xdb, 0x83, 0xbd, 0x7d, 0x4b, 0x6f, 0xe7, 0x94, 0xcb, 0xf1,
	0xf6, 0x40, 0x69, 0x44, 0xde, 0xee, 0xaf, 0x7d, 0x39, 0xde, 0x1e, 0xaa, 0xaa, 0xd0, 0xdb, 0x39,
	0xe2, 0xad, 0xbc, 0x3d, 0x88, 0xbd, 0x1c, 0x6f, 0xf7, 0xca, 0x21, 0xf2, 0x76, 0x1e, 0xbb, 0x2c,
	0x6f, 0x9f, 0x92, 0xbf, 0x98, 0xb7, 0xef, 0x7d, 0x0e, 0x6b, 0x21, 0x2f, 0x46, 0xd7, 0x60, 0xab,
	0xd6, 0x6c, 0x55, 0xb4, 0x4e, 0x13, 0x37, 0xda, 0x0d, 0xad, 0x71, 0xd4, 0xa9, 0x37, 0xea, 0x15,
	0x79, 0x09, 0x5d, 0x85, 0xcd, 0xa9, 0x40, 0xb9, 0x2a, 0x4b, 0x68, 0x1b, 0xd0, 0xd4, 0x74, 0xa5,
	0xd5, 0x94, 0x63, 0x7b, 0x3f, 0xc6, 0x85, 0x1f, 0x73, 0xe8, 0x16, 0x5c, 0xaf, 0xd4, 0x35, 0xfc,
	0x45, 0xb3, 0x5d, 0x6b, 0xd4, 0x3b, 0xe5, 0xa3, 0x83, 0x06, 0xae, 0xb5, 0xab, 0xc7, 0xde, 0x2a,
	0x77, 0x20, 0x2f, 0x0c, 0x97, 0x2b, 0xad, 0xce, 0x81, 0x76, 0xdc, 0xb9, 0x5f, 0xfa, 0x40, 0x96,
	0x16, 0xa2, 0x4a, 0x0f, 0xff, 0x27, 0xc7, 0xe6, 0xa2, 0x34, 0xae, 0x15, 0x5f, 0x8c, 0x7a, 0x54,
	0x92, 0x13, 0x0b, 0x51, 0xce, 0x8a, 0xcb, 0xf3, 0x51, 0xaa, 0xc6, 0x56, 0x4c, 0x2e, 0x46, 0x3d,
	0x2a, 0xc9, 0xa9, 0x85, 0x28, 0x67, 0xc5, 0x74, 0x64, 0x39, 0xf7, 0x2b, 0xad, 0x07, 0xf2, 0x0a,
	0xca, 0xc3, 0x4d, 0x61, 0x58, 0xab, 0x96, 0x9d, 0x7f, 0x32, 0xec, 0xfd, 0x26, 0x45, 0xfe, 0xe4,
	0x42, 0xb7, 0xe1, 0x56, 0xf9, 0x49, 0xbb, 0x5a, 0xa9, 0xb7, 0x6b, 0x5a, 0x39, 0xb2, 0x5f, 0x91,
	0x10, 0xde, 0x0d, 0xb7, 0x5f, 0x73, 0x51, 0x9a, 0x76, 0x2c, 0xc7, 0xe6, 0x2e, 0x57, 0x3d, 0x2e,
	0x6b, 0x72, 0x1c, 0x15, 0xe0, 0xce, 0x7c, 0x21, 0x55, 0xeb, 0xb4, 0xaa, 0x65, 0x39, 0x51, 0xfa,
	0x79, 0x19, 0xd2, 0xee, 0x49, 0x39, 0xed, 0xa2, 0x4f, 0xa7, 0xbf, 0xb8, 0xb5, 0x31, 0xd1, 0x29,
	0x41, 0x39, 0xd1, 0xef, 0x74, 0xf7, 0xa4, 0xe6, 0x6e, 0x08, 0x63, 0xfc, 0x94, 0x2f, 0xcd, 0x4a,
	0x3e, 0x31, 0x7b, 0xef, 0x29, 0xd9, 0x86, 0xcd, 0x99, 0x8f, 0x12, 0x74, 0x4b, 0xc0, 0x99, 0x5c,
	0x7e, 0xb9, 0x9d, 0xa8, 0xb0, 0xaf, 0xfa, 0x74, 0x3a, 0x51, 0xf7, 0xc6, 0x40, 0x79, 0x01, 0x33,
	0x74, 0x57, 0xe5, 0x6e, 0xcf, 0x41, 0x08, 0xea, 0xc0, 0x2f, 0x24, 0x51, 0x69, 0xc3, 0x8e, 0x15,
	0xae, 0xc3, 0x94, 0xa3, 0x88, 0x24, 0x45, 0xa5, 0x7d, 0x37, 0xc9, 0x49, 0x69, 0x27, 0x9e, 0x10,
	0x2e, 0xed, 0x8c, 0xaf, 0x84, 0x4b, 0x3b, 0x6b, 0x25, 0xa1, 0xd2, 0x86, 0x2e, 0xe3, 0x70, 0x69,
	0x45, 0x36, 0x10, 0x2e, 0xad, 0xf0, 0x26, 0x57, 0x96, 0xd4, 0xd5, 0x5f, 0x5e, 0xef, 0x48, 0xaf,
	0x5e, 0xef, 0x48, 0x7f, 0xbc, 0xde, 0x91, 0x9e, 0x25, 0xd9, 0xdf, 0x1e, 0x1f, 0xfc, 0x1d, 0x00,
	0x00, 0xff, 0xff, 0x30, 0xf4, 0x90, 0x00, 0xad, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IpsecSvcClient is the client API for IpsecSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IpsecSvcClient interface {
	IpsecSAEncryptCreate(ctx context.Context, in *IpsecSAEncryptRequest, opts ...grpc.CallOption) (*IpsecSAEncryptResponse, error)
	IpsecSAEncryptUpdate(ctx context.Context, in *IpsecSAEncryptRequest, opts ...grpc.CallOption) (*IpsecSAEncryptResponse, error)
	IpsecSAEncryptGet(ctx context.Context, in *IpsecSAEncryptGetRequest, opts ...grpc.CallOption) (*IpsecSAEncryptGetResponse, error)
	IpsecSAEncryptDelete(ctx context.Context, in *IpsecSAEncryptDeleteRequest, opts ...grpc.CallOption) (*IpsecSAEncryptDeleteResponse, error)
	IpsecSADecryptCreate(ctx context.Context, in *IpsecSADecryptRequest, opts ...grpc.CallOption) (*IpsecSADecryptResponse, error)
	IpsecSADecryptUpdate(ctx context.Context, in *IpsecSADecryptRequest, opts ...grpc.CallOption) (*IpsecSADecryptResponse, error)
	IpsecSADecryptGet(ctx context.Context, in *IpsecSADecryptGetRequest, opts ...grpc.CallOption) (*IpsecSADecryptGetResponse, error)
	IpsecSADecryptDelete(ctx context.Context, in *IpsecSADecryptDeleteRequest, opts ...grpc.CallOption) (*IpsecSADecryptDeleteResponse, error)
}

type ipsecSvcClient struct {
	cc *grpc.ClientConn
}

func NewIpsecSvcClient(cc *grpc.ClientConn) IpsecSvcClient {
	return &ipsecSvcClient{cc}
}

func (c *ipsecSvcClient) IpsecSAEncryptCreate(ctx context.Context, in *IpsecSAEncryptRequest, opts ...grpc.CallOption) (*IpsecSAEncryptResponse, error) {
	out := new(IpsecSAEncryptResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSAEncryptCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSAEncryptUpdate(ctx context.Context, in *IpsecSAEncryptRequest, opts ...grpc.CallOption) (*IpsecSAEncryptResponse, error) {
	out := new(IpsecSAEncryptResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSAEncryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSAEncryptGet(ctx context.Context, in *IpsecSAEncryptGetRequest, opts ...grpc.CallOption) (*IpsecSAEncryptGetResponse, error) {
	out := new(IpsecSAEncryptGetResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSAEncryptGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSAEncryptDelete(ctx context.Context, in *IpsecSAEncryptDeleteRequest, opts ...grpc.CallOption) (*IpsecSAEncryptDeleteResponse, error) {
	out := new(IpsecSAEncryptDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSAEncryptDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSADecryptCreate(ctx context.Context, in *IpsecSADecryptRequest, opts ...grpc.CallOption) (*IpsecSADecryptResponse, error) {
	out := new(IpsecSADecryptResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSADecryptCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSADecryptUpdate(ctx context.Context, in *IpsecSADecryptRequest, opts ...grpc.CallOption) (*IpsecSADecryptResponse, error) {
	out := new(IpsecSADecryptResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSADecryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSADecryptGet(ctx context.Context, in *IpsecSADecryptGetRequest, opts ...grpc.CallOption) (*IpsecSADecryptGetResponse, error) {
	out := new(IpsecSADecryptGetResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSADecryptGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipsecSvcClient) IpsecSADecryptDelete(ctx context.Context, in *IpsecSADecryptDeleteRequest, opts ...grpc.CallOption) (*IpsecSADecryptDeleteResponse, error) {
	out := new(IpsecSADecryptDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.IpsecSvc/IpsecSADecryptDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IpsecSvcServer is the server API for IpsecSvc service.
type IpsecSvcServer interface {
	IpsecSAEncryptCreate(context.Context, *IpsecSAEncryptRequest) (*IpsecSAEncryptResponse, error)
	IpsecSAEncryptUpdate(context.Context, *IpsecSAEncryptRequest) (*IpsecSAEncryptResponse, error)
	IpsecSAEncryptGet(context.Context, *IpsecSAEncryptGetRequest) (*IpsecSAEncryptGetResponse, error)
	IpsecSAEncryptDelete(context.Context, *IpsecSAEncryptDeleteRequest) (*IpsecSAEncryptDeleteResponse, error)
	IpsecSADecryptCreate(context.Context, *IpsecSADecryptRequest) (*IpsecSADecryptResponse, error)
	IpsecSADecryptUpdate(context.Context, *IpsecSADecryptRequest) (*IpsecSADecryptResponse, error)
	IpsecSADecryptGet(context.Context, *IpsecSADecryptGetRequest) (*IpsecSADecryptGetResponse, error)
	IpsecSADecryptDelete(context.Context, *IpsecSADecryptDeleteRequest) (*IpsecSADecryptDeleteResponse, error)
}

// UnimplementedIpsecSvcServer can be embedded to have forward compatible implementations.
type UnimplementedIpsecSvcServer struct {
}

func (*UnimplementedIpsecSvcServer) IpsecSAEncryptCreate(ctx context.Context, req *IpsecSAEncryptRequest) (*IpsecSAEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSAEncryptCreate not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSAEncryptUpdate(ctx context.Context, req *IpsecSAEncryptRequest) (*IpsecSAEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSAEncryptUpdate not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSAEncryptGet(ctx context.Context, req *IpsecSAEncryptGetRequest) (*IpsecSAEncryptGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSAEncryptGet not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSAEncryptDelete(ctx context.Context, req *IpsecSAEncryptDeleteRequest) (*IpsecSAEncryptDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSAEncryptDelete not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSADecryptCreate(ctx context.Context, req *IpsecSADecryptRequest) (*IpsecSADecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSADecryptCreate not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSADecryptUpdate(ctx context.Context, req *IpsecSADecryptRequest) (*IpsecSADecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSADecryptUpdate not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSADecryptGet(ctx context.Context, req *IpsecSADecryptGetRequest) (*IpsecSADecryptGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSADecryptGet not implemented")
}
func (*UnimplementedIpsecSvcServer) IpsecSADecryptDelete(ctx context.Context, req *IpsecSADecryptDeleteRequest) (*IpsecSADecryptDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpsecSADecryptDelete not implemented")
}

func RegisterIpsecSvcServer(s *grpc.Server, srv IpsecSvcServer) {
	s.RegisterService(&_IpsecSvc_serviceDesc, srv)
}

func _IpsecSvc_IpsecSAEncryptCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSAEncryptCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSAEncryptCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSAEncryptCreate(ctx, req.(*IpsecSAEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSAEncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSAEncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSAEncryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSAEncryptUpdate(ctx, req.(*IpsecSAEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSAEncryptGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSAEncryptGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSAEncryptGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSAEncryptGet(ctx, req.(*IpsecSAEncryptGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSAEncryptDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSAEncryptDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSAEncryptDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSAEncryptDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSAEncryptDelete(ctx, req.(*IpsecSAEncryptDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSADecryptCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSADecryptCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSADecryptCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSADecryptCreate(ctx, req.(*IpsecSADecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSADecryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSADecryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSADecryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSADecryptUpdate(ctx, req.(*IpsecSADecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSADecryptGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSADecryptGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSADecryptGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSADecryptGet(ctx, req.(*IpsecSADecryptGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpsecSvc_IpsecSADecryptDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpsecSADecryptDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpsecSvcServer).IpsecSADecryptDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IpsecSvc/IpsecSADecryptDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpsecSvcServer).IpsecSADecryptDelete(ctx, req.(*IpsecSADecryptDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IpsecSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.IpsecSvc",
	HandlerType: (*IpsecSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IpsecSAEncryptCreate",
			Handler:    _IpsecSvc_IpsecSAEncryptCreate_Handler,
		},
		{
			MethodName: "IpsecSAEncryptUpdate",
			Handler:    _IpsecSvc_IpsecSAEncryptUpdate_Handler,
		},
		{
			MethodName: "IpsecSAEncryptGet",
			Handler:    _IpsecSvc_IpsecSAEncryptGet_Handler,
		},
		{
			MethodName: "IpsecSAEncryptDelete",
			Handler:    _IpsecSvc_IpsecSAEncryptDelete_Handler,
		},
		{
			MethodName: "IpsecSADecryptCreate",
			Handler:    _IpsecSvc_IpsecSADecryptCreate_Handler,
		},
		{
			MethodName: "IpsecSADecryptUpdate",
			Handler:    _IpsecSvc_IpsecSADecryptUpdate_Handler,
		},
		{
			MethodName: "IpsecSADecryptGet",
			Handler:    _IpsecSvc_IpsecSADecryptGet_Handler,
		},
		{
			MethodName: "IpsecSADecryptDelete",
			Handler:    _IpsecSvc_IpsecSADecryptDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ipsec.proto",
}

func (m *SymmetricKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymmetricKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SymmetricKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyInfo != nil {
		{
			size := m.KeyInfo.Size()
			i -= size
			if _, err := m.KeyInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SymmetricKey_Key) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *SymmetricKey_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SymmetricKey_KeyLocation) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *SymmetricKey_KeyLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintIpsec(dAtA, i, uint64(m.KeyLocation))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *IpsecSAEncryptSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iv != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Iv))
		i--
		dAtA[i] = 0x50
	}
	if m.Salt != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x48
	}
	if m.NatTraversalPort != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.NatTraversalPort))
		i--
		dAtA[i] = 0x40
	}
	if m.Spi != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Spi))
		i--
		dAtA[i] = 0x38
	}
	if m.EncryptionKey != nil {
		{
			size, err := m.EncryptionKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.EncryptionAlgorithm != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.EncryptionAlgorithm))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthenticationKey != nil {
		{
			size, err := m.AuthenticationKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthenticationAlgorithm != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.AuthenticationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.Protocol != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeqNo != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x10
	}
	if m.KeyIndex != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.KeyIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxDrops != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxDrops))
		i--
		dAtA[i] = 0x30
	}
	if m.RxDrops != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxDrops))
		i--
		dAtA[i] = 0x28
	}
	if m.TxBytes != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.TxPkts != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxPkts))
		i--
		dAtA[i] = 0x18
	}
	if m.RxBytes != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RxPkts != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxPkts))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncrypt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncrypt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSAEncryptDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSAEncryptDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSAEncryptDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA11 := make([]byte, len(m.ApiStatus)*10)
		var j10 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintIpsec(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Salt != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x60
	}
	if m.RekeySpi != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RekeySpi))
		i--
		dAtA[i] = 0x58
	}
	if m.Spi != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Spi))
		i--
		dAtA[i] = 0x50
	}
	if m.RekeyDecryptionKey != nil {
		{
			size, err := m.RekeyDecryptionKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RekeyAuthenticationKey != nil {
		{
			size, err := m.RekeyAuthenticationKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DecryptionKey != nil {
		{
			size, err := m.DecryptionKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RekeyDecAlgorithm != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RekeyDecAlgorithm))
		i--
		dAtA[i] = 0x30
	}
	if m.DecryptionAlgorithm != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.DecryptionAlgorithm))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthenticationKey != nil {
		{
			size, err := m.AuthenticationKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthenticationAlgorithm != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.AuthenticationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.Protocol != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastReplaySeqNo != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.LastReplaySeqNo))
		i--
		dAtA[i] = 0x30
	}
	if m.SeqNoBmp != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.SeqNoBmp))
		i--
		dAtA[i] = 0x28
	}
	if m.SeqNo != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x20
	}
	if m.RekeyActive != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RekeyActive))
		i--
		dAtA[i] = 0x18
	}
	if m.NewKeyIndex != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.NewKeyIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.KeyIndex != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.KeyIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxDrops != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxDrops))
		i--
		dAtA[i] = 0x30
	}
	if m.RxDrops != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxDrops))
		i--
		dAtA[i] = 0x28
	}
	if m.TxBytes != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.TxPkts != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.TxPkts))
		i--
		dAtA[i] = 0x18
	}
	if m.RxBytes != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RxPkts != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.RxPkts))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecrypt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecrypt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintIpsec(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintIpsec(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpsec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecSADecryptDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecSADecryptDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecSADecryptDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA24 := make([]byte, len(m.ApiStatus)*10)
		var j23 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintIpsec(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIpsec(dAtA []byte, offset int, v uint64) int {
	offset -= sovIpsec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SymmetricKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyInfo != nil {
		n += m.KeyInfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymmetricKey_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovIpsec(uint64(l))
	}
	return n
}
func (m *SymmetricKey_KeyLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIpsec(uint64(m.KeyLocation))
	return n
}
func (m *IpsecSAEncryptSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovIpsec(uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		n += 1 + sovIpsec(uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		l = m.AuthenticationKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.EncryptionAlgorithm != 0 {
		n += 1 + sovIpsec(uint64(m.EncryptionAlgorithm))
	}
	if m.EncryptionKey != nil {
		l = m.EncryptionKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Spi != 0 {
		n += 1 + sovIpsec(uint64(m.Spi))
	}
	if m.NatTraversalPort != 0 {
		n += 1 + sovIpsec(uint64(m.NatTraversalPort))
	}
	if m.Salt != 0 {
		n += 1 + sovIpsec(uint64(m.Salt))
	}
	if m.Iv != 0 {
		n += 1 + sovIpsec(uint64(m.Iv))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyIndex != 0 {
		n += 1 + sovIpsec(uint64(m.KeyIndex))
	}
	if m.SeqNo != 0 {
		n += 1 + sovIpsec(uint64(m.SeqNo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RxPkts != 0 {
		n += 1 + sovIpsec(uint64(m.RxPkts))
	}
	if m.RxBytes != 0 {
		n += 1 + sovIpsec(uint64(m.RxBytes))
	}
	if m.TxPkts != 0 {
		n += 1 + sovIpsec(uint64(m.TxPkts))
	}
	if m.TxBytes != 0 {
		n += 1 + sovIpsec(uint64(m.TxBytes))
	}
	if m.RxDrops != 0 {
		n += 1 + sovIpsec(uint64(m.RxDrops))
	}
	if m.TxDrops != 0 {
		n += 1 + sovIpsec(uint64(m.TxDrops))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncrypt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsec(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsec(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSAEncryptDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovIpsec(uint64(e))
		}
		n += 1 + sovIpsec(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovIpsec(uint64(m.Protocol))
	}
	if m.AuthenticationAlgorithm != 0 {
		n += 1 + sovIpsec(uint64(m.AuthenticationAlgorithm))
	}
	if m.AuthenticationKey != nil {
		l = m.AuthenticationKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.DecryptionAlgorithm != 0 {
		n += 1 + sovIpsec(uint64(m.DecryptionAlgorithm))
	}
	if m.RekeyDecAlgorithm != 0 {
		n += 1 + sovIpsec(uint64(m.RekeyDecAlgorithm))
	}
	if m.DecryptionKey != nil {
		l = m.DecryptionKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.RekeyAuthenticationKey != nil {
		l = m.RekeyAuthenticationKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.RekeyDecryptionKey != nil {
		l = m.RekeyDecryptionKey.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Spi != 0 {
		n += 1 + sovIpsec(uint64(m.Spi))
	}
	if m.RekeySpi != 0 {
		n += 1 + sovIpsec(uint64(m.RekeySpi))
	}
	if m.Salt != 0 {
		n += 1 + sovIpsec(uint64(m.Salt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyIndex != 0 {
		n += 1 + sovIpsec(uint64(m.KeyIndex))
	}
	if m.NewKeyIndex != 0 {
		n += 1 + sovIpsec(uint64(m.NewKeyIndex))
	}
	if m.RekeyActive != 0 {
		n += 1 + sovIpsec(uint64(m.RekeyActive))
	}
	if m.SeqNo != 0 {
		n += 1 + sovIpsec(uint64(m.SeqNo))
	}
	if m.SeqNoBmp != 0 {
		n += 1 + sovIpsec(uint64(m.SeqNoBmp))
	}
	if m.LastReplaySeqNo != 0 {
		n += 1 + sovIpsec(uint64(m.LastReplaySeqNo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RxPkts != 0 {
		n += 1 + sovIpsec(uint64(m.RxPkts))
	}
	if m.RxBytes != 0 {
		n += 1 + sovIpsec(uint64(m.RxBytes))
	}
	if m.TxPkts != 0 {
		n += 1 + sovIpsec(uint64(m.TxPkts))
	}
	if m.TxBytes != 0 {
		n += 1 + sovIpsec(uint64(m.TxBytes))
	}
	if m.RxDrops != 0 {
		n += 1 + sovIpsec(uint64(m.RxDrops))
	}
	if m.TxDrops != 0 {
		n += 1 + sovIpsec(uint64(m.TxDrops))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecrypt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsec(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovIpsec(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovIpsec(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovIpsec(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpsecSADecryptDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovIpsec(uint64(e))
		}
		n += 1 + sovIpsec(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIpsec(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIpsec(x uint64) (n int) {
	return sovIpsec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SymmetricKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymmetricKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymmetricKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyInfo = &SymmetricKey_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLocation", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyInfo = &SymmetricKey_KeyLocation{v}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= IpsecProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgorithm", wireType)
			}
			m.AuthenticationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationAlgorithm |= AuthenticationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticationKey == nil {
				m.AuthenticationKey = &SymmetricKey{}
			}
			if err := m.AuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgorithm", wireType)
			}
			m.EncryptionAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionAlgorithm |= EncryptionAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionKey == nil {
				m.EncryptionKey = &SymmetricKey{}
			}
			if err := m.EncryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatTraversalPort", wireType)
			}
			m.NatTraversalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NatTraversalPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iv", wireType)
			}
			m.Iv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIndex", wireType)
			}
			m.KeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPkts", wireType)
			}
			m.RxPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPkts", wireType)
			}
			m.TxPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDrops", wireType)
			}
			m.RxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDrops", wireType)
			}
			m.TxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &IpsecSAEncryptSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &IpsecSAEncryptStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &IpsecSAEncryptStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSAEncryptSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSAEncryptStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSAEncrypt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSAEncryptDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSAEncryptDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthIpsec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= IpsecProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgorithm", wireType)
			}
			m.AuthenticationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationAlgorithm |= AuthenticationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticationKey == nil {
				m.AuthenticationKey = &SymmetricKey{}
			}
			if err := m.AuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionAlgorithm", wireType)
			}
			m.DecryptionAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecryptionAlgorithm |= EncryptionAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecAlgorithm", wireType)
			}
			m.RekeyDecAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeyDecAlgorithm |= EncryptionAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecryptionKey == nil {
				m.DecryptionKey = &SymmetricKey{}
			}
			if err := m.DecryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyAuthenticationKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RekeyAuthenticationKey == nil {
				m.RekeyAuthenticationKey = &SymmetricKey{}
			}
			if err := m.RekeyAuthenticationKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyDecryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RekeyDecryptionKey == nil {
				m.RekeyDecryptionKey = &SymmetricKey{}
			}
			if err := m.RekeyDecryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spi", wireType)
			}
			m.Spi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeySpi", wireType)
			}
			m.RekeySpi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeySpi |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIndex", wireType)
			}
			m.KeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyIndex", wireType)
			}
			m.NewKeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewKeyIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RekeyActive", wireType)
			}
			m.RekeyActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RekeyActive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNoBmp", wireType)
			}
			m.SeqNoBmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNoBmp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReplaySeqNo", wireType)
			}
			m.LastReplaySeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReplaySeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPkts", wireType)
			}
			m.RxPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPkts", wireType)
			}
			m.TxPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDrops", wireType)
			}
			m.RxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDrops", wireType)
			}
			m.TxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &IpsecSADecryptSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &IpsecSADecryptStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &IpsecSADecryptStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &IpsecSADecryptSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSADecryptStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &IpsecSADecrypt{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpsec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpsec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecSADecryptDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecSADecryptDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIpsec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthIpsec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIpsec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpsec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpsec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpsec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIpsec
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIpsec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpsec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpsec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIpsec
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpsec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpsec   = fmt.Errorf("proto: integer overflow")
)
