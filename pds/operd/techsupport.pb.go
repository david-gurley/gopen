// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: techsupport.proto

package operd

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	pds1 "github.com/david-gurley/gopen/pds"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// techsupport collect status
type TechSupportStatus_CollectStatus int32

const (
	TechSupportStatus_COLLECT_STATUS_NONE        TechSupportStatus_CollectStatus = 0
	TechSupportStatus_COLLECT_STATUS_FINISHED    TechSupportStatus_CollectStatus = 1
	TechSupportStatus_COLLECT_STATUS_IN_PROGRESS TechSupportStatus_CollectStatus = 2
	TechSupportStatus_COLLECT_STATUS_ERROR       TechSupportStatus_CollectStatus = 3
)

var TechSupportStatus_CollectStatus_name = map[int32]string{
	0: "COLLECT_STATUS_NONE",
	1: "COLLECT_STATUS_FINISHED",
	2: "COLLECT_STATUS_IN_PROGRESS",
	3: "COLLECT_STATUS_ERROR",
}

var TechSupportStatus_CollectStatus_value = map[string]int32{
	"COLLECT_STATUS_NONE":        0,
	"COLLECT_STATUS_FINISHED":    1,
	"COLLECT_STATUS_IN_PROGRESS": 2,
	"COLLECT_STATUS_ERROR":       3,
}

func (x TechSupportStatus_CollectStatus) String() string {
	return proto.EnumName(TechSupportStatus_CollectStatus_name, int32(x))
}

func (TechSupportStatus_CollectStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{1, 0}
}

// TechSupportSpec defines the configuration of the techsupport object
type TechSupportSpec struct {
	// SkipCores can be set to true to exclude core files from techsupport
	// output
	SkipCores bool `protobuf:"varint,1,opt,name=SkipCores,proto3" json:"SkipCores,omitempty"`
	// techsupport request unique identifier
	Id []byte `protobuf:"bytes,2,opt,name=Id,proto3" json:"Id,omitempty"`
	// Async can be set to collect techsupport asynchronously
	// TechSupportGet rpc gives the status of issued request
	Async                bool     `protobuf:"varint,3,opt,name=Async,proto3" json:"Async,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TechSupportSpec) Reset()         { *m = TechSupportSpec{} }
func (m *TechSupportSpec) String() string { return proto.CompactTextString(m) }
func (*TechSupportSpec) ProtoMessage()    {}
func (*TechSupportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{0}
}
func (m *TechSupportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportSpec.Merge(m, src)
}
func (m *TechSupportSpec) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportSpec proto.InternalMessageInfo

func (m *TechSupportSpec) GetSkipCores() bool {
	if m != nil {
		return m.SkipCores
	}
	return false
}

func (m *TechSupportSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TechSupportSpec) GetAsync() bool {
	if m != nil {
		return m.Async
	}
	return false
}

// TechSupportStatus captures the current status of the techsupport job
type TechSupportStatus struct {
	// full path of the gzipped techsupport file created, if successful
	FilePath             string                          `protobuf:"bytes,1,opt,name=FilePath,proto3" json:"FilePath,omitempty"`
	Status               TechSupportStatus_CollectStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=operd.TechSupportStatus_CollectStatus" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *TechSupportStatus) Reset()         { *m = TechSupportStatus{} }
func (m *TechSupportStatus) String() string { return proto.CompactTextString(m) }
func (*TechSupportStatus) ProtoMessage()    {}
func (*TechSupportStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{1}
}
func (m *TechSupportStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportStatus.Merge(m, src)
}
func (m *TechSupportStatus) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportStatus proto.InternalMessageInfo

func (m *TechSupportStatus) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *TechSupportStatus) GetStatus() TechSupportStatus_CollectStatus {
	if m != nil {
		return m.Status
	}
	return TechSupportStatus_COLLECT_STATUS_NONE
}

// TechSupportStats contains stats related to techsupport
type TechSupportStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TechSupportStats) Reset()         { *m = TechSupportStats{} }
func (m *TechSupportStats) String() string { return proto.CompactTextString(m) }
func (*TechSupportStats) ProtoMessage()    {}
func (*TechSupportStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{2}
}
func (m *TechSupportStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportStats.Merge(m, src)
}
func (m *TechSupportStats) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportStats.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportStats proto.InternalMessageInfo

// Techsupport object
type TechSupport struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *TechSupportSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *TechSupportStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *TechSupportStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TechSupport) Reset()         { *m = TechSupport{} }
func (m *TechSupport) String() string { return proto.CompactTextString(m) }
func (*TechSupport) ProtoMessage()    {}
func (*TechSupport) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{3}
}
func (m *TechSupport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupport.Merge(m, src)
}
func (m *TechSupport) XXX_Size() int {
	return m.Size()
}
func (m *TechSupport) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupport.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupport proto.InternalMessageInfo

func (m *TechSupport) GetSpec() *TechSupportSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *TechSupport) GetStatus() *TechSupportStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *TechSupport) GetStats() *TechSupportStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// TechSupport create request
type TechSupportRequest struct {
	// config specification
	Request              *TechSupportSpec `protobuf:"bytes,1,opt,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TechSupportRequest) Reset()         { *m = TechSupportRequest{} }
func (m *TechSupportRequest) String() string { return proto.CompactTextString(m) }
func (*TechSupportRequest) ProtoMessage()    {}
func (*TechSupportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{4}
}
func (m *TechSupportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportRequest.Merge(m, src)
}
func (m *TechSupportRequest) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportRequest proto.InternalMessageInfo

func (m *TechSupportRequest) GetRequest() *TechSupportSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// TechSupport create response
type TechSupportResponse struct {
	// success or failure status
	ApiStatus            pds1.ApiStatus     `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             *TechSupportStatus `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TechSupportResponse) Reset()         { *m = TechSupportResponse{} }
func (m *TechSupportResponse) String() string { return proto.CompactTextString(m) }
func (*TechSupportResponse) ProtoMessage()    {}
func (*TechSupportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{5}
}
func (m *TechSupportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportResponse.Merge(m, src)
}
func (m *TechSupportResponse) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportResponse proto.InternalMessageInfo

func (m *TechSupportResponse) GetApiStatus() pds1.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return pds1.ApiStatus_API_STATUS_OK
}

func (m *TechSupportResponse) GetResponse() *TechSupportStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// TechSupport get request
type TechSupportGetRequest struct {
	// techsupport request unique identifier
	Id                   []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TechSupportGetRequest) Reset()         { *m = TechSupportGetRequest{} }
func (m *TechSupportGetRequest) String() string { return proto.CompactTextString(m) }
func (*TechSupportGetRequest) ProtoMessage()    {}
func (*TechSupportGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5a078f5a54e5df5, []int{6}
}
func (m *TechSupportGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechSupportGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechSupportGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechSupportGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechSupportGetRequest.Merge(m, src)
}
func (m *TechSupportGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *TechSupportGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TechSupportGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TechSupportGetRequest proto.InternalMessageInfo

func (m *TechSupportGetRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func init() {
	proto.RegisterEnum("operd.TechSupportStatus_CollectStatus", TechSupportStatus_CollectStatus_name, TechSupportStatus_CollectStatus_value)
	proto.RegisterType((*TechSupportSpec)(nil), "operd.TechSupportSpec")
	proto.RegisterType((*TechSupportStatus)(nil), "operd.TechSupportStatus")
	proto.RegisterType((*TechSupportStats)(nil), "operd.TechSupportStats")
	proto.RegisterType((*TechSupport)(nil), "operd.TechSupport")
	proto.RegisterType((*TechSupportRequest)(nil), "operd.TechSupportRequest")
	proto.RegisterType((*TechSupportResponse)(nil), "operd.TechSupportResponse")
	proto.RegisterType((*TechSupportGetRequest)(nil), "operd.TechSupportGetRequest")
}

func init() { proto.RegisterFile("techsupport.proto", fileDescriptor_b5a078f5a54e5df5) }

var fileDescriptor_b5a078f5a54e5df5 = []byte{
	// 581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xcf, 0x4e, 0xdb, 0x40,
	0x10, 0xc6, 0x59, 0x43, 0x20, 0x4c, 0x20, 0x31, 0x03, 0x05, 0xd7, 0x45, 0x09, 0xf2, 0xa1, 0xe5,
	0x80, 0xdc, 0x2a, 0xed, 0xad, 0x12, 0x15, 0x4e, 0x13, 0x1a, 0x09, 0x12, 0xb4, 0x0e, 0x67, 0x14,
	0xcc, 0x0a, 0xdc, 0x86, 0x78, 0x9b, 0x5d, 0x2a, 0x45, 0x3d, 0xf4, 0x89, 0xfa, 0x1e, 0x3d, 0x72,
	0xeb, 0x2d, 0xaa, 0x38, 0x72, 0xea, 0x23, 0x54, 0x59, 0x6f, 0x8c, 0xf3, 0xaf, 0x97, 0xc8, 0xf3,
	0xcd, 0x7c, 0x3f, 0xef, 0xcc, 0x78, 0x03, 0x1b, 0x92, 0x05, 0x37, 0xe2, 0x8e, 0xf3, 0xa8, 0x27,
	0x5d, 0xde, 0x8b, 0x64, 0x84, 0x99, 0x88, 0xb3, 0xde, 0x95, 0x0d, 0xd7, 0xd1, 0x75, 0x14, 0x4b,
	0x76, 0xe1, 0x96, 0xc9, 0xf6, 0xeb, 0xe1, 0x8f, 0x16, 0x72, 0xb2, 0xcf, 0x99, 0x88, 0x03, 0xe7,
	0x1c, 0x0a, 0x2d, 0x16, 0xdc, 0xf8, 0x31, 0xc5, 0xe7, 0x2c, 0xc0, 0x5d, 0x58, 0xf5, 0xbf, 0x84,
	0xbc, 0x12, 0xf5, 0x98, 0xb0, 0xc8, 0x1e, 0xd9, 0xcf, 0xd2, 0x27, 0x01, 0xf3, 0x60, 0xd4, 0xaf,
	0x2c, 0x63, 0x8f, 0xec, 0xaf, 0x51, 0xa3, 0x7e, 0x85, 0x5b, 0x90, 0x39, 0x12, 0xfd, 0x6e, 0x60,
	0x2d, 0xaa, 0xca, 0x38, 0x70, 0xfe, 0x12, 0xd8, 0x48, 0x73, 0x65, 0x5b, 0xde, 0x09, 0xb4, 0x21,
	0x5b, 0x0b, 0x3b, 0xec, 0xac, 0x2d, 0x6f, 0x14, 0x78, 0x95, 0x26, 0x31, 0x1e, 0xc2, 0x72, 0x5c,
	0xa5, 0xd8, 0xf9, 0xf2, 0x4b, 0x57, 0xb5, 0xe2, 0x4e, 0x51, 0xdc, 0x4a, 0xd4, 0xe9, 0xb0, 0x40,
	0x47, 0x54, 0xbb, 0x9c, 0x1f, 0xb0, 0x3e, 0x96, 0xc0, 0x1d, 0xd8, 0xac, 0x34, 0x4f, 0x4e, 0xaa,
	0x95, 0xd6, 0x85, 0xdf, 0x3a, 0x6a, 0x9d, 0xfb, 0x17, 0x8d, 0x66, 0xa3, 0x6a, 0x2e, 0xe0, 0x0b,
	0xd8, 0x99, 0x48, 0xd4, 0xea, 0x8d, 0xba, 0xff, 0xa9, 0xfa, 0xd1, 0x24, 0x58, 0x04, 0x7b, 0x22,
	0x59, 0x6f, 0x5c, 0x9c, 0xd1, 0xe6, 0x31, 0xad, 0xfa, 0xbe, 0x69, 0xa0, 0x05, 0x5b, 0x13, 0xf9,
	0x2a, 0xa5, 0x4d, 0x6a, 0x2e, 0x3a, 0x08, 0xe6, 0xc4, 0x59, 0x85, 0xf3, 0xdb, 0x80, 0x5c, 0x4a,
	0xc4, 0xf7, 0x90, 0x6d, 0xf5, 0x39, 0x3b, 0x65, 0xb2, 0xad, 0x06, 0x90, 0x2b, 0xe7, 0x5d, 0xb5,
	0x99, 0x91, 0xea, 0x15, 0xee, 0x07, 0x25, 0xf2, 0x38, 0x28, 0xad, 0x1c, 0x84, 0xdd, 0x4e, 0xd8,
	0x65, 0x34, 0x31, 0xe0, 0x07, 0x58, 0x69, 0x5e, 0x7e, 0x56, 0x5e, 0x43, 0x79, 0xd7, 0x63, 0xaf,
	0x16, 0xbd, 0x6d, 0x6d, 0xcd, 0x0f, 0xd5, 0x83, 0xe8, 0x36, 0x94, 0xec, 0x96, 0xcb, 0x3e, 0x1d,
	0xb9, 0xf0, 0x10, 0x96, 0x86, 0x0b, 0x56, 0x9b, 0xca, 0x95, 0xb7, 0x67, 0x0c, 0x98, 0xb3, 0xc0,
	0xc3, 0x21, 0x42, 0x70, 0x16, 0xa4, 0x10, 0xca, 0x87, 0xb5, 0x64, 0x45, 0x4b, 0x8a, 0x60, 0xcd,
	0x5b, 0x91, 0xb7, 0xf5, 0x38, 0x28, 0x99, 0x42, 0x3d, 0xa7, 0x28, 0xda, 0x8d, 0x1e, 0x64, 0xd4,
	0x78, 0xac, 0x8c, 0xc2, 0xec, 0xcc, 0xc6, 0x08, 0x6f, 0xf3, 0x71, 0x50, 0x2a, 0x0c, 0x29, 0x69,
	0x48, 0x6c, 0x75, 0x6a, 0x80, 0xa9, 0x7a, 0xca, 0xbe, 0xde, 0x31, 0x21, 0xf1, 0x0d, 0xac, 0xe8,
	0x47, 0x3d, 0xde, 0x39, 0x4d, 0xd2, 0x51, 0x99, 0xf3, 0x1d, 0x36, 0xc7, 0x38, 0x82, 0x47, 0x5d,
	0xc1, 0xd0, 0x85, 0xd5, 0x23, 0x1e, 0xea, 0x6e, 0x89, 0xfa, 0x20, 0x4d, 0x37, 0xbe, 0x37, 0x89,
	0x4e, 0x9f, 0x4a, 0xf0, 0x1d, 0x64, 0x47, 0x5e, 0xbd, 0x9c, 0xb9, 0xc3, 0xa1, 0x49, 0xa5, 0xf3,
	0x0a, 0x9e, 0xa5, 0xd2, 0xc7, 0x2c, 0xe9, 0x23, 0xbe, 0x64, 0x64, 0x74, 0xc9, 0xca, 0x3f, 0x09,
	0xe4, 0xd3, 0xa0, 0x6f, 0x01, 0x9e, 0x8e, 0x0d, 0x40, 0x7f, 0xfa, 0xf8, 0x7c, 0xfa, 0xad, 0x9a,
	0x69, 0xdb, 0xb3, 0x52, 0xfa, 0x20, 0x0b, 0x78, 0x32, 0xf6, 0x82, 0x63, 0x26, 0x71, 0x77, 0xba,
	0xfe, 0xe9, 0x84, 0xff, 0xa7, 0x79, 0x6b, 0xbf, 0x1e, 0x8a, 0xe4, 0xfe, 0xa1, 0x48, 0xfe, 0x3c,
	0x14, 0xc9, 0xe5, 0xb2, 0xfa, 0xab, 0x79, 0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x40, 0x9e,
	0xee, 0xb0, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TechSupportSvcClient is the client API for TechSupportSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TechSupportSvcClient interface {
	// TechSupportCollect initiates a new techsupport information collection
	// NOTE: This API will fail, if there is already one pending request in
	//       progress
	TechSupportCollect(ctx context.Context, in *TechSupportRequest, opts ...grpc.CallOption) (*TechSupportResponse, error)
	// TechSupportGet returns the current status of techsupport job
	TechSupportGet(ctx context.Context, in *TechSupportGetRequest, opts ...grpc.CallOption) (*TechSupportResponse, error)
}

type techSupportSvcClient struct {
	cc *grpc.ClientConn
}

func NewTechSupportSvcClient(cc *grpc.ClientConn) TechSupportSvcClient {
	return &techSupportSvcClient{cc}
}

func (c *techSupportSvcClient) TechSupportCollect(ctx context.Context, in *TechSupportRequest, opts ...grpc.CallOption) (*TechSupportResponse, error) {
	out := new(TechSupportResponse)
	err := c.cc.Invoke(ctx, "/operd.TechSupportSvc/TechSupportCollect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *techSupportSvcClient) TechSupportGet(ctx context.Context, in *TechSupportGetRequest, opts ...grpc.CallOption) (*TechSupportResponse, error) {
	out := new(TechSupportResponse)
	err := c.cc.Invoke(ctx, "/operd.TechSupportSvc/TechSupportGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TechSupportSvcServer is the server API for TechSupportSvc service.
type TechSupportSvcServer interface {
	// TechSupportCollect initiates a new techsupport information collection
	// NOTE: This API will fail, if there is already one pending request in
	//       progress
	TechSupportCollect(context.Context, *TechSupportRequest) (*TechSupportResponse, error)
	// TechSupportGet returns the current status of techsupport job
	TechSupportGet(context.Context, *TechSupportGetRequest) (*TechSupportResponse, error)
}

// UnimplementedTechSupportSvcServer can be embedded to have forward compatible implementations.
type UnimplementedTechSupportSvcServer struct {
}

func (*UnimplementedTechSupportSvcServer) TechSupportCollect(ctx context.Context, req *TechSupportRequest) (*TechSupportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TechSupportCollect not implemented")
}
func (*UnimplementedTechSupportSvcServer) TechSupportGet(ctx context.Context, req *TechSupportGetRequest) (*TechSupportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TechSupportGet not implemented")
}

func RegisterTechSupportSvcServer(s *grpc.Server, srv TechSupportSvcServer) {
	s.RegisterService(&_TechSupportSvc_serviceDesc, srv)
}

func _TechSupportSvc_TechSupportCollect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechSupportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TechSupportSvcServer).TechSupportCollect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.TechSupportSvc/TechSupportCollect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TechSupportSvcServer).TechSupportCollect(ctx, req.(*TechSupportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TechSupportSvc_TechSupportGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechSupportGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TechSupportSvcServer).TechSupportGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.TechSupportSvc/TechSupportGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TechSupportSvcServer).TechSupportGet(ctx, req.(*TechSupportGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TechSupportSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "operd.TechSupportSvc",
	HandlerType: (*TechSupportSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TechSupportCollect",
			Handler:    _TechSupportSvc_TechSupportCollect_Handler,
		},
		{
			MethodName: "TechSupportGet",
			Handler:    _TechSupportSvc_TechSupportGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "techsupport.proto",
}

func (m *TechSupportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Async {
		i--
		if m.Async {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTechsupport(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.SkipCores {
		i--
		if m.SkipCores {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TechSupportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintTechsupport(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintTechsupport(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechSupportStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TechSupport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechSupportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechSupportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTechsupport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTechsupport(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TechSupportGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechSupportGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechSupportGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTechsupport(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTechsupport(dAtA []byte, offset int, v uint64) int {
	offset -= sovTechsupport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TechSupportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkipCores {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.Async {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupportStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTechsupport(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupportStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTechsupport(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechSupportGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTechsupport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTechsupport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTechsupport(x uint64) (n int) {
	return sovTechsupport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TechSupportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCores", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipCores = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Async", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Async = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TechSupportStatus_CollectStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &TechSupportSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TechSupportStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TechSupportStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &TechSupportSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= pds1.ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &TechSupportStatus{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechSupportGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechSupportGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechSupportGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTechsupport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTechsupport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTechsupport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTechsupport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTechsupport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTechsupport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTechsupport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTechsupport
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTechsupport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTechsupport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTechsupport(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTechsupport
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTechsupport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTechsupport   = fmt.Errorf("proto: integer overflow")
)
