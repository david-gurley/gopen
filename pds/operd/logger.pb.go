// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: logger.proto

package operd

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	pds "github.com/david-gurley/gopen/pds"
	pds1 "github.com/david-gurley/gopen/pds/meta/pds"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Source int32

const (
	Source_SOURCE_NONE       Source = 0
	Source_SOURCE_EVENTS     Source = 1
	Source_SOURCE_FLOWLOG    Source = 2
	Source_SOURCE_SYSMGRLOGS Source = 3
)

var Source_name = map[int32]string{
	0: "SOURCE_NONE",
	1: "SOURCE_EVENTS",
	2: "SOURCE_FLOWLOG",
	3: "SOURCE_SYSMGRLOGS",
}

var Source_value = map[string]int32{
	"SOURCE_NONE":       0,
	"SOURCE_EVENTS":     1,
	"SOURCE_FLOWLOG":    2,
	"SOURCE_SYSMGRLOGS": 3,
}

func (x Source) String() string {
	return proto.EnumName(Source_name, int32(x))
}

func (Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{0}
}

type SyslogProtocol int32

const (
	SyslogProtocol_SYSLOG_PROTOCOL_NONE SyslogProtocol = 0
	SyslogProtocol_SYSLOG_PROTOCOL_BSD  SyslogProtocol = 1
	SyslogProtocol_SYSLOG_PROTOCOL_RFC  SyslogProtocol = 2
)

var SyslogProtocol_name = map[int32]string{
	0: "SYSLOG_PROTOCOL_NONE",
	1: "SYSLOG_PROTOCOL_BSD",
	2: "SYSLOG_PROTOCOL_RFC",
}

var SyslogProtocol_value = map[string]int32{
	"SYSLOG_PROTOCOL_NONE": 0,
	"SYSLOG_PROTOCOL_BSD":  1,
	"SYSLOG_PROTOCOL_RFC":  2,
}

func (x SyslogProtocol) String() string {
	return proto.EnumName(SyslogProtocol_name, int32(x))
}

func (SyslogProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{1}
}

type LoggerCreateRequest struct {
	Request              []*LoggerSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LoggerCreateRequest) Reset()         { *m = LoggerCreateRequest{} }
func (m *LoggerCreateRequest) String() string { return proto.CompactTextString(m) }
func (*LoggerCreateRequest) ProtoMessage()    {}
func (*LoggerCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{0}
}
func (m *LoggerCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerCreateRequest.Merge(m, src)
}
func (m *LoggerCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoggerCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerCreateRequest proto.InternalMessageInfo

func (m *LoggerCreateRequest) GetRequest() []*LoggerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type LoggerCreateResponse struct {
	ApiStatus            []pds.ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LoggerCreateResponse) Reset()         { *m = LoggerCreateResponse{} }
func (m *LoggerCreateResponse) String() string { return proto.CompactTextString(m) }
func (*LoggerCreateResponse) ProtoMessage()    {}
func (*LoggerCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{1}
}
func (m *LoggerCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerCreateResponse.Merge(m, src)
}
func (m *LoggerCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoggerCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerCreateResponse proto.InternalMessageInfo

func (m *LoggerCreateResponse) GetApiStatus() []pds.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

type LoggerUpdateRequest struct {
	Request              []*LoggerSpec `protobuf:"bytes,1,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LoggerUpdateRequest) Reset()         { *m = LoggerUpdateRequest{} }
func (m *LoggerUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*LoggerUpdateRequest) ProtoMessage()    {}
func (*LoggerUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{2}
}
func (m *LoggerUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerUpdateRequest.Merge(m, src)
}
func (m *LoggerUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoggerUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerUpdateRequest proto.InternalMessageInfo

func (m *LoggerUpdateRequest) GetRequest() []*LoggerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type LoggerUpdateResponse struct {
	ApiStatus            []pds.ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LoggerUpdateResponse) Reset()         { *m = LoggerUpdateResponse{} }
func (m *LoggerUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*LoggerUpdateResponse) ProtoMessage()    {}
func (*LoggerUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{3}
}
func (m *LoggerUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerUpdateResponse.Merge(m, src)
}
func (m *LoggerUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoggerUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerUpdateResponse proto.InternalMessageInfo

func (m *LoggerUpdateResponse) GetApiStatus() []pds.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

type LoggerGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoggerGetRequest) Reset()         { *m = LoggerGetRequest{} }
func (m *LoggerGetRequest) String() string { return proto.CompactTextString(m) }
func (*LoggerGetRequest) ProtoMessage()    {}
func (*LoggerGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{4}
}
func (m *LoggerGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerGetRequest.Merge(m, src)
}
func (m *LoggerGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoggerGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerGetRequest proto.InternalMessageInfo

func (m *LoggerGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type LoggerGetResponse struct {
	ApiStatus            pds.ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Logger     `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LoggerGetResponse) Reset()         { *m = LoggerGetResponse{} }
func (m *LoggerGetResponse) String() string { return proto.CompactTextString(m) }
func (*LoggerGetResponse) ProtoMessage()    {}
func (*LoggerGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{5}
}
func (m *LoggerGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerGetResponse.Merge(m, src)
}
func (m *LoggerGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoggerGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerGetResponse proto.InternalMessageInfo

func (m *LoggerGetResponse) GetApiStatus() pds.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return pds.ApiStatus_API_STATUS_OK
}

func (m *LoggerGetResponse) GetResponse() []*Logger {
	if m != nil {
		return m.Response
	}
	return nil
}

type LoggerDeleteRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoggerDeleteRequest) Reset()         { *m = LoggerDeleteRequest{} }
func (m *LoggerDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*LoggerDeleteRequest) ProtoMessage()    {}
func (*LoggerDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{6}
}
func (m *LoggerDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerDeleteRequest.Merge(m, src)
}
func (m *LoggerDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoggerDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerDeleteRequest proto.InternalMessageInfo

func (m *LoggerDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type LoggerDeleteResponse struct {
	ApiStatus            []pds.ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LoggerDeleteResponse) Reset()         { *m = LoggerDeleteResponse{} }
func (m *LoggerDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*LoggerDeleteResponse) ProtoMessage()    {}
func (*LoggerDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{7}
}
func (m *LoggerDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerDeleteResponse.Merge(m, src)
}
func (m *LoggerDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoggerDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerDeleteResponse proto.InternalMessageInfo

func (m *LoggerDeleteResponse) GetApiStatus() []pds.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

type SyslogSpec struct {
	RemoteAddr           *pds.IPAddress `protobuf:"bytes,1,opt,name=RemoteAddr,proto3" json:"RemoteAddr,omitempty"`
	RemotePort           uint32         `protobuf:"varint,2,opt,name=RemotePort,proto3" json:"RemotePort,omitempty"`
	Protocol             SyslogProtocol `protobuf:"varint,3,opt,name=Protocol,proto3,enum=operd.SyslogProtocol" json:"Protocol,omitempty"`
	Facility             uint32         `protobuf:"varint,4,opt,name=Facility,proto3" json:"Facility,omitempty"`
	Hostname             string         `protobuf:"bytes,5,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	AppName              string         `protobuf:"bytes,6,opt,name=AppName,proto3" json:"AppName,omitempty"`
	ProcID               string         `protobuf:"bytes,7,opt,name=ProcID,proto3" json:"ProcID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SyslogSpec) Reset()         { *m = SyslogSpec{} }
func (m *SyslogSpec) String() string { return proto.CompactTextString(m) }
func (*SyslogSpec) ProtoMessage()    {}
func (*SyslogSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{8}
}
func (m *SyslogSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyslogSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyslogSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyslogSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyslogSpec.Merge(m, src)
}
func (m *SyslogSpec) XXX_Size() int {
	return m.Size()
}
func (m *SyslogSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SyslogSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SyslogSpec proto.InternalMessageInfo

func (m *SyslogSpec) GetRemoteAddr() *pds.IPAddress {
	if m != nil {
		return m.RemoteAddr
	}
	return nil
}

func (m *SyslogSpec) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

func (m *SyslogSpec) GetProtocol() SyslogProtocol {
	if m != nil {
		return m.Protocol
	}
	return SyslogProtocol_SYSLOG_PROTOCOL_NONE
}

func (m *SyslogSpec) GetFacility() uint32 {
	if m != nil {
		return m.Facility
	}
	return 0
}

func (m *SyslogSpec) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *SyslogSpec) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *SyslogSpec) GetProcID() string {
	if m != nil {
		return m.ProcID
	}
	return ""
}

type FileSpec struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Level                uint32   `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	MaxFileSizeMB        uint32   `protobuf:"varint,3,opt,name=MaxFileSizeMB,proto3" json:"MaxFileSizeMB,omitempty"`
	MaxFiles             uint32   `protobuf:"varint,4,opt,name=MaxFiles,proto3" json:"MaxFiles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileSpec) Reset()         { *m = FileSpec{} }
func (m *FileSpec) String() string { return proto.CompactTextString(m) }
func (*FileSpec) ProtoMessage()    {}
func (*FileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{9}
}
func (m *FileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileSpec.Merge(m, src)
}
func (m *FileSpec) XXX_Size() int {
	return m.Size()
}
func (m *FileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FileSpec proto.InternalMessageInfo

func (m *FileSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileSpec) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *FileSpec) GetMaxFileSizeMB() uint32 {
	if m != nil {
		return m.MaxFileSizeMB
	}
	return 0
}

func (m *FileSpec) GetMaxFiles() uint32 {
	if m != nil {
		return m.MaxFiles
	}
	return 0
}

type PSMExportSpec struct {
	Level                uint32   `protobuf:"varint,1,opt,name=Level,proto3" json:"Level,omitempty"`
	MaxFileSizeMB        uint32   `protobuf:"varint,2,opt,name=MaxFileSizeMB,proto3" json:"MaxFileSizeMB,omitempty"`
	MaxFiles             uint32   `protobuf:"varint,3,opt,name=MaxFiles,proto3" json:"MaxFiles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSMExportSpec) Reset()         { *m = PSMExportSpec{} }
func (m *PSMExportSpec) String() string { return proto.CompactTextString(m) }
func (*PSMExportSpec) ProtoMessage()    {}
func (*PSMExportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{10}
}
func (m *PSMExportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSMExportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSMExportSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSMExportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSMExportSpec.Merge(m, src)
}
func (m *PSMExportSpec) XXX_Size() int {
	return m.Size()
}
func (m *PSMExportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PSMExportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PSMExportSpec proto.InternalMessageInfo

func (m *PSMExportSpec) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PSMExportSpec) GetMaxFileSizeMB() uint32 {
	if m != nil {
		return m.MaxFileSizeMB
	}
	return 0
}

func (m *PSMExportSpec) GetMaxFiles() uint32 {
	if m != nil {
		return m.MaxFiles
	}
	return 0
}

type RonSpec struct {
	RemoteAddr           *pds.IPAddress `protobuf:"bytes,1,opt,name=RemoteAddr,proto3" json:"RemoteAddr,omitempty"`
	RemotePort           uint32         `protobuf:"varint,2,opt,name=RemotePort,proto3" json:"RemotePort,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RonSpec) Reset()         { *m = RonSpec{} }
func (m *RonSpec) String() string { return proto.CompactTextString(m) }
func (*RonSpec) ProtoMessage()    {}
func (*RonSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{11}
}
func (m *RonSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RonSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RonSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RonSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RonSpec.Merge(m, src)
}
func (m *RonSpec) XXX_Size() int {
	return m.Size()
}
func (m *RonSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RonSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RonSpec proto.InternalMessageInfo

func (m *RonSpec) GetRemoteAddr() *pds.IPAddress {
	if m != nil {
		return m.RemoteAddr
	}
	return nil
}

func (m *RonSpec) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

type LoggerSpec struct {
	Id     []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Source []Source `protobuf:"varint,2,rep,packed,name=Source,proto3,enum=operd.Source" json:"Source,omitempty"`
	// Types that are valid to be assigned to Config:
	//	*LoggerSpec_SyslogConfig
	//	*LoggerSpec_FileConfig
	//	*LoggerSpec_PSMConfig
	//	*LoggerSpec_RonConfig
	Config               isLoggerSpec_Config `protobuf_oneof:"config"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LoggerSpec) Reset()         { *m = LoggerSpec{} }
func (m *LoggerSpec) String() string { return proto.CompactTextString(m) }
func (*LoggerSpec) ProtoMessage()    {}
func (*LoggerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{12}
}
func (m *LoggerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggerSpec.Merge(m, src)
}
func (m *LoggerSpec) XXX_Size() int {
	return m.Size()
}
func (m *LoggerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LoggerSpec proto.InternalMessageInfo

type isLoggerSpec_Config interface {
	isLoggerSpec_Config()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LoggerSpec_SyslogConfig struct {
	SyslogConfig *SyslogSpec `protobuf:"bytes,3,opt,name=SyslogConfig,proto3,oneof"`
}
type LoggerSpec_FileConfig struct {
	FileConfig *FileSpec `protobuf:"bytes,4,opt,name=FileConfig,proto3,oneof"`
}
type LoggerSpec_PSMConfig struct {
	PSMConfig *PSMExportSpec `protobuf:"bytes,5,opt,name=PSMConfig,proto3,oneof"`
}
type LoggerSpec_RonConfig struct {
	RonConfig *RonSpec `protobuf:"bytes,6,opt,name=RonConfig,proto3,oneof"`
}

func (*LoggerSpec_SyslogConfig) isLoggerSpec_Config() {}
func (*LoggerSpec_FileConfig) isLoggerSpec_Config()   {}
func (*LoggerSpec_PSMConfig) isLoggerSpec_Config()    {}
func (*LoggerSpec_RonConfig) isLoggerSpec_Config()    {}

func (m *LoggerSpec) GetConfig() isLoggerSpec_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *LoggerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LoggerSpec) GetSource() []Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *LoggerSpec) GetSyslogConfig() *SyslogSpec {
	if x, ok := m.GetConfig().(*LoggerSpec_SyslogConfig); ok {
		return x.SyslogConfig
	}
	return nil
}

func (m *LoggerSpec) GetFileConfig() *FileSpec {
	if x, ok := m.GetConfig().(*LoggerSpec_FileConfig); ok {
		return x.FileConfig
	}
	return nil
}

func (m *LoggerSpec) GetPSMConfig() *PSMExportSpec {
	if x, ok := m.GetConfig().(*LoggerSpec_PSMConfig); ok {
		return x.PSMConfig
	}
	return nil
}

func (m *LoggerSpec) GetRonConfig() *RonSpec {
	if x, ok := m.GetConfig().(*LoggerSpec_RonConfig); ok {
		return x.RonConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LoggerSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LoggerSpec_SyslogConfig)(nil),
		(*LoggerSpec_FileConfig)(nil),
		(*LoggerSpec_PSMConfig)(nil),
		(*LoggerSpec_RonConfig)(nil),
	}
}

type Logger struct {
	*pds1.TypeMeta       `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds1.ObjMeta        `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *LoggerSpec `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Logger) Reset()         { *m = Logger{} }
func (m *Logger) String() string { return proto.CompactTextString(m) }
func (*Logger) ProtoMessage()    {}
func (*Logger) Descriptor() ([]byte, []int) {
	return fileDescriptor_d43b7bfc6b6f7b16, []int{13}
}
func (m *Logger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Logger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Logger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Logger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Logger.Merge(m, src)
}
func (m *Logger) XXX_Size() int {
	return m.Size()
}
func (m *Logger) XXX_DiscardUnknown() {
	xxx_messageInfo_Logger.DiscardUnknown(m)
}

var xxx_messageInfo_Logger proto.InternalMessageInfo

func (m *Logger) GetSpec() *LoggerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func init() {
	proto.RegisterEnum("operd.Source", Source_name, Source_value)
	proto.RegisterEnum("operd.SyslogProtocol", SyslogProtocol_name, SyslogProtocol_value)
	proto.RegisterType((*LoggerCreateRequest)(nil), "operd.LoggerCreateRequest")
	proto.RegisterType((*LoggerCreateResponse)(nil), "operd.LoggerCreateResponse")
	proto.RegisterType((*LoggerUpdateRequest)(nil), "operd.LoggerUpdateRequest")
	proto.RegisterType((*LoggerUpdateResponse)(nil), "operd.LoggerUpdateResponse")
	proto.RegisterType((*LoggerGetRequest)(nil), "operd.LoggerGetRequest")
	proto.RegisterType((*LoggerGetResponse)(nil), "operd.LoggerGetResponse")
	proto.RegisterType((*LoggerDeleteRequest)(nil), "operd.LoggerDeleteRequest")
	proto.RegisterType((*LoggerDeleteResponse)(nil), "operd.LoggerDeleteResponse")
	proto.RegisterType((*SyslogSpec)(nil), "operd.SyslogSpec")
	proto.RegisterType((*FileSpec)(nil), "operd.FileSpec")
	proto.RegisterType((*PSMExportSpec)(nil), "operd.PSMExportSpec")
	proto.RegisterType((*RonSpec)(nil), "operd.RonSpec")
	proto.RegisterType((*LoggerSpec)(nil), "operd.LoggerSpec")
	proto.RegisterType((*Logger)(nil), "operd.Logger")
}

func init() { proto.RegisterFile("logger.proto", fileDescriptor_d43b7bfc6b6f7b16) }

var fileDescriptor_d43b7bfc6b6f7b16 = []byte{
	// 876 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdf, 0x6e, 0xdb, 0x54,
	0x18, 0x8f, 0xdd, 0x36, 0x7f, 0xbe, 0x26, 0xae, 0x7b, 0xd6, 0x6d, 0x56, 0x90, 0xba, 0xca, 0x62,
	0x52, 0x19, 0x53, 0x60, 0x05, 0x09, 0x21, 0x2e, 0xa0, 0x4e, 0x93, 0x34, 0x52, 0x52, 0x5b, 0xc7,
	0x1d, 0xd3, 0x04, 0xd2, 0xe4, 0x39, 0x87, 0x60, 0xe4, 0xf8, 0x18, 0xfb, 0xb4, 0x5a, 0x78, 0x19,
	0xde, 0x80, 0x77, 0xe0, 0x8e, 0xcb, 0x3d, 0xc1, 0x84, 0x7a, 0xc9, 0x2b, 0x70, 0x83, 0x7c, 0x7c,
	0x8e, 0x1d, 0x7b, 0x15, 0x93, 0x86, 0xb8, 0x89, 0x7c, 0x7e, 0xdf, 0xef, 0xf7, 0xfd, 0x3b, 0x9f,
	0xfd, 0x05, 0xba, 0x21, 0x5d, 0x2e, 0x49, 0x32, 0x88, 0x13, 0xca, 0x28, 0xda, 0xa1, 0x31, 0x49,
	0x16, 0x7d, 0x58, 0xd2, 0x25, 0xcd, 0xa1, 0xfe, 0xde, 0x8a, 0x30, 0xef, 0x93, 0xec, 0x47, 0x00,
	0xbb, 0x6c, 0x1d, 0x93, 0x34, 0x3f, 0x98, 0x16, 0xdc, 0x99, 0x71, 0x07, 0xc3, 0x84, 0x78, 0x8c,
	0x60, 0xf2, 0xf3, 0x15, 0x49, 0x19, 0xfa, 0x18, 0x5a, 0xe2, 0xd1, 0x50, 0x8e, 0xb6, 0x8e, 0x77,
	0x4f, 0xf6, 0x07, 0xdc, 0xf3, 0x20, 0x27, 0xbb, 0x31, 0xf1, 0xb1, 0x64, 0x98, 0x63, 0x38, 0xa8,
	0xfa, 0x48, 0x63, 0x1a, 0xa5, 0x04, 0x0d, 0xa0, 0x73, 0x1a, 0x07, 0x2e, 0xf3, 0xd8, 0x55, 0xca,
	0xdd, 0x68, 0x27, 0xfa, 0x20, 0x0f, 0x5e, 0xe0, 0xb8, 0xa4, 0x94, 0xb9, 0x3c, 0x8d, 0x17, 0xff,
	0x39, 0x17, 0xe9, 0xe3, 0x3d, 0x73, 0x31, 0x41, 0xcf, 0xfd, 0x4c, 0x08, 0x93, 0x89, 0x68, 0xa0,
	0x4e, 0x17, 0x5c, 0xdc, 0xc5, 0xea, 0x74, 0x61, 0x46, 0xb0, 0xbf, 0xc1, 0xb9, 0x3d, 0x90, 0xf2,
	0x8e, 0x40, 0xe8, 0x23, 0x68, 0x4b, 0xad, 0xa1, 0xf2, 0xf2, 0x7a, 0x95, 0xf2, 0x70, 0x61, 0x36,
	0x1f, 0xca, 0xfe, 0x9c, 0x91, 0x90, 0x94, 0xfd, 0xa9, 0xa7, 0x55, 0xb4, 0x40, 0xd2, 0xde, 0xb3,
	0x05, 0x7f, 0x2b, 0x00, 0xee, 0x3a, 0x0d, 0xe9, 0x32, 0x6b, 0x31, 0xfa, 0x14, 0x00, 0x93, 0x15,
	0x65, 0xe4, 0x74, 0xb1, 0x48, 0x78, 0x65, 0xbb, 0x85, 0x7e, 0xea, 0x64, 0x20, 0x49, 0x53, 0xbc,
	0xc1, 0x41, 0x87, 0x52, 0xe1, 0xd0, 0x84, 0x19, 0xea, 0x91, 0x72, 0xdc, 0xc3, 0x1b, 0x08, 0x7a,
	0x02, 0x6d, 0x27, 0x1b, 0x42, 0x9f, 0x86, 0xc6, 0x16, 0xef, 0xd4, 0x5d, 0x51, 0x7a, 0x1e, 0x56,
	0x1a, 0x71, 0x41, 0x43, 0x7d, 0x68, 0x8f, 0x3d, 0x3f, 0x08, 0x03, 0xb6, 0x36, 0xb6, 0xb9, 0xc3,
	0xe2, 0x9c, 0xd9, 0xce, 0x69, 0xca, 0x22, 0x6f, 0x45, 0x8c, 0x9d, 0x23, 0xe5, 0xb8, 0x83, 0x8b,
	0x33, 0x32, 0xa0, 0x75, 0x1a, 0xc7, 0x17, 0x99, 0xa9, 0xc9, 0x4d, 0xf2, 0x88, 0xee, 0x41, 0xd3,
	0x49, 0xa8, 0x3f, 0x3d, 0x33, 0x5a, 0xdc, 0x20, 0x4e, 0xe6, 0x35, 0xb4, 0xc7, 0x41, 0x48, 0x78,
	0xe9, 0x08, 0xb6, 0x1d, 0x8f, 0xfd, 0xc8, 0x8b, 0xee, 0x60, 0xfe, 0x8c, 0x0e, 0x60, 0x67, 0x46,
	0xae, 0x49, 0x28, 0xea, 0xca, 0x0f, 0xe8, 0x43, 0xe8, 0xcd, 0xbd, 0x57, 0x5c, 0x18, 0xfc, 0x42,
	0xe6, 0x16, 0xaf, 0xab, 0x87, 0xab, 0x60, 0x96, 0xa9, 0x00, 0x52, 0x59, 0x85, 0x3c, 0x9b, 0x4b,
	0xe8, 0x39, 0xee, 0x7c, 0xf4, 0x2a, 0xa6, 0x09, 0xe3, 0xc1, 0x8b, 0x40, 0xca, 0xbf, 0x06, 0x52,
	0xdf, 0x15, 0x68, 0xab, 0x16, 0xe8, 0x3b, 0x68, 0x61, 0x1a, 0xfd, 0x3f, 0x57, 0x6b, 0xfe, 0xaa,
	0x02, 0x94, 0xaf, 0x67, 0x31, 0xa2, 0x4a, 0x3e, 0xa2, 0xe8, 0x21, 0x34, 0x5d, 0x7a, 0x95, 0xf8,
	0xf9, 0xc8, 0x6b, 0xc5, 0xc8, 0xe7, 0x20, 0x16, 0x46, 0xf4, 0x05, 0x74, 0xf3, 0x49, 0x18, 0xd2,
	0xe8, 0x87, 0x60, 0xc9, 0x4b, 0x28, 0x5f, 0xff, 0x72, 0x36, 0xcf, 0x1b, 0xb8, 0x42, 0x44, 0x4f,
	0x00, 0xb2, 0x22, 0x85, 0x6c, 0x9b, 0xcb, 0xf6, 0x84, 0x4c, 0xde, 0xea, 0x79, 0x03, 0x6f, 0x90,
	0xd0, 0xe7, 0xd0, 0x71, 0xdc, 0xb9, 0x50, 0xec, 0x70, 0xc5, 0x81, 0x50, 0x54, 0xee, 0xe3, 0xbc,
	0x81, 0x4b, 0x62, 0xf6, 0x4e, 0x61, 0x1a, 0x09, 0x55, 0x93, 0xab, 0x34, 0xa1, 0x12, 0xcd, 0xcd,
	0xf8, 0x05, 0xc5, 0x6a, 0x43, 0xd3, 0xe7, 0x4f, 0xe6, 0xef, 0x0a, 0x34, 0xf3, 0x0e, 0xa1, 0xaf,
	0xa0, 0x7d, 0xb9, 0x8e, 0xc9, 0x9c, 0x30, 0x4f, 0x34, 0x5f, 0x1b, 0xf0, 0xef, 0xb5, 0x44, 0xad,
	0xbd, 0xd7, 0x6f, 0x1e, 0x28, 0x7f, 0xbd, 0x79, 0xd0, 0x7a, 0x1c, 0x44, 0x61, 0x10, 0x11, 0x5c,
	0x08, 0xd0, 0xd7, 0xd0, 0xb2, 0x5f, 0xfe, 0xc4, 0xb5, 0x2a, 0xd7, 0xf6, 0x72, 0xad, 0x00, 0xad,
	0x7b, 0x42, 0xaa, 0x65, 0xe8, 0x63, 0xba, 0x0a, 0x18, 0x59, 0xc5, 0x6c, 0x8d, 0xa5, 0x0a, 0x7d,
	0x09, 0xdb, 0x59, 0x9e, 0xb5, 0xe6, 0x96, 0x97, 0x67, 0xa1, 0x4c, 0x9d, 0xc6, 0xc4, 0xdf, 0x50,
	0x73, 0xc9, 0xa3, 0x67, 0xf2, 0x1a, 0xd1, 0x1e, 0xec, 0xba, 0xf6, 0x53, 0x3c, 0x1c, 0xbd, 0xb8,
	0xb0, 0x2f, 0x46, 0x7a, 0x03, 0xed, 0x43, 0x4f, 0x00, 0xa3, 0x6f, 0x47, 0x17, 0x97, 0xae, 0xae,
	0x20, 0x04, 0x9a, 0x80, 0xc6, 0x33, 0xfb, 0xd9, 0xcc, 0x9e, 0xe8, 0x2a, 0xba, 0x0b, 0xfb, 0x02,
	0x73, 0x9f, 0xbb, 0xf3, 0x09, 0x9e, 0xd9, 0x13, 0x57, 0xdf, 0x7a, 0xf4, 0x3d, 0x68, 0xd5, 0x4f,
	0x00, 0x32, 0xe0, 0xc0, 0x7d, 0xee, 0xce, 0xec, 0xc9, 0x0b, 0x07, 0xdb, 0x97, 0xf6, 0xd0, 0x9e,
	0xc9, 0x48, 0xf7, 0xe1, 0x4e, 0xdd, 0x62, 0xb9, 0x67, 0xba, 0x72, 0x9b, 0x01, 0x8f, 0x87, 0xba,
	0x7a, 0xf2, 0x9b, 0x0a, 0x1d, 0x51, 0xdf, 0xb5, 0x8f, 0xa6, 0xd0, 0xdd, 0xdc, 0x5e, 0xa8, 0x5f,
	0xe9, 0x40, 0x65, 0x2d, 0xf6, 0x3f, 0xb8, 0xd5, 0x26, 0x3e, 0xcf, 0x8d, 0xd2, 0x55, 0xbe, 0x7c,
	0x6a, 0xae, 0x2a, 0x5b, 0xad, 0xe6, 0xaa, 0xba, 0xad, 0xcc, 0x06, 0xfa, 0x46, 0xa6, 0x38, 0x21,
	0x0c, 0xdd, 0xaf, 0x70, 0xcb, 0x8d, 0xd4, 0x37, 0xde, 0x36, 0xbc, 0x9d, 0x4c, 0xbe, 0x06, 0x6a,
	0xc9, 0x54, 0x56, 0x48, 0x2d, 0x99, 0xea, 0xde, 0x30, 0x1b, 0x56, 0xf7, 0x8f, 0x9b, 0x43, 0xe5,
	0xf5, 0xcd, 0xa1, 0xf2, 0xe7, 0xcd, 0xa1, 0xf2, 0xb2, 0xc9, 0xff, 0x39, 0x7c, 0xf6, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xe8, 0xbf, 0x63, 0x7c, 0x7a, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LoggerSvcClient is the client API for LoggerSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LoggerSvcClient interface {
	LoggerCreate(ctx context.Context, in *LoggerCreateRequest, opts ...grpc.CallOption) (*LoggerCreateResponse, error)
	LoggerUpdate(ctx context.Context, in *LoggerUpdateRequest, opts ...grpc.CallOption) (*LoggerUpdateResponse, error)
	LoggerGet(ctx context.Context, in *LoggerGetRequest, opts ...grpc.CallOption) (*LoggerGetResponse, error)
	LoggerDelete(ctx context.Context, in *LoggerDeleteRequest, opts ...grpc.CallOption) (*LoggerDeleteResponse, error)
}

type loggerSvcClient struct {
	cc *grpc.ClientConn
}

func NewLoggerSvcClient(cc *grpc.ClientConn) LoggerSvcClient {
	return &loggerSvcClient{cc}
}

func (c *loggerSvcClient) LoggerCreate(ctx context.Context, in *LoggerCreateRequest, opts ...grpc.CallOption) (*LoggerCreateResponse, error) {
	out := new(LoggerCreateResponse)
	err := c.cc.Invoke(ctx, "/operd.LoggerSvc/LoggerCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerSvcClient) LoggerUpdate(ctx context.Context, in *LoggerUpdateRequest, opts ...grpc.CallOption) (*LoggerUpdateResponse, error) {
	out := new(LoggerUpdateResponse)
	err := c.cc.Invoke(ctx, "/operd.LoggerSvc/LoggerUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerSvcClient) LoggerGet(ctx context.Context, in *LoggerGetRequest, opts ...grpc.CallOption) (*LoggerGetResponse, error) {
	out := new(LoggerGetResponse)
	err := c.cc.Invoke(ctx, "/operd.LoggerSvc/LoggerGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerSvcClient) LoggerDelete(ctx context.Context, in *LoggerDeleteRequest, opts ...grpc.CallOption) (*LoggerDeleteResponse, error) {
	out := new(LoggerDeleteResponse)
	err := c.cc.Invoke(ctx, "/operd.LoggerSvc/LoggerDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoggerSvcServer is the server API for LoggerSvc service.
type LoggerSvcServer interface {
	LoggerCreate(context.Context, *LoggerCreateRequest) (*LoggerCreateResponse, error)
	LoggerUpdate(context.Context, *LoggerUpdateRequest) (*LoggerUpdateResponse, error)
	LoggerGet(context.Context, *LoggerGetRequest) (*LoggerGetResponse, error)
	LoggerDelete(context.Context, *LoggerDeleteRequest) (*LoggerDeleteResponse, error)
}

// UnimplementedLoggerSvcServer can be embedded to have forward compatible implementations.
type UnimplementedLoggerSvcServer struct {
}

func (*UnimplementedLoggerSvcServer) LoggerCreate(ctx context.Context, req *LoggerCreateRequest) (*LoggerCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggerCreate not implemented")
}
func (*UnimplementedLoggerSvcServer) LoggerUpdate(ctx context.Context, req *LoggerUpdateRequest) (*LoggerUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggerUpdate not implemented")
}
func (*UnimplementedLoggerSvcServer) LoggerGet(ctx context.Context, req *LoggerGetRequest) (*LoggerGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggerGet not implemented")
}
func (*UnimplementedLoggerSvcServer) LoggerDelete(ctx context.Context, req *LoggerDeleteRequest) (*LoggerDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggerDelete not implemented")
}

func RegisterLoggerSvcServer(s *grpc.Server, srv LoggerSvcServer) {
	s.RegisterService(&_LoggerSvc_serviceDesc, srv)
}

func _LoggerSvc_LoggerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggerCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerSvcServer).LoggerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.LoggerSvc/LoggerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerSvcServer).LoggerCreate(ctx, req.(*LoggerCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerSvc_LoggerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggerUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerSvcServer).LoggerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.LoggerSvc/LoggerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerSvcServer).LoggerUpdate(ctx, req.(*LoggerUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerSvc_LoggerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerSvcServer).LoggerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.LoggerSvc/LoggerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerSvcServer).LoggerGet(ctx, req.(*LoggerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerSvc_LoggerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerSvcServer).LoggerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operd.LoggerSvc/LoggerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerSvcServer).LoggerDelete(ctx, req.(*LoggerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LoggerSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "operd.LoggerSvc",
	HandlerType: (*LoggerSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoggerCreate",
			Handler:    _LoggerSvc_LoggerCreate_Handler,
		},
		{
			MethodName: "LoggerUpdate",
			Handler:    _LoggerSvc_LoggerUpdate_Handler,
		},
		{
			MethodName: "LoggerGet",
			Handler:    _LoggerSvc_LoggerGet_Handler,
		},
		{
			MethodName: "LoggerDelete",
			Handler:    _LoggerSvc_LoggerDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "logger.proto",
}

func (m *LoggerCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoggerCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA2 := make([]byte, len(m.ApiStatus)*10)
		var j1 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintLogger(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoggerUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoggerUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA4 := make([]byte, len(m.ApiStatus)*10)
		var j3 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintLogger(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoggerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintLogger(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoggerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogger(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoggerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintLogger(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoggerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA6 := make([]byte, len(m.ApiStatus)*10)
		var j5 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintLogger(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyslogSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyslogSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyslogSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProcID) > 0 {
		i -= len(m.ProcID)
		copy(dAtA[i:], m.ProcID)
		i = encodeVarintLogger(dAtA, i, uint64(len(m.ProcID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintLogger(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintLogger(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Facility != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.Facility))
		i--
		dAtA[i] = 0x20
	}
	if m.Protocol != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x18
	}
	if m.RemotePort != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.RemotePort))
		i--
		dAtA[i] = 0x10
	}
	if m.RemoteAddr != nil {
		{
			size, err := m.RemoteAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxFiles != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.MaxFiles))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxFileSizeMB != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.MaxFileSizeMB))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintLogger(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PSMExportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSMExportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSMExportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxFiles != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.MaxFiles))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxFileSizeMB != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.MaxFileSizeMB))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RonSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RonSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RonSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemotePort != 0 {
		i = encodeVarintLogger(dAtA, i, uint64(m.RemotePort))
		i--
		dAtA[i] = 0x10
	}
	if m.RemoteAddr != nil {
		{
			size, err := m.RemoteAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoggerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Source) > 0 {
		dAtA10 := make([]byte, len(m.Source)*10)
		var j9 int
		for _, num := range m.Source {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintLogger(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLogger(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoggerSpec_SyslogConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LoggerSpec_SyslogConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SyslogConfig != nil {
		{
			size, err := m.SyslogConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LoggerSpec_FileConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LoggerSpec_FileConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FileConfig != nil {
		{
			size, err := m.FileConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LoggerSpec_PSMConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LoggerSpec_PSMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PSMConfig != nil {
		{
			size, err := m.PSMConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *LoggerSpec_RonConfig) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LoggerSpec_RonConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RonConfig != nil {
		{
			size, err := m.RonConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Logger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Logger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Logger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogger(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLogger(dAtA []byte, offset int, v uint64) int {
	offset -= sovLogger(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LoggerCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLogger(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovLogger(uint64(e))
		}
		n += 1 + sovLogger(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovLogger(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovLogger(uint64(e))
		}
		n += 1 + sovLogger(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovLogger(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovLogger(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovLogger(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovLogger(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovLogger(uint64(e))
		}
		n += 1 + sovLogger(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyslogSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteAddr != nil {
		l = m.RemoteAddr.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.RemotePort != 0 {
		n += 1 + sovLogger(uint64(m.RemotePort))
	}
	if m.Protocol != 0 {
		n += 1 + sovLogger(uint64(m.Protocol))
	}
	if m.Facility != 0 {
		n += 1 + sovLogger(uint64(m.Facility))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovLogger(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovLogger(uint64(l))
	}
	l = len(m.ProcID)
	if l > 0 {
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovLogger(uint64(m.Level))
	}
	if m.MaxFileSizeMB != 0 {
		n += 1 + sovLogger(uint64(m.MaxFileSizeMB))
	}
	if m.MaxFiles != 0 {
		n += 1 + sovLogger(uint64(m.MaxFiles))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSMExportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovLogger(uint64(m.Level))
	}
	if m.MaxFileSizeMB != 0 {
		n += 1 + sovLogger(uint64(m.MaxFileSizeMB))
	}
	if m.MaxFiles != 0 {
		n += 1 + sovLogger(uint64(m.MaxFiles))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RonSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteAddr != nil {
		l = m.RemoteAddr.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.RemotePort != 0 {
		n += 1 + sovLogger(uint64(m.RemotePort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLogger(uint64(l))
	}
	if len(m.Source) > 0 {
		l = 0
		for _, e := range m.Source {
			l += sovLogger(uint64(e))
		}
		n += 1 + sovLogger(uint64(l)) + l
	}
	if m.Config != nil {
		n += m.Config.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggerSpec_SyslogConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyslogConfig != nil {
		l = m.SyslogConfig.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	return n
}
func (m *LoggerSpec_FileConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileConfig != nil {
		l = m.FileConfig.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	return n
}
func (m *LoggerSpec_PSMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PSMConfig != nil {
		l = m.PSMConfig.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	return n
}
func (m *LoggerSpec_RonConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RonConfig != nil {
		l = m.RonConfig.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	return n
}
func (m *Logger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovLogger(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLogger(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLogger(x uint64) (n int) {
	return sovLogger(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoggerCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LoggerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v pds.ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= pds.ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLogger
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLogger
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]pds.ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v pds.ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= pds.ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &LoggerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v pds.ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= pds.ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLogger
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLogger
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]pds.ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v pds.ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= pds.ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= pds.ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Logger{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v pds.ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= pds.ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLogger
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLogger
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]pds.ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v pds.ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= pds.ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyslogSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyslogSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyslogSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteAddr == nil {
				m.RemoteAddr = &pds.IPAddress{}
			}
			if err := m.RemoteAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			m.RemotePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= SyslogProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facility", wireType)
			}
			m.Facility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Facility |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFileSizeMB", wireType)
			}
			m.MaxFileSizeMB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFileSizeMB |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFiles", wireType)
			}
			m.MaxFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFiles |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSMExportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSMExportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSMExportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFileSizeMB", wireType)
			}
			m.MaxFileSizeMB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFileSizeMB |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFiles", wireType)
			}
			m.MaxFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFiles |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RonSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RonSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RonSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteAddr == nil {
				m.RemoteAddr = &pds.IPAddress{}
			}
			if err := m.RemoteAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			m.RemotePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Source
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Source(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Source = append(m.Source, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLogger
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLogger
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Source) == 0 {
					m.Source = make([]Source, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Source
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogger
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Source(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Source = append(m.Source, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyslogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyslogSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &LoggerSpec_SyslogConfig{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &LoggerSpec_FileConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSMConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PSMExportSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &LoggerSpec_PSMConfig{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RonConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RonSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &LoggerSpec_RonConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Logger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Logger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Logger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds1.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogger
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogger
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &LoggerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogger(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogger
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogger(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogger
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogger
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogger
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLogger
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLogger
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLogger(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLogger
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLogger = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogger   = fmt.Errorf("proto: integer overflow")
)
