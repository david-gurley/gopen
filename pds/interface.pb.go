// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: interface.proto

package pds

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	pds "github.com/david-gurley/gopen/pds/meta/pds"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// types of interfaces
type IfType int32

const (
	IfType_IF_TYPE_NONE IfType = 0
	// uplink interface
	IfType_IF_TYPE_UPLINK IfType = 1
	// uplink port-channel interface
	IfType_IF_TYPE_UPLINK_PC IfType = 2
	// L3 interface
	IfType_IF_TYPE_L3 IfType = 3
	// loopback interface
	IfType_IF_TYPE_LOOPBACK IfType = 4
	// inband management/control interface
	IfType_IF_TYPE_CONTROL IfType = 5
	// host visible PF/VF device
	IfType_IF_TYPE_HOST IfType = 6
)

var IfType_name = map[int32]string{
	0: "IF_TYPE_NONE",
	1: "IF_TYPE_UPLINK",
	2: "IF_TYPE_UPLINK_PC",
	3: "IF_TYPE_L3",
	4: "IF_TYPE_LOOPBACK",
	5: "IF_TYPE_CONTROL",
	6: "IF_TYPE_HOST",
}

var IfType_value = map[string]int32{
	"IF_TYPE_NONE":      0,
	"IF_TYPE_UPLINK":    1,
	"IF_TYPE_UPLINK_PC": 2,
	"IF_TYPE_L3":        3,
	"IF_TYPE_LOOPBACK":  4,
	"IF_TYPE_CONTROL":   5,
	"IF_TYPE_HOST":      6,
}

func (x IfType) String() string {
	return proto.EnumName(IfType_name, int32(x))
}

func (IfType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{0}
}

// IfStatus status reflects the operational status of Interface
type IfStatus int32

const (
	IfStatus_IF_STATUS_NONE IfStatus = 0
	IfStatus_IF_STATUS_UP   IfStatus = 1
	IfStatus_IF_STATUS_DOWN IfStatus = 2
)

var IfStatus_name = map[int32]string{
	0: "IF_STATUS_NONE",
	1: "IF_STATUS_UP",
	2: "IF_STATUS_DOWN",
}

var IfStatus_value = map[string]int32{
	"IF_STATUS_NONE": 0,
	"IF_STATUS_UP":   1,
	"IF_STATUS_DOWN": 2,
}

func (x IfStatus) String() string {
	return proto.EnumName(IfStatus_name, int32(x))
}

func (IfStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{1}
}

// LLDP chassis/port Identifier key type
type LldpIdType int32

const (
	LldpIdType_LLDPID_SUBTYPE_NONE    LldpIdType = 0
	LldpIdType_LLDPID_SUBTYPE_IFNAME  LldpIdType = 1
	LldpIdType_LLDPID_SUBTYPE_IFALIAS LldpIdType = 2
	LldpIdType_LLDPID_SUBTYPE_LOCAL   LldpIdType = 3
	LldpIdType_LLDPID_SUBTYPE_MAC     LldpIdType = 4
	LldpIdType_LLDPID_SUBTYPE_IP      LldpIdType = 5
	LldpIdType_LLDPID_SUBTYPE_PORT    LldpIdType = 6
	LldpIdType_LLDPID_SUBTYPE_CHASSIS LldpIdType = 7
)

var LldpIdType_name = map[int32]string{
	0: "LLDPID_SUBTYPE_NONE",
	1: "LLDPID_SUBTYPE_IFNAME",
	2: "LLDPID_SUBTYPE_IFALIAS",
	3: "LLDPID_SUBTYPE_LOCAL",
	4: "LLDPID_SUBTYPE_MAC",
	5: "LLDPID_SUBTYPE_IP",
	6: "LLDPID_SUBTYPE_PORT",
	7: "LLDPID_SUBTYPE_CHASSIS",
}

var LldpIdType_value = map[string]int32{
	"LLDPID_SUBTYPE_NONE":    0,
	"LLDPID_SUBTYPE_IFNAME":  1,
	"LLDPID_SUBTYPE_IFALIAS": 2,
	"LLDPID_SUBTYPE_LOCAL":   3,
	"LLDPID_SUBTYPE_MAC":     4,
	"LLDPID_SUBTYPE_IP":      5,
	"LLDPID_SUBTYPE_PORT":    6,
	"LLDPID_SUBTYPE_CHASSIS": 7,
}

func (x LldpIdType) String() string {
	return proto.EnumName(LldpIdType_name, int32(x))
}

func (LldpIdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{2}
}

// Protocol used for LLDP
type LldpProtoMode int32

const (
	LldpProtoMode_LLDP_MODE_NONE  LldpProtoMode = 0
	LldpProtoMode_LLDP_MODE_LLDP  LldpProtoMode = 1
	LldpProtoMode_LLDP_MODE_CDPV1 LldpProtoMode = 2
	LldpProtoMode_LLDP_MODE_CDPV2 LldpProtoMode = 3
	LldpProtoMode_LLDP_MODE_EDP   LldpProtoMode = 4
	LldpProtoMode_LLDP_MODE_FDP   LldpProtoMode = 5
	LldpProtoMode_LLDP_MODE_SONMP LldpProtoMode = 6
)

var LldpProtoMode_name = map[int32]string{
	0: "LLDP_MODE_NONE",
	1: "LLDP_MODE_LLDP",
	2: "LLDP_MODE_CDPV1",
	3: "LLDP_MODE_CDPV2",
	4: "LLDP_MODE_EDP",
	5: "LLDP_MODE_FDP",
	6: "LLDP_MODE_SONMP",
}

var LldpProtoMode_value = map[string]int32{
	"LLDP_MODE_NONE":  0,
	"LLDP_MODE_LLDP":  1,
	"LLDP_MODE_CDPV1": 2,
	"LLDP_MODE_CDPV2": 3,
	"LLDP_MODE_EDP":   4,
	"LLDP_MODE_FDP":   5,
	"LLDP_MODE_SONMP": 6,
}

func (x LldpProtoMode) String() string {
	return proto.EnumName(LldpProtoMode_name, int32(x))
}

func (LldpProtoMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{3}
}

// Capabilities on the interfce
type LldpCapType int32

const (
	LldpCapType_LLDP_CAPTYPE_OTHER     LldpCapType = 0
	LldpCapType_LLDP_CAPTYPE_REPEATER  LldpCapType = 1
	LldpCapType_LLDP_CAPTYPE_BRIDGE    LldpCapType = 2
	LldpCapType_LLDP_CAPTYPE_ROUTER    LldpCapType = 3
	LldpCapType_LLDP_CAPTYPE_WLAN      LldpCapType = 4
	LldpCapType_LLDP_CAPTYPE_TELEPHONE LldpCapType = 5
	LldpCapType_LLDP_CAPTYPE_DOCSIS    LldpCapType = 6
	LldpCapType_LLDP_CAPTYPE_STATION   LldpCapType = 7
)

var LldpCapType_name = map[int32]string{
	0: "LLDP_CAPTYPE_OTHER",
	1: "LLDP_CAPTYPE_REPEATER",
	2: "LLDP_CAPTYPE_BRIDGE",
	3: "LLDP_CAPTYPE_ROUTER",
	4: "LLDP_CAPTYPE_WLAN",
	5: "LLDP_CAPTYPE_TELEPHONE",
	6: "LLDP_CAPTYPE_DOCSIS",
	7: "LLDP_CAPTYPE_STATION",
}

var LldpCapType_value = map[string]int32{
	"LLDP_CAPTYPE_OTHER":     0,
	"LLDP_CAPTYPE_REPEATER":  1,
	"LLDP_CAPTYPE_BRIDGE":    2,
	"LLDP_CAPTYPE_ROUTER":    3,
	"LLDP_CAPTYPE_WLAN":      4,
	"LLDP_CAPTYPE_TELEPHONE": 5,
	"LLDP_CAPTYPE_DOCSIS":    6,
	"LLDP_CAPTYPE_STATION":   7,
}

func (x LldpCapType) String() string {
	return proto.EnumName(LldpCapType_name, int32(x))
}

func (LldpCapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{4}
}

type LldpIfStats struct {
	TxCount              uint32   `protobuf:"varint,1,opt,name=TxCount,proto3" json:"TxCount,omitempty"`
	RxCount              uint32   `protobuf:"varint,2,opt,name=RxCount,proto3" json:"RxCount,omitempty"`
	RxDiscarded          uint32   `protobuf:"varint,3,opt,name=RxDiscarded,proto3" json:"RxDiscarded,omitempty"`
	RxUnrecognized       uint32   `protobuf:"varint,4,opt,name=RxUnrecognized,proto3" json:"RxUnrecognized,omitempty"`
	AgeoutCount          uint32   `protobuf:"varint,5,opt,name=AgeoutCount,proto3" json:"AgeoutCount,omitempty"`
	InsertCount          uint32   `protobuf:"varint,6,opt,name=InsertCount,proto3" json:"InsertCount,omitempty"`
	DeleteCount          uint32   `protobuf:"varint,7,opt,name=DeleteCount,proto3" json:"DeleteCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LldpIfStats) Reset()         { *m = LldpIfStats{} }
func (m *LldpIfStats) String() string { return proto.CompactTextString(m) }
func (*LldpIfStats) ProtoMessage()    {}
func (*LldpIfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{0}
}
func (m *LldpIfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpIfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpIfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpIfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpIfStats.Merge(m, src)
}
func (m *LldpIfStats) XXX_Size() int {
	return m.Size()
}
func (m *LldpIfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpIfStats.DiscardUnknown(m)
}

var xxx_messageInfo_LldpIfStats proto.InternalMessageInfo

func (m *LldpIfStats) GetTxCount() uint32 {
	if m != nil {
		return m.TxCount
	}
	return 0
}

func (m *LldpIfStats) GetRxCount() uint32 {
	if m != nil {
		return m.RxCount
	}
	return 0
}

func (m *LldpIfStats) GetRxDiscarded() uint32 {
	if m != nil {
		return m.RxDiscarded
	}
	return 0
}

func (m *LldpIfStats) GetRxUnrecognized() uint32 {
	if m != nil {
		return m.RxUnrecognized
	}
	return 0
}

func (m *LldpIfStats) GetAgeoutCount() uint32 {
	if m != nil {
		return m.AgeoutCount
	}
	return 0
}

func (m *LldpIfStats) GetInsertCount() uint32 {
	if m != nil {
		return m.InsertCount
	}
	return 0
}

func (m *LldpIfStats) GetDeleteCount() uint32 {
	if m != nil {
		return m.DeleteCount
	}
	return 0
}

// Key-type and value for Identified
type LldpId struct {
	Type                 LldpIdType `protobuf:"varint,1,opt,name=Type,proto3,enum=pds.LldpIdType" json:"Type,omitempty"`
	Value                []byte     `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LldpId) Reset()         { *m = LldpId{} }
func (m *LldpId) String() string { return proto.CompactTextString(m) }
func (*LldpId) ProtoMessage()    {}
func (*LldpId) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{1}
}
func (m *LldpId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpId.Merge(m, src)
}
func (m *LldpId) XXX_Size() int {
	return m.Size()
}
func (m *LldpId) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpId.DiscardUnknown(m)
}

var xxx_messageInfo_LldpId proto.InternalMessageInfo

func (m *LldpId) GetType() LldpIdType {
	if m != nil {
		return m.Type
	}
	return LldpIdType_LLDPID_SUBTYPE_NONE
}

func (m *LldpId) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type LldpChassisCapabilityInfo struct {
	CapType              LldpCapType `protobuf:"varint,1,opt,name=CapType,proto3,enum=pds.LldpCapType" json:"CapType,omitempty"`
	CapEnabled           bool        `protobuf:"varint,2,opt,name=CapEnabled,proto3" json:"CapEnabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LldpChassisCapabilityInfo) Reset()         { *m = LldpChassisCapabilityInfo{} }
func (m *LldpChassisCapabilityInfo) String() string { return proto.CompactTextString(m) }
func (*LldpChassisCapabilityInfo) ProtoMessage()    {}
func (*LldpChassisCapabilityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{2}
}
func (m *LldpChassisCapabilityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpChassisCapabilityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpChassisCapabilityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpChassisCapabilityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpChassisCapabilityInfo.Merge(m, src)
}
func (m *LldpChassisCapabilityInfo) XXX_Size() int {
	return m.Size()
}
func (m *LldpChassisCapabilityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpChassisCapabilityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LldpChassisCapabilityInfo proto.InternalMessageInfo

func (m *LldpChassisCapabilityInfo) GetCapType() LldpCapType {
	if m != nil {
		return m.CapType
	}
	return LldpCapType_LLDP_CAPTYPE_OTHER
}

func (m *LldpChassisCapabilityInfo) GetCapEnabled() bool {
	if m != nil {
		return m.CapEnabled
	}
	return false
}

type LldpIfChassisInfo struct {
	SysName              string                       `protobuf:"bytes,1,opt,name=SysName,proto3" json:"SysName,omitempty"`
	ChassisId            *LldpId                      `protobuf:"bytes,2,opt,name=ChassisId,proto3" json:"ChassisId,omitempty"`
	SysDescr             string                       `protobuf:"bytes,3,opt,name=SysDescr,proto3" json:"SysDescr,omitempty"`
	MgmtIP               *IPAddress                   `protobuf:"bytes,4,opt,name=MgmtIP,proto3" json:"MgmtIP,omitempty"`
	Capability           []*LldpChassisCapabilityInfo `protobuf:"bytes,5,rep,name=Capability,proto3" json:"Capability,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *LldpIfChassisInfo) Reset()         { *m = LldpIfChassisInfo{} }
func (m *LldpIfChassisInfo) String() string { return proto.CompactTextString(m) }
func (*LldpIfChassisInfo) ProtoMessage()    {}
func (*LldpIfChassisInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{3}
}
func (m *LldpIfChassisInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpIfChassisInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpIfChassisInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpIfChassisInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpIfChassisInfo.Merge(m, src)
}
func (m *LldpIfChassisInfo) XXX_Size() int {
	return m.Size()
}
func (m *LldpIfChassisInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpIfChassisInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LldpIfChassisInfo proto.InternalMessageInfo

func (m *LldpIfChassisInfo) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *LldpIfChassisInfo) GetChassisId() *LldpId {
	if m != nil {
		return m.ChassisId
	}
	return nil
}

func (m *LldpIfChassisInfo) GetSysDescr() string {
	if m != nil {
		return m.SysDescr
	}
	return ""
}

func (m *LldpIfChassisInfo) GetMgmtIP() *IPAddress {
	if m != nil {
		return m.MgmtIP
	}
	return nil
}

func (m *LldpIfChassisInfo) GetCapability() []*LldpChassisCapabilityInfo {
	if m != nil {
		return m.Capability
	}
	return nil
}

type LldpSpec struct {
	LldpIfChassisSpec    *LldpIfChassisInfo `protobuf:"bytes,1,opt,name=LldpIfChassisSpec,proto3" json:"LldpIfChassisSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LldpSpec) Reset()         { *m = LldpSpec{} }
func (m *LldpSpec) String() string { return proto.CompactTextString(m) }
func (*LldpSpec) ProtoMessage()    {}
func (*LldpSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{4}
}
func (m *LldpSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpSpec.Merge(m, src)
}
func (m *LldpSpec) XXX_Size() int {
	return m.Size()
}
func (m *LldpSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LldpSpec proto.InternalMessageInfo

func (m *LldpSpec) GetLldpIfChassisSpec() *LldpIfChassisInfo {
	if m != nil {
		return m.LldpIfChassisSpec
	}
	return nil
}

// Uplink configuration (if interface type is IF_TYPE_UPLINK)
type UplinkSpec struct {
	// physical port id corresponding to this interface
	PortId []byte `protobuf:"bytes,1,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagged
	NativeVlanId         uint32   `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UplinkSpec) Reset()         { *m = UplinkSpec{} }
func (m *UplinkSpec) String() string { return proto.CompactTextString(m) }
func (*UplinkSpec) ProtoMessage()    {}
func (*UplinkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{5}
}
func (m *UplinkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkSpec.Merge(m, src)
}
func (m *UplinkSpec) XXX_Size() int {
	return m.Size()
}
func (m *UplinkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkSpec proto.InternalMessageInfo

func (m *UplinkSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *UplinkSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

// Uplink port-channel configuration (i.e., if interface type is
// IF_TYPE_UPLINK_PC)
type UplinkPCSpec struct {
	// member interfaces of this port-channel in the form of bitmap
	// (e.g. if uplink interfaces 1 and 2 part of this port channel
	// this is set to 0x11
	MemberIfBitmap uint64 `protobuf:"varint,1,opt,name=MemberIfBitmap,proto3" json:"MemberIfBitmap,omitempty"`
	// Untagged ingress packets are considered as coming with this VLAN id
	// Egress packet tagged with this VLAN id are sent untagged
	NativeVlanId         uint32   `protobuf:"varint,2,opt,name=NativeVlanId,proto3" json:"NativeVlanId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UplinkPCSpec) Reset()         { *m = UplinkPCSpec{} }
func (m *UplinkPCSpec) String() string { return proto.CompactTextString(m) }
func (*UplinkPCSpec) ProtoMessage()    {}
func (*UplinkPCSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{6}
}
func (m *UplinkPCSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkPCSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkPCSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkPCSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkPCSpec.Merge(m, src)
}
func (m *UplinkPCSpec) XXX_Size() int {
	return m.Size()
}
func (m *UplinkPCSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkPCSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkPCSpec proto.InternalMessageInfo

func (m *UplinkPCSpec) GetMemberIfBitmap() uint64 {
	if m != nil {
		return m.MemberIfBitmap
	}
	return 0
}

func (m *UplinkPCSpec) GetNativeVlanId() uint32 {
	if m != nil {
		return m.NativeVlanId
	}
	return 0
}

// L3 interface configuration
type L3IfSpec struct {
	// vpc/vrf this L3 interface belongs to
	VpcId []byte `protobuf:"bytes,1,opt,name=VpcId,proto3" json:"VpcId,omitempty" meta:mandatory,immutable`
	// IP address, prefix of this L3 interface
	// NOTE: currently one IPv4 and one IPv6 prefixes are supported
	Prefix []*IPPrefix `protobuf:"bytes,2,rep,name=Prefix,proto3" json:"Prefix,omitempty" meta:mandatory,immutable`
	// Physical port of this L3 interface
	PortId []byte `protobuf:"bytes,3,opt,name=PortId,proto3" json:"PortId,omitempty" meta:mandatory,immutable`
	// (optional) encap used for packet rewrites if this is a L3 sub interface
	Encap *Encap `protobuf:"bytes,4,opt,name=Encap,proto3" json:"Encap,omitempty" meta:immutable`
	// MAC address of this L3 interface
	MACAddress           uint64   `protobuf:"varint,5,opt,name=MACAddress,proto3" json:"MACAddress,omitempty" meta:immutable`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L3IfSpec) Reset()         { *m = L3IfSpec{} }
func (m *L3IfSpec) String() string { return proto.CompactTextString(m) }
func (*L3IfSpec) ProtoMessage()    {}
func (*L3IfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{7}
}
func (m *L3IfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3IfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3IfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3IfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3IfSpec.Merge(m, src)
}
func (m *L3IfSpec) XXX_Size() int {
	return m.Size()
}
func (m *L3IfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_L3IfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_L3IfSpec proto.InternalMessageInfo

func (m *L3IfSpec) GetVpcId() []byte {
	if m != nil {
		return m.VpcId
	}
	return nil
}

func (m *L3IfSpec) GetPrefix() []*IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *L3IfSpec) GetPortId() []byte {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *L3IfSpec) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *L3IfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

// Loopback interface configuration
type LoopbackIfSpec struct {
	// IP address hosted on the loopback interface and is the DSC's TEP IP
	// NOTE: This IP address is in underlay VPC
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"Prefix,omitempty" meta:mandatory`
	// RouteMetric is metric used by the routing protocol to advertise this
	// loopback TEP IP
	// NOTE: two DSCs can have same TEP IP and same RouteMetric in a active-active
	//       configuration or same IP with different metrics in active-standby
	//       configuration
	RouteMetric uint32 `protobuf:"varint,2,opt,name=RouteMetric,proto3" json:"RouteMetric,omitempty"`
	// number of times the local AS number is repeated in the AS path
	// when advertising this loopback TEP IP via BGP
	// NOTE: multiple DSCs can advertise same TEP IP with same AS path length in
	//       an all active configuration or advertise same TEP IP with different
	//       AS path lengths in an active-standby configuration
	BgpAsPathPrependCount uint32 `protobuf:"varint,3,opt,name=BgpAsPathPrependCount,proto3" json:"BgpAsPathPrependCount,omitempty"`
	// BGP standard community values to be attached to the route advertising this
	// loopback TEP IP
	Community            []*BGPCommunity `protobuf:"bytes,4,rep,name=Community,proto3" json:"Community,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LoopbackIfSpec) Reset()         { *m = LoopbackIfSpec{} }
func (m *LoopbackIfSpec) String() string { return proto.CompactTextString(m) }
func (*LoopbackIfSpec) ProtoMessage()    {}
func (*LoopbackIfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{8}
}
func (m *LoopbackIfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoopbackIfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoopbackIfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoopbackIfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopbackIfSpec.Merge(m, src)
}
func (m *LoopbackIfSpec) XXX_Size() int {
	return m.Size()
}
func (m *LoopbackIfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopbackIfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LoopbackIfSpec proto.InternalMessageInfo

func (m *LoopbackIfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *LoopbackIfSpec) GetRouteMetric() uint32 {
	if m != nil {
		return m.RouteMetric
	}
	return 0
}

func (m *LoopbackIfSpec) GetBgpAsPathPrependCount() uint32 {
	if m != nil {
		return m.BgpAsPathPrependCount
	}
	return 0
}

func (m *LoopbackIfSpec) GetCommunity() []*BGPCommunity {
	if m != nil {
		return m.Community
	}
	return nil
}

// Inband control interface configuration
type ControlIfSpec struct {
	// IP address hosted on the inband control interface
	Prefix               *IPPrefix `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"Prefix,omitempty" meta:mandatory`
	MACAddress           uint64    `protobuf:"varint,2,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ControlIfSpec) Reset()         { *m = ControlIfSpec{} }
func (m *ControlIfSpec) String() string { return proto.CompactTextString(m) }
func (*ControlIfSpec) ProtoMessage()    {}
func (*ControlIfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{9}
}
func (m *ControlIfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlIfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlIfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlIfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlIfSpec.Merge(m, src)
}
func (m *ControlIfSpec) XXX_Size() int {
	return m.Size()
}
func (m *ControlIfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlIfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ControlIfSpec proto.InternalMessageInfo

func (m *ControlIfSpec) GetPrefix() *IPPrefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ControlIfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

// HostIfSpec represents a host visisble device (e.g. eth interface)
// NOTE: host interfaces can't be created or deleted via the API, they are
//       created during bringup of DSC; only policies (for example, (mirror
//       policy) can be applied on such interfaces and they can't be brought
//       down or up as they are host devices and DSC has no control over them
type HostIfSpec struct {
	// Vf is set to true, for VF devices
	Vf bool `protobuf:"varint,1,opt,name=Vf,proto3" json:"Vf,omitempty" meta:immutable`
	// ConnTrackEn, if set to true, will enable full connection tracking
	// NOTE:
	// 1. this knob is useful to enable connection tracking on per PF level if
	//    enabling connection tracking for the entire DSC is not desirable
	//    i.e, if SecurityProfileSpec has ConnTrackEn set to false but
	//    ConnTrackEn is set to true in this object, then connection tracking
	//    is enabled only for traffic from/to this host interface alone
	// 2. to disable connection tracking only for a PF or subset of PFs but keep
	//    it enabled for all other PFs the following configuration steps
	//    should be followed:
	//    a) set ConnTrackEn attribute in SecurityProfileSpec to false
	//    b) set ConnTrackEn attribute in HostIfSpec to true on the PFs where
	//       conneection tracking is needed
	//    c) set ConnTrackEn attribute in HostIfSpec to false on the PFs where
	//       conneection tracking is not needed
	//    In other words, connection tracking is disabled only if ConnTrackEn
	//    attribute is set to false in BOTH HostIfSpec and SecurityProfileSpec
	//    and enabled if either of these objects have ConnTrackEn set to true
	// 3. if ConnTrackEn is modified on the fly, it will take affect only on
	//    sessions created thereafter and doesn't affect existing sessions
	ConnTrackEn bool `protobuf:"varint,2,opt,name=ConnTrackEn,proto3" json:"ConnTrackEn,omitempty" meta:default=false`
	// Tx policer uuid
	TxPolicer []byte `protobuf:"bytes,3,opt,name=TxPolicer,proto3" json:"TxPolicer,omitempty"`
	// by default MAC address is assigned to PF when PF is created and this can be
	// modified by user provided MAC address by setting MACAddress attribute
	// NOTE: as PFs are created during initialization time, updating the MAC
	//       will not take affect immediately, it will take affect only after
	//       next reboot
	MACAddress uint64 `protobuf:"varint,4,opt,name=MACAddress,proto3" json:"MACAddress,omitempty" persisted`
	// controls for flow logging
	FlowLogSpec *FlowLogSpec `protobuf:"bytes,5,opt,name=FlowLogSpec,proto3" json:"FlowLogSpec,omitempty"`
	// MAC/IP learning controls
	// NOTE: if LearnSpec is not configured, learning related configuration
	//       is inherited from the global DeviceSpec configuration object
	LearnSpec *LearnSpec `protobuf:"bytes,6,opt,name=LearnSpec,proto3" json:"LearnSpec,omitempty"`
	// VNF (potentially virtualized) workloads/appliances like firewalls, virtual
	// switches/bridges, security monitoring appliances etc. are the kind of
	// workloads that act as devices in the middle providing bump in the wire
	// services and they can receive traffic from various IP and MAC addresses
	// and also generate traffic with different sources and MAC addresses
	// (potentially looping back the received traffic after performing the
	// services and/or doing certain packet rewrites). For such workloads,
	// VNF attribute is set to true and the source IP address in the traffic from
	// the PF/VF will be ignored for learning purposes
	VNF bool `protobuf:"varint,7,opt,name=VNF,proto3" json:"VNF,omitempty"`
	// optional name of host interface
	// NOTE:
	// 1. this name is used only in host interface create operation where some
	//    configuration is persisted to take effect on next reboot of the DSC
	// 2. this attribute is not filled in GET operation, name of the host
	//    interface is returned in the status portion of GET response
	Name                 string   `protobuf:"bytes,8,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostIfSpec) Reset()         { *m = HostIfSpec{} }
func (m *HostIfSpec) String() string { return proto.CompactTextString(m) }
func (*HostIfSpec) ProtoMessage()    {}
func (*HostIfSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{10}
}
func (m *HostIfSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostIfSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostIfSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostIfSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostIfSpec.Merge(m, src)
}
func (m *HostIfSpec) XXX_Size() int {
	return m.Size()
}
func (m *HostIfSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HostIfSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HostIfSpec proto.InternalMessageInfo

func (m *HostIfSpec) GetVf() bool {
	if m != nil {
		return m.Vf
	}
	return false
}

func (m *HostIfSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *HostIfSpec) GetTxPolicer() []byte {
	if m != nil {
		return m.TxPolicer
	}
	return nil
}

func (m *HostIfSpec) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

func (m *HostIfSpec) GetFlowLogSpec() *FlowLogSpec {
	if m != nil {
		return m.FlowLogSpec
	}
	return nil
}

func (m *HostIfSpec) GetLearnSpec() *LearnSpec {
	if m != nil {
		return m.LearnSpec
	}
	return nil
}

func (m *HostIfSpec) GetVNF() bool {
	if m != nil {
		return m.VNF
	}
	return false
}

func (m *HostIfSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// InterfaceSpec is used to add or update of an interface
type InterfaceSpec struct {
	// unique interface id
	// NOTE: interface ids start from 1, for IF_TYPE_UPLINK this id is in the
	//       range [1...max-ports#] and same for IF_TYPE_UPLINK_PC
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory`
	// 1. AdminState on ethernet interfaces will bring up or down adminstratively
	// 2. AdminState on host interface (PF/VF etc.) will give the ability to the
	//    cloud provider to shutdown traffic from/to a PF irrespective of the
	//    admin state of PF on the host. To bring a PF up, admin state here must
	//    be configured as UP AND PF should be brought up on host as well
	//    (e.g. via "ifconfig <intf> up"). If the admin state configured on the
	//    host OR if the AdminState configured in this object is DOWN, then PF
	//    will remain in down state and traffic will be dropped and host will see
	//    this PF as down
	AdminStatus IfStatus `protobuf:"varint,2,opt,name=AdminStatus,proto3,enum=pds.IfStatus" json:"AdminStatus,omitempty" meta:default=IF_STATUS_UP`
	// interface type specific configuration
	//
	// Types that are valid to be assigned to Ifinfo:
	//	*InterfaceSpec_UplinkSpec
	//	*InterfaceSpec_UplinkPCSpec
	//	*InterfaceSpec_L3IfSpec
	//	*InterfaceSpec_LoopbackIfSpec
	//	*InterfaceSpec_ControlIfSpec
	//	*InterfaceSpec_HostIfSpec
	Ifinfo isInterfaceSpec_Ifinfo `protobuf_oneof:"ifinfo"`
	// Tx/egress mirror session id list, if any
	TxMirrorSessionId [][]byte `protobuf:"bytes,9,rep,name=TxMirrorSessionId,proto3" json:"TxMirrorSessionId,omitempty" meta:constraints={InterfaceSpec.Type==IF_TYPE_HOST}`
	// Rx/ingress mirror session id list, if any
	RxMirrorSessionId    [][]byte `protobuf:"bytes,10,rep,name=RxMirrorSessionId,proto3" json:"RxMirrorSessionId,omitempty" meta:constraints={InterfaceSpec.Type==IF_TYPE_HOST}`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfaceSpec) Reset()         { *m = InterfaceSpec{} }
func (m *InterfaceSpec) String() string { return proto.CompactTextString(m) }
func (*InterfaceSpec) ProtoMessage()    {}
func (*InterfaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{11}
}
func (m *InterfaceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceSpec.Merge(m, src)
}
func (m *InterfaceSpec) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceSpec proto.InternalMessageInfo

type isInterfaceSpec_Ifinfo interface {
	isInterfaceSpec_Ifinfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceSpec_UplinkSpec struct {
	UplinkSpec *UplinkSpec `protobuf:"bytes,3,opt,name=UplinkSpec,proto3,oneof"`
}
type InterfaceSpec_UplinkPCSpec struct {
	UplinkPCSpec *UplinkPCSpec `protobuf:"bytes,4,opt,name=UplinkPCSpec,proto3,oneof"`
}
type InterfaceSpec_L3IfSpec struct {
	L3IfSpec *L3IfSpec `protobuf:"bytes,5,opt,name=L3IfSpec,proto3,oneof"`
}
type InterfaceSpec_LoopbackIfSpec struct {
	LoopbackIfSpec *LoopbackIfSpec `protobuf:"bytes,6,opt,name=LoopbackIfSpec,proto3,oneof"`
}
type InterfaceSpec_ControlIfSpec struct {
	ControlIfSpec *ControlIfSpec `protobuf:"bytes,7,opt,name=ControlIfSpec,proto3,oneof"`
}
type InterfaceSpec_HostIfSpec struct {
	HostIfSpec *HostIfSpec `protobuf:"bytes,8,opt,name=HostIfSpec,proto3,oneof"`
}

func (*InterfaceSpec_UplinkSpec) isInterfaceSpec_Ifinfo()     {}
func (*InterfaceSpec_UplinkPCSpec) isInterfaceSpec_Ifinfo()   {}
func (*InterfaceSpec_L3IfSpec) isInterfaceSpec_Ifinfo()       {}
func (*InterfaceSpec_LoopbackIfSpec) isInterfaceSpec_Ifinfo() {}
func (*InterfaceSpec_ControlIfSpec) isInterfaceSpec_Ifinfo()  {}
func (*InterfaceSpec_HostIfSpec) isInterfaceSpec_Ifinfo()     {}

func (m *InterfaceSpec) GetIfinfo() isInterfaceSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (m *InterfaceSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *InterfaceSpec) GetAdminStatus() IfStatus {
	if m != nil {
		return m.AdminStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceSpec) GetUplinkSpec() *UplinkSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkSpec); ok {
		return x.UplinkSpec
	}
	return nil
}

func (m *InterfaceSpec) GetUplinkPCSpec() *UplinkPCSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_UplinkPCSpec); ok {
		return x.UplinkPCSpec
	}
	return nil
}

func (m *InterfaceSpec) GetL3IfSpec() *L3IfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_L3IfSpec); ok {
		return x.L3IfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetLoopbackIfSpec() *LoopbackIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_LoopbackIfSpec); ok {
		return x.LoopbackIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetControlIfSpec() *ControlIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_ControlIfSpec); ok {
		return x.ControlIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetHostIfSpec() *HostIfSpec {
	if x, ok := m.GetIfinfo().(*InterfaceSpec_HostIfSpec); ok {
		return x.HostIfSpec
	}
	return nil
}

func (m *InterfaceSpec) GetTxMirrorSessionId() [][]byte {
	if m != nil {
		return m.TxMirrorSessionId
	}
	return nil
}

func (m *InterfaceSpec) GetRxMirrorSessionId() [][]byte {
	if m != nil {
		return m.RxMirrorSessionId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceSpec_UplinkSpec)(nil),
		(*InterfaceSpec_UplinkPCSpec)(nil),
		(*InterfaceSpec_L3IfSpec)(nil),
		(*InterfaceSpec_LoopbackIfSpec)(nil),
		(*InterfaceSpec_ControlIfSpec)(nil),
		(*InterfaceSpec_HostIfSpec)(nil),
	}
}

type LldpIfPortStatus struct {
	PortId               *LldpId  `protobuf:"bytes,1,opt,name=PortId,proto3" json:"PortId,omitempty"`
	PortDescr            string   `protobuf:"bytes,2,opt,name=PortDescr,proto3" json:"PortDescr,omitempty"`
	Ttl                  uint32   `protobuf:"varint,3,opt,name=Ttl,proto3" json:"Ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LldpIfPortStatus) Reset()         { *m = LldpIfPortStatus{} }
func (m *LldpIfPortStatus) String() string { return proto.CompactTextString(m) }
func (*LldpIfPortStatus) ProtoMessage()    {}
func (*LldpIfPortStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{12}
}
func (m *LldpIfPortStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpIfPortStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpIfPortStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpIfPortStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpIfPortStatus.Merge(m, src)
}
func (m *LldpIfPortStatus) XXX_Size() int {
	return m.Size()
}
func (m *LldpIfPortStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpIfPortStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LldpIfPortStatus proto.InternalMessageInfo

func (m *LldpIfPortStatus) GetPortId() *LldpId {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *LldpIfPortStatus) GetPortDescr() string {
	if m != nil {
		return m.PortDescr
	}
	return ""
}

func (m *LldpIfPortStatus) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type LldpUnknownTlvStatus struct {
	Oui                  string   `protobuf:"bytes,1,opt,name=Oui,proto3" json:"Oui,omitempty"`
	Subtype              uint32   `protobuf:"varint,2,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	Len                  uint32   `protobuf:"varint,3,opt,name=Len,proto3" json:"Len,omitempty"`
	Value                string   `protobuf:"bytes,4,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LldpUnknownTlvStatus) Reset()         { *m = LldpUnknownTlvStatus{} }
func (m *LldpUnknownTlvStatus) String() string { return proto.CompactTextString(m) }
func (*LldpUnknownTlvStatus) ProtoMessage()    {}
func (*LldpUnknownTlvStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{13}
}
func (m *LldpUnknownTlvStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpUnknownTlvStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpUnknownTlvStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpUnknownTlvStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpUnknownTlvStatus.Merge(m, src)
}
func (m *LldpUnknownTlvStatus) XXX_Size() int {
	return m.Size()
}
func (m *LldpUnknownTlvStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpUnknownTlvStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LldpUnknownTlvStatus proto.InternalMessageInfo

func (m *LldpUnknownTlvStatus) GetOui() string {
	if m != nil {
		return m.Oui
	}
	return ""
}

func (m *LldpUnknownTlvStatus) GetSubtype() uint32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LldpUnknownTlvStatus) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *LldpUnknownTlvStatus) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type LldpIfStatus struct {
	IfName               string                  `protobuf:"bytes,1,opt,name=IfName,proto3" json:"IfName,omitempty"`
	RouterId             uint32                  `protobuf:"varint,2,opt,name=RouterId,proto3" json:"RouterId,omitempty"`
	Proto                LldpProtoMode           `protobuf:"varint,3,opt,name=Proto,proto3,enum=pds.LldpProtoMode" json:"Proto,omitempty"`
	Age                  []byte                  `protobuf:"bytes,4,opt,name=Age,proto3" json:"Age,omitempty"`
	LldpIfChassisStatus  *LldpIfChassisInfo      `protobuf:"bytes,5,opt,name=LldpIfChassisStatus,proto3" json:"LldpIfChassisStatus,omitempty"`
	LldpIfPortStatus     *LldpIfPortStatus       `protobuf:"bytes,6,opt,name=LldpIfPortStatus,proto3" json:"LldpIfPortStatus,omitempty"`
	LldpUnknownTlvStatus []*LldpUnknownTlvStatus `protobuf:"bytes,7,rep,name=LldpUnknownTlvStatus,proto3" json:"LldpUnknownTlvStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LldpIfStatus) Reset()         { *m = LldpIfStatus{} }
func (m *LldpIfStatus) String() string { return proto.CompactTextString(m) }
func (*LldpIfStatus) ProtoMessage()    {}
func (*LldpIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{14}
}
func (m *LldpIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpIfStatus.Merge(m, src)
}
func (m *LldpIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *LldpIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LldpIfStatus proto.InternalMessageInfo

func (m *LldpIfStatus) GetIfName() string {
	if m != nil {
		return m.IfName
	}
	return ""
}

func (m *LldpIfStatus) GetRouterId() uint32 {
	if m != nil {
		return m.RouterId
	}
	return 0
}

func (m *LldpIfStatus) GetProto() LldpProtoMode {
	if m != nil {
		return m.Proto
	}
	return LldpProtoMode_LLDP_MODE_NONE
}

func (m *LldpIfStatus) GetAge() []byte {
	if m != nil {
		return m.Age
	}
	return nil
}

func (m *LldpIfStatus) GetLldpIfChassisStatus() *LldpIfChassisInfo {
	if m != nil {
		return m.LldpIfChassisStatus
	}
	return nil
}

func (m *LldpIfStatus) GetLldpIfPortStatus() *LldpIfPortStatus {
	if m != nil {
		return m.LldpIfPortStatus
	}
	return nil
}

func (m *LldpIfStatus) GetLldpUnknownTlvStatus() []*LldpUnknownTlvStatus {
	if m != nil {
		return m.LldpUnknownTlvStatus
	}
	return nil
}

type LldpStatus struct {
	LldpIfStatus         *LldpIfStatus `protobuf:"bytes,1,opt,name=LldpIfStatus,proto3" json:"LldpIfStatus,omitempty"`
	LldpNbrStatus        *LldpIfStatus `protobuf:"bytes,2,opt,name=LldpNbrStatus,proto3" json:"LldpNbrStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LldpStatus) Reset()         { *m = LldpStatus{} }
func (m *LldpStatus) String() string { return proto.CompactTextString(m) }
func (*LldpStatus) ProtoMessage()    {}
func (*LldpStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{15}
}
func (m *LldpStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LldpStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LldpStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LldpStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LldpStatus.Merge(m, src)
}
func (m *LldpStatus) XXX_Size() int {
	return m.Size()
}
func (m *LldpStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LldpStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LldpStatus proto.InternalMessageInfo

func (m *LldpStatus) GetLldpIfStatus() *LldpIfStatus {
	if m != nil {
		return m.LldpIfStatus
	}
	return nil
}

func (m *LldpStatus) GetLldpNbrStatus() *LldpIfStatus {
	if m != nil {
		return m.LldpNbrStatus
	}
	return nil
}

// operational status of uplink interface
type UplinkIfStatus struct {
	// lif id associated with this uplink
	LifId                uint32      `protobuf:"varint,1,opt,name=LifId,proto3" json:"LifId,omitempty"`
	LldpStatus           *LldpStatus `protobuf:"bytes,2,opt,name=LldpStatus,proto3" json:"LldpStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UplinkIfStatus) Reset()         { *m = UplinkIfStatus{} }
func (m *UplinkIfStatus) String() string { return proto.CompactTextString(m) }
func (*UplinkIfStatus) ProtoMessage()    {}
func (*UplinkIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{16}
}
func (m *UplinkIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkIfStatus.Merge(m, src)
}
func (m *UplinkIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *UplinkIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkIfStatus proto.InternalMessageInfo

func (m *UplinkIfStatus) GetLifId() uint32 {
	if m != nil {
		return m.LifId
	}
	return 0
}

func (m *UplinkIfStatus) GetLldpStatus() *LldpStatus {
	if m != nil {
		return m.LldpStatus
	}
	return nil
}

// operational status of loopback interface
type LoopbackIfStatus struct {
	// loopback interface name in linux
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopbackIfStatus) Reset()         { *m = LoopbackIfStatus{} }
func (m *LoopbackIfStatus) String() string { return proto.CompactTextString(m) }
func (*LoopbackIfStatus) ProtoMessage()    {}
func (*LoopbackIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{17}
}
func (m *LoopbackIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoopbackIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoopbackIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoopbackIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopbackIfStatus.Merge(m, src)
}
func (m *LoopbackIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *LoopbackIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopbackIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LoopbackIfStatus proto.InternalMessageInfo

func (m *LoopbackIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// operational status of host interfaces
type HostIfStatus struct {
	// host interface can have one or more lifs behind it
	LifId [][]byte `protobuf:"bytes,1,rep,name=LifId,proto3" json:"LifId,omitempty"`
	// MAC address of this interface
	MACAddress uint64 `protobuf:"varint,2,opt,name=MACAddress,proto3" json:"MACAddress,omitempty"`
	// operational status of this interface
	Status IfStatus `protobuf:"varint,3,opt,name=Status,proto3,enum=pds.IfStatus" json:"Status,omitempty"`
	// host interface name
	Name                 string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostIfStatus) Reset()         { *m = HostIfStatus{} }
func (m *HostIfStatus) String() string { return proto.CompactTextString(m) }
func (*HostIfStatus) ProtoMessage()    {}
func (*HostIfStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{18}
}
func (m *HostIfStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostIfStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostIfStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostIfStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostIfStatus.Merge(m, src)
}
func (m *HostIfStatus) XXX_Size() int {
	return m.Size()
}
func (m *HostIfStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_HostIfStatus.DiscardUnknown(m)
}

var xxx_messageInfo_HostIfStatus proto.InternalMessageInfo

func (m *HostIfStatus) GetLifId() [][]byte {
	if m != nil {
		return m.LifId
	}
	return nil
}

func (m *HostIfStatus) GetMACAddress() uint64 {
	if m != nil {
		return m.MACAddress
	}
	return 0
}

func (m *HostIfStatus) GetStatus() IfStatus {
	if m != nil {
		return m.Status
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *HostIfStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// operational status of an interface, if any
type InterfaceStatus struct {
	// encoded interface index of this interface
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// operational status of the interface
	OperStatus IfStatus `protobuf:"varint,2,opt,name=OperStatus,proto3,enum=pds.IfStatus" json:"OperStatus,omitempty"`
	// Types that are valid to be assigned to Ifstatus:
	//	*InterfaceStatus_UplinkIfStatus
	//	*InterfaceStatus_LoopbackIfStatus
	//	*InterfaceStatus_HostIfStatus
	Ifstatus             isInterfaceStatus_Ifstatus `protobuf_oneof:"ifstatus"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *InterfaceStatus) Reset()         { *m = InterfaceStatus{} }
func (m *InterfaceStatus) String() string { return proto.CompactTextString(m) }
func (*InterfaceStatus) ProtoMessage()    {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{19}
}
func (m *InterfaceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceStatus.Merge(m, src)
}
func (m *InterfaceStatus) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceStatus proto.InternalMessageInfo

type isInterfaceStatus_Ifstatus interface {
	isInterfaceStatus_Ifstatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceStatus_UplinkIfStatus struct {
	UplinkIfStatus *UplinkIfStatus `protobuf:"bytes,3,opt,name=UplinkIfStatus,proto3,oneof"`
}
type InterfaceStatus_LoopbackIfStatus struct {
	LoopbackIfStatus *LoopbackIfStatus `protobuf:"bytes,4,opt,name=LoopbackIfStatus,proto3,oneof"`
}
type InterfaceStatus_HostIfStatus struct {
	HostIfStatus *HostIfStatus `protobuf:"bytes,5,opt,name=HostIfStatus,proto3,oneof"`
}

func (*InterfaceStatus_UplinkIfStatus) isInterfaceStatus_Ifstatus()   {}
func (*InterfaceStatus_LoopbackIfStatus) isInterfaceStatus_Ifstatus() {}
func (*InterfaceStatus_HostIfStatus) isInterfaceStatus_Ifstatus()     {}

func (m *InterfaceStatus) GetIfstatus() isInterfaceStatus_Ifstatus {
	if m != nil {
		return m.Ifstatus
	}
	return nil
}

func (m *InterfaceStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *InterfaceStatus) GetOperStatus() IfStatus {
	if m != nil {
		return m.OperStatus
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *InterfaceStatus) GetUplinkIfStatus() *UplinkIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_UplinkIfStatus); ok {
		return x.UplinkIfStatus
	}
	return nil
}

func (m *InterfaceStatus) GetLoopbackIfStatus() *LoopbackIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_LoopbackIfStatus); ok {
		return x.LoopbackIfStatus
	}
	return nil
}

func (m *InterfaceStatus) GetHostIfStatus() *HostIfStatus {
	if x, ok := m.GetIfstatus().(*InterfaceStatus_HostIfStatus); ok {
		return x.HostIfStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceStatus) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceStatus_UplinkIfStatus)(nil),
		(*InterfaceStatus_LoopbackIfStatus)(nil),
		(*InterfaceStatus_HostIfStatus)(nil),
	}
}

type UplinkIfStats struct {
	LldpIfStats          *LldpIfStats `protobuf:"bytes,1,opt,name=LldpIfStats,proto3" json:"LldpIfStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UplinkIfStats) Reset()         { *m = UplinkIfStats{} }
func (m *UplinkIfStats) String() string { return proto.CompactTextString(m) }
func (*UplinkIfStats) ProtoMessage()    {}
func (*UplinkIfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{20}
}
func (m *UplinkIfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkIfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkIfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkIfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkIfStats.Merge(m, src)
}
func (m *UplinkIfStats) XXX_Size() int {
	return m.Size()
}
func (m *UplinkIfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkIfStats.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkIfStats proto.InternalMessageInfo

func (m *UplinkIfStats) GetLldpIfStats() *LldpIfStats {
	if m != nil {
		return m.LldpIfStats
	}
	return nil
}

type UplinkPCStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UplinkPCStats) Reset()         { *m = UplinkPCStats{} }
func (m *UplinkPCStats) String() string { return proto.CompactTextString(m) }
func (*UplinkPCStats) ProtoMessage()    {}
func (*UplinkPCStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{21}
}
func (m *UplinkPCStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkPCStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkPCStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkPCStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkPCStats.Merge(m, src)
}
func (m *UplinkPCStats) XXX_Size() int {
	return m.Size()
}
func (m *UplinkPCStats) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkPCStats.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkPCStats proto.InternalMessageInfo

type L3IfStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L3IfStats) Reset()         { *m = L3IfStats{} }
func (m *L3IfStats) String() string { return proto.CompactTextString(m) }
func (*L3IfStats) ProtoMessage()    {}
func (*L3IfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{22}
}
func (m *L3IfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3IfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3IfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3IfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3IfStats.Merge(m, src)
}
func (m *L3IfStats) XXX_Size() int {
	return m.Size()
}
func (m *L3IfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_L3IfStats.DiscardUnknown(m)
}

var xxx_messageInfo_L3IfStats proto.InternalMessageInfo

type LoopbackIfStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopbackIfStats) Reset()         { *m = LoopbackIfStats{} }
func (m *LoopbackIfStats) String() string { return proto.CompactTextString(m) }
func (*LoopbackIfStats) ProtoMessage()    {}
func (*LoopbackIfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{23}
}
func (m *LoopbackIfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoopbackIfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoopbackIfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoopbackIfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopbackIfStats.Merge(m, src)
}
func (m *LoopbackIfStats) XXX_Size() int {
	return m.Size()
}
func (m *LoopbackIfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopbackIfStats.DiscardUnknown(m)
}

var xxx_messageInfo_LoopbackIfStats proto.InternalMessageInfo

type ControlIfStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControlIfStats) Reset()         { *m = ControlIfStats{} }
func (m *ControlIfStats) String() string { return proto.CompactTextString(m) }
func (*ControlIfStats) ProtoMessage()    {}
func (*ControlIfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{24}
}
func (m *ControlIfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlIfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlIfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlIfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlIfStats.Merge(m, src)
}
func (m *ControlIfStats) XXX_Size() int {
	return m.Size()
}
func (m *ControlIfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlIfStats.DiscardUnknown(m)
}

var xxx_messageInfo_ControlIfStats proto.InternalMessageInfo

// stats for an interface, if any
type InterfaceStats struct {
	// Types that are valid to be assigned to Ifstats:
	//	*InterfaceStats_UplinkIfStats
	//	*InterfaceStats_UplinkPCStats
	//	*InterfaceStats_L3IfStats
	//	*InterfaceStats_LoopbackIfStats
	//	*InterfaceStats_ControlIfStats
	Ifstats              isInterfaceStats_Ifstats `protobuf_oneof:"ifstats"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *InterfaceStats) Reset()         { *m = InterfaceStats{} }
func (m *InterfaceStats) String() string { return proto.CompactTextString(m) }
func (*InterfaceStats) ProtoMessage()    {}
func (*InterfaceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{25}
}
func (m *InterfaceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceStats.Merge(m, src)
}
func (m *InterfaceStats) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceStats.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceStats proto.InternalMessageInfo

type isInterfaceStats_Ifstats interface {
	isInterfaceStats_Ifstats()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceStats_UplinkIfStats struct {
	UplinkIfStats *UplinkIfStats `protobuf:"bytes,1,opt,name=UplinkIfStats,proto3,oneof"`
}
type InterfaceStats_UplinkPCStats struct {
	UplinkPCStats *UplinkPCStats `protobuf:"bytes,2,opt,name=UplinkPCStats,proto3,oneof"`
}
type InterfaceStats_L3IfStats struct {
	L3IfStats *L3IfStats `protobuf:"bytes,3,opt,name=L3IfStats,proto3,oneof"`
}
type InterfaceStats_LoopbackIfStats struct {
	LoopbackIfStats *LoopbackIfStats `protobuf:"bytes,4,opt,name=LoopbackIfStats,proto3,oneof"`
}
type InterfaceStats_ControlIfStats struct {
	ControlIfStats *ControlIfStats `protobuf:"bytes,5,opt,name=ControlIfStats,proto3,oneof"`
}

func (*InterfaceStats_UplinkIfStats) isInterfaceStats_Ifstats()   {}
func (*InterfaceStats_UplinkPCStats) isInterfaceStats_Ifstats()   {}
func (*InterfaceStats_L3IfStats) isInterfaceStats_Ifstats()       {}
func (*InterfaceStats_LoopbackIfStats) isInterfaceStats_Ifstats() {}
func (*InterfaceStats_ControlIfStats) isInterfaceStats_Ifstats()  {}

func (m *InterfaceStats) GetIfstats() isInterfaceStats_Ifstats {
	if m != nil {
		return m.Ifstats
	}
	return nil
}

func (m *InterfaceStats) GetUplinkIfStats() *UplinkIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_UplinkIfStats); ok {
		return x.UplinkIfStats
	}
	return nil
}

func (m *InterfaceStats) GetUplinkPCStats() *UplinkPCStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_UplinkPCStats); ok {
		return x.UplinkPCStats
	}
	return nil
}

func (m *InterfaceStats) GetL3IfStats() *L3IfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_L3IfStats); ok {
		return x.L3IfStats
	}
	return nil
}

func (m *InterfaceStats) GetLoopbackIfStats() *LoopbackIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_LoopbackIfStats); ok {
		return x.LoopbackIfStats
	}
	return nil
}

func (m *InterfaceStats) GetControlIfStats() *ControlIfStats {
	if x, ok := m.GetIfstats().(*InterfaceStats_ControlIfStats); ok {
		return x.ControlIfStats
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceStats) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceStats_UplinkIfStats)(nil),
		(*InterfaceStats_UplinkPCStats)(nil),
		(*InterfaceStats_L3IfStats)(nil),
		(*InterfaceStats_LoopbackIfStats)(nil),
		(*InterfaceStats_ControlIfStats)(nil),
	}
}

// interface Object
type Interface struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *InterfaceSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *InterfaceStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *InterfaceStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Interface) Reset()         { *m = Interface{} }
func (m *Interface) String() string { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()    {}
func (*Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{26}
}
func (m *Interface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interface.Merge(m, src)
}
func (m *Interface) XXX_Size() int {
	return m.Size()
}
func (m *Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_Interface.DiscardUnknown(m)
}

var xxx_messageInfo_Interface proto.InternalMessageInfo

func (m *Interface) GetSpec() *InterfaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Interface) GetStatus() *InterfaceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Interface) GetStats() *InterfaceStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// interface create and update request
type InterfaceRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	// batched requests
	Request              []*InterfaceSpec `protobuf:"bytes,2,rep,name=Request,proto3" json:"Request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *InterfaceRequest) Reset()         { *m = InterfaceRequest{} }
func (m *InterfaceRequest) String() string { return proto.CompactTextString(m) }
func (*InterfaceRequest) ProtoMessage()    {}
func (*InterfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{27}
}
func (m *InterfaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceRequest.Merge(m, src)
}
func (m *InterfaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceRequest proto.InternalMessageInfo

func (m *InterfaceRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceRequest) GetRequest() []*InterfaceSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// interface create and update response
type InterfaceResponse struct {
	ApiStatus            ApiStatus          `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*InterfaceStatus `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *InterfaceResponse) Reset()         { *m = InterfaceResponse{} }
func (m *InterfaceResponse) String() string { return proto.CompactTextString(m) }
func (*InterfaceResponse) ProtoMessage()    {}
func (*InterfaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{28}
}
func (m *InterfaceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceResponse.Merge(m, src)
}
func (m *InterfaceResponse) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceResponse proto.InternalMessageInfo

func (m *InterfaceResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceResponse) GetResponse() []*InterfaceStatus {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface get request
type InterfaceGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfaceGetRequest) Reset()         { *m = InterfaceGetRequest{} }
func (m *InterfaceGetRequest) String() string { return proto.CompactTextString(m) }
func (*InterfaceGetRequest) ProtoMessage()    {}
func (*InterfaceGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{29}
}
func (m *InterfaceGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceGetRequest.Merge(m, src)
}
func (m *InterfaceGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceGetRequest proto.InternalMessageInfo

func (m *InterfaceGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface get response
type InterfaceGetResponse struct {
	ApiStatus            ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Interface `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *InterfaceGetResponse) Reset()         { *m = InterfaceGetResponse{} }
func (m *InterfaceGetResponse) String() string { return proto.CompactTextString(m) }
func (*InterfaceGetResponse) ProtoMessage()    {}
func (*InterfaceGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{30}
}
func (m *InterfaceGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceGetResponse.Merge(m, src)
}
func (m *InterfaceGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceGetResponse proto.InternalMessageInfo

func (m *InterfaceGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *InterfaceGetResponse) GetResponse() []*Interface {
	if m != nil {
		return m.Response
	}
	return nil
}

// interface delete request
type InterfaceDeleteRequest struct {
	// optional batch context, if this request is part of batch of API calls
	BatchCtxt            *BatchCtxt `protobuf:"bytes,1,opt,name=BatchCtxt,proto3" json:"BatchCtxt,omitempty"`
	Id                   [][]byte   `protobuf:"bytes,2,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *InterfaceDeleteRequest) Reset()         { *m = InterfaceDeleteRequest{} }
func (m *InterfaceDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*InterfaceDeleteRequest) ProtoMessage()    {}
func (*InterfaceDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{31}
}
func (m *InterfaceDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDeleteRequest.Merge(m, src)
}
func (m *InterfaceDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDeleteRequest proto.InternalMessageInfo

func (m *InterfaceDeleteRequest) GetBatchCtxt() *BatchCtxt {
	if m != nil {
		return m.BatchCtxt
	}
	return nil
}

func (m *InterfaceDeleteRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// interface delete response
type InterfaceDeleteResponse struct {
	ApiStatus            []ApiStatus `protobuf:"varint,1,rep,packed,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InterfaceDeleteResponse) Reset()         { *m = InterfaceDeleteResponse{} }
func (m *InterfaceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*InterfaceDeleteResponse) ProtoMessage()    {}
func (*InterfaceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{32}
}
func (m *InterfaceDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDeleteResponse.Merge(m, src)
}
func (m *InterfaceDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDeleteResponse proto.InternalMessageInfo

func (m *InterfaceDeleteResponse) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

/// Lif (Logical interface) object represents a device (eth/storage etc.)
/// NOTE: Lif objects are internal and host devices can have multiple lifs
///       behind them
type LifSpec struct {
	// unique key of the lif
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// type of the lif device
	Type LifType `protobuf:"varint,2,opt,name=Type,proto3,enum=types.LifType" json:"Type,omitempty"`
	// MAC address of the lif, if any
	MacAddress uint64 `protobuf:"varint,3,opt,name=MacAddress,proto3" json:"MacAddress,omitempty"`
	// pinned uplink interface, if applicable for this device
	PinnedInterface      []byte   `protobuf:"bytes,4,opt,name=PinnedInterface,proto3" json:"PinnedInterface,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LifSpec) Reset()         { *m = LifSpec{} }
func (m *LifSpec) String() string { return proto.CompactTextString(m) }
func (*LifSpec) ProtoMessage()    {}
func (*LifSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{33}
}
func (m *LifSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifSpec.Merge(m, src)
}
func (m *LifSpec) XXX_Size() int {
	return m.Size()
}
func (m *LifSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LifSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LifSpec proto.InternalMessageInfo

func (m *LifSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LifSpec) GetType() LifType {
	if m != nil {
		return m.Type
	}
	return LifType_LIF_TYPE_NONE
}

func (m *LifSpec) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *LifSpec) GetPinnedInterface() []byte {
	if m != nil {
		return m.PinnedInterface
	}
	return nil
}

type LifStatus struct {
	// encoded ifindex of this lif
	IfIndex uint32 `protobuf:"varint,1,opt,name=IfIndex,proto3" json:"IfIndex,omitempty"`
	// name of this lif (as seen on the host)
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// admin state of the lif (reflects PF/VF status on the host/VM)
	AdminState IfStatus `protobuf:"varint,3,opt,name=AdminState,proto3,enum=pds.IfStatus" json:"AdminState,omitempty"`
	// operational status of this lif
	Status IfStatus `protobuf:"varint,4,opt,name=Status,proto3,enum=pds.IfStatus" json:"Status,omitempty"`
	// nexthop hw idx of this lif, if any
	NhIndex uint32 `protobuf:"varint,5,opt,name=NhIndex,proto3" json:"NhIndex,omitempty"`
	// vnic hw idx of this lif
	VnicIndex            uint32   `protobuf:"varint,6,opt,name=VnicIndex,proto3" json:"VnicIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LifStatus) Reset()         { *m = LifStatus{} }
func (m *LifStatus) String() string { return proto.CompactTextString(m) }
func (*LifStatus) ProtoMessage()    {}
func (*LifStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{34}
}
func (m *LifStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifStatus.Merge(m, src)
}
func (m *LifStatus) XXX_Size() int {
	return m.Size()
}
func (m *LifStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LifStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LifStatus proto.InternalMessageInfo

func (m *LifStatus) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *LifStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LifStatus) GetAdminState() IfStatus {
	if m != nil {
		return m.AdminState
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *LifStatus) GetStatus() IfStatus {
	if m != nil {
		return m.Status
	}
	return IfStatus_IF_STATUS_NONE
}

func (m *LifStatus) GetNhIndex() uint32 {
	if m != nil {
		return m.NhIndex
	}
	return 0
}

func (m *LifStatus) GetVnicIndex() uint32 {
	if m != nil {
		return m.VnicIndex
	}
	return 0
}

type LifStats struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LifStats) Reset()         { *m = LifStats{} }
func (m *LifStats) String() string { return proto.CompactTextString(m) }
func (*LifStats) ProtoMessage()    {}
func (*LifStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{35}
}
func (m *LifStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifStats.Merge(m, src)
}
func (m *LifStats) XXX_Size() int {
	return m.Size()
}
func (m *LifStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LifStats.DiscardUnknown(m)
}

var xxx_messageInfo_LifStats proto.InternalMessageInfo

type Lif struct {
	*pds.TypeMeta        `protobuf:"bytes,1,opt,name=TypeMeta,proto3,embedded=TypeMeta" json:",inline"`
	*pds.ObjMeta         `protobuf:"bytes,2,opt,name=ObjMeta,proto3,embedded=ObjMeta" json:"meta,omitempty"`
	Spec                 *LifSpec   `protobuf:"bytes,3,opt,name=Spec,proto3" json:"spec,omitempty"`
	Status               *LifStatus `protobuf:"bytes,4,opt,name=Status,proto3" json:"status,omitempty"`
	Stats                *LifStats  `protobuf:"bytes,5,opt,name=Stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Lif) Reset()         { *m = Lif{} }
func (m *Lif) String() string { return proto.CompactTextString(m) }
func (*Lif) ProtoMessage()    {}
func (*Lif) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{36}
}
func (m *Lif) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lif) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Lif.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Lif) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lif.Merge(m, src)
}
func (m *Lif) XXX_Size() int {
	return m.Size()
}
func (m *Lif) XXX_DiscardUnknown() {
	xxx_messageInfo_Lif.DiscardUnknown(m)
}

var xxx_messageInfo_Lif proto.InternalMessageInfo

func (m *Lif) GetSpec() *LifSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Lif) GetStatus() *LifStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Lif) GetStats() *LifStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type LifGetRequest struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LifGetRequest) Reset()         { *m = LifGetRequest{} }
func (m *LifGetRequest) String() string { return proto.CompactTextString(m) }
func (*LifGetRequest) ProtoMessage()    {}
func (*LifGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{37}
}
func (m *LifGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifGetRequest.Merge(m, src)
}
func (m *LifGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LifGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LifGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LifGetRequest proto.InternalMessageInfo

func (m *LifGetRequest) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type LifGetResponse struct {
	ApiStatus            ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response             []*Lif    `protobuf:"bytes,2,rep,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LifGetResponse) Reset()         { *m = LifGetResponse{} }
func (m *LifGetResponse) String() string { return proto.CompactTextString(m) }
func (*LifGetResponse) ProtoMessage()    {}
func (*LifGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ef53c9e620778f1, []int{38}
}
func (m *LifGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifGetResponse.Merge(m, src)
}
func (m *LifGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LifGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LifGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LifGetResponse proto.InternalMessageInfo

func (m *LifGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *LifGetResponse) GetResponse() []*Lif {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterEnum("pds.IfType", IfType_name, IfType_value)
	proto.RegisterEnum("pds.IfStatus", IfStatus_name, IfStatus_value)
	proto.RegisterEnum("pds.LldpIdType", LldpIdType_name, LldpIdType_value)
	proto.RegisterEnum("pds.LldpProtoMode", LldpProtoMode_name, LldpProtoMode_value)
	proto.RegisterEnum("pds.LldpCapType", LldpCapType_name, LldpCapType_value)
	proto.RegisterType((*LldpIfStats)(nil), "pds.LldpIfStats")
	proto.RegisterType((*LldpId)(nil), "pds.LldpId")
	proto.RegisterType((*LldpChassisCapabilityInfo)(nil), "pds.LldpChassisCapabilityInfo")
	proto.RegisterType((*LldpIfChassisInfo)(nil), "pds.LldpIfChassisInfo")
	proto.RegisterType((*LldpSpec)(nil), "pds.LldpSpec")
	proto.RegisterType((*UplinkSpec)(nil), "pds.UplinkSpec")
	proto.RegisterType((*UplinkPCSpec)(nil), "pds.UplinkPCSpec")
	proto.RegisterType((*L3IfSpec)(nil), "pds.L3IfSpec")
	proto.RegisterType((*LoopbackIfSpec)(nil), "pds.LoopbackIfSpec")
	proto.RegisterType((*ControlIfSpec)(nil), "pds.ControlIfSpec")
	proto.RegisterType((*HostIfSpec)(nil), "pds.HostIfSpec")
	proto.RegisterType((*InterfaceSpec)(nil), "pds.InterfaceSpec")
	proto.RegisterType((*LldpIfPortStatus)(nil), "pds.LldpIfPortStatus")
	proto.RegisterType((*LldpUnknownTlvStatus)(nil), "pds.LldpUnknownTlvStatus")
	proto.RegisterType((*LldpIfStatus)(nil), "pds.LldpIfStatus")
	proto.RegisterType((*LldpStatus)(nil), "pds.LldpStatus")
	proto.RegisterType((*UplinkIfStatus)(nil), "pds.UplinkIfStatus")
	proto.RegisterType((*LoopbackIfStatus)(nil), "pds.LoopbackIfStatus")
	proto.RegisterType((*HostIfStatus)(nil), "pds.HostIfStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "pds.InterfaceStatus")
	proto.RegisterType((*UplinkIfStats)(nil), "pds.UplinkIfStats")
	proto.RegisterType((*UplinkPCStats)(nil), "pds.UplinkPCStats")
	proto.RegisterType((*L3IfStats)(nil), "pds.L3IfStats")
	proto.RegisterType((*LoopbackIfStats)(nil), "pds.LoopbackIfStats")
	proto.RegisterType((*ControlIfStats)(nil), "pds.ControlIfStats")
	proto.RegisterType((*InterfaceStats)(nil), "pds.InterfaceStats")
	proto.RegisterType((*Interface)(nil), "pds.Interface")
	proto.RegisterType((*InterfaceRequest)(nil), "pds.InterfaceRequest")
	proto.RegisterType((*InterfaceResponse)(nil), "pds.InterfaceResponse")
	proto.RegisterType((*InterfaceGetRequest)(nil), "pds.InterfaceGetRequest")
	proto.RegisterType((*InterfaceGetResponse)(nil), "pds.InterfaceGetResponse")
	proto.RegisterType((*InterfaceDeleteRequest)(nil), "pds.InterfaceDeleteRequest")
	proto.RegisterType((*InterfaceDeleteResponse)(nil), "pds.InterfaceDeleteResponse")
	proto.RegisterType((*LifSpec)(nil), "pds.LifSpec")
	proto.RegisterType((*LifStatus)(nil), "pds.LifStatus")
	proto.RegisterType((*LifStats)(nil), "pds.LifStats")
	proto.RegisterType((*Lif)(nil), "pds.Lif")
	proto.RegisterType((*LifGetRequest)(nil), "pds.LifGetRequest")
	proto.RegisterType((*LifGetResponse)(nil), "pds.LifGetResponse")
}

func init() { proto.RegisterFile("interface.proto", fileDescriptor_3ef53c9e620778f1) }

var fileDescriptor_3ef53c9e620778f1 = []byte{
	// 2590 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x19, 0x4d, 0x6f, 0x1b, 0xc7,
	0xd5, 0xfc, 0x26, 0x1f, 0x29, 0x6a, 0x35, 0x92, 0x15, 0x5a, 0x75, 0x4d, 0x63, 0xd3, 0x04, 0xae,
	0xe0, 0x2a, 0x8d, 0xec, 0xc4, 0xa9, 0x13, 0xa7, 0xe5, 0x92, 0x74, 0x44, 0x94, 0x22, 0x17, 0x43,
	0x4a, 0x69, 0x8b, 0x02, 0xc2, 0x8a, 0x1c, 0xca, 0x1b, 0x93, 0xbb, 0xdb, 0xdd, 0xa5, 0x23, 0xa5,
	0x2d, 0x7a, 0x29, 0x90, 0x7b, 0xcf, 0xbd, 0xf5, 0xd0, 0x73, 0x7f, 0x43, 0x0b, 0xb4, 0xbd, 0xe5,
	0x18, 0xe4, 0x40, 0x14, 0x39, 0xe6, 0x56, 0xfd, 0x82, 0x62, 0x3e, 0x76, 0x77, 0x76, 0x49, 0xc8,
	0xb1, 0x5a, 0xa0, 0x17, 0x62, 0xe7, 0x7d, 0xcf, 0x7b, 0x6f, 0xde, 0x7b, 0x33, 0x84, 0x75, 0xd3,
	0xf2, 0x89, 0x3b, 0x31, 0x46, 0x64, 0xcf, 0x71, 0x6d, 0xdf, 0x46, 0x19, 0x67, 0xec, 0xed, 0xac,
	0xcf, 0x88, 0x6f, 0xbc, 0x45, 0x7f, 0x38, 0x74, 0xa7, 0xec, 0x5f, 0x38, 0xc4, 0xe3, 0x0b, 0xf5,
	0xdf, 0x29, 0x28, 0x77, 0xa7, 0x63, 0xa7, 0x33, 0x19, 0xf8, 0x86, 0xef, 0xa1, 0x1a, 0x14, 0x86,
	0xe7, 0x4d, 0x7b, 0x6e, 0xf9, 0xb5, 0xd4, 0xdd, 0xd4, 0xbd, 0x35, 0x1c, 0x2c, 0x29, 0x06, 0x0b,
	0x4c, 0x9a, 0x63, 0xc4, 0x12, 0xdd, 0x85, 0x32, 0x3e, 0x6f, 0x99, 0xde, 0xc8, 0x70, 0xc7, 0x64,
	0x5c, 0xcb, 0x30, 0xac, 0x0c, 0x42, 0x6f, 0x42, 0x15, 0x9f, 0x1f, 0x59, 0x2e, 0x19, 0xd9, 0x67,
	0x96, 0xf9, 0x19, 0x19, 0xd7, 0xb2, 0x8c, 0x28, 0x01, 0xa5, 0x92, 0x1a, 0x67, 0xc4, 0x9e, 0xfb,
	0x5c, 0x4f, 0x8e, 0x4b, 0x92, 0x40, 0x94, 0xa2, 0x63, 0x79, 0xc4, 0x15, 0x14, 0x79, 0x4e, 0x21,
	0x81, 0x28, 0x45, 0x8b, 0x4c, 0x89, 0x4f, 0x38, 0x45, 0x81, 0x53, 0x48, 0x20, 0xb5, 0x09, 0x79,
	0xb6, 0xe5, 0x31, 0x7a, 0x1d, 0xb2, 0xc3, 0x0b, 0x87, 0xb0, 0xad, 0x56, 0xf7, 0xd7, 0xf7, 0x9c,
	0xb1, 0xb7, 0xc7, 0x51, 0x14, 0x8c, 0x19, 0x12, 0x6d, 0x41, 0xee, 0xd8, 0x98, 0xce, 0x09, 0xdb,
	0x76, 0x05, 0xf3, 0x85, 0x7a, 0x06, 0xb7, 0x28, 0x65, 0xf3, 0x99, 0xe1, 0x79, 0xa6, 0xd7, 0x34,
	0x1c, 0xe3, 0xd4, 0x9c, 0x9a, 0xfe, 0x45, 0xc7, 0x9a, 0xd8, 0x68, 0x17, 0x0a, 0x4d, 0xc3, 0x91,
	0x44, 0x2b, 0xa1, 0x68, 0x01, 0xc7, 0x01, 0x01, 0xba, 0x03, 0xd0, 0x34, 0x9c, 0xb6, 0x65, 0x9c,
	0x4e, 0xc9, 0x98, 0xe9, 0x28, 0x62, 0x09, 0xa2, 0x2e, 0x52, 0xb0, 0xc1, 0x23, 0x24, 0x74, 0x31,
	0x0d, 0x35, 0x28, 0x0c, 0x2e, 0xbc, 0x9e, 0x31, 0xe3, 0x1a, 0x4a, 0x38, 0x58, 0xa2, 0xef, 0x43,
	0x29, 0x20, 0xe4, 0xe2, 0xca, 0xfb, 0x65, 0x69, 0x63, 0x38, 0xc2, 0xa2, 0x1d, 0x28, 0x0e, 0x2e,
	0xbc, 0x16, 0xf1, 0x46, 0x2e, 0x8b, 0x5a, 0x09, 0x87, 0x6b, 0x74, 0x0f, 0xf2, 0x87, 0x67, 0x33,
	0xbf, 0xa3, 0xb3, 0x50, 0x95, 0xf7, 0x95, 0x3d, 0x9e, 0x36, 0x1d, 0xbd, 0x31, 0x1e, 0xbb, 0xc4,
	0xf3, 0xb0, 0xc0, 0xa3, 0x0f, 0xd9, 0x06, 0xc4, 0xf6, 0x6b, 0xb9, 0xbb, 0x99, 0x7b, 0xe5, 0xfd,
	0x3b, 0xd1, 0x7e, 0x57, 0x39, 0x08, 0x4b, 0x1c, 0xaa, 0x0e, 0x45, 0x4a, 0x38, 0x70, 0xc8, 0x08,
	0xb5, 0x12, 0x7b, 0xa5, 0x40, 0xb6, 0xc1, 0xf2, 0xfe, 0x76, 0xb4, 0x09, 0xd9, 0x13, 0x78, 0x99,
	0x41, 0xfd, 0x25, 0xc0, 0x91, 0x33, 0x35, 0xad, 0xe7, 0x4c, 0xe6, 0x2e, 0xe4, 0x75, 0xdb, 0xf5,
	0x3b, 0x63, 0x26, 0xa8, 0xa2, 0xa1, 0xcb, 0x45, 0xbd, 0x4a, 0xcf, 0xc3, 0xe3, 0x99, 0x61, 0x8d,
	0x0d, 0xdf, 0x76, 0x2f, 0xb0, 0xa0, 0x40, 0x2a, 0x54, 0x7a, 0x86, 0x6f, 0xbe, 0x20, 0xc7, 0x53,
	0xc3, 0x12, 0xfe, 0x5b, 0xc3, 0x31, 0x98, 0xfa, 0x0b, 0xa8, 0x70, 0xe9, 0x7a, 0x93, 0xc9, 0x7f,
	0x13, 0xaa, 0x87, 0x64, 0x76, 0x4a, 0xdc, 0xce, 0x44, 0x33, 0xfd, 0x99, 0xe1, 0x30, 0x3d, 0x59,
	0x9c, 0x80, 0x7e, 0x2b, 0xd9, 0x7f, 0x4e, 0x43, 0xb1, 0xfb, 0xa0, 0x33, 0x61, 0x82, 0xf7, 0x21,
	0x77, 0xec, 0x8c, 0x42, 0xbb, 0x6f, 0x5f, 0x2e, 0xea, 0xb5, 0xb8, 0xdd, 0xf7, 0xcd, 0xd9, 0x6c,
	0xee, 0xd3, 0x3c, 0xc1, 0x9c, 0x14, 0xb5, 0x21, 0xaf, 0xbb, 0x64, 0x62, 0x9e, 0xd7, 0xd2, 0x2c,
	0x10, 0xeb, 0x61, 0xd8, 0x38, 0xf8, 0x25, 0x52, 0x04, 0x33, 0x7a, 0x18, 0xfa, 0x2c, 0xf3, 0x2d,
	0x74, 0x07, 0xde, 0x7b, 0x17, 0x72, 0x6d, 0x6b, 0x64, 0x38, 0x22, 0x65, 0x2a, 0x42, 0x37, 0x83,
	0x49, 0x6e, 0x97, 0x8c, 0x66, 0x28, 0xb4, 0x0f, 0x70, 0xd8, 0x68, 0x8a, 0xbc, 0x62, 0xa7, 0x3e,
	0xbb, 0x92, 0x5c, 0xa2, 0x52, 0xbf, 0x4c, 0x41, 0xb5, 0x6b, 0xdb, 0xce, 0xa9, 0x31, 0x7a, 0x2e,
	0xfc, 0xf5, 0x7e, 0xb8, 0x77, 0x9e, 0x31, 0x4b, 0x7b, 0x5f, 0x1d, 0x79, 0xbe, 0x63, 0x5a, 0xc4,
	0xec, 0xb9, 0x4f, 0x0e, 0x89, 0xef, 0x9a, 0x23, 0x11, 0x1c, 0x19, 0x84, 0x1e, 0xc2, 0x4d, 0xed,
	0xcc, 0x69, 0x78, 0xba, 0xe1, 0x3f, 0xd3, 0x5d, 0xe2, 0x10, 0x6b, 0xcc, 0x4b, 0x0c, 0x2f, 0x78,
	0xab, 0x91, 0xe8, 0x6d, 0x28, 0x35, 0xed, 0xd9, 0x6c, 0x6e, 0xd1, 0xc3, 0x91, 0x65, 0x31, 0xd9,
	0x14, 0x76, 0x69, 0x1f, 0xe9, 0x21, 0x0a, 0x47, 0x54, 0xea, 0x14, 0xd6, 0x9a, 0xb6, 0xe5, 0xbb,
	0xf6, 0xf4, 0x7f, 0xb1, 0xb1, 0x3b, 0x31, 0xe7, 0xa6, 0x59, 0x6a, 0xca, 0x8e, 0xfc, 0x6b, 0x1a,
	0xe0, 0xc0, 0xf6, 0x7c, 0xa1, 0x4b, 0x85, 0xf4, 0xf1, 0x84, 0xe9, 0x29, 0xae, 0x8c, 0x41, 0xfa,
	0x78, 0x82, 0xde, 0x83, 0x72, 0xd3, 0xb6, 0xac, 0xa1, 0x6b, 0x8c, 0x9e, 0xb7, 0x2d, 0x5e, 0xb3,
	0xb4, 0xed, 0xcb, 0x45, 0x1d, 0x31, 0xe2, 0x31, 0x99, 0x18, 0xf3, 0xa9, 0xff, 0x64, 0x62, 0x4c,
	0x3d, 0x82, 0x65, 0x52, 0x74, 0x1b, 0x4a, 0xc3, 0x73, 0xdd, 0x9e, 0x9a, 0x23, 0xc2, 0x4b, 0x4e,
	0x05, 0x47, 0x00, 0xf4, 0x83, 0x98, 0xa9, 0x59, 0x96, 0x07, 0x6b, 0x97, 0x8b, 0x7a, 0xc9, 0x21,
	0xae, 0x67, 0x7a, 0x3e, 0x19, 0xcb, 0x96, 0xa3, 0x87, 0x50, 0x7e, 0x3a, 0xb5, 0x3f, 0xed, 0xda,
	0x67, 0xac, 0x4c, 0xe4, 0x98, 0x6f, 0x90, 0xf0, 0x8d, 0x84, 0xc1, 0x32, 0x19, 0xda, 0x83, 0x52,
	0x97, 0x18, 0xae, 0xc5, 0x78, 0xf2, 0xb1, 0xda, 0x16, 0xc2, 0x71, 0x44, 0x82, 0x14, 0xc8, 0x1c,
	0xf7, 0x9e, 0xb2, 0x3e, 0x52, 0xc4, 0xf4, 0x13, 0x21, 0xc8, 0xb2, 0xc2, 0x5b, 0x64, 0x25, 0x93,
	0x7d, 0xab, 0xbf, 0x2f, 0xc2, 0x5a, 0x27, 0x68, 0xbf, 0x81, 0x23, 0xaf, 0x2c, 0x39, 0xe9, 0xce,
	0x18, 0xf5, 0xa0, 0xdc, 0x18, 0xcf, 0x4c, 0x8b, 0xf6, 0xde, 0x39, 0x0f, 0x4e, 0x75, 0x7f, 0x8d,
	0x15, 0x3a, 0xde, 0x90, 0xe7, 0x9e, 0xf6, 0xdd, 0xcb, 0x45, 0xfd, 0x56, 0xcc, 0xaf, 0x9d, 0xa7,
	0x27, 0x83, 0x61, 0x63, 0x78, 0x34, 0x38, 0x39, 0xd2, 0xb1, 0x2c, 0x00, 0x4d, 0xe5, 0xc2, 0xc7,
	0xfc, 0x5b, 0x16, 0x5d, 0x2d, 0x02, 0x6b, 0x3f, 0xba, 0x5c, 0xd4, 0xdf, 0x61, 0x02, 0x47, 0xb6,
	0xe5, 0xf9, 0xae, 0x61, 0x5a, 0xbe, 0xf7, 0xe4, 0xd7, 0x31, 0xeb, 0xf7, 0x68, 0x6b, 0x7a, 0x42,
	0x35, 0x0d, 0x7f, 0xae, 0xb7, 0x4f, 0x8e, 0xf4, 0x6e, 0xa7, 0xf7, 0xd3, 0xdf, 0x1e, 0xdc, 0xc0,
	0x72, 0x61, 0x9d, 0xc7, 0x0b, 0xa1, 0x38, 0xf5, 0x1b, 0x92, 0x3e, 0x8e, 0xd0, 0x3e, 0xb8, 0x5c,
	0xd4, 0xdf, 0xbb, 0x8e, 0xc6, 0x13, 0xbd, 0x49, 0x95, 0xc6, 0xeb, 0xed, 0x69, 0x54, 0x22, 0x45,
	0xcc, 0xb9, 0xc7, 0x02, 0xa0, 0xf6, 0xce, 0xe5, 0xa2, 0xfe, 0xf6, 0xab, 0xa9, 0xeb, 0x3e, 0xa0,
	0x7a, 0xa2, 0xd2, 0xfb, 0x59, 0xb2, 0xb8, 0x88, 0x4c, 0xd9, 0xe4, 0x9a, 0x62, 0x28, 0xed, 0xfd,
	0xcb, 0x45, 0xfd, 0xd1, 0x2b, 0xea, 0xeb, 0xf7, 0x75, 0xad, 0xd1, 0x64, 0x2e, 0x4d, 0x96, 0xb1,
	0x17, 0x89, 0xe3, 0xcf, 0x52, 0x8f, 0x26, 0x36, 0x55, 0x1d, 0xc3, 0x68, 0x8f, 0x2f, 0x17, 0xf5,
	0x77, 0x5f, 0x4d, 0x73, 0xb3, 0xdf, 0x1b, 0xe2, 0x7e, 0x97, 0x2a, 0x4e, 0x54, 0x99, 0x4f, 0xe4,
	0x3a, 0xc0, 0x92, 0x3b, 0x48, 0x9e, 0x08, 0xac, 0x3d, 0xba, 0x5c, 0xd4, 0x1f, 0xbc, 0x9a, 0xc6,
	0x83, 0xfe, 0x60, 0xc8, 0x52, 0x47, 0xaa, 0x32, 0x04, 0x36, 0x86, 0xe7, 0x87, 0xa6, 0xeb, 0xda,
	0xee, 0x80, 0x78, 0x9e, 0x69, 0xd3, 0x86, 0x58, 0xba, 0x9b, 0xb9, 0x57, 0xb9, 0xb6, 0x06, 0xbc,
	0x2c, 0x91, 0xaa, 0xc1, 0x4b, 0x6a, 0xe0, 0xbf, 0x54, 0xb3, 0x24, 0x51, 0x2b, 0x42, 0xde, 0x9c,
	0x98, 0xd6, 0xc4, 0x56, 0xcf, 0x40, 0xe1, 0xe3, 0x08, 0xed, 0x88, 0xe2, 0x50, 0xbe, 0x1e, 0x9b,
	0x3f, 0x12, 0xd3, 0x58, 0xd0, 0x3a, 0x6f, 0x43, 0x89, 0x7e, 0xf1, 0x59, 0x2c, 0xcd, 0x0a, 0x4b,
	0x04, 0xa0, 0x35, 0x68, 0xe8, 0x4f, 0x45, 0xa3, 0xa1, 0x9f, 0xea, 0x27, 0xb0, 0x45, 0x25, 0x1c,
	0x59, 0xcf, 0x2d, 0xfb, 0x53, 0x6b, 0x38, 0x7d, 0x21, 0x94, 0x29, 0x90, 0xe9, 0xcf, 0x4d, 0x31,
	0x13, 0xd2, 0x4f, 0x36, 0x29, 0xce, 0x4f, 0x69, 0x81, 0x0b, 0xe6, 0x76, 0xb1, 0xa4, 0xb4, 0x5d,
	0x62, 0x05, 0x52, 0xbb, 0xc4, 0x8a, 0x46, 0xdd, 0x2c, 0xe3, 0x17, 0xa3, 0xee, 0x57, 0x69, 0xa8,
	0x44, 0x77, 0x84, 0xb9, 0x87, 0xb6, 0x21, 0xdf, 0x99, 0x48, 0xb3, 0xa7, 0x58, 0xd1, 0x79, 0x92,
	0x35, 0x4c, 0x37, 0x9c, 0x6e, 0xc2, 0x35, 0xba, 0x07, 0x39, 0x9d, 0xde, 0x38, 0x98, 0xba, 0xaa,
	0xc8, 0x66, 0x2a, 0x95, 0x41, 0x0f, 0xed, 0x31, 0xc1, 0x9c, 0x80, 0x9a, 0xd5, 0x38, 0xe3, 0x26,
	0x54, 0x30, 0xfd, 0x44, 0x07, 0xb0, 0x19, 0x1f, 0xf2, 0x78, 0xb9, 0xcc, 0x5d, 0x39, 0x17, 0xae,
	0x62, 0x41, 0x8d, 0xe5, 0xf8, 0x88, 0x93, 0x7d, 0x53, 0x12, 0x13, 0x21, 0xf1, 0x72, 0x38, 0x0f,
	0x57, 0x7b, 0xbe, 0x56, 0x60, 0xbd, 0xfd, 0x56, 0x28, 0x26, 0x49, 0x80, 0x57, 0xb2, 0xa9, 0xbf,
	0x01, 0x60, 0xd3, 0x2f, 0x17, 0xfe, 0x4e, 0xdc, 0xd3, 0x22, 0x63, 0x36, 0x24, 0xdb, 0x84, 0xb0,
	0x78, 0x40, 0x1e, 0xc1, 0x1a, 0x5d, 0xf7, 0x4e, 0x5d, 0xa9, 0x93, 0xac, 0xe4, 0x8b, 0xd3, 0xa9,
	0x1f, 0x43, 0x95, 0xd7, 0xd6, 0x50, 0xd4, 0x16, 0xe4, 0xba, 0xe6, 0x44, 0x24, 0xeb, 0x1a, 0xe6,
	0x0b, 0xf4, 0x96, 0x6c, 0xa5, 0x90, 0x1e, 0x5d, 0x97, 0x84, 0x6c, 0x89, 0x44, 0x7d, 0x13, 0x14,
	0xa9, 0xac, 0x71, 0xd1, 0x08, 0xb2, 0x56, 0x94, 0x34, 0xec, 0x5b, 0xfd, 0x1d, 0x54, 0x44, 0x59,
	0x58, 0x52, 0x9f, 0xa1, 0x97, 0x2d, 0xae, 0xfe, 0x25, 0x33, 0x0c, 0x7a, 0x03, 0xf2, 0xc2, 0xb4,
	0xcc, 0x8a, 0x16, 0x8a, 0xf3, 0x91, 0x01, 0x2c, 0x6b, 0xb3, 0x52, 0xe3, 0xfe, 0x53, 0x1a, 0xd6,
	0xa3, 0x43, 0xcf, 0xe9, 0x6a, 0x50, 0xe8, 0x4c, 0x3a, 0xd6, 0x98, 0x9c, 0x07, 0x97, 0x60, 0xb1,
	0xa4, 0x13, 0x4a, 0xdf, 0x21, 0xee, 0x15, 0xfd, 0x1a, 0x4b, 0x04, 0xe8, 0x49, 0xd2, 0xbd, 0xa2,
	0x27, 0x6f, 0x4a, 0x3d, 0x32, 0x40, 0xd1, 0x4e, 0x90, 0x88, 0x45, 0x73, 0xd9, 0x89, 0xa2, 0xc9,
	0xde, 0x4c, 0xf6, 0xa1, 0x40, 0xc4, 0xb2, 0xd7, 0x1f, 0xc5, 0x3d, 0x2c, 0x4e, 0xcd, 0x86, 0x5c,
	0xd8, 0x03, 0xe6, 0x18, 0xa1, 0x06, 0x50, 0x34, 0x27, 0x1e, 0x0f, 0x67, 0x13, 0xd6, 0x64, 0xdb,
	0x3c, 0xb4, 0x1f, 0x7b, 0x36, 0x10, 0x79, 0xaa, 0x24, 0xf2, 0xcd, 0xc3, 0x32, 0x91, 0xba, 0x1e,
	0x08, 0xd1, 0x9b, 0x1c, 0x50, 0x86, 0x12, 0xeb, 0xb8, 0x6c, 0xb1, 0x01, 0xeb, 0x71, 0xdb, 0x3d,
	0x55, 0x81, 0x6a, 0xd4, 0xa2, 0x18, 0xe4, 0x6f, 0x69, 0xa8, 0xc6, 0xa2, 0xe5, 0xa1, 0xc7, 0x09,
	0xd3, 0x84, 0x2d, 0x68, 0xc9, 0xc5, 0x74, 0x87, 0x89, 0x5d, 0x3c, 0x4e, 0x58, 0x24, 0x32, 0x1b,
	0xc5, 0x47, 0x98, 0x38, 0xaf, 0x00, 0xb0, 0x39, 0x32, 0x30, 0x5e, 0x84, 0xb5, 0x1a, 0xcd, 0x21,
	0x82, 0x27, 0x22, 0x41, 0x3f, 0x59, 0xda, 0x9f, 0x88, 0xe5, 0xd6, 0x8a, 0x58, 0x52, 0xde, 0x24,
	0x39, 0xcd, 0xa6, 0xb8, 0x3b, 0x44, 0x2c, 0x37, 0x13, 0x93, 0x81, 0xe0, 0x4f, 0x10, 0x6b, 0x25,
	0x28, 0xf0, 0x78, 0x7a, 0xea, 0x3f, 0xd3, 0x50, 0x0a, 0xdd, 0x88, 0xde, 0x87, 0x22, 0x6d, 0x74,
	0x87, 0xc4, 0x37, 0x84, 0xf3, 0xaa, 0x7b, 0xec, 0xbd, 0x28, 0x80, 0x6a, 0xeb, 0x5f, 0x2c, 0xea,
	0xa9, 0x6f, 0x16, 0xf5, 0xc2, 0x7d, 0xd3, 0x9a, 0x9a, 0x16, 0xc1, 0x21, 0x03, 0xfa, 0x31, 0x14,
	0xfa, 0xa7, 0x9f, 0x30, 0xde, 0xb4, 0x18, 0xc6, 0x18, 0xaf, 0x00, 0x6a, 0xdb, 0x82, 0x95, 0x8d,
	0xbf, 0xf7, 0xed, 0x99, 0xe9, 0x93, 0x99, 0xe3, 0x5f, 0xe0, 0x80, 0x0b, 0x3d, 0x86, 0xac, 0x34,
	0xad, 0x72, 0xd7, 0xc7, 0xba, 0xb0, 0x86, 0x28, 0xbb, 0xe7, 0x90, 0x91, 0xc4, 0xce, 0x78, 0x90,
	0x16, 0x9e, 0x7b, 0xd9, 0x95, 0x89, 0xe3, 0xac, 0x6d, 0x7d, 0xb3, 0xa8, 0x2b, 0x3c, 0x91, 0x25,
	0x09, 0x41, 0x51, 0xf8, 0x10, 0x72, 0xcb, 0xce, 0x8c, 0xe7, 0x98, 0xb6, 0xf9, 0xcd, 0xa2, 0xbe,
	0xce, 0x5c, 0x27, 0x09, 0xe0, 0x6c, 0xaa, 0x03, 0x4a, 0x48, 0x8d, 0xc9, 0xaf, 0xe6, 0xc4, 0xf3,
	0x69, 0x6e, 0x68, 0x86, 0x3f, 0x7a, 0xd6, 0xf4, 0xcf, 0xfd, 0xf0, 0x6c, 0x88, 0x4b, 0x5f, 0x00,
	0xc7, 0x11, 0x09, 0xba, 0x0f, 0x05, 0xc1, 0x2a, 0xae, 0xed, 0x2b, 0xdc, 0x80, 0x03, 0x12, 0x75,
	0x0e, 0x1b, 0x92, 0x46, 0xcf, 0xb1, 0x2d, 0x8f, 0x50, 0x95, 0x0d, 0xc7, 0x94, 0xda, 0x46, 0x35,
	0x54, 0x19, 0xc2, 0x71, 0x44, 0x82, 0x7e, 0x08, 0xc5, 0x80, 0x57, 0xe8, 0x5c, 0xe9, 0x3c, 0x1c,
	0x52, 0xa9, 0x6f, 0xc0, 0x66, 0x88, 0xfc, 0x88, 0xf8, 0xc1, 0x5e, 0xab, 0xe2, 0x9e, 0x43, 0xcb,
	0x75, 0xba, 0x33, 0x56, 0x5d, 0xd8, 0x8a, 0x93, 0x5d, 0xd3, 0xc0, 0xdd, 0x25, 0x03, 0xab, 0x71,
	0x03, 0x25, 0xd3, 0x7e, 0x06, 0xdb, 0x21, 0x98, 0xbf, 0xf4, 0x5d, 0x37, 0x12, 0x7c, 0x37, 0xe9,
	0x70, 0x37, 0x1d, 0x78, 0x6d, 0x49, 0xf2, 0xea, 0x0d, 0x65, 0x5e, 0xb2, 0x21, 0xf5, 0xf3, 0x14,
	0x14, 0xba, 0x26, 0x9f, 0x7f, 0xab, 0xd1, 0xe5, 0x90, 0x5d, 0x04, 0x55, 0xf1, 0x10, 0xc9, 0x3b,
	0x4a, 0x35, 0xb8, 0x8f, 0x9a, 0x13, 0xe9, 0x1d, 0x92, 0x36, 0x41, 0x63, 0x14, 0x34, 0xc1, 0x8c,
	0x68, 0x82, 0x21, 0x04, 0xdd, 0x83, 0x75, 0xdd, 0xb4, 0x2c, 0x32, 0x0e, 0x0d, 0x16, 0x33, 0x54,
	0x12, 0xac, 0xfe, 0x3d, 0x05, 0x25, 0x6a, 0xc9, 0xcb, 0xba, 0x5d, 0xd0, 0x2f, 0xd3, 0x51, 0xbf,
	0xa4, 0x1d, 0x30, 0xbc, 0x71, 0x92, 0xd5, 0xed, 0x56, 0x22, 0x90, 0x3a, 0x73, 0xf6, 0xaa, 0xce,
	0x5c, 0x83, 0x42, 0xef, 0x19, 0xb7, 0x81, 0x3f, 0xfa, 0x06, 0x4b, 0x3a, 0x18, 0x1f, 0x5b, 0xe6,
	0x88, 0xe3, 0xf8, 0x73, 0x6f, 0x04, 0x50, 0x01, 0x8a, 0x62, 0x23, 0x9e, 0xfa, 0x97, 0x34, 0x64,
	0xba, 0xe6, 0xe4, 0xff, 0x5c, 0xce, 0x1e, 0xc6, 0xca, 0x59, 0x85, 0xd7, 0x76, 0x1e, 0xf5, 0x2b,
	0x0a, 0xd9, 0x07, 0x89, 0x42, 0x56, 0x0d, 0xf9, 0xbe, 0x4d, 0x09, 0x7b, 0x2f, 0x5e, 0xc2, 0xd6,
	0x64, 0xe6, 0xab, 0x8b, 0x57, 0x1d, 0xd6, 0xba, 0xe6, 0xe4, 0x8a, 0xd3, 0x3c, 0x81, 0x6a, 0x40,
	0x70, 0xcd, 0x73, 0xfc, 0xbd, 0xa5, 0x73, 0x5c, 0x0c, 0xec, 0x8b, 0x4e, 0xf0, 0xee, 0x1f, 0x52,
	0xf4, 0x4e, 0x31, 0xe4, 0xd7, 0x92, 0x4a, 0x70, 0xe3, 0xea, 0xf5, 0x7b, 0x6d, 0xe5, 0x06, 0x42,
	0x50, 0x8d, 0xbf, 0x0b, 0x28, 0x29, 0x74, 0x13, 0x36, 0x96, 0xde, 0x0a, 0x94, 0x34, 0xaa, 0x02,
	0x44, 0x77, 0x7a, 0x25, 0x83, 0xb6, 0x40, 0x49, 0xde, 0xb9, 0x95, 0x2c, 0xda, 0x84, 0xf5, 0xc4,
	0x7d, 0x58, 0xc9, 0xc9, 0x7a, 0xe9, 0x4d, 0x4f, 0xc9, 0xef, 0xb6, 0xa0, 0x28, 0x0d, 0xaf, 0xd5,
	0xe8, 0xdd, 0x45, 0xd8, 0xc5, 0x39, 0xc2, 0xb7, 0x18, 0x25, 0x15, 0xa7, 0x6a, 0xf5, 0x3f, 0xee,
	0x29, 0xe9, 0xdd, 0xaf, 0x52, 0x7c, 0x78, 0xe6, 0x7f, 0x2a, 0xa0, 0xd7, 0x60, 0xb3, 0xdb, 0x6d,
	0xe9, 0x9d, 0xd6, 0xc9, 0xe0, 0x48, 0x93, 0x77, 0x79, 0x0b, 0x6e, 0x26, 0x10, 0x9d, 0xa7, 0xbd,
	0xc6, 0x61, 0x5b, 0x49, 0xa1, 0x1d, 0xd8, 0x5e, 0x42, 0x35, 0xba, 0x9d, 0xc6, 0x40, 0x49, 0xa3,
	0x1a, 0x6c, 0x25, 0x70, 0xdd, 0x7e, 0xb3, 0xd1, 0x55, 0x32, 0x68, 0x1b, 0x50, 0x02, 0x73, 0xd8,
	0x68, 0x2a, 0x59, 0xea, 0xba, 0xa4, 0x34, 0x5d, 0xc9, 0xad, 0x30, 0x4c, 0xef, 0xe3, 0xa1, 0x92,
	0x5f, 0xa1, 0xbd, 0x79, 0xd0, 0x18, 0x0c, 0x3a, 0x03, 0xa5, 0xb0, 0xfb, 0xc7, 0x14, 0xbf, 0x7a,
	0x84, 0xb7, 0x38, 0xea, 0x02, 0x4a, 0x7d, 0x72, 0xd8, 0x6f, 0xc9, 0x01, 0x8c, 0x60, 0xf4, 0x4b,
	0x49, 0xd1, 0x18, 0x44, 0xb0, 0x66, 0x4b, 0x3f, 0x7e, 0x5b, 0x49, 0x2f, 0x03, 0xf7, 0x95, 0x0c,
	0xda, 0x80, 0xb5, 0x08, 0xd8, 0x6e, 0xe9, 0x4a, 0x36, 0x0e, 0x7a, 0xda, 0xa2, 0xe6, 0xc7, 0x58,
	0x07, 0xfd, 0xde, 0xa1, 0xae, 0xe4, 0x77, 0xbf, 0x14, 0x7f, 0x6f, 0x05, 0x7f, 0xb6, 0x08, 0x97,
	0x9c, 0x34, 0x1b, 0x3a, 0xdb, 0x48, 0x7f, 0x78, 0xd0, 0xc6, 0x91, 0xef, 0x43, 0x38, 0x6e, 0xeb,
	0xed, 0xc6, 0xb0, 0x8d, 0x95, 0x54, 0xe0, 0x96, 0x10, 0xa5, 0xe1, 0x4e, 0xeb, 0xa3, 0xb6, 0x92,
	0x5e, 0x42, 0xe0, 0xfe, 0x11, 0xe5, 0xc8, 0x04, 0xfe, 0x0d, 0x11, 0x1f, 0x77, 0x1b, 0x3d, 0x25,
	0x1b, 0xb8, 0x31, 0x04, 0x0f, 0xdb, 0xdd, 0xb6, 0x7e, 0x40, 0x1d, 0x94, 0x5b, 0x92, 0xd5, 0xea,
	0x37, 0xa9, 0x7f, 0xf3, 0x41, 0x74, 0x43, 0x04, 0x4d, 0xad, 0x4e, 0xbf, 0xa7, 0x14, 0xf6, 0x3f,
	0xcf, 0x40, 0xae, 0x33, 0x19, 0xbc, 0xa0, 0x53, 0x50, 0x74, 0x83, 0x69, 0xba, 0x84, 0x96, 0xdd,
	0x9b, 0x89, 0x56, 0xc9, 0x4f, 0xf7, 0xce, 0x76, 0x12, 0x2c, 0xfa, 0xe7, 0x8d, 0x98, 0x8c, 0x23,
	0x67, 0x7c, 0x2d, 0x19, 0x3d, 0x49, 0x06, 0xef, 0x95, 0xe8, 0x3b, 0x71, 0xe2, 0x58, 0x6f, 0xde,
	0xb9, 0xbd, 0x1a, 0x19, 0xca, 0x6b, 0x43, 0x45, 0x9e, 0x24, 0x50, 0x2d, 0x4e, 0x1f, 0x55, 0xad,
	0x9d, 0x5b, 0x2b, 0x30, 0xa1, 0x98, 0x07, 0x90, 0xe7, 0x25, 0x0c, 0xa1, 0xa0, 0xf0, 0x48, 0xac,
	0x9b, 0x31, 0x58, 0xc8, 0xb4, 0xcb, 0x0a, 0x23, 0xbf, 0xc4, 0x10, 0x8f, 0xf8, 0xa8, 0x14, 0xbc,
	0xb9, 0x8f, 0x77, 0xc2, 0xff, 0x35, 0x68, 0x25, 0x55, 0x6f, 0x68, 0x95, 0x7f, 0x7c, 0x7d, 0x27,
	0xf5, 0xc5, 0xd7, 0x77, 0x52, 0xff, 0xfa, 0xfa, 0x4e, 0xea, 0x34, 0xcf, 0xfe, 0x58, 0x7d, 0xf0,
	0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5c, 0x78, 0x22, 0xdf, 0x8e, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IfSvcClient is the client API for IfSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IfSvcClient interface {
	InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error)
	InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error)
	InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error)
	LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error)
	// given a uuid of a lif, clear its stats or else clear stats of all lifs
	LifStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type ifSvcClient struct {
	cc *grpc.ClientConn
}

func NewIfSvcClient(cc *grpc.ClientConn) IfSvcClient {
	return &ifSvcClient{cc}
}

func (c *ifSvcClient) InterfaceCreate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/InterfaceCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceUpdate(ctx context.Context, in *InterfaceRequest, opts ...grpc.CallOption) (*InterfaceResponse, error) {
	out := new(InterfaceResponse)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/InterfaceUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceDelete(ctx context.Context, in *InterfaceDeleteRequest, opts ...grpc.CallOption) (*InterfaceDeleteResponse, error) {
	out := new(InterfaceDeleteResponse)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/InterfaceDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error) {
	out := new(InterfaceGetResponse)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/InterfaceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) LifGet(ctx context.Context, in *LifGetRequest, opts ...grpc.CallOption) (*LifGetResponse, error) {
	out := new(LifGetResponse)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/LifGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ifSvcClient) LifStatsReset(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pds.IfSvc/LifStatsReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IfSvcServer is the server API for IfSvc service.
type IfSvcServer interface {
	InterfaceCreate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceUpdate(context.Context, *InterfaceRequest) (*InterfaceResponse, error)
	InterfaceDelete(context.Context, *InterfaceDeleteRequest) (*InterfaceDeleteResponse, error)
	InterfaceGet(context.Context, *InterfaceGetRequest) (*InterfaceGetResponse, error)
	LifGet(context.Context, *LifGetRequest) (*LifGetResponse, error)
	// given a uuid of a lif, clear its stats or else clear stats of all lifs
	LifStatsReset(context.Context, *Id) (*Empty, error)
}

// UnimplementedIfSvcServer can be embedded to have forward compatible implementations.
type UnimplementedIfSvcServer struct {
}

func (*UnimplementedIfSvcServer) InterfaceCreate(ctx context.Context, req *InterfaceRequest) (*InterfaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceCreate not implemented")
}
func (*UnimplementedIfSvcServer) InterfaceUpdate(ctx context.Context, req *InterfaceRequest) (*InterfaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceUpdate not implemented")
}
func (*UnimplementedIfSvcServer) InterfaceDelete(ctx context.Context, req *InterfaceDeleteRequest) (*InterfaceDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceDelete not implemented")
}
func (*UnimplementedIfSvcServer) InterfaceGet(ctx context.Context, req *InterfaceGetRequest) (*InterfaceGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceGet not implemented")
}
func (*UnimplementedIfSvcServer) LifGet(ctx context.Context, req *LifGetRequest) (*LifGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifGet not implemented")
}
func (*UnimplementedIfSvcServer) LifStatsReset(ctx context.Context, req *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifStatsReset not implemented")
}

func RegisterIfSvcServer(s *grpc.Server, srv IfSvcServer) {
	s.RegisterService(&_IfSvc_serviceDesc, srv)
}

func _IfSvc_InterfaceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceCreate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceUpdate(ctx, req.(*InterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceDelete(ctx, req.(*InterfaceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_InterfaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).InterfaceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/InterfaceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).InterfaceGet(ctx, req.(*InterfaceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_LifGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).LifGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/LifGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).LifGet(ctx, req.(*LifGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IfSvc_LifStatsReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IfSvcServer).LifStatsReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.IfSvc/LifStatsReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IfSvcServer).LifStatsReset(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _IfSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.IfSvc",
	HandlerType: (*IfSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InterfaceCreate",
			Handler:    _IfSvc_InterfaceCreate_Handler,
		},
		{
			MethodName: "InterfaceUpdate",
			Handler:    _IfSvc_InterfaceUpdate_Handler,
		},
		{
			MethodName: "InterfaceDelete",
			Handler:    _IfSvc_InterfaceDelete_Handler,
		},
		{
			MethodName: "InterfaceGet",
			Handler:    _IfSvc_InterfaceGet_Handler,
		},
		{
			MethodName: "LifGet",
			Handler:    _IfSvc_LifGet_Handler,
		},
		{
			MethodName: "LifStatsReset",
			Handler:    _IfSvc_LifStatsReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "interface.proto",
}

func (m *LldpIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeleteCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.DeleteCount))
		i--
		dAtA[i] = 0x38
	}
	if m.InsertCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.InsertCount))
		i--
		dAtA[i] = 0x30
	}
	if m.AgeoutCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.AgeoutCount))
		i--
		dAtA[i] = 0x28
	}
	if m.RxUnrecognized != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.RxUnrecognized))
		i--
		dAtA[i] = 0x20
	}
	if m.RxDiscarded != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.RxDiscarded))
		i--
		dAtA[i] = 0x18
	}
	if m.RxCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.RxCount))
		i--
		dAtA[i] = 0x10
	}
	if m.TxCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.TxCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LldpId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LldpChassisCapabilityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpChassisCapabilityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpChassisCapabilityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CapEnabled {
		i--
		if m.CapEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CapType != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.CapType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LldpIfChassisInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfChassisInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpIfChassisInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Capability) > 0 {
		for iNdEx := len(m.Capability) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Capability[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MgmtIP != nil {
		{
			size, err := m.MgmtIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SysDescr) > 0 {
		i -= len(m.SysDescr)
		copy(dAtA[i:], m.SysDescr)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.SysDescr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChassisId != nil {
		{
			size, err := m.ChassisId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SysName) > 0 {
		i -= len(m.SysName)
		copy(dAtA[i:], m.SysName)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.SysName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LldpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LldpIfChassisSpec != nil {
		{
			size, err := m.LldpIfChassisSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UplinkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NativeVlanId != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UplinkPCSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkPCSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NativeVlanId != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.NativeVlanId))
		i--
		dAtA[i] = 0x10
	}
	if m.MemberIfBitmap != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MemberIfBitmap))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L3IfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3IfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddress != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x28
	}
	if m.Encap != nil {
		{
			size, err := m.Encap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		for iNdEx := len(m.Prefix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prefix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoopbackIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Community) > 0 {
		for iNdEx := len(m.Community) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Community[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.BgpAsPathPrependCount != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.BgpAsPathPrependCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RouteMetric != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.RouteMetric))
		i--
		dAtA[i] = 0x10
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControlIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlIfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MACAddress != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x10
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HostIfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIfSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if m.VNF {
		i--
		if m.VNF {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LearnSpec != nil {
		{
			size, err := m.LearnSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FlowLogSpec != nil {
		{
			size, err := m.FlowLogSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MACAddress != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TxPolicer) > 0 {
		i -= len(m.TxPolicer)
		copy(dAtA[i:], m.TxPolicer)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.TxPolicer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnTrackEn {
		i--
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Vf {
		i--
		if m.Vf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RxMirrorSessionId) > 0 {
		for iNdEx := len(m.RxMirrorSessionId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RxMirrorSessionId[iNdEx])
			copy(dAtA[i:], m.RxMirrorSessionId[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.RxMirrorSessionId[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.TxMirrorSessionId) > 0 {
		for iNdEx := len(m.TxMirrorSessionId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TxMirrorSessionId[iNdEx])
			copy(dAtA[i:], m.TxMirrorSessionId[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.TxMirrorSessionId[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Ifinfo != nil {
		{
			size := m.Ifinfo.Size()
			i -= size
			if _, err := m.Ifinfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AdminStatus != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.AdminStatus))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceSpec_UplinkSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_UplinkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UplinkSpec != nil {
		{
			size, err := m.UplinkSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceSpec_UplinkPCSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_UplinkPCSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UplinkPCSpec != nil {
		{
			size, err := m.UplinkPCSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceSpec_L3IfSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_L3IfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L3IfSpec != nil {
		{
			size, err := m.L3IfSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceSpec_LoopbackIfSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_LoopbackIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackIfSpec != nil {
		{
			size, err := m.LoopbackIfSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceSpec_ControlIfSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_ControlIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ControlIfSpec != nil {
		{
			size, err := m.ControlIfSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceSpec_HostIfSpec) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceSpec_HostIfSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostIfSpec != nil {
		{
			size, err := m.HostIfSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *LldpIfPortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfPortStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpIfPortStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ttl != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PortDescr) > 0 {
		i -= len(m.PortDescr)
		copy(dAtA[i:], m.PortDescr)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PortDescr)))
		i--
		dAtA[i] = 0x12
	}
	if m.PortId != nil {
		{
			size, err := m.PortId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LldpUnknownTlvStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpUnknownTlvStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpUnknownTlvStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if m.Len != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x18
	}
	if m.Subtype != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Subtype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Oui) > 0 {
		i -= len(m.Oui)
		copy(dAtA[i:], m.Oui)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Oui)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LldpIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LldpUnknownTlvStatus) > 0 {
		for iNdEx := len(m.LldpUnknownTlvStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LldpUnknownTlvStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LldpIfPortStatus != nil {
		{
			size, err := m.LldpIfPortStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LldpIfChassisStatus != nil {
		{
			size, err := m.LldpIfChassisStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Age) > 0 {
		i -= len(m.Age)
		copy(dAtA[i:], m.Age)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Age)))
		i--
		dAtA[i] = 0x22
	}
	if m.Proto != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Proto))
		i--
		dAtA[i] = 0x18
	}
	if m.RouterId != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.RouterId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.IfName) > 0 {
		i -= len(m.IfName)
		copy(dAtA[i:], m.IfName)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.IfName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LldpStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LldpStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LldpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LldpNbrStatus != nil {
		{
			size, err := m.LldpNbrStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LldpIfStatus != nil {
		{
			size, err := m.LldpIfStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UplinkIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LldpStatus != nil {
		{
			size, err := m.LldpStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LifId != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.LifId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoopbackIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HostIfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIfStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.MACAddress != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MACAddress))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LifId) > 0 {
		for iNdEx := len(m.LifId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LifId[iNdEx])
			copy(dAtA[i:], m.LifId[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.LifId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ifstatus != nil {
		{
			size := m.Ifstatus.Size()
			i -= size
			if _, err := m.Ifstatus.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OperStatus != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.OperStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.IfIndex != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStatus_UplinkIfStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStatus_UplinkIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UplinkIfStatus != nil {
		{
			size, err := m.UplinkIfStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStatus_LoopbackIfStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStatus_LoopbackIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackIfStatus != nil {
		{
			size, err := m.LoopbackIfStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStatus_HostIfStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStatus_HostIfStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostIfStatus != nil {
		{
			size, err := m.HostIfStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *UplinkIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkIfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LldpIfStats != nil {
		{
			size, err := m.LldpIfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UplinkPCStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkPCStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkPCStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *L3IfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3IfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3IfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LoopbackIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackIfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ControlIfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlIfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ifstats != nil {
		{
			size := m.Ifstats.Size()
			i -= size
			if _, err := m.Ifstats.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStats_UplinkIfStats) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStats_UplinkIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UplinkIfStats != nil {
		{
			size, err := m.UplinkIfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStats_UplinkPCStats) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStats_UplinkPCStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UplinkPCStats != nil {
		{
			size, err := m.UplinkPCStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStats_L3IfStats) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStats_L3IfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L3IfStats != nil {
		{
			size, err := m.L3IfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStats_LoopbackIfStats) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStats_LoopbackIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackIfStats != nil {
		{
			size, err := m.LoopbackIfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceStats_ControlIfStats) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *InterfaceStats_ControlIfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ControlIfStats != nil {
		{
			size, err := m.ControlIfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Request) > 0 {
		for iNdEx := len(m.Request) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Request[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchCtxt != nil {
		{
			size, err := m.BatchCtxt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiStatus) > 0 {
		dAtA38 := make([]byte, len(m.ApiStatus)*10)
		var j37 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintInterface(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LifSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PinnedInterface) > 0 {
		i -= len(m.PinnedInterface)
		copy(dAtA[i:], m.PinnedInterface)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PinnedInterface)))
		i--
		dAtA[i] = 0x22
	}
	if m.MacAddress != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.MacAddress))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LifStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VnicIndex != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.VnicIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.NhIndex != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.NhIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.AdminState != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.AdminState))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfIndex != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LifStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Lif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lif) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lif) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjMeta != nil {
		{
			size, err := m.ObjMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TypeMeta != nil {
		{
			size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInterface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LifGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintInterface(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LifGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInterface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ApiStatus != 0 {
		i = encodeVarintInterface(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintInterface(dAtA []byte, offset int, v uint64) int {
	offset -= sovInterface(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LldpIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxCount != 0 {
		n += 1 + sovInterface(uint64(m.TxCount))
	}
	if m.RxCount != 0 {
		n += 1 + sovInterface(uint64(m.RxCount))
	}
	if m.RxDiscarded != 0 {
		n += 1 + sovInterface(uint64(m.RxDiscarded))
	}
	if m.RxUnrecognized != 0 {
		n += 1 + sovInterface(uint64(m.RxUnrecognized))
	}
	if m.AgeoutCount != 0 {
		n += 1 + sovInterface(uint64(m.AgeoutCount))
	}
	if m.InsertCount != 0 {
		n += 1 + sovInterface(uint64(m.InsertCount))
	}
	if m.DeleteCount != 0 {
		n += 1 + sovInterface(uint64(m.DeleteCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpChassisCapabilityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CapType != 0 {
		n += 1 + sovInterface(uint64(m.CapType))
	}
	if m.CapEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpIfChassisInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SysName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ChassisId != nil {
		l = m.ChassisId.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.SysDescr)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MgmtIP != nil {
		l = m.MgmtIP.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Capability) > 0 {
		for _, e := range m.Capability {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LldpIfChassisSpec != nil {
		l = m.LldpIfChassisSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UplinkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UplinkPCSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberIfBitmap != 0 {
		n += 1 + sovInterface(uint64(m.MemberIfBitmap))
	}
	if m.NativeVlanId != 0 {
		n += 1 + sovInterface(uint64(m.NativeVlanId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L3IfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Prefix) > 0 {
		for _, e := range m.Prefix {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoopbackIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.RouteMetric != 0 {
		n += 1 + sovInterface(uint64(m.RouteMetric))
	}
	if m.BgpAsPathPrependCount != 0 {
		n += 1 + sovInterface(uint64(m.BgpAsPathPrependCount))
	}
	if len(m.Community) > 0 {
		for _, e := range m.Community {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ControlIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vf {
		n += 2
	}
	if m.ConnTrackEn {
		n += 2
	}
	l = len(m.TxPolicer)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	if m.FlowLogSpec != nil {
		l = m.FlowLogSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LearnSpec != nil {
		l = m.LearnSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.VNF {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.AdminStatus != 0 {
		n += 1 + sovInterface(uint64(m.AdminStatus))
	}
	if m.Ifinfo != nil {
		n += m.Ifinfo.Size()
	}
	if len(m.TxMirrorSessionId) > 0 {
		for _, b := range m.TxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if len(m.RxMirrorSessionId) > 0 {
		for _, b := range m.RxMirrorSessionId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceSpec_UplinkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UplinkSpec != nil {
		l = m.UplinkSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_UplinkPCSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UplinkPCSpec != nil {
		l = m.UplinkPCSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_L3IfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L3IfSpec != nil {
		l = m.L3IfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_LoopbackIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackIfSpec != nil {
		l = m.LoopbackIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_ControlIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlIfSpec != nil {
		l = m.ControlIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceSpec_HostIfSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostIfSpec != nil {
		l = m.HostIfSpec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *LldpIfPortStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortId != nil {
		l = m.PortId.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.PortDescr)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovInterface(uint64(m.Ttl))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpUnknownTlvStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oui)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Subtype != 0 {
		n += 1 + sovInterface(uint64(m.Subtype))
	}
	if m.Len != 0 {
		n += 1 + sovInterface(uint64(m.Len))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IfName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.RouterId != 0 {
		n += 1 + sovInterface(uint64(m.RouterId))
	}
	if m.Proto != 0 {
		n += 1 + sovInterface(uint64(m.Proto))
	}
	l = len(m.Age)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LldpIfChassisStatus != nil {
		l = m.LldpIfChassisStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LldpIfPortStatus != nil {
		l = m.LldpIfPortStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.LldpUnknownTlvStatus) > 0 {
		for _, e := range m.LldpUnknownTlvStatus {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LldpStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LldpIfStatus != nil {
		l = m.LldpIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.LldpNbrStatus != nil {
		l = m.LldpNbrStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UplinkIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LifId != 0 {
		n += 1 + sovInterface(uint64(m.LifId))
	}
	if m.LldpStatus != nil {
		l = m.LldpStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoopbackIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LifId) > 0 {
		for _, b := range m.LifId {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.MACAddress != 0 {
		n += 1 + sovInterface(uint64(m.MACAddress))
	}
	if m.Status != 0 {
		n += 1 + sovInterface(uint64(m.Status))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	if m.OperStatus != 0 {
		n += 1 + sovInterface(uint64(m.OperStatus))
	}
	if m.Ifstatus != nil {
		n += m.Ifstatus.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceStatus_UplinkIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UplinkIfStatus != nil {
		l = m.UplinkIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStatus_LoopbackIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackIfStatus != nil {
		l = m.LoopbackIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStatus_HostIfStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostIfStatus != nil {
		l = m.HostIfStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *UplinkIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LldpIfStats != nil {
		l = m.LldpIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UplinkPCStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L3IfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoopbackIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ControlIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ifstats != nil {
		n += m.Ifstats.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceStats_UplinkIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UplinkIfStats != nil {
		l = m.UplinkIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_UplinkPCStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UplinkPCStats != nil {
		l = m.UplinkPCStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_L3IfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L3IfStats != nil {
		l = m.L3IfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_LoopbackIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackIfStats != nil {
		l = m.LoopbackIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *InterfaceStats_ControlIfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlIfStats != nil {
		l = m.ControlIfStats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}
func (m *Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCtxt != nil {
		l = m.BatchCtxt.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovInterface(uint64(e))
		}
		n += 1 + sovInterface(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LifSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInterface(uint64(m.Type))
	}
	if m.MacAddress != 0 {
		n += 1 + sovInterface(uint64(m.MacAddress))
	}
	l = len(m.PinnedInterface)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LifStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfIndex != 0 {
		n += 1 + sovInterface(uint64(m.IfIndex))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.AdminState != 0 {
		n += 1 + sovInterface(uint64(m.AdminState))
	}
	if m.Status != 0 {
		n += 1 + sovInterface(uint64(m.Status))
	}
	if m.NhIndex != 0 {
		n += 1 + sovInterface(uint64(m.NhIndex))
	}
	if m.VnicIndex != 0 {
		n += 1 + sovInterface(uint64(m.VnicIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LifStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Lif) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.ObjMeta != nil {
		l = m.ObjMeta.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LifGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LifGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovInterface(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInterface(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInterface(x uint64) (n int) {
	return sovInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LldpIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCount", wireType)
			}
			m.TxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxCount", wireType)
			}
			m.RxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDiscarded", wireType)
			}
			m.RxDiscarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDiscarded |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxUnrecognized", wireType)
			}
			m.RxUnrecognized = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxUnrecognized |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgeoutCount", wireType)
			}
			m.AgeoutCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgeoutCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertCount", wireType)
			}
			m.InsertCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCount", wireType)
			}
			m.DeleteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LldpIdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpChassisCapabilityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpChassisCapabilityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpChassisCapabilityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapType", wireType)
			}
			m.CapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapType |= LldpCapType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CapEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfChassisInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfChassisInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfChassisInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChassisId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChassisId == nil {
				m.ChassisId = &LldpId{}
			}
			if err := m.ChassisId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysDescr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysDescr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtIP == nil {
				m.MgmtIP = &IPAddress{}
			}
			if err := m.MgmtIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capability = append(m.Capability, &LldpChassisCapabilityInfo{})
			if err := m.Capability[len(m.Capability)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfChassisSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfChassisSpec == nil {
				m.LldpIfChassisSpec = &LldpIfChassisInfo{}
			}
			if err := m.LldpIfChassisSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkPCSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkPCSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkPCSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberIfBitmap", wireType)
			}
			m.MemberIfBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberIfBitmap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVlanId", wireType)
			}
			m.NativeVlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVlanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3IfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3IfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3IfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = append(m.VpcId[:0], dAtA[iNdEx:postIndex]...)
			if m.VpcId == nil {
				m.VpcId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix, &IPPrefix{})
			if err := m.Prefix[len(m.Prefix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = append(m.PortId[:0], dAtA[iNdEx:postIndex]...)
			if m.PortId == nil {
				m.PortId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &Encap{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteMetric", wireType)
			}
			m.RouteMetric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteMetric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpAsPathPrependCount", wireType)
			}
			m.BgpAsPathPrependCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpAsPathPrependCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Community", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Community = append(m.Community, &BGPCommunity{})
			if err := m.Community[len(m.Community)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &IPPrefix{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vf = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPolicer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxPolicer = append(m.TxPolicer[:0], dAtA[iNdEx:postIndex]...)
			if m.TxPolicer == nil {
				m.TxPolicer = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLogSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowLogSpec == nil {
				m.FlowLogSpec = &FlowLogSpec{}
			}
			if err := m.FlowLogSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnSpec == nil {
				m.LearnSpec = &LearnSpec{}
			}
			if err := m.LearnSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNF", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VNF = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			m.AdminStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminStatus |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkSpec{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPCSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkPCSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_UplinkPCSpec{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3IfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3IfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_L3IfSpec{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_LoopbackIfSpec{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControlIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_ControlIfSpec{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostIfSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifinfo = &InterfaceSpec_HostIfSpec{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMirrorSessionId = append(m.TxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.TxMirrorSessionId[len(m.TxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMirrorSessionId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RxMirrorSessionId = append(m.RxMirrorSessionId, make([]byte, postIndex-iNdEx))
			copy(m.RxMirrorSessionId[len(m.RxMirrorSessionId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfPortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfPortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfPortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortId == nil {
				m.PortId = &LldpId{}
			}
			if err := m.PortId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDescr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortDescr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpUnknownTlvStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpUnknownTlvStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpUnknownTlvStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oui", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oui = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			m.RouterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= LldpProtoMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Age = append(m.Age[:0], dAtA[iNdEx:postIndex]...)
			if m.Age == nil {
				m.Age = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfChassisStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfChassisStatus == nil {
				m.LldpIfChassisStatus = &LldpIfChassisInfo{}
			}
			if err := m.LldpIfChassisStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfPortStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfPortStatus == nil {
				m.LldpIfPortStatus = &LldpIfPortStatus{}
			}
			if err := m.LldpIfPortStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpUnknownTlvStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LldpUnknownTlvStatus = append(m.LldpUnknownTlvStatus, &LldpUnknownTlvStatus{})
			if err := m.LldpUnknownTlvStatus[len(m.LldpUnknownTlvStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LldpStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LldpStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LldpStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfStatus == nil {
				m.LldpIfStatus = &LldpIfStatus{}
			}
			if err := m.LldpIfStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpNbrStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpNbrStatus == nil {
				m.LldpNbrStatus = &LldpIfStatus{}
			}
			if err := m.LldpNbrStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifId", wireType)
			}
			m.LifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpStatus == nil {
				m.LldpStatus = &LldpStatus{}
			}
			if err := m.LldpStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LifId = append(m.LifId, make([]byte, postIndex-iNdEx))
			copy(m.LifId[len(m.LifId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			m.MACAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MACAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			m.OperStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperStatus |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_UplinkIfStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_LoopbackIfStatus{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostIfStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstatus = &InterfaceStatus_HostIfStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LldpIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LldpIfStats == nil {
				m.LldpIfStats = &LldpIfStats{}
			}
			if err := m.LldpIfStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkPCStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkPCStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkPCStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3IfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3IfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3IfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlIfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlIfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlIfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_UplinkIfStats{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UplinkPCStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_UplinkPCStats{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3IfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L3IfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_L3IfStats{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_LoopbackIfStats{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlIfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControlIfStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ifstats = &InterfaceStats_ControlIfStats{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InterfaceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InterfaceStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &InterfaceStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &InterfaceSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &InterfaceStatus{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Interface{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCtxt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchCtxt == nil {
				m.BatchCtxt = &BatchCtxt{}
			}
			if err := m.BatchCtxt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApiStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInterface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInterface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ApiStatus) == 0 {
					m.ApiStatus = make([]ApiStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInterface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApiStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LifType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			m.MacAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedInterface", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinnedInterface = append(m.PinnedInterface[:0], dAtA[iNdEx:postIndex]...)
			if m.PinnedInterface == nil {
				m.PinnedInterface = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			m.AdminState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminState |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= IfStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NhIndex", wireType)
			}
			m.NhIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NhIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicIndex", wireType)
			}
			m.VnicIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VnicIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &pds.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjMeta == nil {
				m.ObjMeta = &pds.ObjMeta{}
			}
			if err := m.ObjMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &LifSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &LifStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &LifStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInterface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Lif{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInterface
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInterface
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInterface   = fmt.Errorf("proto: integer overflow")
)
