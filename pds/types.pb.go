// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

package pds

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	gogoproto "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

var E_EnumStringer = gogoproto.E_EnumStringer

var E_EnumCustomname = gogoproto.E_EnumCustomname

var E_Enumdecl = gogoproto.E_Enumdecl

var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

var E_FaceAll = gogoproto.E_FaceAll

var E_GostringAll = gogoproto.E_GostringAll

var E_PopulateAll = gogoproto.E_PopulateAll

var E_StringerAll = gogoproto.E_StringerAll

var E_OnlyoneAll = gogoproto.E_OnlyoneAll

var E_EqualAll = gogoproto.E_EqualAll

var E_DescriptionAll = gogoproto.E_DescriptionAll

var E_TestgenAll = gogoproto.E_TestgenAll

var E_BenchgenAll = gogoproto.E_BenchgenAll

var E_MarshalerAll = gogoproto.E_MarshalerAll

var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

var E_SizerAll = gogoproto.E_SizerAll

var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

var E_EnumStringerAll = gogoproto.E_EnumStringerAll

var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

var E_GogoprotoImport = gogoproto.E_GogoprotoImport

var E_ProtosizerAll = gogoproto.E_ProtosizerAll

var E_CompareAll = gogoproto.E_CompareAll

var E_TypedeclAll = gogoproto.E_TypedeclAll

var E_EnumdeclAll = gogoproto.E_EnumdeclAll

var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

var E_MessagenameAll = gogoproto.E_MessagenameAll

var E_GoprotoSizecacheAll = gogoproto.E_GoprotoSizecacheAll

var E_GoprotoUnkeyedAll = gogoproto.E_GoprotoUnkeyedAll

var E_GoprotoGetters = gogoproto.E_GoprotoGetters

var E_GoprotoStringer = gogoproto.E_GoprotoStringer

var E_VerboseEqual = gogoproto.E_VerboseEqual

var E_Face = gogoproto.E_Face

var E_Gostring = gogoproto.E_Gostring

var E_Populate = gogoproto.E_Populate

var E_Stringer = gogoproto.E_Stringer

var E_Onlyone = gogoproto.E_Onlyone

var E_Equal = gogoproto.E_Equal

var E_Description = gogoproto.E_Description

var E_Testgen = gogoproto.E_Testgen

var E_Benchgen = gogoproto.E_Benchgen

var E_Marshaler = gogoproto.E_Marshaler

var E_Unmarshaler = gogoproto.E_Unmarshaler

var E_StableMarshaler = gogoproto.E_StableMarshaler

var E_Sizer = gogoproto.E_Sizer

var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

var E_Protosizer = gogoproto.E_Protosizer

var E_Compare = gogoproto.E_Compare

var E_Typedecl = gogoproto.E_Typedecl

var E_Messagename = gogoproto.E_Messagename

var E_GoprotoSizecache = gogoproto.E_GoprotoSizecache

var E_GoprotoUnkeyed = gogoproto.E_GoprotoUnkeyed

var E_Nullable = gogoproto.E_Nullable

var E_Embed = gogoproto.E_Embed

var E_Customtype = gogoproto.E_Customtype

var E_Customname = gogoproto.E_Customname

var E_Jsontag = gogoproto.E_Jsontag

var E_Moretags = gogoproto.E_Moretags

var E_Casttype = gogoproto.E_Casttype

var E_Castkey = gogoproto.E_Castkey

var E_Castvalue = gogoproto.E_Castvalue

var E_Stdtime = gogoproto.E_Stdtime

var E_Stdduration = gogoproto.E_Stdduration

var E_Wktpointer = gogoproto.E_Wktpointer

// API return codes (more descriptive than protobuf enums)
type ApiStatus int32

const (
	ApiStatus_API_STATUS_OK                    ApiStatus = 0
	ApiStatus_API_STATUS_ERR                   ApiStatus = 1
	ApiStatus_API_STATUS_INVALID_ARG           ApiStatus = 2
	ApiStatus_API_STATUS_EXISTS_ALREADY        ApiStatus = 3
	ApiStatus_API_STATUS_OUT_OF_MEM            ApiStatus = 4
	ApiStatus_API_STATUS_NOT_FOUND             ApiStatus = 5
	ApiStatus_API_STATUS_OUT_OF_RESOURCE       ApiStatus = 6
	ApiStatus_API_STATUS_RETRY                 ApiStatus = 7
	ApiStatus_API_STATUS_OPERATION_NOT_ALLOWED ApiStatus = 8
	// specific type of object
	ApiStatus_API_STATUS_TIMEOUT         ApiStatus = 9
	ApiStatus_API_STATUS_HW_ENTRY_EXISTS ApiStatus = 10
)

var ApiStatus_name = map[int32]string{
	0:  "API_STATUS_OK",
	1:  "API_STATUS_ERR",
	2:  "API_STATUS_INVALID_ARG",
	3:  "API_STATUS_EXISTS_ALREADY",
	4:  "API_STATUS_OUT_OF_MEM",
	5:  "API_STATUS_NOT_FOUND",
	6:  "API_STATUS_OUT_OF_RESOURCE",
	7:  "API_STATUS_RETRY",
	8:  "API_STATUS_OPERATION_NOT_ALLOWED",
	9:  "API_STATUS_TIMEOUT",
	10: "API_STATUS_HW_ENTRY_EXISTS",
}

var ApiStatus_value = map[string]int32{
	"API_STATUS_OK":                    0,
	"API_STATUS_ERR":                   1,
	"API_STATUS_INVALID_ARG":           2,
	"API_STATUS_EXISTS_ALREADY":        3,
	"API_STATUS_OUT_OF_MEM":            4,
	"API_STATUS_NOT_FOUND":             5,
	"API_STATUS_OUT_OF_RESOURCE":       6,
	"API_STATUS_RETRY":                 7,
	"API_STATUS_OPERATION_NOT_ALLOWED": 8,
	"API_STATUS_TIMEOUT":               9,
	"API_STATUS_HW_ENTRY_EXISTS":       10,
}

func (x ApiStatus) String() string {
	return proto.EnumName(ApiStatus_name, int32(x))
}

func (ApiStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{0}
}

// asic types
type AsicType int32

const (
	AsicType_ASIC_TYPE_NONE  AsicType = 0
	AsicType_ASIC_TYPE_CAPRI AsicType = 1
	AsicType_ASIC_TYPE_ELBA  AsicType = 2
)

var AsicType_name = map[int32]string{
	0: "ASIC_TYPE_NONE",
	1: "ASIC_TYPE_CAPRI",
	2: "ASIC_TYPE_ELBA",
}

var AsicType_value = map[string]int32{
	"ASIC_TYPE_NONE":  0,
	"ASIC_TYPE_CAPRI": 1,
	"ASIC_TYPE_ELBA":  2,
}

func (x AsicType) String() string {
	return proto.EnumName(AsicType_name, int32(x))
}

func (AsicType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{1}
}

// IP address families
type IPAF int32

const (
	IPAF_IP_AF_NONE  IPAF = 0
	IPAF_IP_AF_INET  IPAF = 1
	IPAF_IP_AF_INET6 IPAF = 2
)

var IPAF_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}

var IPAF_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAF) String() string {
	return proto.EnumName(IPAF_name, int32(x))
}

func (IPAF) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{2}
}

type WildcardMatch int32

const (
	WildcardMatch_MATCH_NONE WildcardMatch = 0
	WildcardMatch_MATCH_ANY  WildcardMatch = 256
)

var WildcardMatch_name = map[int32]string{
	0:   "MATCH_NONE",
	256: "MATCH_ANY",
}

var WildcardMatch_value = map[string]int32{
	"MATCH_NONE": 0,
	"MATCH_ANY":  256,
}

func (x WildcardMatch) String() string {
	return proto.EnumName(WildcardMatch_name, int32(x))
}

func (WildcardMatch) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{3}
}

// direction in which policy is enforced
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
type RuleDir int32

const (
	RuleDir_RULE_DIR_NONE    RuleDir = 0
	RuleDir_RULE_DIR_INGRESS RuleDir = 1
	RuleDir_RULE_DIR_EGRESS  RuleDir = 2
)

var RuleDir_name = map[int32]string{
	0: "RULE_DIR_NONE",
	1: "RULE_DIR_INGRESS",
	2: "RULE_DIR_EGRESS",
}

var RuleDir_value = map[string]int32{
	"RULE_DIR_NONE":    0,
	"RULE_DIR_INGRESS": 1,
	"RULE_DIR_EGRESS":  2,
}

func (x RuleDir) String() string {
	return proto.EnumName(RuleDir_name, int32(x))
}

func (RuleDir) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{4}
}

// encap types in the network
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE     EncapType = 0
	EncapType_ENCAP_TYPE_DOT1Q    EncapType = 1
	EncapType_ENCAP_TYPE_QINQ     EncapType = 2
	EncapType_ENCAP_TYPE_MPLSoUDP EncapType = 3
	EncapType_ENCAP_TYPE_VXLAN    EncapType = 4
	EncapType_ENCAP_TYPE_NVGRE    EncapType = 5
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_DOT1Q",
	2: "ENCAP_TYPE_QINQ",
	3: "ENCAP_TYPE_MPLSoUDP",
	4: "ENCAP_TYPE_VXLAN",
	5: "ENCAP_TYPE_NVGRE",
}

var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":     0,
	"ENCAP_TYPE_DOT1Q":    1,
	"ENCAP_TYPE_QINQ":     2,
	"ENCAP_TYPE_MPLSoUDP": 3,
	"ENCAP_TYPE_VXLAN":    4,
	"ENCAP_TYPE_NVGRE":    5,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}

func (EncapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{5}
}

// types of lif
type LifType int32

const (
	LifType_LIF_TYPE_NONE          LifType = 0
	LifType_LIF_TYPE_HOST          LifType = 1
	LifType_LIF_TYPE_HOST_VF       LifType = 2
	LifType_LIF_TYPE_HOST_MGMT     LifType = 3
	LifType_LIF_TYPE_OOB_MGMT      LifType = 4
	LifType_LIF_TYPE_INBAND_MGMT   LifType = 5
	LifType_LIF_TYPE_INTERNAL_MGMT LifType = 6
	LifType_LIF_TYPE_DATAPATH      LifType = 7
	LifType_LIF_TYPE_LEARN         LifType = 8
	LifType_LIF_TYPE_CONTROL       LifType = 9
	LifType_LIF_TYPE_UPLINK        LifType = 10
)

var LifType_name = map[int32]string{
	0:  "LIF_TYPE_NONE",
	1:  "LIF_TYPE_HOST",
	2:  "LIF_TYPE_HOST_VF",
	3:  "LIF_TYPE_HOST_MGMT",
	4:  "LIF_TYPE_OOB_MGMT",
	5:  "LIF_TYPE_INBAND_MGMT",
	6:  "LIF_TYPE_INTERNAL_MGMT",
	7:  "LIF_TYPE_DATAPATH",
	8:  "LIF_TYPE_LEARN",
	9:  "LIF_TYPE_CONTROL",
	10: "LIF_TYPE_UPLINK",
}

var LifType_value = map[string]int32{
	"LIF_TYPE_NONE":          0,
	"LIF_TYPE_HOST":          1,
	"LIF_TYPE_HOST_VF":       2,
	"LIF_TYPE_HOST_MGMT":     3,
	"LIF_TYPE_OOB_MGMT":      4,
	"LIF_TYPE_INBAND_MGMT":   5,
	"LIF_TYPE_INTERNAL_MGMT": 6,
	"LIF_TYPE_DATAPATH":      7,
	"LIF_TYPE_LEARN":         8,
	"LIF_TYPE_CONTROL":       9,
	"LIF_TYPE_UPLINK":        10,
}

func (x LifType) String() string {
	return proto.EnumName(LifType_name, int32(x))
}

func (LifType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{6}
}

// security rule action is one of the below
type SecurityRuleAction int32

const (
	SecurityRuleAction_SECURITY_RULE_ACTION_NONE  SecurityRuleAction = 0
	SecurityRuleAction_SECURITY_RULE_ACTION_ALLOW SecurityRuleAction = 1
	SecurityRuleAction_SECURITY_RULE_ACTION_DENY  SecurityRuleAction = 2
)

var SecurityRuleAction_name = map[int32]string{
	0: "SECURITY_RULE_ACTION_NONE",
	1: "SECURITY_RULE_ACTION_ALLOW",
	2: "SECURITY_RULE_ACTION_DENY",
}

var SecurityRuleAction_value = map[string]int32{
	"SECURITY_RULE_ACTION_NONE":  0,
	"SECURITY_RULE_ACTION_ALLOW": 1,
	"SECURITY_RULE_ACTION_DENY":  2,
}

func (x SecurityRuleAction) String() string {
	return proto.EnumName(SecurityRuleAction_name, int32(x))
}

func (SecurityRuleAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{7}
}

// firewall policy action transposition scheme
// NOTE:
// for every new session from/to a vnic, there are potentially multiple policies
// that need to be evaluated. For example, ingress/egress policies attached to
// vnic's vpc, ingress/egress policies attached to vnic's subnet and
// ingress/egress policies directly attached to vnic must evaluated. Each policy
// evaluated may give potentially different and conflicting result compared to
// the previous other policy evaluated w.r.t the action that needs to
// be taken (allow or deny). So, users must to be able to specify how to resolve
// this and arrive at final action to pick for that session.
// FwPolicyXposn defines how such action transposition has to be performed
// across policies
// NOTE:
// within a policy, always highest priority rule within that policy wins in all
// transposition schemes
type FwPolicyXposn int32

const (
	FwPolicyXposn_FW_POLICY_XPOSN_NONE FwPolicyXposn = 0
	// if GLOBAL_PRIORITY transposition scheme is configured, rule that is picked
	// is the rule with highest priority (numerically lowest value) across all
	// policies that are evaluated for a given packet
	FwPolicyXposn_FW_POLICY_XPOSN_GLOBAL_PRIORITY FwPolicyXposn = 1
	// if ANY_DENY transposition scheme is configured, and a given packet matches
	// a deny rule (and that rule has highest priority in that policy) in any of
	// the policies evaluated for that packet, then session is created with
	// deny/drop action
	// NOTE:
	// 1. once a deny rule is hit as highest prioity rule, in this scheme, rest of
	//    policies in the chain are not evaluated (even though they might have
	//    terminating rules) so in ANY_DENY scheme once a DENY rule is picked
	//    that rule and action wins
	// 2. priority of rules across policies doesn't matter in this scheme (i.e.
	//    priority values are local to the policy object)
	FwPolicyXposn_FW_POLICY_XPOSN_ANY_DENY FwPolicyXposn = 2
	// if LAST_MATCHED_RULE transposition scheme is configured
	// 1. from each policy highest priority rule is picked (note that if no rule
	//    is matched, policy level default action is picked)
	// 2. if that rule is a terminating rule, corresponding action is picked and
	//    no more policies are evaluated (i.e. terminating rule wins)
	// 3. if that rule is not a terminating rule, next policy in the chain is
	//    evaluated and action from a matching rule (or default action) is picked
	// 4. the above steps are repeated until all policies are evaluated
	//
	// in this scheme, unless a terminating rule is encountered in some policy,
	// the rule in the last policy evaluated always wins (so for a packet to be
	// allowed if last policy has allow rule, then that wins even though all other
	// policies have deny rule that matches the packet (and are not terminating
	// rules)
	FwPolicyXposn_FW_POLICY_XPOSN_LAST_MATCHED_RULE FwPolicyXposn = 3
)

var FwPolicyXposn_name = map[int32]string{
	0: "FW_POLICY_XPOSN_NONE",
	1: "FW_POLICY_XPOSN_GLOBAL_PRIORITY",
	2: "FW_POLICY_XPOSN_ANY_DENY",
	3: "FW_POLICY_XPOSN_LAST_MATCHED_RULE",
}

var FwPolicyXposn_value = map[string]int32{
	"FW_POLICY_XPOSN_NONE":              0,
	"FW_POLICY_XPOSN_GLOBAL_PRIORITY":   1,
	"FW_POLICY_XPOSN_ANY_DENY":          2,
	"FW_POLICY_XPOSN_LAST_MATCHED_RULE": 3,
}

func (x FwPolicyXposn) String() string {
	return proto.EnumName(FwPolicyXposn_name, int32(x))
}

func (FwPolicyXposn) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{8}
}

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_ACTION_NONE NatAction = 0
	// Address only static NAT
	NatAction_NAT_ACTION_STATIC NatAction = 1
	// address and port translation to the public (aka. Internet) address space
	NatAction_NAT_ACTION_NAPT_PUBLIC NatAction = 2
	// address and port translation to internal service address space
	NatAction_NAT_ACTION_NAPT_SVC NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_ACTION_NONE",
	1: "NAT_ACTION_STATIC",
	2: "NAT_ACTION_NAPT_PUBLIC",
	3: "NAT_ACTION_NAPT_SVC",
}

var NatAction_value = map[string]int32{
	"NAT_ACTION_NONE":        0,
	"NAT_ACTION_STATIC":      1,
	"NAT_ACTION_NAPT_PUBLIC": 2,
	"NAT_ACTION_NAPT_SVC":    3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}

func (NatAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{9}
}

// meter classes that can be used on per route basis for accouting
// (i.e., packet and byte counters)
type MeterClass int32

const (
	MeterClass_METER_CLASS_NONE MeterClass = 0
	MeterClass_METER_CLASS_1    MeterClass = 1
	MeterClass_METER_CLASS_2    MeterClass = 2
	MeterClass_METER_CLASS_3    MeterClass = 3
	MeterClass_METER_CLASS_4    MeterClass = 4
	MeterClass_METER_CLASS_5    MeterClass = 5
	MeterClass_METER_CLASS_6    MeterClass = 6
	MeterClass_METER_CLASS_7    MeterClass = 7
	MeterClass_METER_CLASS_8    MeterClass = 8
	MeterClass_METER_CLASS_9    MeterClass = 9
	MeterClass_METER_CLASS_10   MeterClass = 10
	MeterClass_METER_CLASS_11   MeterClass = 11
	MeterClass_METER_CLASS_12   MeterClass = 12
	MeterClass_METER_CLASS_13   MeterClass = 13
	MeterClass_METER_CLASS_14   MeterClass = 14
	MeterClass_METER_CLASS_15   MeterClass = 15
)

var MeterClass_name = map[int32]string{
	0:  "METER_CLASS_NONE",
	1:  "METER_CLASS_1",
	2:  "METER_CLASS_2",
	3:  "METER_CLASS_3",
	4:  "METER_CLASS_4",
	5:  "METER_CLASS_5",
	6:  "METER_CLASS_6",
	7:  "METER_CLASS_7",
	8:  "METER_CLASS_8",
	9:  "METER_CLASS_9",
	10: "METER_CLASS_10",
	11: "METER_CLASS_11",
	12: "METER_CLASS_12",
	13: "METER_CLASS_13",
	14: "METER_CLASS_14",
	15: "METER_CLASS_15",
}

var MeterClass_value = map[string]int32{
	"METER_CLASS_NONE": 0,
	"METER_CLASS_1":    1,
	"METER_CLASS_2":    2,
	"METER_CLASS_3":    3,
	"METER_CLASS_4":    4,
	"METER_CLASS_5":    5,
	"METER_CLASS_6":    6,
	"METER_CLASS_7":    7,
	"METER_CLASS_8":    8,
	"METER_CLASS_9":    9,
	"METER_CLASS_10":   10,
	"METER_CLASS_11":   11,
	"METER_CLASS_12":   12,
	"METER_CLASS_13":   13,
	"METER_CLASS_14":   14,
	"METER_CLASS_15":   15,
}

func (x MeterClass) String() string {
	return proto.EnumName(MeterClass_name, int32(x))
}

func (MeterClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{10}
}

// public/Internet or Service/Infra address
type AddressType int32

const (
	AddressType_ADDR_TYPE_NONE    AddressType = 0
	AddressType_ADDR_TYPE_PUBLIC  AddressType = 1
	AddressType_ADDR_TYPE_SERVICE AddressType = 2
)

var AddressType_name = map[int32]string{
	0: "ADDR_TYPE_NONE",
	1: "ADDR_TYPE_PUBLIC",
	2: "ADDR_TYPE_SERVICE",
}

var AddressType_value = map[string]int32{
	"ADDR_TYPE_NONE":    0,
	"ADDR_TYPE_PUBLIC":  1,
	"ADDR_TYPE_SERVICE": 2,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{11}
}

// admin state of control plane objects
type AdminState int32

const (
	AdminState_ADMIN_STATE_NONE    AdminState = 0
	AdminState_ADMIN_STATE_ENABLE  AdminState = 1
	AdminState_ADMIN_STATE_DISABLE AdminState = 2
)

var AdminState_name = map[int32]string{
	0: "ADMIN_STATE_NONE",
	1: "ADMIN_STATE_ENABLE",
	2: "ADMIN_STATE_DISABLE",
}

var AdminState_value = map[string]int32{
	"ADMIN_STATE_NONE":    0,
	"ADMIN_STATE_ENABLE":  1,
	"ADMIN_STATE_DISABLE": 2,
}

func (x AdminState) String() string {
	return proto.EnumName(AdminState_name, int32(x))
}

func (AdminState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{12}
}

// route type
type RouteType int32

const (
	RouteType_ROUTE_TYPE_NONE   RouteType = 0
	RouteType_ROUTE_TYPE_OTHER  RouteType = 1
	RouteType_ROUTE_TYPE_REJECT RouteType = 2
	RouteType_ROUTE_TYPE_LOCAL  RouteType = 3
	RouteType_ROUTE_TYPE_REMOTE RouteType = 4
)

var RouteType_name = map[int32]string{
	0: "ROUTE_TYPE_NONE",
	1: "ROUTE_TYPE_OTHER",
	2: "ROUTE_TYPE_REJECT",
	3: "ROUTE_TYPE_LOCAL",
	4: "ROUTE_TYPE_REMOTE",
}

var RouteType_value = map[string]int32{
	"ROUTE_TYPE_NONE":   0,
	"ROUTE_TYPE_OTHER":  1,
	"ROUTE_TYPE_REJECT": 2,
	"ROUTE_TYPE_LOCAL":  3,
	"ROUTE_TYPE_REMOTE": 4,
}

func (x RouteType) String() string {
	return proto.EnumName(RouteType_name, int32(x))
}

func (RouteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{13}
}

// route protocols
type RouteProtocol int32

const (
	RouteProtocol_ROUTE_PROTO_NONE   RouteProtocol = 0
	RouteProtocol_ROUTE_PROTO_LOCAL  RouteProtocol = 2
	RouteProtocol_ROUTE_PROTO_STATIC RouteProtocol = 3
	RouteProtocol_ROUTE_PROTO_BGP    RouteProtocol = 14
)

var RouteProtocol_name = map[int32]string{
	0:  "ROUTE_PROTO_NONE",
	2:  "ROUTE_PROTO_LOCAL",
	3:  "ROUTE_PROTO_STATIC",
	14: "ROUTE_PROTO_BGP",
}

var RouteProtocol_value = map[string]int32{
	"ROUTE_PROTO_NONE":   0,
	"ROUTE_PROTO_LOCAL":  2,
	"ROUTE_PROTO_STATIC": 3,
	"ROUTE_PROTO_BGP":    14,
}

func (x RouteProtocol) String() string {
	return proto.EnumName(RouteProtocol_name, int32(x))
}

func (RouteProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{14}
}

// PortSpeed specifies the speed of the port
type PortSpeed int32

const (
	PortSpeed_PORT_SPEED_NONE PortSpeed = 0
	PortSpeed_PORT_SPEED_10M  PortSpeed = 1
	PortSpeed_PORT_SPEED_100M PortSpeed = 2
	PortSpeed_PORT_SPEED_1G   PortSpeed = 3
	PortSpeed_PORT_SPEED_10G  PortSpeed = 4
	PortSpeed_PORT_SPEED_25G  PortSpeed = 5
	PortSpeed_PORT_SPEED_40G  PortSpeed = 6
	PortSpeed_PORT_SPEED_50G  PortSpeed = 7
	PortSpeed_PORT_SPEED_100G PortSpeed = 8
	PortSpeed_PORT_SPEED_200G PortSpeed = 9
	PortSpeed_PORT_SPEED_RSVD PortSpeed = 10
)

var PortSpeed_name = map[int32]string{
	0:  "PORT_SPEED_NONE",
	1:  "PORT_SPEED_10M",
	2:  "PORT_SPEED_100M",
	3:  "PORT_SPEED_1G",
	4:  "PORT_SPEED_10G",
	5:  "PORT_SPEED_25G",
	6:  "PORT_SPEED_40G",
	7:  "PORT_SPEED_50G",
	8:  "PORT_SPEED_100G",
	9:  "PORT_SPEED_200G",
	10: "PORT_SPEED_RSVD",
}

var PortSpeed_value = map[string]int32{
	"PORT_SPEED_NONE": 0,
	"PORT_SPEED_10M":  1,
	"PORT_SPEED_100M": 2,
	"PORT_SPEED_1G":   3,
	"PORT_SPEED_10G":  4,
	"PORT_SPEED_25G":  5,
	"PORT_SPEED_40G":  6,
	"PORT_SPEED_50G":  7,
	"PORT_SPEED_100G": 8,
	"PORT_SPEED_200G": 9,
	"PORT_SPEED_RSVD": 10,
}

func (x PortSpeed) String() string {
	return proto.EnumName(PortSpeed_name, int32(x))
}

func (PortSpeed) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{15}
}

// supported learn modes
type LearnMode int32

const (
	// when learn mode is set to LEARN_MODE_NONE, learning is completely disabled
	LearnMode_LEARN_MODE_NONE LearnMode = 0
	// in LEARN_MODE_NOTIFY mode, when a unknown MAC/IP is seen, notification
	// is generated via operd to the app, learn module will not populate the
	// p4 tables with the MAC or IP; they will be programmed when app comes back
	// and install vnics and/or IP mappings because of these learn notifications
	// NOTE:
	// 1. as learn events are simply notified to app, learn module doesn't need to
	//    perform aging of the MAC/IP entries in this mode.
	// 2. in order to de-dup back-to-back learn events and not bombard the app
	//    listening  to these notifications, some state will be maintained about
	//    the notified MAC/IP entries and will be deleted within short time
	LearnMode_LEARN_MODE_NOTIFY LearnMode = 1
	// in LEARN_MODE_AUTO, learn module will learn and automatically program the
	// learnt MAC/IP in the datapath. Additionally, notifications will be
	// generated for the clients of interest via operd
	LearnMode_LEARN_MODE_AUTO LearnMode = 2
)

var LearnMode_name = map[int32]string{
	0: "LEARN_MODE_NONE",
	1: "LEARN_MODE_NOTIFY",
	2: "LEARN_MODE_AUTO",
}

var LearnMode_value = map[string]int32{
	"LEARN_MODE_NONE":   0,
	"LEARN_MODE_NOTIFY": 1,
	"LEARN_MODE_AUTO":   2,
}

func (x LearnMode) String() string {
	return proto.EnumName(LearnMode_name, int32(x))
}

func (LearnMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{16}
}

// ServiceRequestOp encodes the API operation in the user
// issues request via Unix Domain Socket (UDS)
type ServiceRequestOp int32

const (
	ServiceRequestOp_SERVICE_OP_NONE   ServiceRequestOp = 0
	ServiceRequestOp_SERVICE_OP_CREATE ServiceRequestOp = 1
	ServiceRequestOp_SERVICE_OP_DELETE ServiceRequestOp = 2
	ServiceRequestOp_SERVICE_OP_UPDATE ServiceRequestOp = 3
	ServiceRequestOp_SERVICE_OP_READ   ServiceRequestOp = 4
)

var ServiceRequestOp_name = map[int32]string{
	0: "SERVICE_OP_NONE",
	1: "SERVICE_OP_CREATE",
	2: "SERVICE_OP_DELETE",
	3: "SERVICE_OP_UPDATE",
	4: "SERVICE_OP_READ",
}

var ServiceRequestOp_value = map[string]int32{
	"SERVICE_OP_NONE":   0,
	"SERVICE_OP_CREATE": 1,
	"SERVICE_OP_DELETE": 2,
	"SERVICE_OP_UPDATE": 3,
	"SERVICE_OP_READ":   4,
}

func (x ServiceRequestOp) String() string {
	return proto.EnumName(ServiceRequestOp_name, int32(x))
}

func (ServiceRequestOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{17}
}

// empty message
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// generic request with uuid
type Id struct {
	Id                   []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{1}
}
func (m *Id) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return m.Size()
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// IP Address object
type IPAddress struct {
	Af IPAF `protobuf:"varint,1,opt,name=Af,proto3,enum=types.IPAF" json:"Af,omitempty" meta:mandatory`
	// IP address family
	//
	// Types that are valid to be assigned to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6               isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{2}
}
func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddress_V4Addr struct {
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=V4Addr,proto3,oneof"`
}
type IPAddress_V6Addr struct {
	V6Addr []byte `protobuf:"bytes,3,opt,name=V6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}
func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (m *IPAddress) GetAf() IPAF {
	if m != nil {
		return m.Af
	}
	return IPAF_IP_AF_NONE
}

func (m *IPAddress) GetV4Addr() uint32 {
	if x, ok := m.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (m *IPAddress) GetV6Addr() []byte {
	if x, ok := m.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPAddress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
}

// IP Prefix object
type IPPrefix struct {
	// IP prefix address
	Addr *IPAddress `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	// IP Prefix length
	Len                  uint32   `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-128`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPPrefix) Reset()         { *m = IPPrefix{} }
func (m *IPPrefix) String() string { return proto.CompactTextString(m) }
func (*IPPrefix) ProtoMessage()    {}
func (*IPPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{3}
}
func (m *IPPrefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPPrefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPPrefix.Merge(m, src)
}
func (m *IPPrefix) XXX_Size() int {
	return m.Size()
}
func (m *IPPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_IPPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_IPPrefix proto.InternalMessageInfo

func (m *IPPrefix) GetAddr() *IPAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *IPPrefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IP Range
type IPRange struct {
	// starting IP address
	Low *IPAddress `protobuf:"bytes,1,opt,name=Low,proto3" json:"Low,omitempty"`
	// ending IP address
	High                 *IPAddress `protobuf:"bytes,2,opt,name=High,proto3" json:"High,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IPRange) Reset()         { *m = IPRange{} }
func (m *IPRange) String() string { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()    {}
func (*IPRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{4}
}
func (m *IPRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPRange.Merge(m, src)
}
func (m *IPRange) XXX_Size() int {
	return m.Size()
}
func (m *IPRange) XXX_DiscardUnknown() {
	xxx_messageInfo_IPRange.DiscardUnknown(m)
}

var xxx_messageInfo_IPRange proto.InternalMessageInfo

func (m *IPRange) GetLow() *IPAddress {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *IPRange) GetHigh() *IPAddress {
	if m != nil {
		return m.High
	}
	return nil
}

// IPEntry represents any form of IP address/prefix/range/tag etc.
type IPEntry struct {
	// Types that are valid to be assigned to IpEntry:
	//	*IPEntry_Prefix
	//	*IPEntry_Range
	//	*IPEntry_Tag
	IpEntry              isIPEntry_IpEntry `protobuf_oneof:"ip_entry"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IPEntry) Reset()         { *m = IPEntry{} }
func (m *IPEntry) String() string { return proto.CompactTextString(m) }
func (*IPEntry) ProtoMessage()    {}
func (*IPEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{5}
}
func (m *IPEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPEntry.Merge(m, src)
}
func (m *IPEntry) XXX_Size() int {
	return m.Size()
}
func (m *IPEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_IPEntry.DiscardUnknown(m)
}

var xxx_messageInfo_IPEntry proto.InternalMessageInfo

type isIPEntry_IpEntry interface {
	isIPEntry_IpEntry()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPEntry_Prefix struct {
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=Prefix,proto3,oneof"`
}
type IPEntry_Range struct {
	Range *AddressRange `protobuf:"bytes,2,opt,name=Range,proto3,oneof"`
}
type IPEntry_Tag struct {
	Tag uint32 `protobuf:"varint,3,opt,name=Tag,proto3,oneof"`
}

func (*IPEntry_Prefix) isIPEntry_IpEntry() {}
func (*IPEntry_Range) isIPEntry_IpEntry()  {}
func (*IPEntry_Tag) isIPEntry_IpEntry()    {}

func (m *IPEntry) GetIpEntry() isIPEntry_IpEntry {
	if m != nil {
		return m.IpEntry
	}
	return nil
}

func (m *IPEntry) GetPrefix() *IPPrefix {
	if x, ok := m.GetIpEntry().(*IPEntry_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *IPEntry) GetRange() *AddressRange {
	if x, ok := m.GetIpEntry().(*IPEntry_Range); ok {
		return x.Range
	}
	return nil
}

func (m *IPEntry) GetTag() uint32 {
	if x, ok := m.GetIpEntry().(*IPEntry_Tag); ok {
		return x.Tag
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPEntry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPEntry_Prefix)(nil),
		(*IPEntry_Range)(nil),
		(*IPEntry_Tag)(nil),
	}
}

// IPList is a list of IPEntry objects
type IPList struct {
	IPEntry              []*IPEntry `protobuf:"bytes,1,rep,name=IPEntry,proto3" json:"IPEntry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IPList) Reset()         { *m = IPList{} }
func (m *IPList) String() string { return proto.CompactTextString(m) }
func (*IPList) ProtoMessage()    {}
func (*IPList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{6}
}
func (m *IPList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPList.Merge(m, src)
}
func (m *IPList) XXX_Size() int {
	return m.Size()
}
func (m *IPList) XXX_DiscardUnknown() {
	xxx_messageInfo_IPList.DiscardUnknown(m)
}

var xxx_messageInfo_IPList proto.InternalMessageInfo

func (m *IPList) GetIPEntry() []*IPEntry {
	if m != nil {
		return m.IPEntry
	}
	return nil
}

// IPv4 Prefix
type IPv4Prefix struct {
	// IPv4 address portion
	Addr uint32 `protobuf:"fixed32,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	// prefix length
	Len                  uint32   `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-32`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPv4Prefix) Reset()         { *m = IPv4Prefix{} }
func (m *IPv4Prefix) String() string { return proto.CompactTextString(m) }
func (*IPv4Prefix) ProtoMessage()    {}
func (*IPv4Prefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{7}
}
func (m *IPv4Prefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4Prefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4Prefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv4Prefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4Prefix.Merge(m, src)
}
func (m *IPv4Prefix) XXX_Size() int {
	return m.Size()
}
func (m *IPv4Prefix) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4Prefix.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4Prefix proto.InternalMessageInfo

func (m *IPv4Prefix) GetAddr() uint32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *IPv4Prefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IPv6 Prefix
type IPv6Prefix struct {
	// IPv6 address bytes
	Addr []byte `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	// prefix length
	Len                  uint32   `protobuf:"varint,2,opt,name=Len,proto3" json:"Len,omitempty" meta:range=0-128`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPv6Prefix) Reset()         { *m = IPv6Prefix{} }
func (m *IPv6Prefix) String() string { return proto.CompactTextString(m) }
func (*IPv6Prefix) ProtoMessage()    {}
func (*IPv6Prefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{8}
}
func (m *IPv6Prefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6Prefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6Prefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6Prefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6Prefix.Merge(m, src)
}
func (m *IPv6Prefix) XXX_Size() int {
	return m.Size()
}
func (m *IPv6Prefix) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6Prefix.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6Prefix proto.InternalMessageInfo

func (m *IPv6Prefix) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *IPv6Prefix) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

// IPSubnet represents an IPv4 or IPv6 subnet
type IPSubnet struct {
	// Types that are valid to be assigned to Subnet:
	//	*IPSubnet_IPv4Subnet
	//	*IPSubnet_IPv6Subnet
	Subnet               isIPSubnet_Subnet `protobuf_oneof:"subnet"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IPSubnet) Reset()         { *m = IPSubnet{} }
func (m *IPSubnet) String() string { return proto.CompactTextString(m) }
func (*IPSubnet) ProtoMessage()    {}
func (*IPSubnet) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{9}
}
func (m *IPSubnet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPSubnet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPSubnet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPSubnet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPSubnet.Merge(m, src)
}
func (m *IPSubnet) XXX_Size() int {
	return m.Size()
}
func (m *IPSubnet) XXX_DiscardUnknown() {
	xxx_messageInfo_IPSubnet.DiscardUnknown(m)
}

var xxx_messageInfo_IPSubnet proto.InternalMessageInfo

type isIPSubnet_Subnet interface {
	isIPSubnet_Subnet()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPSubnet_IPv4Subnet struct {
	IPv4Subnet *IPPrefix `protobuf:"bytes,1,opt,name=IPv4Subnet,proto3,oneof"`
}
type IPSubnet_IPv6Subnet struct {
	IPv6Subnet *IPPrefix `protobuf:"bytes,2,opt,name=IPv6Subnet,proto3,oneof"`
}

func (*IPSubnet_IPv4Subnet) isIPSubnet_Subnet() {}
func (*IPSubnet_IPv6Subnet) isIPSubnet_Subnet() {}

func (m *IPSubnet) GetSubnet() isIPSubnet_Subnet {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *IPSubnet) GetIPv4Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_IPv4Subnet); ok {
		return x.IPv4Subnet
	}
	return nil
}

func (m *IPSubnet) GetIPv6Subnet() *IPPrefix {
	if x, ok := m.GetSubnet().(*IPSubnet_IPv6Subnet); ok {
		return x.IPv6Subnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPSubnet) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPSubnet_IPv4Subnet)(nil),
		(*IPSubnet_IPv6Subnet)(nil),
	}
}

// AddressRange represents an IPv4 or IPv6 address range
type AddressRange struct {
	// Types that are valid to be assigned to Range:
	//	*AddressRange_IPv4Range
	//	*AddressRange_IPv6Range
	Range                isAddressRange_Range `protobuf_oneof:"range"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AddressRange) Reset()         { *m = AddressRange{} }
func (m *AddressRange) String() string { return proto.CompactTextString(m) }
func (*AddressRange) ProtoMessage()    {}
func (*AddressRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{10}
}
func (m *AddressRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressRange.Merge(m, src)
}
func (m *AddressRange) XXX_Size() int {
	return m.Size()
}
func (m *AddressRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressRange.DiscardUnknown(m)
}

var xxx_messageInfo_AddressRange proto.InternalMessageInfo

type isAddressRange_Range interface {
	isAddressRange_Range()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AddressRange_IPv4Range struct {
	IPv4Range *IPRange `protobuf:"bytes,1,opt,name=IPv4Range,proto3,oneof"`
}
type AddressRange_IPv6Range struct {
	IPv6Range *IPRange `protobuf:"bytes,2,opt,name=IPv6Range,proto3,oneof"`
}

func (*AddressRange_IPv4Range) isAddressRange_Range() {}
func (*AddressRange_IPv6Range) isAddressRange_Range() {}

func (m *AddressRange) GetRange() isAddressRange_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *AddressRange) GetIPv4Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_IPv4Range); ok {
		return x.IPv4Range
	}
	return nil
}

func (m *AddressRange) GetIPv6Range() *IPRange {
	if x, ok := m.GetRange().(*AddressRange_IPv6Range); ok {
		return x.IPv6Range
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AddressRange) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AddressRange_IPv4Range)(nil),
		(*AddressRange_IPv6Range)(nil),
	}
}

// Address object is the prefix or range
type Address struct {
	// Types that are valid to be assigned to Address:
	//	*Address_Prefix
	//	*Address_Range
	Address              isAddress_Address `protobuf_oneof:"address"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{11}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

type isAddress_Address interface {
	isAddress_Address()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Address_Prefix struct {
	Prefix *IPSubnet `protobuf:"bytes,1,opt,name=Prefix,proto3,oneof"`
}
type Address_Range struct {
	Range *AddressRange `protobuf:"bytes,2,opt,name=Range,proto3,oneof"`
}

func (*Address_Prefix) isAddress_Address() {}
func (*Address_Range) isAddress_Address()  {}

func (m *Address) GetAddress() isAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Address) GetPrefix() *IPSubnet {
	if x, ok := m.GetAddress().(*Address_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *Address) GetRange() *AddressRange {
	if x, ok := m.GetAddress().(*Address_Range); ok {
		return x.Range
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Address) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Address_Prefix)(nil),
		(*Address_Range)(nil),
	}
}

// PortRange object has low and high end of the port ranges
type PortRange struct {
	PortLow              uint32   `protobuf:"varint,1,opt,name=PortLow,proto3" json:"PortLow,omitempty" meta:range:0-65535`
	PortHigh             uint32   `protobuf:"varint,2,opt,name=PortHigh,proto3" json:"PortHigh,omitempty" meta:range:0-65535`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortRange) Reset()         { *m = PortRange{} }
func (m *PortRange) String() string { return proto.CompactTextString(m) }
func (*PortRange) ProtoMessage()    {}
func (*PortRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{12}
}
func (m *PortRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortRange.Merge(m, src)
}
func (m *PortRange) XXX_Size() int {
	return m.Size()
}
func (m *PortRange) XXX_DiscardUnknown() {
	xxx_messageInfo_PortRange.DiscardUnknown(m)
}

var xxx_messageInfo_PortRange proto.InternalMessageInfo

func (m *PortRange) GetPortLow() uint32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *PortRange) GetPortHigh() uint32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

// L3 rule match criteria
type RuleL3Match struct {
	// IP Protocol
	//
	// Types that are valid to be assigned to Protomatch:
	//	*RuleL3Match_ProtoNum
	//	*RuleL3Match_ProtoWildcard
	Protomatch isRuleL3Match_Protomatch `protobuf_oneof:"protomatch"`
	// Types that are valid to be assigned to Srcmatch:
	//	*RuleL3Match_SrcPrefix
	//	*RuleL3Match_SrcRange
	//	*RuleL3Match_SrcTag
	//	*RuleL3Match_SrcIPList
	Srcmatch isRuleL3Match_Srcmatch `protobuf_oneof:"srcmatch"`
	// Types that are valid to be assigned to Dstmatch:
	//	*RuleL3Match_DstPrefix
	//	*RuleL3Match_DstRange
	//	*RuleL3Match_DstTag
	//	*RuleL3Match_DstIPList
	Dstmatch             isRuleL3Match_Dstmatch `protobuf_oneof:"dstmatch"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RuleL3Match) Reset()         { *m = RuleL3Match{} }
func (m *RuleL3Match) String() string { return proto.CompactTextString(m) }
func (*RuleL3Match) ProtoMessage()    {}
func (*RuleL3Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{13}
}
func (m *RuleL3Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleL3Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleL3Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleL3Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleL3Match.Merge(m, src)
}
func (m *RuleL3Match) XXX_Size() int {
	return m.Size()
}
func (m *RuleL3Match) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleL3Match.DiscardUnknown(m)
}

var xxx_messageInfo_RuleL3Match proto.InternalMessageInfo

type isRuleL3Match_Protomatch interface {
	isRuleL3Match_Protomatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRuleL3Match_Srcmatch interface {
	isRuleL3Match_Srcmatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRuleL3Match_Dstmatch interface {
	isRuleL3Match_Dstmatch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleL3Match_ProtoNum struct {
	ProtoNum uint32 `protobuf:"varint,1,opt,name=ProtoNum,proto3,oneof"`
}
type RuleL3Match_ProtoWildcard struct {
	ProtoWildcard WildcardMatch `protobuf:"varint,2,opt,name=ProtoWildcard,proto3,enum=types.WildcardMatch,oneof"`
}
type RuleL3Match_SrcPrefix struct {
	SrcPrefix *IPPrefix `protobuf:"bytes,3,opt,name=SrcPrefix,proto3,oneof"`
}
type RuleL3Match_SrcRange struct {
	SrcRange *AddressRange `protobuf:"bytes,4,opt,name=SrcRange,proto3,oneof"`
}
type RuleL3Match_SrcTag struct {
	SrcTag uint32 `protobuf:"varint,5,opt,name=SrcTag,proto3,oneof"`
}
type RuleL3Match_SrcIPList struct {
	SrcIPList *IPList `protobuf:"bytes,6,opt,name=SrcIPList,proto3,oneof"`
}
type RuleL3Match_DstPrefix struct {
	DstPrefix *IPPrefix `protobuf:"bytes,7,opt,name=DstPrefix,proto3,oneof"`
}
type RuleL3Match_DstRange struct {
	DstRange *AddressRange `protobuf:"bytes,8,opt,name=DstRange,proto3,oneof"`
}
type RuleL3Match_DstTag struct {
	DstTag uint32 `protobuf:"varint,9,opt,name=DstTag,proto3,oneof"`
}
type RuleL3Match_DstIPList struct {
	DstIPList *IPList `protobuf:"bytes,10,opt,name=DstIPList,proto3,oneof"`
}

func (*RuleL3Match_ProtoNum) isRuleL3Match_Protomatch()      {}
func (*RuleL3Match_ProtoWildcard) isRuleL3Match_Protomatch() {}
func (*RuleL3Match_SrcPrefix) isRuleL3Match_Srcmatch()       {}
func (*RuleL3Match_SrcRange) isRuleL3Match_Srcmatch()        {}
func (*RuleL3Match_SrcTag) isRuleL3Match_Srcmatch()          {}
func (*RuleL3Match_SrcIPList) isRuleL3Match_Srcmatch()       {}
func (*RuleL3Match_DstPrefix) isRuleL3Match_Dstmatch()       {}
func (*RuleL3Match_DstRange) isRuleL3Match_Dstmatch()        {}
func (*RuleL3Match_DstTag) isRuleL3Match_Dstmatch()          {}
func (*RuleL3Match_DstIPList) isRuleL3Match_Dstmatch()       {}

func (m *RuleL3Match) GetProtomatch() isRuleL3Match_Protomatch {
	if m != nil {
		return m.Protomatch
	}
	return nil
}
func (m *RuleL3Match) GetSrcmatch() isRuleL3Match_Srcmatch {
	if m != nil {
		return m.Srcmatch
	}
	return nil
}
func (m *RuleL3Match) GetDstmatch() isRuleL3Match_Dstmatch {
	if m != nil {
		return m.Dstmatch
	}
	return nil
}

func (m *RuleL3Match) GetProtoNum() uint32 {
	if x, ok := m.GetProtomatch().(*RuleL3Match_ProtoNum); ok {
		return x.ProtoNum
	}
	return 0
}

func (m *RuleL3Match) GetProtoWildcard() WildcardMatch {
	if x, ok := m.GetProtomatch().(*RuleL3Match_ProtoWildcard); ok {
		return x.ProtoWildcard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *RuleL3Match) GetSrcPrefix() *IPPrefix {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcPrefix); ok {
		return x.SrcPrefix
	}
	return nil
}

func (m *RuleL3Match) GetSrcRange() *AddressRange {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcRange); ok {
		return x.SrcRange
	}
	return nil
}

func (m *RuleL3Match) GetSrcTag() uint32 {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcTag); ok {
		return x.SrcTag
	}
	return 0
}

func (m *RuleL3Match) GetSrcIPList() *IPList {
	if x, ok := m.GetSrcmatch().(*RuleL3Match_SrcIPList); ok {
		return x.SrcIPList
	}
	return nil
}

func (m *RuleL3Match) GetDstPrefix() *IPPrefix {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstPrefix); ok {
		return x.DstPrefix
	}
	return nil
}

func (m *RuleL3Match) GetDstRange() *AddressRange {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstRange); ok {
		return x.DstRange
	}
	return nil
}

func (m *RuleL3Match) GetDstTag() uint32 {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstTag); ok {
		return x.DstTag
	}
	return 0
}

func (m *RuleL3Match) GetDstIPList() *IPList {
	if x, ok := m.GetDstmatch().(*RuleL3Match_DstIPList); ok {
		return x.DstIPList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RuleL3Match) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RuleL3Match_ProtoNum)(nil),
		(*RuleL3Match_ProtoWildcard)(nil),
		(*RuleL3Match_SrcPrefix)(nil),
		(*RuleL3Match_SrcRange)(nil),
		(*RuleL3Match_SrcTag)(nil),
		(*RuleL3Match_SrcIPList)(nil),
		(*RuleL3Match_DstPrefix)(nil),
		(*RuleL3Match_DstRange)(nil),
		(*RuleL3Match_DstTag)(nil),
		(*RuleL3Match_DstIPList)(nil),
	}
}

// TCP/UDP rule match criteria
type PortMatch struct {
	// source port range
	SrcPortRange *PortRange `protobuf:"bytes,1,opt,name=SrcPortRange,proto3" json:"SrcPortRange,omitempty"`
	// destination port range
	DstPortRange         *PortRange `protobuf:"bytes,2,opt,name=DstPortRange,proto3" json:"DstPortRange,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PortMatch) Reset()         { *m = PortMatch{} }
func (m *PortMatch) String() string { return proto.CompactTextString(m) }
func (*PortMatch) ProtoMessage()    {}
func (*PortMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{14}
}
func (m *PortMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortMatch.Merge(m, src)
}
func (m *PortMatch) XXX_Size() int {
	return m.Size()
}
func (m *PortMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PortMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PortMatch proto.InternalMessageInfo

func (m *PortMatch) GetSrcPortRange() *PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *PortMatch) GetDstPortRange() *PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// ICMPv4/ICMPv6 rule match criteria
type ICMPMatch struct {
	// ICMP type
	//
	// Types that are valid to be assigned to Typematch:
	//	*ICMPMatch_Type
	//	*ICMPMatch_TypeWildcard
	Typematch isICMPMatch_Typematch `protobuf_oneof:"typematch"`
	// ICMP code
	//
	// Types that are valid to be assigned to Codematch:
	//	*ICMPMatch_Code
	//	*ICMPMatch_CodeWildcard
	Codematch            isICMPMatch_Codematch `protobuf_oneof:"codematch"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ICMPMatch) Reset()         { *m = ICMPMatch{} }
func (m *ICMPMatch) String() string { return proto.CompactTextString(m) }
func (*ICMPMatch) ProtoMessage()    {}
func (*ICMPMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{15}
}
func (m *ICMPMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPMatch.Merge(m, src)
}
func (m *ICMPMatch) XXX_Size() int {
	return m.Size()
}
func (m *ICMPMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPMatch proto.InternalMessageInfo

type isICMPMatch_Typematch interface {
	isICMPMatch_Typematch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isICMPMatch_Codematch interface {
	isICMPMatch_Codematch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ICMPMatch_Type struct {
	Type uint32 `protobuf:"varint,1,opt,name=Type,proto3,oneof"`
}
type ICMPMatch_TypeWildcard struct {
	TypeWildcard WildcardMatch `protobuf:"varint,2,opt,name=TypeWildcard,proto3,enum=types.WildcardMatch,oneof"`
}
type ICMPMatch_Code struct {
	Code uint32 `protobuf:"varint,3,opt,name=Code,proto3,oneof"`
}
type ICMPMatch_CodeWildcard struct {
	CodeWildcard WildcardMatch `protobuf:"varint,4,opt,name=CodeWildcard,proto3,enum=types.WildcardMatch,oneof"`
}

func (*ICMPMatch_Type) isICMPMatch_Typematch()         {}
func (*ICMPMatch_TypeWildcard) isICMPMatch_Typematch() {}
func (*ICMPMatch_Code) isICMPMatch_Codematch()         {}
func (*ICMPMatch_CodeWildcard) isICMPMatch_Codematch() {}

func (m *ICMPMatch) GetTypematch() isICMPMatch_Typematch {
	if m != nil {
		return m.Typematch
	}
	return nil
}
func (m *ICMPMatch) GetCodematch() isICMPMatch_Codematch {
	if m != nil {
		return m.Codematch
	}
	return nil
}

func (m *ICMPMatch) GetType() uint32 {
	if x, ok := m.GetTypematch().(*ICMPMatch_Type); ok {
		return x.Type
	}
	return 0
}

func (m *ICMPMatch) GetTypeWildcard() WildcardMatch {
	if x, ok := m.GetTypematch().(*ICMPMatch_TypeWildcard); ok {
		return x.TypeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *ICMPMatch) GetCode() uint32 {
	if x, ok := m.GetCodematch().(*ICMPMatch_Code); ok {
		return x.Code
	}
	return 0
}

func (m *ICMPMatch) GetCodeWildcard() WildcardMatch {
	if x, ok := m.GetCodematch().(*ICMPMatch_CodeWildcard); ok {
		return x.CodeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ICMPMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ICMPMatch_Type)(nil),
		(*ICMPMatch_TypeWildcard)(nil),
		(*ICMPMatch_Code)(nil),
		(*ICMPMatch_CodeWildcard)(nil),
	}
}

// TCP/UDP source and destination port list
type PortListMatch struct {
	// list of source ports or port ranges
	SrcPortRange []*PortRange `protobuf:"bytes,1,rep,name=SrcPortRange,proto3" json:"SrcPortRange,omitempty"`
	// list of destination ports or port ranges
	DstPortRange         []*PortRange `protobuf:"bytes,2,rep,name=DstPortRange,proto3" json:"DstPortRange,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PortListMatch) Reset()         { *m = PortListMatch{} }
func (m *PortListMatch) String() string { return proto.CompactTextString(m) }
func (*PortListMatch) ProtoMessage()    {}
func (*PortListMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{16}
}
func (m *PortListMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortListMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortListMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortListMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortListMatch.Merge(m, src)
}
func (m *PortListMatch) XXX_Size() int {
	return m.Size()
}
func (m *PortListMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PortListMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PortListMatch proto.InternalMessageInfo

func (m *PortListMatch) GetSrcPortRange() []*PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *PortListMatch) GetDstPortRange() []*PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// ICMP type/code match condition list
type ICMPMatchList struct {
	// ICMP type/code list
	ICMPMatchList        []*ICMPMatch `protobuf:"bytes,1,rep,name=ICMPMatchList,proto3" json:"ICMPMatchList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ICMPMatchList) Reset()         { *m = ICMPMatchList{} }
func (m *ICMPMatchList) String() string { return proto.CompactTextString(m) }
func (*ICMPMatchList) ProtoMessage()    {}
func (*ICMPMatchList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{17}
}
func (m *ICMPMatchList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPMatchList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPMatchList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPMatchList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPMatchList.Merge(m, src)
}
func (m *ICMPMatchList) XXX_Size() int {
	return m.Size()
}
func (m *ICMPMatchList) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPMatchList.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPMatchList proto.InternalMessageInfo

func (m *ICMPMatchList) GetICMPMatchList() []*ICMPMatch {
	if m != nil {
		return m.ICMPMatchList
	}
	return nil
}

// L4 rule match criteria
type RuleL4Match struct {
	// Types that are valid to be assigned to L4Info:
	//	*RuleL4Match_Ports
	//	*RuleL4Match_TypeCode
	//	*RuleL4Match_PortList
	//	*RuleL4Match_ICMPMatchList
	L4Info               isRuleL4Match_L4Info `protobuf_oneof:"l4info"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RuleL4Match) Reset()         { *m = RuleL4Match{} }
func (m *RuleL4Match) String() string { return proto.CompactTextString(m) }
func (*RuleL4Match) ProtoMessage()    {}
func (*RuleL4Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{18}
}
func (m *RuleL4Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleL4Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleL4Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleL4Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleL4Match.Merge(m, src)
}
func (m *RuleL4Match) XXX_Size() int {
	return m.Size()
}
func (m *RuleL4Match) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleL4Match.DiscardUnknown(m)
}

var xxx_messageInfo_RuleL4Match proto.InternalMessageInfo

type isRuleL4Match_L4Info interface {
	isRuleL4Match_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleL4Match_Ports struct {
	Ports *PortMatch `protobuf:"bytes,1,opt,name=Ports,proto3,oneof"`
}
type RuleL4Match_TypeCode struct {
	TypeCode *ICMPMatch `protobuf:"bytes,2,opt,name=TypeCode,proto3,oneof"`
}
type RuleL4Match_PortList struct {
	PortList *PortListMatch `protobuf:"bytes,3,opt,name=PortList,proto3,oneof"`
}
type RuleL4Match_ICMPMatchList struct {
	ICMPMatchList *ICMPMatchList `protobuf:"bytes,4,opt,name=ICMPMatchList,proto3,oneof"`
}

func (*RuleL4Match_Ports) isRuleL4Match_L4Info()         {}
func (*RuleL4Match_TypeCode) isRuleL4Match_L4Info()      {}
func (*RuleL4Match_PortList) isRuleL4Match_L4Info()      {}
func (*RuleL4Match_ICMPMatchList) isRuleL4Match_L4Info() {}

func (m *RuleL4Match) GetL4Info() isRuleL4Match_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *RuleL4Match) GetPorts() *PortMatch {
	if x, ok := m.GetL4Info().(*RuleL4Match_Ports); ok {
		return x.Ports
	}
	return nil
}

func (m *RuleL4Match) GetTypeCode() *ICMPMatch {
	if x, ok := m.GetL4Info().(*RuleL4Match_TypeCode); ok {
		return x.TypeCode
	}
	return nil
}

func (m *RuleL4Match) GetPortList() *PortListMatch {
	if x, ok := m.GetL4Info().(*RuleL4Match_PortList); ok {
		return x.PortList
	}
	return nil
}

func (m *RuleL4Match) GetICMPMatchList() *ICMPMatchList {
	if x, ok := m.GetL4Info().(*RuleL4Match_ICMPMatchList); ok {
		return x.ICMPMatchList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RuleL4Match) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RuleL4Match_Ports)(nil),
		(*RuleL4Match_TypeCode)(nil),
		(*RuleL4Match_PortList)(nil),
		(*RuleL4Match_ICMPMatchList)(nil),
	}
}

// rule match criteria
type RuleMatch struct {
	// Layer 3 match criteria
	L3Match *RuleL3Match `protobuf:"bytes,1,opt,name=L3Match,proto3" json:"L3Match,omitempty"`
	// Layer 4 match criteria
	L4Match              *RuleL4Match `protobuf:"bytes,2,opt,name=L4Match,proto3" json:"L4Match,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RuleMatch) Reset()         { *m = RuleMatch{} }
func (m *RuleMatch) String() string { return proto.CompactTextString(m) }
func (*RuleMatch) ProtoMessage()    {}
func (*RuleMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{19}
}
func (m *RuleMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleMatch.Merge(m, src)
}
func (m *RuleMatch) XXX_Size() int {
	return m.Size()
}
func (m *RuleMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RuleMatch proto.InternalMessageInfo

func (m *RuleMatch) GetL3Match() *RuleL3Match {
	if m != nil {
		return m.L3Match
	}
	return nil
}

func (m *RuleMatch) GetL4Match() *RuleL4Match {
	if m != nil {
		return m.L4Match
	}
	return nil
}

// QinQ encap
type QinQ struct {
	// Service VLAN tag
	STag uint32 `protobuf:"varint,1,opt,name=STag,proto3" json:"STag,omitempty" meta:mandatory`
	// Customer VLAN tag
	CTag                 uint32   `protobuf:"varint,2,opt,name=CTag,proto3" json:"CTag,omitempty" meta:mandatory`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QinQ) Reset()         { *m = QinQ{} }
func (m *QinQ) String() string { return proto.CompactTextString(m) }
func (*QinQ) ProtoMessage()    {}
func (*QinQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{20}
}
func (m *QinQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QinQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QinQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QinQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QinQ.Merge(m, src)
}
func (m *QinQ) XXX_Size() int {
	return m.Size()
}
func (m *QinQ) XXX_DiscardUnknown() {
	xxx_messageInfo_QinQ.DiscardUnknown(m)
}

var xxx_messageInfo_QinQ proto.InternalMessageInfo

func (m *QinQ) GetSTag() uint32 {
	if m != nil {
		return m.STag
	}
	return 0
}

func (m *QinQ) GetCTag() uint32 {
	if m != nil {
		return m.CTag
	}
	return 0
}

// based on the encap type in the fabric, one can carry per vnic information
// for example, in case of MPLSoUDP, MPLS tag (along with source tunnel IP)
// can uniquely identify the vnic from where the packet is originating and
// another MPLS tag (along with the destination tunnel IP) can identify the
// destination VNIC
type EncapVal struct {
	// Types that are valid to be assigned to Val:
	//	*EncapVal_VlanId
	//	*EncapVal_MPLSTag
	//	*EncapVal_Vnid
	//	*EncapVal_QinQ
	//	*EncapVal_Vsid
	Val                  isEncapVal_Val `protobuf_oneof:"val"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EncapVal) Reset()         { *m = EncapVal{} }
func (m *EncapVal) String() string { return proto.CompactTextString(m) }
func (*EncapVal) ProtoMessage()    {}
func (*EncapVal) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{21}
}
func (m *EncapVal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncapVal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncapVal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncapVal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncapVal.Merge(m, src)
}
func (m *EncapVal) XXX_Size() int {
	return m.Size()
}
func (m *EncapVal) XXX_DiscardUnknown() {
	xxx_messageInfo_EncapVal.DiscardUnknown(m)
}

var xxx_messageInfo_EncapVal proto.InternalMessageInfo

type isEncapVal_Val interface {
	isEncapVal_Val()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EncapVal_VlanId struct {
	VlanId uint32 `protobuf:"varint,1,opt,name=VlanId,proto3,oneof"`
}
type EncapVal_MPLSTag struct {
	MPLSTag uint32 `protobuf:"varint,2,opt,name=MPLSTag,proto3,oneof"`
}
type EncapVal_Vnid struct {
	Vnid uint32 `protobuf:"varint,3,opt,name=Vnid,proto3,oneof"`
}
type EncapVal_QinQ struct {
	QinQ *QinQ `protobuf:"bytes,4,opt,name=QinQ,proto3,oneof"`
}
type EncapVal_Vsid struct {
	Vsid uint32 `protobuf:"varint,5,opt,name=Vsid,proto3,oneof"`
}

func (*EncapVal_VlanId) isEncapVal_Val()  {}
func (*EncapVal_MPLSTag) isEncapVal_Val() {}
func (*EncapVal_Vnid) isEncapVal_Val()    {}
func (*EncapVal_QinQ) isEncapVal_Val()    {}
func (*EncapVal_Vsid) isEncapVal_Val()    {}

func (m *EncapVal) GetVal() isEncapVal_Val {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *EncapVal) GetVlanId() uint32 {
	if x, ok := m.GetVal().(*EncapVal_VlanId); ok {
		return x.VlanId
	}
	return 0
}

func (m *EncapVal) GetMPLSTag() uint32 {
	if x, ok := m.GetVal().(*EncapVal_MPLSTag); ok {
		return x.MPLSTag
	}
	return 0
}

func (m *EncapVal) GetVnid() uint32 {
	if x, ok := m.GetVal().(*EncapVal_Vnid); ok {
		return x.Vnid
	}
	return 0
}

func (m *EncapVal) GetQinQ() *QinQ {
	if x, ok := m.GetVal().(*EncapVal_QinQ); ok {
		return x.QinQ
	}
	return nil
}

func (m *EncapVal) GetVsid() uint32 {
	if x, ok := m.GetVal().(*EncapVal_Vsid); ok {
		return x.Vsid
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EncapVal) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EncapVal_VlanId)(nil),
		(*EncapVal_MPLSTag)(nil),
		(*EncapVal_Vnid)(nil),
		(*EncapVal_QinQ)(nil),
		(*EncapVal_Vsid)(nil),
	}
}

// fabric encap
type Encap struct {
	Type                 EncapType `protobuf:"varint,1,opt,name=Type,proto3,enum=types.EncapType" json:"Type,omitempty"`
	Value                *EncapVal `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Encap) Reset()         { *m = Encap{} }
func (m *Encap) String() string { return proto.CompactTextString(m) }
func (*Encap) ProtoMessage()    {}
func (*Encap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{22}
}
func (m *Encap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Encap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Encap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Encap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Encap.Merge(m, src)
}
func (m *Encap) XXX_Size() int {
	return m.Size()
}
func (m *Encap) XXX_DiscardUnknown() {
	xxx_messageInfo_Encap.DiscardUnknown(m)
}

var xxx_messageInfo_Encap proto.InternalMessageInfo

func (m *Encap) GetType() EncapType {
	if m != nil {
		return m.Type
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *Encap) GetValue() *EncapVal {
	if m != nil {
		return m.Value
	}
	return nil
}

// BatchCtxt is opaque to application(s) and is expected to be passed
// back (to identify the batch) in every API call of this batch until
// BatchCommit() or BatchAbort()
type BatchCtxt struct {
	// opaque cookie
	BatchCookie          uint64   `protobuf:"varint,1,opt,name=BatchCookie,proto3" json:"BatchCookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchCtxt) Reset()         { *m = BatchCtxt{} }
func (m *BatchCtxt) String() string { return proto.CompactTextString(m) }
func (*BatchCtxt) ProtoMessage()    {}
func (*BatchCtxt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{23}
}
func (m *BatchCtxt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCtxt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCtxt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCtxt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCtxt.Merge(m, src)
}
func (m *BatchCtxt) XXX_Size() int {
	return m.Size()
}
func (m *BatchCtxt) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCtxt.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCtxt proto.InternalMessageInfo

func (m *BatchCtxt) GetBatchCookie() uint64 {
	if m != nil {
		return m.BatchCookie
	}
	return 0
}

// flow key for non-IP flows
type MACFlowKey struct {
	// subnet identifier
	Subnet []byte `protobuf:"bytes,1,opt,name=Subnet,proto3" json:"Subnet,omitempty"`
	// source MAC address
	SrcMAC uint64 `protobuf:"varint,2,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	// destination MAC address
	DstMAC uint64 `protobuf:"varint,3,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	// 16 bits of Ethertype in the Ethernet header
	EtherType            uint32   `protobuf:"varint,4,opt,name=EtherType,proto3" json:"EtherType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MACFlowKey) Reset()         { *m = MACFlowKey{} }
func (m *MACFlowKey) String() string { return proto.CompactTextString(m) }
func (*MACFlowKey) ProtoMessage()    {}
func (*MACFlowKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{24}
}
func (m *MACFlowKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MACFlowKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MACFlowKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MACFlowKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MACFlowKey.Merge(m, src)
}
func (m *MACFlowKey) XXX_Size() int {
	return m.Size()
}
func (m *MACFlowKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MACFlowKey.DiscardUnknown(m)
}

var xxx_messageInfo_MACFlowKey proto.InternalMessageInfo

func (m *MACFlowKey) GetSubnet() []byte {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *MACFlowKey) GetSrcMAC() uint64 {
	if m != nil {
		return m.SrcMAC
	}
	return 0
}

func (m *MACFlowKey) GetDstMAC() uint64 {
	if m != nil {
		return m.DstMAC
	}
	return 0
}

func (m *MACFlowKey) GetEtherType() uint32 {
	if m != nil {
		return m.EtherType
	}
	return 0
}

// L4 portion of flow key tuple
type FlowL4Info struct {
	// Types that are valid to be assigned to L4Info:
	//	*FlowL4Info_TcpUdpInfo
	//	*FlowL4Info_IcmpInfo
	L4Info               isFlowL4Info_L4Info `protobuf_oneof:"l4_info"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FlowL4Info) Reset()         { *m = FlowL4Info{} }
func (m *FlowL4Info) String() string { return proto.CompactTextString(m) }
func (*FlowL4Info) ProtoMessage()    {}
func (*FlowL4Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{25}
}
func (m *FlowL4Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowL4Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowL4Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowL4Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowL4Info.Merge(m, src)
}
func (m *FlowL4Info) XXX_Size() int {
	return m.Size()
}
func (m *FlowL4Info) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowL4Info.DiscardUnknown(m)
}

var xxx_messageInfo_FlowL4Info proto.InternalMessageInfo

type isFlowL4Info_L4Info interface {
	isFlowL4Info_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowL4Info_TcpUdpInfo struct {
	TcpUdpInfo *FlowL4Info_TCPUDPInfo `protobuf:"bytes,1,opt,name=TcpUdpInfo,proto3,oneof"`
}
type FlowL4Info_IcmpInfo struct {
	IcmpInfo *FlowL4Info_ICMPInfo `protobuf:"bytes,2,opt,name=IcmpInfo,proto3,oneof"`
}

func (*FlowL4Info_TcpUdpInfo) isFlowL4Info_L4Info() {}
func (*FlowL4Info_IcmpInfo) isFlowL4Info_L4Info()   {}

func (m *FlowL4Info) GetL4Info() isFlowL4Info_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *FlowL4Info) GetTcpUdpInfo() *FlowL4Info_TCPUDPInfo {
	if x, ok := m.GetL4Info().(*FlowL4Info_TcpUdpInfo); ok {
		return x.TcpUdpInfo
	}
	return nil
}

func (m *FlowL4Info) GetIcmpInfo() *FlowL4Info_ICMPInfo {
	if x, ok := m.GetL4Info().(*FlowL4Info_IcmpInfo); ok {
		return x.IcmpInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FlowL4Info) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FlowL4Info_TcpUdpInfo)(nil),
		(*FlowL4Info_IcmpInfo)(nil),
	}
}

// key fields for TCP/UDP flows
type FlowL4Info_TCPUDPInfo struct {
	SrcPort              uint32   `protobuf:"varint,1,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort              uint32   `protobuf:"varint,2,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowL4Info_TCPUDPInfo) Reset()         { *m = FlowL4Info_TCPUDPInfo{} }
func (m *FlowL4Info_TCPUDPInfo) String() string { return proto.CompactTextString(m) }
func (*FlowL4Info_TCPUDPInfo) ProtoMessage()    {}
func (*FlowL4Info_TCPUDPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{25, 0}
}
func (m *FlowL4Info_TCPUDPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowL4Info_TCPUDPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowL4Info_TCPUDPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowL4Info_TCPUDPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowL4Info_TCPUDPInfo.Merge(m, src)
}
func (m *FlowL4Info_TCPUDPInfo) XXX_Size() int {
	return m.Size()
}
func (m *FlowL4Info_TCPUDPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowL4Info_TCPUDPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FlowL4Info_TCPUDPInfo proto.InternalMessageInfo

func (m *FlowL4Info_TCPUDPInfo) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *FlowL4Info_TCPUDPInfo) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// key fields for ICMP flows
type FlowL4Info_ICMPInfo struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Code                 uint32   `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Id                   uint32   `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowL4Info_ICMPInfo) Reset()         { *m = FlowL4Info_ICMPInfo{} }
func (m *FlowL4Info_ICMPInfo) String() string { return proto.CompactTextString(m) }
func (*FlowL4Info_ICMPInfo) ProtoMessage()    {}
func (*FlowL4Info_ICMPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{25, 1}
}
func (m *FlowL4Info_ICMPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowL4Info_ICMPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowL4Info_ICMPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowL4Info_ICMPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowL4Info_ICMPInfo.Merge(m, src)
}
func (m *FlowL4Info_ICMPInfo) XXX_Size() int {
	return m.Size()
}
func (m *FlowL4Info_ICMPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowL4Info_ICMPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FlowL4Info_ICMPInfo proto.InternalMessageInfo

func (m *FlowL4Info_ICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowL4Info_ICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowL4Info_ICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// flow key for IP flows
type IPFlowKey struct {
	// VPC identifier
	VPCId []byte `protobuf:"bytes,1,opt,name=VPCId,proto3" json:"VPCId,omitempty"`
	// source IP seen in the packet
	SrcIP *IPAddress `protobuf:"bytes,2,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	// destination IP seen in the packet
	DstIP *IPAddress `protobuf:"bytes,3,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	// IP protocol
	IPProtocol uint32 `protobuf:"varint,4,opt,name=IPProtocol,proto3" json:"IPProtocol,omitempty"`
	// L4 information of the flow key
	L4Info               *FlowL4Info `protobuf:"bytes,5,opt,name=L4Info,proto3" json:"L4Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IPFlowKey) Reset()         { *m = IPFlowKey{} }
func (m *IPFlowKey) String() string { return proto.CompactTextString(m) }
func (*IPFlowKey) ProtoMessage()    {}
func (*IPFlowKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{26}
}
func (m *IPFlowKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPFlowKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPFlowKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPFlowKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPFlowKey.Merge(m, src)
}
func (m *IPFlowKey) XXX_Size() int {
	return m.Size()
}
func (m *IPFlowKey) XXX_DiscardUnknown() {
	xxx_messageInfo_IPFlowKey.DiscardUnknown(m)
}

var xxx_messageInfo_IPFlowKey proto.InternalMessageInfo

func (m *IPFlowKey) GetVPCId() []byte {
	if m != nil {
		return m.VPCId
	}
	return nil
}

func (m *IPFlowKey) GetSrcIP() *IPAddress {
	if m != nil {
		return m.SrcIP
	}
	return nil
}

func (m *IPFlowKey) GetDstIP() *IPAddress {
	if m != nil {
		return m.DstIP
	}
	return nil
}

func (m *IPFlowKey) GetIPProtocol() uint32 {
	if m != nil {
		return m.IPProtocol
	}
	return 0
}

func (m *IPFlowKey) GetL4Info() *FlowL4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

// flow key is either IP flow key or non-IP flow key
type FlowKey struct {
	// Types that are valid to be assigned to Key:
	//	*FlowKey_IPFlowKey
	//	*FlowKey_MACFlowKey
	Key                  isFlowKey_Key `protobuf_oneof:"key"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FlowKey) Reset()         { *m = FlowKey{} }
func (m *FlowKey) String() string { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()    {}
func (*FlowKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{27}
}
func (m *FlowKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowKey.Merge(m, src)
}
func (m *FlowKey) XXX_Size() int {
	return m.Size()
}
func (m *FlowKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowKey.DiscardUnknown(m)
}

var xxx_messageInfo_FlowKey proto.InternalMessageInfo

type isFlowKey_Key interface {
	isFlowKey_Key()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlowKey_IPFlowKey struct {
	IPFlowKey *IPFlowKey `protobuf:"bytes,1,opt,name=IPFlowKey,proto3,oneof"`
}
type FlowKey_MACFlowKey struct {
	MACFlowKey *MACFlowKey `protobuf:"bytes,2,opt,name=MACFlowKey,proto3,oneof"`
}

func (*FlowKey_IPFlowKey) isFlowKey_Key()  {}
func (*FlowKey_MACFlowKey) isFlowKey_Key() {}

func (m *FlowKey) GetKey() isFlowKey_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FlowKey) GetIPFlowKey() *IPFlowKey {
	if x, ok := m.GetKey().(*FlowKey_IPFlowKey); ok {
		return x.IPFlowKey
	}
	return nil
}

func (m *FlowKey) GetMACFlowKey() *MACFlowKey {
	if x, ok := m.GetKey().(*FlowKey_MACFlowKey); ok {
		return x.MACFlowKey
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FlowKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FlowKey_IPFlowKey)(nil),
		(*FlowKey_MACFlowKey)(nil),
	}
}

// in case of shared services, route/mapping can dictate some rewrites so that
// the service provider can identify the source subnet/VNET and apply
// policies etc. on the receiving end
type SvcRewriteInfo struct {
	// IPv6 prefix to embed the source IP of the packet into
	// NOTE: only IPv6 prefix is supported
	SrcPrefix *IPPrefix `protobuf:"bytes,1,opt,name=SrcPrefix,proto3" json:"SrcPrefix,omitempty" meta:mandatory`
	// IPv6 prefix to embed the destination IP of the packet into
	// NOTE: only IPv6 prefix is supported
	DstPrefix *IPPrefix `protobuf:"bytes,2,opt,name=DstPrefix,proto3" json:"DstPrefix,omitempty" meta:mandatory`
	// DstNatIP is set, if 1:1 destination NAT needs to be done on the inner
	// destination IP address inside encapped packet before embedding into
	// IPv6 DstPrefix
	// NOTTE: DstNatIP must be IPv4 address
	DstNatIP *IPAddress `protobuf:"bytes,3,opt,name=DstNatIP,proto3" json:"DstNatIP,omitempty"`
	// optional service to backend port mapping information (SvcPortMap points
	// to SvcPortMap object configured to capture the such 1:1 port mappings)
	SvcPortMap           []byte   `protobuf:"bytes,4,opt,name=SvcPortMap,proto3" json:"SvcPortMap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SvcRewriteInfo) Reset()         { *m = SvcRewriteInfo{} }
func (m *SvcRewriteInfo) String() string { return proto.CompactTextString(m) }
func (*SvcRewriteInfo) ProtoMessage()    {}
func (*SvcRewriteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{28}
}
func (m *SvcRewriteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SvcRewriteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SvcRewriteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SvcRewriteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SvcRewriteInfo.Merge(m, src)
}
func (m *SvcRewriteInfo) XXX_Size() int {
	return m.Size()
}
func (m *SvcRewriteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SvcRewriteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SvcRewriteInfo proto.InternalMessageInfo

func (m *SvcRewriteInfo) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *SvcRewriteInfo) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *SvcRewriteInfo) GetDstNatIP() *IPAddress {
	if m != nil {
		return m.DstNatIP
	}
	return nil
}

func (m *SvcRewriteInfo) GetSvcPortMap() []byte {
	if m != nil {
		return m.SvcPortMap
	}
	return nil
}

// DropNexthop is used to blackhole the traffic
type DropNexthop struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropNexthop) Reset()         { *m = DropNexthop{} }
func (m *DropNexthop) String() string { return proto.CompactTextString(m) }
func (*DropNexthop) ProtoMessage()    {}
func (*DropNexthop) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{29}
}
func (m *DropNexthop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropNexthop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropNexthop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropNexthop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropNexthop.Merge(m, src)
}
func (m *DropNexthop) XXX_Size() int {
	return m.Size()
}
func (m *DropNexthop) XXX_DiscardUnknown() {
	xxx_messageInfo_DropNexthop.DiscardUnknown(m)
}

var xxx_messageInfo_DropNexthop proto.InternalMessageInfo

// flow logging specific configuration
// NOTE:
// 1. if FlowLogSpec is not configured on device object and PF/host
//    interface and on vnic object, flow logging is disabled by default
// 2. flow logging configuration can be applied at the device level or at
//    more granular level like per PF or a vnic as well (as an override). For
//    a given packet, the most specific configuration (i.e. vnic
//    object) is picked first, then less specific one (i.e., PF or host
//    interface), if not configured on the vnic object and then the least
//    specific one (i.e., device object), if not configured on interface as
//    well; the first flow log configuraiton seen in that order will be
//    picked and applied
// 3. LogOnCreate and LogOnClose are not mutually exclusive, so for a given
//    session flow logs can be generated both at the flow create and flow
//    delete time
type FlowLogSpec struct {
	// if LogOnCreate is set to true, flow log is generated when flow/session
	// is created
	LogOnCreate bool `protobuf:"varint,1,opt,name=LogOnCreate,proto3" json:"LogOnCreate,omitempty" meta:default=false`
	// if LogOnClose is set to true, flow log is generated when flow/session
	// is closed/deleted/purged/aged
	LogOnDelete bool `protobuf:"varint,2,opt,name=LogOnDelete,proto3" json:"LogOnDelete,omitempty" meta:default=false`
	// LogLongLivedFlows, if set, will result in generation of flow logs for
	// sessions that are active and are consisdered as long lived flows; just
	// like flow logs generated during the flow close/delete time carry
	// flow/session statistics, logs generated for long lived flows also carry
	// statistics
	LogLongLivedFlows    bool     `protobuf:"varint,3,opt,name=LogLongLivedFlows,proto3" json:"LogLongLivedFlows,omitempty" meta:default=false`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowLogSpec) Reset()         { *m = FlowLogSpec{} }
func (m *FlowLogSpec) String() string { return proto.CompactTextString(m) }
func (*FlowLogSpec) ProtoMessage()    {}
func (*FlowLogSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{30}
}
func (m *FlowLogSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowLogSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowLogSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowLogSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowLogSpec.Merge(m, src)
}
func (m *FlowLogSpec) XXX_Size() int {
	return m.Size()
}
func (m *FlowLogSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowLogSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FlowLogSpec proto.InternalMessageInfo

func (m *FlowLogSpec) GetLogOnCreate() bool {
	if m != nil {
		return m.LogOnCreate
	}
	return false
}

func (m *FlowLogSpec) GetLogOnDelete() bool {
	if m != nil {
		return m.LogOnDelete
	}
	return false
}

func (m *FlowLogSpec) GetLogLongLivedFlows() bool {
	if m != nil {
		return m.LogLongLivedFlows
	}
	return false
}

// supported types of packets for learning
// NOTE: when all learn sources are set to false, LearnMode must be set to
//       LEARN_MODE_NONE
type LearnSource struct {
	// when ArpLearnEn is set to true, learning will happen from ARP/GARP/RARP
	// traffic
	ArpLearnEn bool `protobuf:"varint,1,opt,name=ArpLearnEn,proto3" json:"ArpLearnEn,omitempty" meta:default=true`
	// when DhcpLearnEn is se to true, learning will happen from DHCP traffic
	DhcpLearnEn bool `protobuf:"varint,2,opt,name=DhcpLearnEn,proto3" json:"DhcpLearnEn,omitempty" meta:default=true`
	// when DataPktLearnEn is set to true, learning will happen from non-protocol
	// data traffic
	DataPktLearnEn       bool     `protobuf:"varint,3,opt,name=DataPktLearnEn,proto3" json:"DataPktLearnEn,omitempty" meta:default=true`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LearnSource) Reset()         { *m = LearnSource{} }
func (m *LearnSource) String() string { return proto.CompactTextString(m) }
func (*LearnSource) ProtoMessage()    {}
func (*LearnSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{31}
}
func (m *LearnSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnSource.Merge(m, src)
}
func (m *LearnSource) XXX_Size() int {
	return m.Size()
}
func (m *LearnSource) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnSource.DiscardUnknown(m)
}

var xxx_messageInfo_LearnSource proto.InternalMessageInfo

func (m *LearnSource) GetArpLearnEn() bool {
	if m != nil {
		return m.ArpLearnEn
	}
	return false
}

func (m *LearnSource) GetDhcpLearnEn() bool {
	if m != nil {
		return m.DhcpLearnEn
	}
	return false
}

func (m *LearnSource) GetDataPktLearnEn() bool {
	if m != nil {
		return m.DataPktLearnEn
	}
	return false
}

// MAC/IP learning related configuration knobs
type LearnSpec struct {
	// NOTE: when LearnMode mode is modified, it will take affect only after
	//       next reboot of DSC
	LearnMode LearnMode `protobuf:"varint,1,opt,name=LearnMode,proto3,enum=types.LearnMode" json:"LearnMode,omitempty" meta:default=LEARN_MODE_NONE`
	// LearnAgeTimeout is the aging timeout (in seconds) for learnt MAC or IP
	// addresses if LearningEn is set to true. If this is not set and learning is
	// enabled, default value is assumed for aging
	LearnAgeTimeout uint32 `protobuf:"varint,2,opt,name=LearnAgeTimeout,proto3" json:"LearnAgeTimeout,omitempty" meta:range:30-86400,meta:default=300`
	// LearnSource captures packet types that can result in MAC/IP learning
	LearnSource          *LearnSource `protobuf:"bytes,3,opt,name=LearnSource,proto3" json:"LearnSource,omitempty" LearnMode!=LEARN_MODE_NONE`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LearnSpec) Reset()         { *m = LearnSpec{} }
func (m *LearnSpec) String() string { return proto.CompactTextString(m) }
func (*LearnSpec) ProtoMessage()    {}
func (*LearnSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{32}
}
func (m *LearnSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LearnSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LearnSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LearnSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LearnSpec.Merge(m, src)
}
func (m *LearnSpec) XXX_Size() int {
	return m.Size()
}
func (m *LearnSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LearnSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LearnSpec proto.InternalMessageInfo

func (m *LearnSpec) GetLearnMode() LearnMode {
	if m != nil {
		return m.LearnMode
	}
	return LearnMode_LEARN_MODE_NONE
}

func (m *LearnSpec) GetLearnAgeTimeout() uint32 {
	if m != nil {
		return m.LearnAgeTimeout
	}
	return 0
}

func (m *LearnSpec) GetLearnSource() *LearnSource {
	if m != nil {
		return m.LearnSource
	}
	return nil
}

// ServiceRequestMessage represents the config message from the app
// and the corresponding operation to be performed
type ServiceRequestMessage struct {
	// one of the CRUD operations
	ConfigOp ServiceRequestOp `protobuf:"varint,1,opt,name=ConfigOp,proto3,enum=types.ServiceRequestOp" json:"ConfigOp,omitempty"`
	// ConfigMsg is protobuf encoded config message and it can be any of the
	// supported config objects (e.g. VPCRequestMsg etc.)
	ConfigMsg            *types.Any `protobuf:"bytes,2,opt,name=ConfigMsg,proto3" json:"ConfigMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ServiceRequestMessage) Reset()         { *m = ServiceRequestMessage{} }
func (m *ServiceRequestMessage) String() string { return proto.CompactTextString(m) }
func (*ServiceRequestMessage) ProtoMessage()    {}
func (*ServiceRequestMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{33}
}
func (m *ServiceRequestMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceRequestMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceRequestMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceRequestMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceRequestMessage.Merge(m, src)
}
func (m *ServiceRequestMessage) XXX_Size() int {
	return m.Size()
}
func (m *ServiceRequestMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceRequestMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceRequestMessage proto.InternalMessageInfo

func (m *ServiceRequestMessage) GetConfigOp() ServiceRequestOp {
	if m != nil {
		return m.ConfigOp
	}
	return ServiceRequestOp_SERVICE_OP_NONE
}

func (m *ServiceRequestMessage) GetConfigMsg() *types.Any {
	if m != nil {
		return m.ConfigMsg
	}
	return nil
}

// ServiceResponseMessage is the response to ServiceRequestMessage
type ServiceResponseMessage struct {
	// response or reply status for the request
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	// content of the response (esp. for Get requests)
	Response             *types.Any `protobuf:"bytes,2,opt,name=Response,proto3" json:"Response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ServiceResponseMessage) Reset()         { *m = ServiceResponseMessage{} }
func (m *ServiceResponseMessage) String() string { return proto.CompactTextString(m) }
func (*ServiceResponseMessage) ProtoMessage()    {}
func (*ServiceResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{34}
}
func (m *ServiceResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceResponseMessage.Merge(m, src)
}
func (m *ServiceResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *ServiceResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceResponseMessage proto.InternalMessageInfo

func (m *ServiceResponseMessage) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ServiceResponseMessage) GetResponse() *types.Any {
	if m != nil {
		return m.Response
	}
	return nil
}

// Counter holding reason and value
type Counter struct {
	// counter name
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// counter value
	Value                uint64   `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}
func (*Counter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{35}
}
func (m *Counter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Counter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Counter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Counter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Counter.Merge(m, src)
}
func (m *Counter) XXX_Size() int {
	return m.Size()
}
func (m *Counter) XXX_DiscardUnknown() {
	xxx_messageInfo_Counter.DiscardUnknown(m)
}

var xxx_messageInfo_Counter proto.InternalMessageInfo

func (m *Counter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Counter) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// BGP standard community
type BGPCommunity struct {
	// first 16-bit of standard community
	Asn uint32 `protobuf:"varint,1,opt,name=Asn,proto3" json:"Asn,omitempty" meta:range:0-65535,meta:default=0`
	// second 16-bit of standard community
	Community            uint32   `protobuf:"varint,2,opt,name=Community,proto3" json:"Community,omitempty" meta:range:0-65535,meta:default=0`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BGPCommunity) Reset()         { *m = BGPCommunity{} }
func (m *BGPCommunity) String() string { return proto.CompactTextString(m) }
func (*BGPCommunity) ProtoMessage()    {}
func (*BGPCommunity) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{36}
}
func (m *BGPCommunity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPCommunity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BGPCommunity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BGPCommunity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPCommunity.Merge(m, src)
}
func (m *BGPCommunity) XXX_Size() int {
	return m.Size()
}
func (m *BGPCommunity) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPCommunity.DiscardUnknown(m)
}

var xxx_messageInfo_BGPCommunity proto.InternalMessageInfo

func (m *BGPCommunity) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BGPCommunity) GetCommunity() uint32 {
	if m != nil {
		return m.Community
	}
	return 0
}

func init() {
	proto.RegisterEnum("types.ApiStatus", ApiStatus_name, ApiStatus_value)
	proto.RegisterEnum("types.AsicType", AsicType_name, AsicType_value)
	proto.RegisterEnum("types.IPAF", IPAF_name, IPAF_value)
	proto.RegisterEnum("types.WildcardMatch", WildcardMatch_name, WildcardMatch_value)
	proto.RegisterEnum("types.RuleDir", RuleDir_name, RuleDir_value)
	proto.RegisterEnum("types.EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("types.LifType", LifType_name, LifType_value)
	proto.RegisterEnum("types.SecurityRuleAction", SecurityRuleAction_name, SecurityRuleAction_value)
	proto.RegisterEnum("types.FwPolicyXposn", FwPolicyXposn_name, FwPolicyXposn_value)
	proto.RegisterEnum("types.NatAction", NatAction_name, NatAction_value)
	proto.RegisterEnum("types.MeterClass", MeterClass_name, MeterClass_value)
	proto.RegisterEnum("types.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("types.AdminState", AdminState_name, AdminState_value)
	proto.RegisterEnum("types.RouteType", RouteType_name, RouteType_value)
	proto.RegisterEnum("types.RouteProtocol", RouteProtocol_name, RouteProtocol_value)
	proto.RegisterEnum("types.PortSpeed", PortSpeed_name, PortSpeed_value)
	proto.RegisterEnum("types.LearnMode", LearnMode_name, LearnMode_value)
	proto.RegisterEnum("types.ServiceRequestOp", ServiceRequestOp_name, ServiceRequestOp_value)
	proto.RegisterType((*Empty)(nil), "types.Empty")
	proto.RegisterType((*Id)(nil), "types.Id")
	proto.RegisterType((*IPAddress)(nil), "types.IPAddress")
	proto.RegisterType((*IPPrefix)(nil), "types.IPPrefix")
	proto.RegisterType((*IPRange)(nil), "types.IPRange")
	proto.RegisterType((*IPEntry)(nil), "types.IPEntry")
	proto.RegisterType((*IPList)(nil), "types.IPList")
	proto.RegisterType((*IPv4Prefix)(nil), "types.IPv4Prefix")
	proto.RegisterType((*IPv6Prefix)(nil), "types.IPv6Prefix")
	proto.RegisterType((*IPSubnet)(nil), "types.IPSubnet")
	proto.RegisterType((*AddressRange)(nil), "types.AddressRange")
	proto.RegisterType((*Address)(nil), "types.Address")
	proto.RegisterType((*PortRange)(nil), "types.PortRange")
	proto.RegisterType((*RuleL3Match)(nil), "types.RuleL3Match")
	proto.RegisterType((*PortMatch)(nil), "types.PortMatch")
	proto.RegisterType((*ICMPMatch)(nil), "types.ICMPMatch")
	proto.RegisterType((*PortListMatch)(nil), "types.PortListMatch")
	proto.RegisterType((*ICMPMatchList)(nil), "types.ICMPMatchList")
	proto.RegisterType((*RuleL4Match)(nil), "types.RuleL4Match")
	proto.RegisterType((*RuleMatch)(nil), "types.RuleMatch")
	proto.RegisterType((*QinQ)(nil), "types.QinQ")
	proto.RegisterType((*EncapVal)(nil), "types.EncapVal")
	proto.RegisterType((*Encap)(nil), "types.Encap")
	proto.RegisterType((*BatchCtxt)(nil), "types.BatchCtxt")
	proto.RegisterType((*MACFlowKey)(nil), "types.MACFlowKey")
	proto.RegisterType((*FlowL4Info)(nil), "types.FlowL4Info")
	proto.RegisterType((*FlowL4Info_TCPUDPInfo)(nil), "types.FlowL4Info.TCPUDPInfo")
	proto.RegisterType((*FlowL4Info_ICMPInfo)(nil), "types.FlowL4Info.ICMPInfo")
	proto.RegisterType((*IPFlowKey)(nil), "types.IPFlowKey")
	proto.RegisterType((*FlowKey)(nil), "types.FlowKey")
	proto.RegisterType((*SvcRewriteInfo)(nil), "types.SvcRewriteInfo")
	proto.RegisterType((*DropNexthop)(nil), "types.DropNexthop")
	proto.RegisterType((*FlowLogSpec)(nil), "types.FlowLogSpec")
	proto.RegisterType((*LearnSource)(nil), "types.LearnSource")
	proto.RegisterType((*LearnSpec)(nil), "types.LearnSpec")
	proto.RegisterType((*ServiceRequestMessage)(nil), "types.ServiceRequestMessage")
	proto.RegisterType((*ServiceResponseMessage)(nil), "types.ServiceResponseMessage")
	proto.RegisterType((*Counter)(nil), "types.Counter")
	proto.RegisterType((*BGPCommunity)(nil), "types.BGPCommunity")
}

func init() { proto.RegisterFile("types.proto", fileDescriptor_d938547f84707355) }

var fileDescriptor_d938547f84707355 = []byte{
	// 2956 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5f, 0x73, 0xdb, 0x56,
	0x76, 0x17, 0x40, 0x52, 0x24, 0x0f, 0x45, 0xf9, 0xea, 0x5a, 0x76, 0x14, 0x8d, 0x6b, 0xd9, 0x68,
	0x9c, 0x71, 0xd9, 0x58, 0xa6, 0xf5, 0xcf, 0x6e, 0xa6, 0xe9, 0x14, 0x24, 0x20, 0x0a, 0x0d, 0x48,
	0xc0, 0x17, 0x90, 0x6c, 0xf5, 0x85, 0xc3, 0x90, 0x10, 0xcd, 0x09, 0x45, 0x30, 0x04, 0x24, 0x47,
	0x69, 0x1f, 0x92, 0xa7, 0xbe, 0xf4, 0xa1, 0x33, 0x9d, 0x69, 0xbf, 0x49, 0x9f, 0xfa, 0xba, 0xb3,
	0xbb, 0x6f, 0xfb, 0x09, 0x34, 0x3b, 0xd9, 0x7d, 0xd9, 0xd9, 0x37, 0x7d, 0x82, 0x9d, 0xfb, 0x07,
	0x20, 0x00, 0x49, 0xde, 0x24, 0x2f, 0x12, 0xee, 0xef, 0xfc, 0xce, 0x9f, 0x7b, 0xee, 0xb9, 0x07,
	0x07, 0x84, 0x4a, 0x78, 0x31, 0xf5, 0x82, 0xcd, 0xe9, 0xcc, 0x0f, 0x7d, 0x5c, 0x60, 0x8b, 0x75,
	0x18, 0xfa, 0x43, 0x9f, 0x43, 0xeb, 0x1f, 0x0f, 0x7d, 0x7f, 0x38, 0xf6, 0x9e, 0xb3, 0xd5, 0x57,
	0x67, 0x27, 0xcf, 0x7b, 0x93, 0x0b, 0x2e, 0x52, 0x8a, 0x50, 0xd0, 0x4f, 0xa7, 0xe1, 0x85, 0xb2,
	0x0a, 0xb2, 0x31, 0xc0, 0xcb, 0xf4, 0xef, 0x9a, 0xf4, 0x48, 0x7a, 0xba, 0x44, 0x64, 0x63, 0xa0,
	0xfc, 0x3b, 0x94, 0x0d, 0x5b, 0x1d, 0x0c, 0x66, 0x5e, 0x10, 0xe0, 0xe7, 0x20, 0xab, 0x27, 0x4c,
	0xb8, 0xbc, 0x55, 0xd9, 0xe4, 0x3e, 0x0d, 0x5b, 0xdd, 0x6f, 0xe0, 0xab, 0xcb, 0x8d, 0xe5, 0x53,
	0x2f, 0xec, 0x7d, 0x7e, 0xda, 0x9b, 0x0c, 0x7a, 0xa1, 0x3f, 0xbb, 0x20, 0xb2, 0x7a, 0x82, 0xd7,
	0x60, 0xf1, 0x68, 0x87, 0x6a, 0xaf, 0xc9, 0x8f, 0xa4, 0xa7, 0xc5, 0x83, 0x05, 0x22, 0xd6, 0x4c,
	0xb2, 0xc7, 0x24, 0x39, 0xea, 0x8b, 0x49, 0xd8, 0xba, 0x01, 0x50, 0x3a, 0xdf, 0xe9, 0xfa, 0xb3,
	0xee, 0xf9, 0x9e, 0xf2, 0x16, 0x4a, 0x86, 0x6d, 0xcf, 0xbc, 0x93, 0xd1, 0xb7, 0xf8, 0x13, 0xc8,
	0x33, 0x3e, 0x75, 0x5f, 0xd9, 0x42, 0x73, 0xf7, 0x3c, 0x38, 0xc2, 0xa4, 0xf8, 0x53, 0xc8, 0x99,
	0xde, 0x84, 0xb9, 0xab, 0x36, 0x56, 0xaf, 0x2e, 0x37, 0x10, 0x0b, 0x6b, 0xd6, 0x9b, 0x0c, 0xbd,
	0x2f, 0xea, 0xcf, 0x5e, 0x6c, 0xbd, 0x22, 0x94, 0xa0, 0x38, 0x50, 0x34, 0x6c, 0x42, 0x51, 0xac,
	0x40, 0xce, 0xf4, 0xdf, 0xdf, 0x6a, 0x97, 0x0a, 0xa9, 0xf3, 0x83, 0xd1, 0xf0, 0x1d, 0xb3, 0x7b,
	0xa3, 0x73, 0x2a, 0x55, 0x7e, 0x90, 0xa8, 0x55, 0x7d, 0x12, 0xce, 0x2e, 0xf0, 0xdf, 0xc1, 0x22,
	0x0f, 0x5c, 0x18, 0xbe, 0x13, 0xeb, 0x70, 0x98, 0xee, 0x58, 0xec, 0xec, 0xef, 0xa1, 0xc0, 0x22,
	0x11, 0xd6, 0xef, 0x0a, 0x66, 0x64, 0x9b, 0x8a, 0x0e, 0x16, 0x08, 0xe7, 0x60, 0x0c, 0x39, 0xb7,
	0x37, 0x64, 0x59, 0xab, 0x1e, 0x2c, 0x10, 0xba, 0xa0, 0x29, 0x1b, 0x4d, 0xbb, 0x1e, 0xf5, 0xab,
	0x6c, 0xc1, 0xa2, 0x61, 0x9b, 0xa3, 0x20, 0xc4, 0x4f, 0xe3, 0x60, 0xd6, 0xa4, 0x47, 0xb9, 0xa7,
	0x95, 0xad, 0xe5, 0x38, 0x04, 0x86, 0x92, 0x48, 0xac, 0xb4, 0x00, 0x0c, 0xfb, 0x7c, 0x47, 0x84,
	0x83, 0x13, 0x89, 0x2e, 0x8a, 0xb4, 0x3e, 0x49, 0xa6, 0xf5, 0xee, 0xd5, 0xe5, 0xc6, 0x9d, 0x54,
	0x5a, 0xb7, 0xb7, 0x78, 0x56, 0x0f, 0x98, 0xa1, 0xbd, 0x1b, 0x0c, 0x2d, 0xfd, 0xcc, 0xf3, 0xf9,
	0x8e, 0x9e, 0xbc, 0x73, 0xf6, 0xd5, 0xc4, 0x0b, 0xf1, 0x0b, 0x1e, 0x1e, 0x5f, 0xdd, 0x9e, 0xce,
	0x04, 0x49, 0xa8, 0xec, 0x09, 0x15, 0xf9, 0x43, 0x2a, 0x82, 0xd4, 0x28, 0xc1, 0x62, 0xc0, 0x9e,
	0x94, 0xf7, 0xb0, 0x94, 0xcc, 0x3d, 0xde, 0xa4, 0x77, 0xe0, 0x7c, 0x87, 0x9f, 0x11, 0x77, 0x3f,
	0x4f, 0x65, 0x74, 0x3c, 0x73, 0x8a, 0xe0, 0xef, 0x25, 0xcf, 0xf4, 0x66, 0x3e, 0xa7, 0x34, 0x8a,
	0x50, 0x60, 0xfb, 0x57, 0xc6, 0x50, 0x8c, 0xae, 0xda, 0xed, 0xe5, 0xc3, 0xc3, 0xfd, 0x85, 0xe5,
	0xd3, 0x28, 0x43, 0xb1, 0xc7, 0x05, 0xca, 0x37, 0x50, 0xb6, 0xfd, 0x59, 0xc8, 0x63, 0xae, 0x43,
	0x91, 0x2e, 0xa2, 0x8b, 0x50, 0x6d, 0xdc, 0xbf, 0xba, 0xdc, 0xc0, 0xf3, 0xb3, 0xf9, 0xbc, 0xfe,
	0x6c, 0x6f, 0x77, 0x77, 0x7b, 0x97, 0x44, 0x34, 0xbc, 0x05, 0x25, 0xfa, 0x18, 0x5f, 0x8b, 0xdb,
	0x55, 0x62, 0x9e, 0xf2, 0xa7, 0x1c, 0x54, 0xc8, 0xd9, 0xd8, 0x33, 0xb7, 0xdb, 0xbd, 0xb0, 0xff,
	0x0e, 0x3f, 0x80, 0x92, 0x4d, 0xbb, 0x50, 0xe7, 0xec, 0x94, 0xbb, 0x3d, 0x58, 0x20, 0x31, 0x82,
	0xff, 0x11, 0xaa, 0xec, 0xf9, 0xcd, 0x68, 0x3c, 0xe8, 0xf7, 0x66, 0x03, 0xe6, 0x66, 0x79, 0x6b,
	0x55, 0x6c, 0x30, 0x82, 0x99, 0xa9, 0x83, 0x05, 0x92, 0x26, 0xe3, 0xe7, 0x50, 0x76, 0x66, 0x7d,
	0x91, 0xc4, 0xdc, 0xcd, 0x15, 0x20, 0x91, 0x39, 0x07, 0xbf, 0x80, 0x92, 0x33, 0xeb, 0xf3, 0x54,
	0xe6, 0x6f, 0x4f, 0xa5, 0x44, 0x62, 0x1a, 0xed, 0x62, 0xce, 0xac, 0x4f, 0xef, 0x63, 0x81, 0x45,
	0x2f, 0x11, 0xb1, 0xc6, 0xcf, 0x98, 0x77, 0x7e, 0x13, 0xd7, 0x16, 0x99, 0xb5, 0x6a, 0xec, 0x9d,
	0x82, 0xc2, 0xb7, 0xb8, 0xab, 0xcf, 0xa1, 0xac, 0x05, 0xa1, 0x08, 0xb6, 0x78, 0x73, 0xb0, 0x32,
	0x99, 0x73, 0x68, 0xb0, 0x5a, 0xc0, 0xcf, 0x6e, 0xad, 0x74, 0x7b, 0xb0, 0x32, 0x89, 0x69, 0x34,
	0x58, 0x2d, 0x08, 0x69, 0xb0, 0x65, 0x16, 0xac, 0x4c, 0xc4, 0x9a, 0x06, 0xab, 0x05, 0xa1, 0x08,
	0x16, 0x6e, 0x0a, 0x96, 0xfb, 0xe6, 0x8b, 0xc6, 0x12, 0x00, 0x7b, 0x77, 0x9c, 0xd2, 0xc4, 0xd3,
	0xe6, 0x13, 0xcc, 0xfa, 0xf1, 0xf3, 0x20, 0x08, 0xd9, 0xb3, 0xf2, 0x9e, 0x97, 0x17, 0x3f, 0xe8,
	0x1d, 0x58, 0xa2, 0x89, 0x8e, 0xca, 0x2d, 0xd3, 0x6c, 0x63, 0x9c, 0xa4, 0x58, 0x54, 0x8b, 0xee,
	0x38, 0xd6, 0x92, 0x6f, 0xd3, 0x4a, 0xb2, 0x94, 0xdf, 0x4a, 0x50, 0x36, 0x9a, 0x6d, 0x9b, 0x7b,
	0x5e, 0x85, 0xbc, 0x7b, 0x31, 0xf5, 0xe2, 0xf2, 0x62, 0x2b, 0xfc, 0x39, 0x2c, 0xd1, 0xff, 0x3f,
	0xb1, 0xb2, 0x52, 0x5c, 0x6a, 0xb1, 0xe9, 0x0f, 0x3c, 0xd1, 0x82, 0x25, 0xc2, 0x56, 0xd4, 0x22,
	0xfd, 0x1f, 0x5b, 0xcc, 0x7f, 0xc0, 0xa2, 0x44, 0x52, 0xdc, 0x46, 0x05, 0xca, 0x94, 0xc6, 0x73,
	0x58, 0x81, 0x72, 0xdf, 0x1f, 0xf0, 0x85, 0xf2, 0x6f, 0x50, 0x65, 0xf7, 0x6d, 0x14, 0xdc, 0x9a,
	0xc8, 0xdc, 0x2f, 0x4a, 0x64, 0xee, 0x27, 0x24, 0xb2, 0x05, 0xd5, 0x38, 0x8f, 0xac, 0x4a, 0xf7,
	0x32, 0x40, 0xc6, 0x7b, 0x2c, 0x23, 0x69, 0x9a, 0xf2, 0x07, 0x49, 0x5c, 0xfb, 0x1d, 0xbe, 0x89,
	0xa7, 0x50, 0xa0, 0x5e, 0x82, 0x1b, 0xca, 0x20, 0x4a, 0x39, 0x27, 0xe0, 0x4d, 0x28, 0xd1, 0xdc,
	0xb3, 0x7c, 0x67, 0xde, 0xbd, 0x91, 0x07, 0xda, 0x32, 0x22, 0x4e, 0xd4, 0x94, 0x58, 0x70, 0xfc,
	0xce, 0xaf, 0x26, 0x8c, 0xc7, 0x69, 0x64, 0x6d, 0x46, 0x00, 0xb4, 0xcd, 0xa4, 0x77, 0x95, 0x4f,
	0x29, 0xa6, 0x64, 0xb4, 0xcd, 0xa4, 0x00, 0xfa, 0xda, 0x18, 0xef, 0x8c, 0x26, 0x27, 0xbe, 0x32,
	0x84, 0x32, 0xdd, 0x24, 0xdf, 0xe2, 0x67, 0x50, 0x14, 0x4d, 0x4e, 0x6c, 0x12, 0x0b, 0x73, 0x89,
	0xf6, 0x47, 0x22, 0x0a, 0x63, 0xf3, 0xdc, 0x88, 0x5d, 0xa6, 0xd8, 0x3b, 0x11, 0x9b, 0x3f, 0x28,
	0x47, 0x90, 0x7f, 0x3d, 0x9a, 0xbc, 0xc6, 0x9f, 0x42, 0xde, 0xa1, 0xd7, 0x99, 0x37, 0xec, 0x9b,
	0x66, 0x30, 0x26, 0xa7, 0xbc, 0x26, 0xe5, 0xc9, 0xb7, 0xf3, 0xa8, 0x5c, 0xf9, 0x1f, 0x09, 0x4a,
	0xfa, 0xa4, 0xdf, 0x9b, 0x1e, 0xf5, 0xc6, 0x6c, 0x40, 0x1b, 0xf7, 0x26, 0x62, 0x18, 0xac, 0xb2,
	0x01, 0x8d, 0xad, 0xf1, 0x3a, 0x14, 0xdb, 0xb6, 0xe9, 0xc4, 0x16, 0x0f, 0x16, 0x48, 0x04, 0xd0,
	0xbb, 0x71, 0x34, 0x19, 0x0d, 0xe2, 0xf1, 0x84, 0xad, 0xf0, 0x63, 0x1e, 0xb0, 0x48, 0x6c, 0x34,
	0x39, 0x52, 0x88, 0x52, 0xd8, 0x5e, 0xa8, 0x62, 0x30, 0x1a, 0x88, 0x3e, 0x4a, 0x15, 0x83, 0xd1,
	0xa0, 0x51, 0x80, 0xdc, 0x79, 0x6f, 0xac, 0xb8, 0x50, 0x60, 0x71, 0xd1, 0x31, 0x2c, 0xbe, 0xcc,
	0xcb, 0x71, 0x29, 0x30, 0x19, 0xc5, 0xc5, 0xe5, 0x7e, 0x02, 0x85, 0xa3, 0xde, 0xf8, 0xcc, 0xcb,
	0xbc, 0xf7, 0xa3, 0xad, 0x11, 0x2e, 0x55, 0x9e, 0x41, 0xb9, 0x41, 0xf3, 0xd9, 0x0c, 0xbf, 0x0d,
	0xf1, 0x23, 0xa8, 0xf0, 0x85, 0xef, 0x7f, 0x3d, 0xe2, 0x0e, 0xf2, 0x24, 0x09, 0x29, 0x33, 0x80,
	0xb6, 0xda, 0xdc, 0x1f, 0xfb, 0xef, 0xbf, 0xf4, 0x2e, 0xf0, 0x7d, 0x58, 0x4c, 0xcc, 0x23, 0x4b,
	0x44, 0xac, 0x18, 0x3e, 0xeb, 0xb7, 0xd5, 0x26, 0x73, 0x9e, 0x27, 0x62, 0x45, 0x71, 0x2d, 0x08,
	0x29, 0x9e, 0xe3, 0x38, 0x5f, 0xe1, 0x07, 0x50, 0xd6, 0xc3, 0x77, 0xde, 0x8c, 0x6d, 0x8b, 0xe6,
	0xa7, 0x4a, 0xe6, 0x80, 0xf2, 0xbf, 0x32, 0x00, 0xf5, 0x68, 0xee, 0x18, 0x93, 0x13, 0x1f, 0xff,
	0x13, 0x80, 0xdb, 0x9f, 0x1e, 0x0e, 0xa6, 0x74, 0x25, 0xea, 0xea, 0x81, 0xd8, 0xdd, 0x9c, 0xb6,
	0xe9, 0x36, 0xed, 0x43, 0xcd, 0xa6, 0x8f, 0x74, 0xc4, 0x99, 0x6b, 0xe0, 0x57, 0x50, 0x32, 0xfa,
	0xa7, 0x5c, 0x9b, 0xe7, 0x66, 0xfd, 0xba, 0x36, 0x2d, 0x6f, 0xa1, 0x1b, 0xb3, 0xd7, 0xff, 0x19,
	0x60, 0x6e, 0x15, 0xaf, 0x41, 0x51, 0xb4, 0x17, 0x5e, 0x1c, 0x24, 0x5a, 0x52, 0x89, 0x68, 0x21,
	0xbc, 0x36, 0x48, 0xb4, 0x5c, 0x6f, 0x40, 0x29, 0xb2, 0x4c, 0x07, 0xc3, 0x79, 0x4f, 0x16, 0x87,
	0x86, 0x45, 0x57, 0xe5, 0x6a, 0xbc, 0xa7, 0xf2, 0x8f, 0x11, 0x56, 0x4b, 0xf4, 0x63, 0x84, 0x0e,
	0x2f, 0xe3, 0x9d, 0x2e, 0xbb, 0x6c, 0xff, 0x4f, 0x9b, 0xbc, 0x1d, 0x9d, 0xc6, 0x2a, 0x14, 0x8e,
	0xec, 0x66, 0xfc, 0xe1, 0xc2, 0x17, 0xf8, 0x53, 0x28, 0xb0, 0x37, 0xec, 0xad, 0x53, 0x3b, 0x17,
	0x53, 0x1e, 0x7b, 0xb9, 0x89, 0x8e, 0x71, 0x03, 0x8f, 0x89, 0xf1, 0x43, 0x3a, 0x54, 0xb2, 0x21,
	0xa3, 0xef, 0x8f, 0xc5, 0x61, 0x25, 0x10, 0x3a, 0xb3, 0xf1, 0x1c, 0xb2, 0x2a, 0xae, 0x6c, 0xad,
	0x5c, 0x4b, 0x2e, 0x11, 0x04, 0xe5, 0x3d, 0x14, 0xa3, 0xd8, 0xeb, 0x89, 0x8d, 0x5c, 0xfb, 0x08,
	0x11, 0x38, 0x9f, 0x17, 0x23, 0x8d, 0xed, 0x64, 0x25, 0x8a, 0xcd, 0x45, 0xbe, 0xe6, 0x02, 0x7a,
	0xf6, 0xf3, 0x15, 0xbd, 0x4a, 0x5f, 0x7b, 0x17, 0xca, 0x1f, 0x25, 0x58, 0x76, 0xce, 0xfb, 0xc4,
	0x7b, 0x3f, 0x1b, 0x85, 0x1e, 0x3b, 0x0d, 0x35, 0x39, 0x28, 0xdd, 0x3c, 0x5d, 0xdf, 0xd8, 0x34,
	0x12, 0xa3, 0x93, 0x9a, 0x1c, 0x5f, 0xe4, 0x9f, 0x61, 0x62, 0x3e, 0xd0, 0x7c, 0xc6, 0x06, 0x9a,
	0x4e, 0xef, 0x43, 0xe7, 0x10, 0x33, 0xe8, 0x51, 0x38, 0xe7, 0x7d, 0xfe, 0xc2, 0x98, 0xb2, 0xa3,
	0x58, 0x22, 0x09, 0x44, 0xa9, 0x42, 0x45, 0x9b, 0xf9, 0xd3, 0x8e, 0xf7, 0x6d, 0xf8, 0xce, 0x9f,
	0x2a, 0xbf, 0x96, 0xa0, 0xc2, 0x4e, 0xc1, 0x1f, 0x3a, 0x53, 0xaf, 0x8f, 0x5f, 0x41, 0xc5, 0xf4,
	0x87, 0xd6, 0xa4, 0x39, 0xf3, 0x7a, 0x21, 0xaf, 0xc3, 0x52, 0x62, 0x7c, 0x1d, 0x78, 0x27, 0xbd,
	0xb3, 0x71, 0xf8, 0xc5, 0x49, 0x6f, 0x1c, 0x78, 0x24, 0x49, 0x8d, 0x35, 0x35, 0x6f, 0xec, 0x85,
	0xbc, 0x5a, 0xff, 0x9a, 0x26, 0xa7, 0x62, 0x0d, 0x56, 0x4c, 0x7f, 0x68, 0xfa, 0x93, 0xa1, 0x39,
	0x3a, 0xf7, 0x06, 0x34, 0x9c, 0x80, 0xed, 0xf4, 0x76, 0xfd, 0xeb, 0x0a, 0xb4, 0xee, 0x2b, 0xa6,
	0xd7, 0x9b, 0x4d, 0x1c, 0xff, 0x6c, 0xd6, 0xf7, 0xf0, 0x2e, 0x80, 0x3a, 0x9b, 0x32, 0x44, 0x9f,
	0x88, 0x8d, 0xdc, 0xbb, 0xba, 0xdc, 0x58, 0x49, 0x99, 0x0b, 0x67, 0x67, 0x1e, 0x49, 0x10, 0xf1,
	0x4b, 0xa8, 0x68, 0xef, 0xfa, 0xb1, 0x9e, 0xfc, 0x21, 0xbd, 0x24, 0x13, 0x7f, 0x01, 0xcb, 0x5a,
	0x2f, 0xec, 0xd9, 0x5f, 0x87, 0x91, 0x6e, 0xee, 0x43, 0xba, 0x19, 0xb2, 0xf2, 0x1f, 0x32, 0x94,
	0x79, 0xf8, 0xf4, 0x18, 0x6c, 0xb1, 0x68, 0xd3, 0x8b, 0x9f, 0xee, 0xe9, 0x31, 0xde, 0x78, 0x74,
	0x75, 0xb9, 0xf1, 0x20, 0x65, 0xd9, 0xd4, 0x55, 0xd2, 0xe9, 0xb6, 0x2d, 0x4d, 0xef, 0x76, 0xac,
	0x8e, 0x4e, 0xe6, 0x46, 0x30, 0x81, 0x3b, 0x6c, 0xa1, 0x0e, 0x3d, 0x77, 0x74, 0xea, 0xf9, 0x67,
	0xa2, 0x0f, 0x35, 0x9e, 0x5e, 0x5d, 0x6e, 0x7c, 0x92, 0xf8, 0x36, 0xd9, 0xae, 0x3f, 0x7b, 0xb5,
	0xb7, 0x53, 0xaf, 0x7f, 0x96, 0xb2, 0xbc, 0x5d, 0xaf, 0x93, 0xac, 0x01, 0xec, 0xa6, 0x32, 0x2e,
	0x8a, 0x13, 0x27, 0xe3, 0xe4, 0x92, 0xc6, 0xc3, 0xab, 0xcb, 0x8d, 0xf5, 0x38, 0x96, 0xc7, 0xd7,
	0xe2, 0x4c, 0x9a, 0x51, 0xbe, 0x97, 0xe0, 0x9e, 0xe3, 0xcd, 0xce, 0x47, 0x7d, 0x8f, 0x78, 0xdf,
	0x9c, 0x79, 0x41, 0xd8, 0xf6, 0x82, 0xa0, 0x37, 0xf4, 0xf0, 0x36, 0x94, 0x9a, 0xfe, 0xe4, 0x64,
	0x34, 0xb4, 0xa6, 0x22, 0x29, 0x1f, 0x09, 0x67, 0x69, 0xbe, 0x35, 0x25, 0x31, 0x11, 0x6f, 0x41,
	0x99, 0x3f, 0xb7, 0x83, 0xa1, 0xb8, 0x81, 0xab, 0x9b, 0xfc, 0x57, 0x9f, 0xcd, 0xe8, 0x57, 0x9f,
	0x4d, 0x75, 0x72, 0x41, 0xe6, 0x34, 0xe5, 0x3b, 0xb8, 0x1f, 0x5b, 0x0c, 0xa6, 0xfe, 0x24, 0xf0,
	0xa2, 0x10, 0x36, 0xa1, 0xac, 0x4e, 0x47, 0x4e, 0xd8, 0x0b, 0xcf, 0x82, 0xcc, 0xc1, 0xc4, 0x38,
	0x99, 0x53, 0x70, 0x1d, 0x4a, 0x91, 0x89, 0x0f, 0x3a, 0x8f, 0x59, 0xca, 0x36, 0x14, 0x9b, 0xfe,
	0xd9, 0x24, 0xf4, 0x66, 0xb4, 0xf3, 0x77, 0x7a, 0xa7, 0xbc, 0x00, 0xca, 0x84, 0x3d, 0xb3, 0x86,
	0x1e, 0xbf, 0xc2, 0xf3, 0xd1, 0x1b, 0xfb, 0x3f, 0x25, 0x58, 0x6a, 0xb4, 0xec, 0xa6, 0x7f, 0x7a,
	0x7a, 0x36, 0x19, 0x85, 0x17, 0xf8, 0x25, 0xe4, 0xd4, 0x60, 0x22, 0x06, 0xa0, 0x27, 0x57, 0x97,
	0x1b, 0x8f, 0xaf, 0x7f, 0x7e, 0xa6, 0x4f, 0xb8, 0x4e, 0xa8, 0x06, 0x6e, 0xd2, 0x74, 0x09, 0x2b,
	0xa2, 0x42, 0x7e, 0xa2, 0xfa, 0x5c, 0xaf, 0xf6, 0x7f, 0x72, 0x22, 0x4d, 0x78, 0x05, 0xaa, 0xaa,
	0x6d, 0x74, 0x1d, 0x57, 0x75, 0x0f, 0x9d, 0xae, 0xf5, 0x25, 0x5a, 0xc0, 0x18, 0x96, 0x13, 0x90,
	0x4e, 0x08, 0x92, 0xf0, 0x3a, 0xdc, 0x4f, 0x60, 0x46, 0xe7, 0x48, 0x35, 0x0d, 0xad, 0xab, 0x92,
	0x16, 0x92, 0xf1, 0xdf, 0xc0, 0xc7, 0x49, 0xfe, 0x5b, 0xc3, 0x71, 0x9d, 0xae, 0x6a, 0x12, 0x5d,
	0xd5, 0x8e, 0x51, 0x0e, 0x7f, 0x0c, 0xf7, 0x92, 0x1e, 0x0e, 0xdd, 0xae, 0xb5, 0xdf, 0x6d, 0xeb,
	0x6d, 0x94, 0xc7, 0x6b, 0xb0, 0x9a, 0x10, 0x75, 0x2c, 0xb7, 0xbb, 0x6f, 0x1d, 0x76, 0x34, 0x54,
	0xc0, 0x0f, 0x61, 0xfd, 0xba, 0x12, 0xd1, 0x1d, 0xeb, 0x90, 0x34, 0x75, 0xb4, 0x88, 0x57, 0x01,
	0x25, 0xe4, 0x44, 0x77, 0xc9, 0x31, 0x2a, 0xe2, 0x4f, 0xe0, 0x51, 0x52, 0xcb, 0xd6, 0x89, 0xea,
	0x1a, 0x56, 0x87, 0x59, 0x56, 0x4d, 0xd3, 0x7a, 0xa3, 0x6b, 0xa8, 0x84, 0xef, 0x03, 0x4e, 0xb0,
	0x5c, 0xa3, 0xad, 0x5b, 0x87, 0x2e, 0x2a, 0x67, 0x7c, 0x1e, 0xbc, 0xe9, 0xea, 0x1d, 0x97, 0x1c,
	0x8b, 0x0d, 0x21, 0xa8, 0xb5, 0xa0, 0xa4, 0x06, 0xa3, 0xbe, 0x78, 0xef, 0x2f, 0xab, 0x8e, 0xd1,
	0xec, 0xba, 0xc7, 0x36, 0xbf, 0x26, 0x68, 0x01, 0xdf, 0x85, 0x3b, 0x73, 0xac, 0xa9, 0xda, 0xc4,
	0x40, 0x52, 0x9a, 0xa8, 0x9b, 0x0d, 0x15, 0xc9, 0xb5, 0x97, 0x90, 0x37, 0x6c, 0x75, 0x1f, 0x2f,
	0xd3, 0x37, 0x73, 0x57, 0xdd, 0x8f, 0x0c, 0xc4, 0x6b, 0xa3, 0xa3, 0xbb, 0x48, 0xc2, 0x77, 0xa0,
	0x32, 0x5f, 0xef, 0x21, 0xb9, 0xf6, 0x1c, 0xaa, 0xa9, 0x4f, 0x32, 0xaa, 0xd1, 0x56, 0xdd, 0xe6,
	0xc1, 0xdc, 0x42, 0x99, 0xaf, 0xd5, 0xce, 0x31, 0xfa, 0x5e, 0xae, 0xb5, 0xa0, 0x48, 0x67, 0x71,
	0x6d, 0x34, 0xa3, 0x07, 0x4d, 0x0e, 0x4d, 0xbd, 0xab, 0x19, 0x24, 0x62, 0xaf, 0x02, 0x8a, 0x21,
	0xa3, 0xd3, 0x22, 0xba, 0xe3, 0x20, 0x89, 0x6e, 0x23, 0x46, 0x75, 0x0e, 0xca, 0xb5, 0xff, 0x92,
	0xa0, 0x1c, 0x0f, 0xac, 0x94, 0xa2, 0x77, 0x9a, 0xaa, 0x9d, 0xda, 0xfe, 0x2a, 0xa0, 0x04, 0xa8,
	0x59, 0xee, 0x8b, 0xd7, 0xdc, 0x5a, 0x02, 0x7d, 0x6d, 0x74, 0x5e, 0x23, 0x19, 0x7f, 0x04, 0x77,
	0x13, 0x20, 0x9d, 0xc2, 0xfd, 0x43, 0xcd, 0x46, 0xb9, 0x8c, 0x8d, 0xa3, 0xb7, 0xa6, 0xda, 0x41,
	0xf9, 0x0c, 0xda, 0x39, 0x6a, 0x11, 0x1d, 0x15, 0x6a, 0xdf, 0xcb, 0x50, 0x34, 0x47, 0x27, 0x2c,
	0xa0, 0x15, 0xa8, 0x9a, 0xc6, 0x7e, 0x2a, 0x9c, 0x24, 0x74, 0x60, 0x39, 0x34, 0x9f, 0xab, 0x80,
	0x52, 0x50, 0xf7, 0x68, 0x1f, 0xc9, 0xb4, 0x1c, 0xd2, 0x68, 0xbb, 0xd5, 0x76, 0x51, 0x0e, 0xdf,
	0x83, 0x95, 0x18, 0xb7, 0xac, 0x06, 0x87, 0x59, 0xcd, 0xc6, 0xb0, 0xd1, 0x69, 0xa8, 0x1d, 0x8d,
	0x4b, 0x0a, 0xf4, 0x8e, 0x24, 0x24, 0xae, 0x4e, 0x3a, 0xaa, 0xc9, 0x65, 0x8b, 0x29, 0x63, 0x9a,
	0xea, 0xaa, 0xb6, 0xea, 0x1e, 0xa0, 0x22, 0xad, 0x8e, 0x18, 0x66, 0x7d, 0x17, 0x95, 0x52, 0x51,
	0x36, 0xad, 0x8e, 0x4b, 0x2c, 0x13, 0x95, 0x69, 0x1e, 0x63, 0xf4, 0xd0, 0x36, 0x8d, 0xce, 0x97,
	0x08, 0x6a, 0x33, 0xc0, 0x8e, 0xd7, 0x3f, 0x9b, 0x8d, 0xc2, 0x0b, 0x7a, 0xcc, 0x6a, 0x3f, 0x1c,
	0xf9, 0x13, 0x7a, 0x1f, 0x1d, 0xbd, 0x79, 0x48, 0x0c, 0xf7, 0xb8, 0xcb, 0x4e, 0x52, 0x6d, 0x8a,
	0x5b, 0xc0, 0x12, 0xf3, 0x10, 0xd6, 0x6f, 0x14, 0xb3, 0x0b, 0x82, 0xa4, 0x5b, 0xd5, 0x35, 0xbd,
	0x73, 0x8c, 0xe4, 0xda, 0x7f, 0x4b, 0x50, 0xdd, 0x7f, 0x6f, 0xfb, 0xe3, 0x51, 0xff, 0xe2, 0xed,
	0xd4, 0x0f, 0x26, 0x34, 0x23, 0xfb, 0x6f, 0xba, 0xb6, 0x65, 0x1a, 0xcd, 0xe3, 0xee, 0x5b, 0xdb,
	0x72, 0x62, 0x57, 0x7f, 0x0b, 0x1b, 0x59, 0x49, 0xcb, 0xb4, 0x1a, 0xaa, 0xd9, 0xb5, 0x89, 0x61,
	0x51, 0x0f, 0x48, 0xc2, 0x0f, 0x60, 0x2d, 0x4b, 0x52, 0x3b, 0xc7, 0xc2, 0x1d, 0x7e, 0x02, 0x8f,
	0xb3, 0x52, 0x53, 0xa5, 0x87, 0x44, 0xcb, 0x5c, 0xd7, 0x58, 0x84, 0x28, 0x57, 0x1b, 0x43, 0xb9,
	0xd3, 0x0b, 0x45, 0x02, 0xee, 0xc2, 0x9d, 0x8e, 0xea, 0x66, 0xb6, 0x7d, 0x0f, 0x56, 0x12, 0x20,
	0xbd, 0xe4, 0x46, 0x93, 0x37, 0xb6, 0x24, 0x57, 0xb5, 0xdd, 0xae, 0x7d, 0xd8, 0x30, 0x8d, 0x26,
	0x2f, 0xd3, 0xac, 0xcc, 0x39, 0x6a, 0xa2, 0x5c, 0xed, 0x57, 0x32, 0x40, 0xdb, 0x0b, 0xbd, 0x59,
	0x73, 0xdc, 0x0b, 0x02, 0x7a, 0x62, 0x6d, 0xdd, 0xd5, 0x49, 0xb7, 0x69, 0xaa, 0x8e, 0x93, 0x28,
	0xc0, 0x24, 0xfa, 0x02, 0x49, 0x59, 0x68, 0x0b, 0xc9, 0x59, 0x68, 0x1b, 0xe5, 0xb2, 0xd0, 0x0e,
	0xca, 0x67, 0xa1, 0x5d, 0x54, 0xc8, 0x42, 0x7b, 0x68, 0x31, 0x0b, 0xbd, 0x44, 0xc5, 0x2c, 0xf4,
	0x0a, 0x95, 0xb2, 0xd0, 0x3f, 0xa0, 0x32, 0x2d, 0xc3, 0x54, 0xa8, 0x75, 0x04, 0xd7, 0xb0, 0x17,
	0xa8, 0x72, 0x0d, 0xdb, 0x42, 0x4b, 0xd7, 0xb0, 0x6d, 0x54, 0xbd, 0x86, 0xed, 0xa0, 0xe5, 0x6b,
	0xd8, 0x2e, 0xba, 0x53, 0xeb, 0x40, 0x45, 0x0c, 0xc9, 0x71, 0x53, 0xd5, 0x34, 0x92, 0xed, 0x2a,
	0x73, 0x4c, 0x9c, 0x8c, 0x44, 0x0f, 0x73, 0x8e, 0x3a, 0x3a, 0x39, 0x32, 0x9a, 0x3a, 0x92, 0x6b,
	0x0e, 0x80, 0x3a, 0x38, 0x1d, 0x4d, 0xe8, 0xbb, 0xcd, 0xe3, 0xaa, 0x6d, 0x83, 0x1f, 0x76, 0x6c,
	0x90, 0x76, 0xff, 0x04, 0xaa, 0x77, 0xd4, 0x86, 0xa9, 0x23, 0x89, 0x1e, 0x76, 0x12, 0xd7, 0x0c,
	0x87, 0x09, 0xe4, 0xda, 0x77, 0x50, 0x26, 0xfe, 0x59, 0xe8, 0x45, 0x9d, 0x8f, 0x58, 0x87, 0xae,
	0x9e, 0x8d, 0x31, 0x01, 0x5a, 0xee, 0x81, 0x4e, 0x78, 0x8c, 0x09, 0x94, 0xe8, 0xff, 0xa2, 0x37,
	0x5d, 0x24, 0x67, 0xc8, 0xa6, 0xd5, 0x54, 0x4d, 0xde, 0x6c, 0x52, 0xe4, 0xb6, 0xe5, 0xea, 0x28,
	0x5f, 0x1b, 0x41, 0x95, 0xf9, 0x8e, 0x3f, 0xd6, 0x62, 0x6d, 0x9b, 0x58, 0xae, 0x95, 0xa8, 0xed,
	0x24, 0xca, 0x8d, 0xb2, 0xce, 0x96, 0x84, 0x45, 0xcd, 0xe7, 0xe6, 0x9b, 0xe0, 0x78, 0xa3, 0x65,
	0xa3, 0xe5, 0xda, 0x9f, 0x25, 0xfe, 0xcb, 0xa7, 0x33, 0xf5, 0xbc, 0x01, 0xa5, 0xd8, 0x16, 0x71,
	0xbb, 0x8e, 0xad, 0xeb, 0x5a, 0xe4, 0x06, 0xc3, 0x72, 0x02, 0x7c, 0x51, 0x6f, 0xf3, 0xfe, 0x9e,
	0xc2, 0xea, 0x6d, 0x5e, 0xd4, 0x49, 0xb0, 0x85, 0x72, 0xd7, 0x74, 0x5b, 0x28, 0x9f, 0xc1, 0xb6,
	0x76, 0x5b, 0xa8, 0x90, 0xc1, 0x76, 0xea, 0x2d, 0xb4, 0x98, 0xc1, 0x76, 0xeb, 0x2d, 0x54, 0xbc,
	0xee, 0xb7, 0x85, 0x4a, 0x19, 0x70, 0x8b, 0x82, 0xe5, 0x0c, 0x48, 0x9c, 0x23, 0x0d, 0x41, 0xcd,
	0x4c, 0xcc, 0xf0, 0xac, 0xb7, 0xa6, 0x87, 0x5e, 0x9e, 0xd3, 0x14, 0xe8, 0x1a, 0xfb, 0xc7, 0x7c,
	0xbf, 0x09, 0x58, 0x3d, 0x74, 0x2d, 0x24, 0xd7, 0x7e, 0x90, 0x00, 0x65, 0xa7, 0x5c, 0xca, 0x14,
	0x95, 0xd9, 0xb5, 0xec, 0x84, 0xd5, 0x04, 0xd8, 0x24, 0xba, 0xea, 0xea, 0xbc, 0x56, 0x12, 0xb0,
	0xa6, 0x9b, 0xba, 0xab, 0x23, 0x39, 0x03, 0x1f, 0xda, 0x1a, 0x65, 0xe7, 0x32, 0x96, 0xe9, 0x9c,
	0x85, 0xf2, 0x8d, 0x95, 0xdf, 0xfc, 0xf8, 0x50, 0xfa, 0xdd, 0x8f, 0x0f, 0xa5, 0xdf, 0xff, 0xf8,
	0x50, 0xfa, 0xd7, 0xdc, 0x74, 0x10, 0xd8, 0x0b, 0x5f, 0x2d, 0xb2, 0x39, 0x76, 0xfb, 0x2f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xee, 0x94, 0x41, 0x5f, 0x6a, 0x1d, 0x00, 0x00,
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V4OrV6 != nil {
		{
			size := m.V4OrV6.Size()
			i -= size
			if _, err := m.V4OrV6.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Af != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Af))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress_V4Addr) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPAddress_V4Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.V4Addr))
	i--
	dAtA[i] = 0x15
	return len(dAtA) - i, nil
}
func (m *IPAddress_V6Addr) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPAddress_V6Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V6Addr != nil {
		i -= len(m.V6Addr)
		copy(dAtA[i:], m.V6Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.V6Addr)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IPPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Len != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != nil {
		{
			size, err := m.Addr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.High != nil {
		{
			size, err := m.High.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Low != nil {
		{
			size, err := m.Low.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IpEntry != nil {
		{
			size := m.IpEntry.Size()
			i -= size
			if _, err := m.IpEntry.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPEntry_Prefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPEntry_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IPEntry_Range) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPEntry_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IPEntry_Tag) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPEntry_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Tag))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *IPList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPEntry) > 0 {
		for iNdEx := len(m.IPEntry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IPEntry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPv4Prefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv4Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Len != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Addr))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *IPv6Prefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Len != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Subnet != nil {
		{
			size := m.Subnet.Size()
			i -= size
			if _, err := m.Subnet.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPSubnet_IPv4Subnet) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPSubnet_IPv4Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPv4Subnet != nil {
		{
			size, err := m.IPv4Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IPSubnet_IPv6Subnet) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *IPSubnet_IPv6Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPv6Subnet != nil {
		{
			size, err := m.IPv6Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AddressRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Range != nil {
		{
			size := m.Range.Size()
			i -= size
			if _, err := m.Range.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressRange_IPv4Range) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *AddressRange_IPv4Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPv4Range != nil {
		{
			size, err := m.IPv4Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AddressRange_IPv6Range) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *AddressRange_IPv6Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPv6Range != nil {
		{
			size, err := m.IPv6Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Address != nil {
		{
			size := m.Address.Size()
			i -= size
			if _, err := m.Address.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Address_Prefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Address_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Address_Range) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Address_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PortHigh != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PortHigh))
		i--
		dAtA[i] = 0x10
	}
	if m.PortLow != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PortLow))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RuleL3Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleL3Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleL3Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dstmatch != nil {
		{
			size := m.Dstmatch.Size()
			i -= size
			if _, err := m.Dstmatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Srcmatch != nil {
		{
			size := m.Srcmatch.Size()
			i -= size
			if _, err := m.Srcmatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Protomatch != nil {
		{
			size := m.Protomatch.Size()
			i -= size
			if _, err := m.Protomatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleL3Match_ProtoNum) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_ProtoNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ProtoNum))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_ProtoWildcard) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_ProtoWildcard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ProtoWildcard))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_SrcPrefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_SrcPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrcPrefix != nil {
		{
			size, err := m.SrcPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_SrcRange) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_SrcRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrcRange != nil {
		{
			size, err := m.SrcRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_SrcTag) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_SrcTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.SrcTag))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_SrcIPList) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_SrcIPList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SrcIPList != nil {
		{
			size, err := m.SrcIPList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_DstPrefix) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_DstPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstPrefix != nil {
		{
			size, err := m.DstPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_DstRange) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_DstRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstRange != nil {
		{
			size, err := m.DstRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_DstTag) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_DstTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.DstTag))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *RuleL3Match_DstIPList) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL3Match_DstIPList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIPList != nil {
		{
			size, err := m.DstIPList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *PortMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstPortRange != nil {
		{
			size, err := m.DstPortRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPortRange != nil {
		{
			size, err := m.SrcPortRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ICMPMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Codematch != nil {
		{
			size := m.Codematch.Size()
			i -= size
			if _, err := m.Codematch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Typematch != nil {
		{
			size := m.Typematch.Size()
			i -= size
			if _, err := m.Typematch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ICMPMatch_Type) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ICMPMatch_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ICMPMatch_TypeWildcard) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ICMPMatch_TypeWildcard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.TypeWildcard))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ICMPMatch_Code) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ICMPMatch_Code) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Code))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ICMPMatch_CodeWildcard) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ICMPMatch_CodeWildcard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.CodeWildcard))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *PortListMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortListMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortListMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DstPortRange) > 0 {
		for iNdEx := len(m.DstPortRange) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DstPortRange[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SrcPortRange) > 0 {
		for iNdEx := len(m.SrcPortRange) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcPortRange[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ICMPMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPMatchList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ICMPMatchList) > 0 {
		for iNdEx := len(m.ICMPMatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ICMPMatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleL4Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleL4Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleL4Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4Info != nil {
		{
			size := m.L4Info.Size()
			i -= size
			if _, err := m.L4Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleL4Match_Ports) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL4Match_Ports) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ports != nil {
		{
			size, err := m.Ports.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RuleL4Match_TypeCode) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL4Match_TypeCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypeCode != nil {
		{
			size, err := m.TypeCode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RuleL4Match_PortList) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL4Match_PortList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortList != nil {
		{
			size, err := m.PortList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RuleL4Match_ICMPMatchList) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RuleL4Match_ICMPMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ICMPMatchList != nil {
		{
			size, err := m.ICMPMatchList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4Match != nil {
		{
			size, err := m.L4Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.L3Match != nil {
		{
			size, err := m.L3Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QinQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QinQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QinQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CTag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CTag))
		i--
		dAtA[i] = 0x10
	}
	if m.STag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.STag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EncapVal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncapVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Val != nil {
		{
			size := m.Val.Size()
			i -= size
			if _, err := m.Val.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EncapVal_VlanId) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EncapVal_VlanId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *EncapVal_MPLSTag) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EncapVal_MPLSTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.MPLSTag))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *EncapVal_Vnid) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EncapVal_Vnid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Vnid))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *EncapVal_QinQ) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EncapVal_QinQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QinQ != nil {
		{
			size, err := m.QinQ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *EncapVal_Vsid) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *EncapVal_Vsid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Vsid))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Encap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Encap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Encap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchCtxt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCtxt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCtxt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchCookie != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BatchCookie))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MACFlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MACFlowKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MACFlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EtherType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EtherType))
		i--
		dAtA[i] = 0x20
	}
	if m.DstMAC != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DstMAC))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcMAC != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcMAC))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Subnet) > 0 {
		i -= len(m.Subnet)
		copy(dAtA[i:], m.Subnet)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowL4Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowL4Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4Info != nil {
		{
			size := m.L4Info.Size()
			i -= size
			if _, err := m.L4Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowL4Info_TcpUdpInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *FlowL4Info_TcpUdpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpUdpInfo != nil {
		{
			size, err := m.TcpUdpInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FlowL4Info_IcmpInfo) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *FlowL4Info_IcmpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IcmpInfo != nil {
		{
			size, err := m.IcmpInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FlowL4Info_TCPUDPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info_TCPUDPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowL4Info_TCPUDPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowL4Info_ICMPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowL4Info_ICMPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowL4Info_ICMPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPFlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPFlowKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPFlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4Info != nil {
		{
			size, err := m.L4Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.IPProtocol != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IPProtocol))
		i--
		dAtA[i] = 0x20
	}
	if m.DstIP != nil {
		{
			size, err := m.DstIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcIP != nil {
		{
			size, err := m.SrcIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VPCId) > 0 {
		i -= len(m.VPCId)
		copy(dAtA[i:], m.VPCId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VPCId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size := m.Key.Size()
			i -= size
			if _, err := m.Key.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowKey_IPFlowKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *FlowKey_IPFlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPFlowKey != nil {
		{
			size, err := m.IPFlowKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FlowKey_MACFlowKey) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *FlowKey_MACFlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MACFlowKey != nil {
		{
			size, err := m.MACFlowKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SvcRewriteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SvcRewriteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SvcRewriteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SvcPortMap) > 0 {
		i -= len(m.SvcPortMap)
		copy(dAtA[i:], m.SvcPortMap)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SvcPortMap)))
		i--
		dAtA[i] = 0x22
	}
	if m.DstNatIP != nil {
		{
			size, err := m.DstNatIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DstPrefix != nil {
		{
			size, err := m.DstPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPrefix != nil {
		{
			size, err := m.SrcPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropNexthop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropNexthop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropNexthop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FlowLogSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowLogSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowLogSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogLongLivedFlows {
		i--
		if m.LogLongLivedFlows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.LogOnDelete {
		i--
		if m.LogOnDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.LogOnCreate {
		i--
		if m.LogOnCreate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataPktLearnEn {
		i--
		if m.DataPktLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DhcpLearnEn {
		i--
		if m.DhcpLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ArpLearnEn {
		i--
		if m.ArpLearnEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LearnSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LearnSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LearnSource != nil {
		{
			size, err := m.LearnSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LearnAgeTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LearnAgeTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.LearnMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LearnMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceRequestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceRequestMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceRequestMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigMsg != nil {
		{
			size, err := m.ConfigMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ConfigOp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConfigOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ApiStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Counter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Counter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Counter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPCommunity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPCommunity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPCommunity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Community != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Community))
		i--
		dAtA[i] = 0x10
	}
	if m.Asn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Af != 0 {
		n += 1 + sovTypes(uint64(m.Af))
	}
	if m.V4OrV6 != nil {
		n += m.V4OrV6.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPAddress_V4Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *IPAddress_V6Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V6Addr != nil {
		l = len(m.V6Addr)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != nil {
		l = m.Addr.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Low != nil {
		l = m.Low.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.High != nil {
		l = m.High.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpEntry != nil {
		n += m.IpEntry.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPEntry_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPEntry_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPEntry_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Tag))
	return n
}
func (m *IPList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IPEntry) > 0 {
		for _, e := range m.IPEntry {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPv4Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 5
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPv6Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Len != 0 {
		n += 1 + sovTypes(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		n += m.Subnet.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPSubnet_IPv4Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPv4Subnet != nil {
		l = m.IPv4Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPSubnet_IPv6Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPv6Subnet != nil {
		l = m.IPv6Subnet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		n += m.Range.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressRange_IPv4Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPv4Range != nil {
		l = m.IPv4Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AddressRange_IPv6Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPv6Range != nil {
		l = m.IPv6Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		n += m.Address.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Address_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Address_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortLow != 0 {
		n += 1 + sovTypes(uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		n += 1 + sovTypes(uint64(m.PortHigh))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleL3Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protomatch != nil {
		n += m.Protomatch.Size()
	}
	if m.Srcmatch != nil {
		n += m.Srcmatch.Size()
	}
	if m.Dstmatch != nil {
		n += m.Dstmatch.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleL3Match_ProtoNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ProtoNum))
	return n
}
func (m *RuleL3Match_ProtoWildcard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ProtoWildcard))
	return n
}
func (m *RuleL3Match_SrcPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_SrcRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcRange != nil {
		l = m.SrcRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_SrcTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.SrcTag))
	return n
}
func (m *RuleL3Match_SrcIPList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcIPList != nil {
		l = m.SrcIPList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_DstPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_DstRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstRange != nil {
		l = m.DstRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL3Match_DstTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.DstTag))
	return n
}
func (m *RuleL3Match_DstIPList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIPList != nil {
		l = m.DstIPList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typematch != nil {
		n += m.Typematch.Size()
	}
	if m.Codematch != nil {
		n += m.Codematch.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPMatch_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Type))
	return n
}
func (m *ICMPMatch_TypeWildcard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.TypeWildcard))
	return n
}
func (m *ICMPMatch_Code) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Code))
	return n
}
func (m *ICMPMatch_CodeWildcard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.CodeWildcard))
	return n
}
func (m *PortListMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ICMPMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ICMPMatchList) > 0 {
		for _, e := range m.ICMPMatchList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleL4Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleL4Match_Ports) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL4Match_TypeCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeCode != nil {
		l = m.TypeCode.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL4Match_PortList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortList != nil {
		l = m.PortList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleL4Match_ICMPMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ICMPMatchList != nil {
		l = m.ICMPMatchList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RuleMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L3Match != nil {
		l = m.L3Match.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.L4Match != nil {
		l = m.L4Match.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QinQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.STag != 0 {
		n += 1 + sovTypes(uint64(m.STag))
	}
	if m.CTag != 0 {
		n += 1 + sovTypes(uint64(m.CTag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncapVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != nil {
		n += m.Val.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncapVal_VlanId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VlanId))
	return n
}
func (m *EncapVal_MPLSTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.MPLSTag))
	return n
}
func (m *EncapVal_Vnid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Vnid))
	return n
}
func (m *EncapVal_QinQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QinQ != nil {
		l = m.QinQ.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EncapVal_Vsid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Vsid))
	return n
}
func (m *Encap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchCtxt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchCookie != 0 {
		n += 1 + sovTypes(uint64(m.BatchCookie))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MACFlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SrcMAC != 0 {
		n += 1 + sovTypes(uint64(m.SrcMAC))
	}
	if m.DstMAC != 0 {
		n += 1 + sovTypes(uint64(m.DstMAC))
	}
	if m.EtherType != 0 {
		n += 1 + sovTypes(uint64(m.EtherType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowL4Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowL4Info_TcpUdpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpUdpInfo != nil {
		l = m.TcpUdpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowL4Info_IcmpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IcmpInfo != nil {
		l = m.IcmpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowL4Info_TCPUDPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPort != 0 {
		n += 1 + sovTypes(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovTypes(uint64(m.DstPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowL4Info_ICMPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPFlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VPCId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SrcIP != nil {
		l = m.SrcIP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstIP != nil {
		l = m.DstIP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IPProtocol != 0 {
		n += 1 + sovTypes(uint64(m.IPProtocol))
	}
	if m.L4Info != nil {
		l = m.L4Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		n += m.Key.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowKey_IPFlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPFlowKey != nil {
		l = m.IPFlowKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FlowKey_MACFlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MACFlowKey != nil {
		l = m.MACFlowKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SvcRewriteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstNatIP != nil {
		l = m.DstNatIP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SvcPortMap)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropNexthop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowLogSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogOnCreate {
		n += 2
	}
	if m.LogOnDelete {
		n += 2
	}
	if m.LogLongLivedFlows {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArpLearnEn {
		n += 2
	}
	if m.DhcpLearnEn {
		n += 2
	}
	if m.DataPktLearnEn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LearnSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LearnMode != 0 {
		n += 1 + sovTypes(uint64(m.LearnMode))
	}
	if m.LearnAgeTimeout != 0 {
		n += 1 + sovTypes(uint64(m.LearnAgeTimeout))
	}
	if m.LearnSource != nil {
		l = m.LearnSource.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceRequestMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigOp != 0 {
		n += 1 + sovTypes(uint64(m.ConfigOp))
	}
	if m.ConfigMsg != nil {
		l = m.ConfigMsg.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTypes(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Counter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BGPCommunity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asn != 0 {
		n += 1 + sovTypes(uint64(m.Asn))
	}
	if m.Community != 0 {
		n += 1 + sovTypes(uint64(m.Community))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Af", wireType)
			}
			m.Af = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Af |= IPAF(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Addr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.V4OrV6 = &IPAddress_V4Addr{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.V4OrV6 = &IPAddress_V6Addr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addr == nil {
				m.Addr = &IPAddress{}
			}
			if err := m.Addr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Low == nil {
				m.Low = &IPAddress{}
			}
			if err := m.Low.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.High == nil {
				m.High = &IPAddress{}
			}
			if err := m.High.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpEntry = &IPEntry_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpEntry = &IPEntry_Range{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpEntry = &IPEntry_Tag{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPEntry = append(m.IPEntry, &IPEntry{})
			if err := m.IPEntry[len(m.IPEntry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4Prefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4Prefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4Prefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Prefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Prefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Prefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_IPv4Subnet{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subnet = &IPSubnet_IPv6Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv4Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_IPv4Range{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPv6Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Range = &AddressRange_IPv6Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &Address_Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortLow", wireType)
			}
			m.PortLow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortLow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortHigh", wireType)
			}
			m.PortHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortHigh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleL3Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleL3Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleL3Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protomatch = &RuleL3Match_ProtoNum{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WildcardMatch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protomatch = &RuleL3Match_ProtoWildcard{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Srcmatch = &RuleL3Match_SrcPrefix{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Srcmatch = &RuleL3Match_SrcRange{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Srcmatch = &RuleL3Match_SrcTag{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIPList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Srcmatch = &RuleL3Match_SrcIPList{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPPrefix{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dstmatch = &RuleL3Match_DstPrefix{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dstmatch = &RuleL3Match_DstRange{v}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dstmatch = &RuleL3Match_DstTag{v}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIPList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dstmatch = &RuleL3Match_DstIPList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Typematch = &ICMPMatch_Type{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WildcardMatch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Typematch = &ICMPMatch_TypeWildcard{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Codematch = &ICMPMatch_Code{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeWildcard", wireType)
			}
			var v WildcardMatch
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WildcardMatch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Codematch = &ICMPMatch_CodeWildcard{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortListMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortListMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortListMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPMatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ICMPMatchList = append(m.ICMPMatchList, &ICMPMatch{})
			if err := m.ICMPMatchList[len(m.ICMPMatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleL4Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleL4Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleL4Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_Ports{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_TypeCode{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortListMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_PortList{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPMatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &RuleL4Match_ICMPMatchList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L3Match == nil {
				m.L3Match = &RuleL3Match{}
			}
			if err := m.L3Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4Match == nil {
				m.L4Match = &RuleL4Match{}
			}
			if err := m.L4Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QinQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QinQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QinQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field STag", wireType)
			}
			m.STag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.STag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTag", wireType)
			}
			m.CTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapVal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapVal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapVal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_VlanId{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPLSTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_MPLSTag{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_Vnid{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinQ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QinQ{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Val = &EncapVal_QinQ{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vsid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = &EncapVal_Vsid{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Encap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Encap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Encap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EncapType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &EncapVal{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCtxt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCtxt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCtxt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCookie", wireType)
			}
			m.BatchCookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchCookie |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MACFlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MACFlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MACFlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet[:0], dAtA[iNdEx:postIndex]...)
			if m.Subnet == nil {
				m.Subnet = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			m.SrcMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMAC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			m.DstMAC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMAC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			m.EtherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtherType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowL4Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowL4Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUdpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowL4Info_TCPUDPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &FlowL4Info_TcpUdpInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlowL4Info_ICMPInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &FlowL4Info_IcmpInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info_TCPUDPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPUDPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPUDPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowL4Info_ICMPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPFlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPFlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPFlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCId = append(m.VPCId[:0], dAtA[iNdEx:postIndex]...)
			if m.VPCId == nil {
				m.VPCId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIP == nil {
				m.SrcIP = &IPAddress{}
			}
			if err := m.SrcIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIP == nil {
				m.DstIP = &IPAddress{}
			}
			if err := m.DstIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPProtocol", wireType)
			}
			m.IPProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IPProtocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4Info == nil {
				m.L4Info = &FlowL4Info{}
			}
			if err := m.L4Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPFlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPFlowKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &FlowKey_IPFlowKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACFlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MACFlowKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Key = &FlowKey_MACFlowKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SvcRewriteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SvcRewriteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SvcRewriteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPrefix == nil {
				m.SrcPrefix = &IPPrefix{}
			}
			if err := m.SrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPrefix == nil {
				m.DstPrefix = &IPPrefix{}
			}
			if err := m.DstPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatIP == nil {
				m.DstNatIP = &IPAddress{}
			}
			if err := m.DstNatIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcPortMap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SvcPortMap = append(m.SvcPortMap[:0], dAtA[iNdEx:postIndex]...)
			if m.SvcPortMap == nil {
				m.SvcPortMap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropNexthop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropNexthop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropNexthop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowLogSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowLogSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowLogSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOnCreate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogOnCreate = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOnDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogOnDelete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLongLivedFlows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogLongLivedFlows = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArpLearnEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DhcpLearnEn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPktLearnEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataPktLearnEn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnMode", wireType)
			}
			m.LearnMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnMode |= LearnMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnAgeTimeout", wireType)
			}
			m.LearnAgeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LearnAgeTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnSource == nil {
				m.LearnSource = &LearnSource{}
			}
			if err := m.LearnSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceRequestMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceRequestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceRequestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOp", wireType)
			}
			m.ConfigOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigOp |= ServiceRequestOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMsg == nil {
				m.ConfigMsg = &types.Any{}
			}
			if err := m.ConfigMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= ApiStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &types.Any{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Counter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Counter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Counter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPCommunity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPCommunity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPCommunity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Community", wireType)
			}
			m.Community = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Community |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)
